import { lib, game, ui, get, ai, _status } from '../../../../noname.js';
import MiNikill_sight from './MiNikill_sight.js';

const packs = function () {
    var MiNikill = {
        name: 'MiNikill',
        connect: true,
        characterSort: {
            MiNikill: {
                MiNi_wei: ['old_liubei', 'guohuai', 'caochong', 'caochun', 'caoying', 'dc_jiachong', 'zhugeruoxue', 'dukui', 'xinpi', 'caimaozhangyun', 'bianyue', 'caoanmin', 'zhaoang', 'zhanggong', 'simalang', 'hanhaoshihuan', 'chentai', 'zhenghun', 'guanlu', 'guanqiujian', 'wenqin', 'dc_liuye', 'chenlin', 'wangshuang', 'yanrou', 'dc_yanghu', 'ruanyu', 'chengyu', 'jianggan', 'yuejin', 'bianfuren', 'zhugedan', 'caohong', 'yinfuren', 'kuailiangkuaiyue', 'chenqun', 'xiahoulingnv', 'wenyang', 'caocao', 'caozhang', 'dufuren', 'yangxiu', 'zhangchangpu', 'zhonghui', 'caoxiu', 'xunyou', 'lidian', 'zhongyao', 'caozhen', 'guohuanghou', 'xinxianying', 'xiahouyuan', 'xizhicai', 'caorui', 'xunyu', 'dengai', 'caozhi', 'caopi', 'caoang', 'zhenji', 'old_caoren', 'zhangchunhua', 'xiahoudun', 'dianwei', 'zhanghe', 'yujin', 'xuhuang'].map(i => `Mbaby_${i}`),
                MiNi_shu: ['dc_wuban', 'pangtong', 'mifangfushiren', 'guanyue', 'xianglang', 'huanghao', 'ganfurenmifuren', 'zhaotongzhaoguang', 'wulan', 'leitong', 'zongyu', 're_mazhong', 're_dengzhi', 'dc_hujinding', 'jiangfei', 'zhangyi', 'guanzhang', 'wolongfengchu', 'wangtao', 'wangyue', 'xf_yiji', 'mizhu', 'mifuren', 'liuyong', 'ganfuren', 'lvkai', 'zhoucang', 'yangwan', 'liuchen', 'liyan', 'chendao', 'yanyan', 'xiahouba', 'huaman', 'sp_zhugeliang', 'zhugeguo', 'jianyong', 'wangping', 'mayunlu', 'guansuo', 'xiahoushi', 'shamoke', 'wuxian', 'zhugezhan', 'qinmi', 'guanyinping', 'guanyu', 'zhugeliang', 'liubei', 'machao', 'zhurong', 'zhangfei', 'zhaoyun', 'huangzhong', 'weiyan', 'liaohua', 'menghuo', 'ol_jiangwei', 'liushan', 'xin_fazheng', 'madai', 'guanping', 'liufeng', 'zhangxingcai', 'dongyun', 'xushu', 'xin_masu'].map(i => `Mbaby_${i}`),
                MiNi_wu: ['old_sunquan', 'sunhuan', 'gexuan', 'lvfan', 'xielingyu', 'zhupeilan', 'xugong', 'chendong', 'kanze', 're_panzhangmazhong', 'weiwenzhugezhi', 'zhangwen', 'dc_sunhanhua', 'heqi', 'lvdai', 'jiangqing', 're_guyong', 'quancong', 'yufan', 'dc_sunru', 'sunxiu', 'zhangfen', 'xuezong', 'panjun', 'luji', 'zhoufang', 'zhangxuan', 'yanjun', 'zhuhuan', 'luyusheng', 're_jsp_pangtong', 'sunhao', 'lukang', 'buzhi', 'xushi', 'zhugeke', 'zhoufei', 'zhangzhang', 'sunliang', 'sunjian', 'zhuzhi', 'bulianshi', 'chengpu', 'daqiao', 'ganning', 'huanggai', 'lusu', 'luxun', 'lvmeng', 'sunce', 'sunluban', 'sunluyu', 'sunquan', 'sunshangxiang', 'taishici', 'wuguotai', 'xiaoqiao', 'xusheng', 'old_zhoutai', 'zhouyu', 'zhugejin', 'zumao'].map(i => `Mbaby_${i}`),
                MiNi_qun: ['diaochan', 'xurong', 're_taoqian', 'hejin', 'jiling', 'zhangrang', 'duanwei', 're_chendeng', 'caiyong', 'mengjie', 'dc_gaolan', 'yl_luzhi', 'tadun', 're_hansui', 'dongxie', 'fuwan', 'wutugu', 'huangfusong', 'fanchou', 'guosi', 'yanbaihu', 'dc_huangzu', 'licaiwei', 'ol_dingyuan', 'liubian', 're_pangdegong', 'zhangning', 'zhanglu', 'wangyun', 'zoushi', 'dc_huangchengyan', 'simahui', 'tw_mateng', 'laiyinger', 'sp_kongrong', 'zhujun', 'gongsunyuan', 'guotufengji', 'yanfuren', 'tangji', 'caojie', 'liangxing', 'caoxing', 'wangrong', 'hetaihou', 'zhangji', 'dongbai', 'beimihu', 'chunyuqiong', 'zhangqiying', 'fuhuanghou', 'liuxie', 'quyi', 'lijue', 'panfeng', 'liuzhang', 'jiaxu', 'zhangbao', 'zhangliang', 'gaoshun', 'caifuren', 'xuyou', 'pangde', 'yj_jushou', 'liru', 'dongzhuo', 'sp_zhangjiao', 'huatuo', 'lvbu', 'huaxiong', 'yuji', 'liubiao', 'yuanshao', 'yuanshu', 'chengong', 'zuoci'].map(i => `Mbaby_${i}`),
                MiNi_shen: [
                    ...['lusu', 'luxun', 'dengai', 'zuoci', 'taishici', 'diaochan', 'daxiaoqiao', 'zhenji', 'guojia', 'huatuo', 'dianwei', 'lvbu', 'zhugeliang', 'lvmeng', 'zhouyu', 'guanyu', 'liubei', 'caocao', 'zhangliao', 'sunquan', 'simayi', 'zhaoyun', 'ganning', 'pangtong'].map(i => `shen_${i}`),
                    ...['1_daxiaoqiao', '2_daxiaoqiao'].map(i => `old_${i}`),
                    ...[],
                ].map(i => `Mbaby_${i}`),
                MiNi_change: ['sb_guojia', 'ol_sb_jiangwei', 'sb_sunquan', 'guanning', 're_nanhualaoxian', 're_sunyi', 'zhaoxiang', 'xushao', 'baosanniang', 'quanhuijie'].map(i => `Mbaby_${i}`),
                MiNi_refresh: [
                    ...['liaohua', 'sundeng', 'zhangchunhua', 'gongsunyuan', 'caorui', 'chengong', 'fazheng', 'xusheng', 'taishici', 'dianwei', 'huangyueying', 'gongsunzan', 'tadun', 'menghuo', 'jiaxu', 'luxun', 'masu', 'zhangjiao', 'zhouyu', 'sunce', 'caifuren', 'liubiao', 'weiyan', 'guohuai', 'lvbu', 'huatuo', 'pangde', 'zhugeliang', 'guojia', 'simayi', 'lvmeng', 'sunshangxiang', 'zhenji', 'diaochan', 'daqiao', 'ganning', 'huanggai', 'xiahoudun', 'xuzhu', 'zhangliao', 'sunquan', 'caocao', 'liubei', 'guanyu', 'zhangfei', 'zhaoyun', 'machao', 'huangzhong'].map(i => `re_${i}`),
                    ...['xunyu', 'liushan', 'caiwenji', 'wuguotai', 'yanwen', 'dongzhuo', 'sunjian', 'zhurong', 'lusu', 'xiahouyuan', 'pangtong', 'xiaoqiao'].map(i => `ol_${i}`),
                    ...['xusheng', 'yuanshao', 'gaoshun'].map(i => `xin_${i}`),
                    ...['mb_guanyinping', 'yl_yuanshu', 'dingfeng', 'sunqian', 'wangji', 'zhoutai', 'caoren', 'sb_huaxiong'],
                ].map(i => `Mbaby_${i}`),
                MiNi_sp: [
                    ...['jsp_guanyu', 'sb_xiahoushi', 're_jsp_pangtong', 'jsp_huangyueying'].map(i => `Mbaby_${i}`),
                    ...['caiwenji', 'jiangwei', 'pangde', 'jiaxu', 'caoren', 'sunshangxiang', 'diaochan', 'machao', 'taishici', 'menghuo', 'zhangliao', 'ol_zhanghe'].map(i => `Mbaby_sp_${i}`),
                    ...['zhenji', 'daqiao', 'zhangfei', 'sunjian', 'liubei', 'xuhuang', 'xiaoqiao'].map(i => `Mbabysp_${i}`),
                    ...[],
                ],
                MiNi_sbCharacter: [
                    ...['zhenji', 'ganning', 'huangyueying', 'sunshangxiang', 'xuhuang', 'zhaoyun', 'liubei', 'caocao', 'huanggai', 'yuanshao', 'yujin', 'machao', 'lvmeng', 'huangzhong'].map(i => `Mbaby_sb_${i}`),
                    ...['huaxiong', 'guanyu'].map(i => `Mbaby_ol_sb_${i}`),
                    ...['chengyu'].map(i => `Mbaby_dc_sb_${i}`),
                    ...[],
                ],
                MiNi_starCharacter: ['xunyu', 'yuanshu'].map(i => `Mbaby_star_${i}`),
                MiNi_miaoKill: ['mayunlu', 'guanyinping', 'caoying', 'caiwenji', 'diaochan', 'caifuren', 'zhangxingcai', 'zhurong', 'huangyueying', 'daqiao', 'wangyi', 'zhangchunhua', 'zhenji', 'sunshangxiang', 'xiaoqiao', 'lvlingqi'].map(i => `Mmiao_${i}`),
                MiNi_nianKill: ['caopi', 'zhugeliang', 'lvbu', 'zhouyu'].map(i => `Mnian_${i}`),
                MiNi_fightKill: ['huangzhong', 'zhangliao', 'luxun', 'dianwei', 'machao', 'jiangwei'].map(i => `Mfight_${i}`),
                MiNi_yinKill: ['xushu'].map(i => `Myin_${i}`),
                MiNi_shengzhiyifa: ['jingwei', 'sunwukong', 'dalanmao', 'libai', 'change', 'nvwa', 'tunxingmenglix', 'xiaoshan'].map(i => `Mbaby_${i}`),
            },
        },
        character: {
            //魏
            Mbaby_caopi: ['male', 'wei', 3, ['minixingshang', 'minifangzhu', 'songwei'], ['zhu']],
            Mbaby_caoang: ['male', 'wei', 4, ['minikangkai']],
            Mbaby_zhenji: ['female', 'wei', 3, ['miniluoshen', 'qingguo']],
            Mbaby_re_zhenji: ['female', 'wei', 3, ['minireluoshen', 'reqingguo']],
            Mbaby_old_caoren: ['male', 'wei', 4, ['minijushou'], ['character:Mbaby_caoren']],
            Mbaby_caoren: ['male', 'wei', 4, ['minijushou', 'xinjiewei']],
            Mbaby_zhangchunhua: ['female', 'wei', 3, ['jueqing', 'minishangshi']],
            Mbaby_re_zhangchunhua: ['female', 'wei', 3, ['minijueqing', 'minireshangshi']],
            Mbaby_re_xuzhu: ['male', 'wei', 4, ['luoyi', 'minihuchi']],
            Mbaby_guohuai: ['male', 'wei', 4, ['jingce']],//不是你怎么也复活了？？？
            Mbaby_re_guohuai: ['male', 'wei', 4, ['minijingce']],
            Mbaby_dianwei: ['male', 'wei', 4, ['miniqiangxi']],
            Mbaby_re_dianwei: ['male', 'wei', 4, ['minireqiangxi']],
            Mbaby_zhanghe: ['male', 'wei', 4, ['miniqiaobian']],
            Mbaby_yujin: ['male', 'wei', 4, ['miniyizhong', 'decadezhenjun']],
            Mbaby_xuhuang: ['male', 'wei', 4, ['duanliang', 'minijiezi']],
            Mbaby_xunyu: ['male', 'wei', 3, ['miniquhu', 'minijieming'], ['clan:颍川荀氏']],
            Mbaby_dengai: ['male', 'wei', 4, ['minituntian', 'zaoxian']],
            Mbaby_sp_caiwenji: ['female', 'wei', 3, ['minichenqing', 'mozhi'], ['name:蔡|琰']],
            Mbaby_caozhi: ['male', 'wei', 3, ['miniluoying', 'minijiushi']],
            Mbaby_caorui: ['male', 'wei', 3, ['minihuituo', 'minimingjian', 'minixingshuai'], ['zhu']],
            Mbaby_re_caorui: ['male', 'wei', 3, ['minihuituo', 'miniremingjian', 'minirexingshuai'], ['zhu', 'character:Mbaby_caorui']],
            Mbaby_xizhicai: ['male', 'wei', 3, ['tiandu', 'xianfu', 'minichouce']],
            Mbaby_xiahouyuan: ['male', 'wei', 4, ['minishensu'], ['name:夏侯|渊']],
            Mbaby_ol_xiahouyuan: ['male', 'wei', 4, ['minishensu', 'minishebian'], ['name:夏侯|渊', 'character:Mbaby_xiahouyuan']],
            Mbaby_caoying: ['female', 'wei', 4, ['minilingren', 'minifujian']],
            Mbaby_xinxianying: ['female', 'wei', 3, ['minizhongjian', 'minicaishi']],
            Mbaby_xiahoudun: ['male', 'wei', 4, ['reganglie'], ['name:夏侯|惇']],
            Mbaby_re_xiahoudun: ['male', 'wei', 4, ['reganglie', 'miniqingjian'], ['name:夏侯|惇', 'character:Mbaby_xiahoudun']],
            Mbaby_guohuanghou: ['female', 'wei', 3, ['minijiaozhao', 'minidanxin']],
            Mbaby_caozhen: ['male', 'wei', 4, ['minisidi']],
            Mbaby_zhongyao: ['male', 'wei', 3, ['minihomo', 'minizuoding'], ['clan:颍川钟氏']],
            Mbaby_lidian: ['male', 'wei', 3, ['minixunxun', 'wangxi']],
            Mbaby_re_zhangliao: ['male', 'wei', 4, ['new_retuxi', 'minizhengbing']],
            Mbaby_xunyou: ['male', 'wei', 3, ['miniqice', 'minizhiyu'], ['clan:颍川荀氏']],
            Mbaby_caoxiu: ['male', 'wei', 4, ['qianju', 'miniqingxi']],
            Mbaby_sp_jiangwei: ['male', 'wei', 4, ['minikunfen', 'minifengliang']],
            Mbaby_zhonghui: ['male', 'wei', 3, ['miniquanji', 'paiyi'], ['clan:颍川钟氏']],
            Mbaby_zhangchangpu: ['female', 'wei', 3, ['miniyanjiao', 'xingshen']],
            Mbaby_yangxiu: ['male', 'wei', 3, ['danlao', 'minijilei']],
            Mbaby_re_simayi: ['male', 'wei', 3, ['minifankui', 'miniguicai'], ['name:司马|懿']],
            Mbaby_dufuren: ['female', 'wei', 3, ['miniyise', 'minishunshi'], ['name:杜|null']],
            Mbaby_caozhang: ['male', 'wei', 4, ['minijiangchi']],
            Mbaby_caocao: ['male', 'wei', 4, ['new_rejianxiong', 'hujia'], ['zhu']],//？OL服外的界曹操拉这儿了？？？
            Mbaby_re_caocao: ['male', 'wei', 4, ['minijianxiong', 'minihujia'], ['zhu']],
            Mbaby_sp_pangde: ['male', 'wei', 4, ['minijuesi', 'miniyuma']],
            Mbaby_wenyang: ['male', 'wei', 5, ['xinlvli', 'minichoujue']],
            Mbaby_xiahoulingnv: ['female', 'wei', 4, ['fuping', 'miniweilie'], ['name:夏侯|令女']],
            Mbaby_chenqun: ['male', 'wei', 3, ['pindi', 'minifaen']],
            Mbaby_wangji: ['male', 'wei', 3, ['miniqizhi', 'minijinqu']],
            Mbaby_jsp_guanyu: ['male', 'wei', 4, ['minispwusheng', 'minidanji']],
            Mbaby_kuailiangkuaiyue: ['male', 'wei', 3, ['nzry_jianxiang', 'minishenshi']],
            Mbaby_sp_jiaxu: ['male', 'wei', 3, ['zhenlue', 'minijianshu', 'miniyongdi']],
            Mbaby_yinfuren: ['female', 'wei', 3, ['dcyingyu', 'miniyongbi'], ['name:尹|null']],
            Mbaby_sp_caoren: ['male', 'wei', 4, ['miniweikui', 'minilizhan']],
            Mbaby_re_guojia: ['male', 'wei', 3, ['tiandu', 'new_reyiji', 'minishenglun']],
            Mbaby_caohong: ['male', 'wei', 4, ['miniyuanhu', 'minijuezhu']],
            Mbaby_sb_caocao: ['male', 'wei', 4, ['minisbjianxiong', 'minisbqingzheng', 'sbhujia'], ['zhu']],
            Mbaby_zhugedan: ['male', 'wei', 4, ['minigongao', 'minijuyi'], ['name:诸葛|诞']],
            Mbaby_bianfuren: ['female', 'wei', 3, ['miniwanwei', 'miniyuejian'], ['name:卞|null']],
            Mbaby_sb_yujin: ['male', 'wei', 4, ['minixiayuan', 'minijieyue']],
            Mbaby_yuejin: ['male', 'wei', 4, ['minixiaoguo']],
            Mbaby_jianggan: ["male", "wei", 3, ['miniweicheng', 'minidaoshu']],
            Mbaby_chengyu: ['male', 'wei', 3, ['minishefu', 'minibenyu']],
            Mbaby_sb_xuhuang: ['male', 'wei', 4, ['minisbduanliang', 'sbshipo']],
            Mbaby_ruanyu: ['male', 'wei', 3, ['minixingzuo', 'miaoxian']],
            Mbaby_dc_yanghu: ['male', 'wei', 3, ['minideshao', 'dcmingfa']],
            Mbaby_yanrou: ['male', 'wei', 4, ['choutao', 'minixiangshu']],
            Mbaby_wangshuang: ['male', 'wei', 8, ['minizhuilie']],
            Mbaby_chenlin: ['male', 'wei', 3, ['bifa', 'minisongci']],
            Mbaby_dc_liuye: ['male', 'wei', 3, ['minipoyuan', 'dchuace']],
            Mbaby_wenqin: ['male', 'wei', 4, ['olguangao', 'minihuiqi']],
            Mbaby_guanqiujian: ['male', 'wei', 4, ['minizhengrong', 'minihongju']],
            Mbaby_guanlu: ['male', 'wei', 3, ['tuiyan', 'minibusuan', 'minimingjie']],
            Mbaby_zhenghun: ['male', 'wei', 3, ['miniqiangzhi', 'dcpitian']],
            Mbaby_chentai: ['male', 'wei', 4, ['minijiuxian', 'dcchenyong']],
            Mbaby_hanhaoshihuan: ['male', 'wei', 4, ['shenduan', 'miniyonglve']],
            Mbaby_sb_zhenji: ['female', 'wei', 3, ['minisbluoshen', 'minisbqingguo']],
            Mbaby_simalang: ['male', 'wei', 3, ['rejunbing', 'miniquji'], ['name:司马|朗']],
            Mbaby_zhanggong: ['male', 'wei', 3, ['miniqianxin', 'xinfu_zhenxing']],
            Mbaby_zhaoang: ['male', 'wei', 4, ['dczhongjie', 'minisushou']],
            Mbaby_caoanmin: ['male', 'wei', 4, ['minixianwei']],
            Mbaby_bianyue: ['female', 'wei', 3, ['dcbizu', 'miniwuxie']],
            Mbaby_sb_guojia: ['male', 'wei', 3, ['minisbxianmou', 'lunshi']],
            Mbaby_caimaozhangyun: ['male', 'wei', 4, ['minilianzhou', 'minijilang']],
            Mbaby_xinpi: ['male', 'wei', 3, ['minichijie', 'yinju']],
            Mbaby_dukui: ['male', 'wei', 3, ['minifanyin', 'minipeiqi']],
            Mbaby_zhugeruoxue: ['female', 'wei', 3, ['miniqiongying', 'dcnuanhui'], ['name:诸葛|若雪']],
            Mbaby_star_xunyu: ['male', 'wei', 3, ['minianshu', 'starkuangzuo'], ['clan:颍川荀氏']],
            Mbaby_dc_jiachong: ['male', 'wei', 3, ['minibeini', 'minishizong'], ['border:jin']],
            Mbaby_ol_xunyu: ['male', 'wei', 3, ['minirequhu', 'minirejieming'], ['clan:颍川荀氏', 'character:Mbaby_xunyu']],
            Mbaby_dc_sb_chengyu: ['male', 'wei', 3, ['dcshizha', 'minigaojian']],
            Mbaby_caochong: ['male', 'wei', 3, ['minichengxiang', 'renxin']],
            Mbaby_caochun: ['male', 'wei', 4, ['minishanjia']],
            //蜀
            Mbaby_guanyu: ['male', 'shu', 4, ['miniwusheng']],
            Mbaby_re_guanyu: ['male', 'shu', 4, ['minirewusheng', 'minituodao', 'jsrgguanjue']],
            Mbaby_zhugeliang: ['male', 'shu', 3, ['miniguanxing', 'minikongcheng'], ['name:诸葛|亮']],
            Mbaby_re_zhugeliang: ['male', 'shu', 3, ['minireguanxing', 'minikongcheng'], ['name:诸葛|亮']],
            Mbaby_liubei: ['male', 'shu', 4, ['rerende', 'minijijiang'], ['zhu']],
            Mbaby_re_liubei: ['male', 'shu', 4, ['minirerende', 'minirejijiang'], ['zhu']],
            Mbaby_old_liubei: ['male', 'shu', 4, ['minirende', 'jijiang'], ['zhu', 'character:Mbaby_liubei', ...['die', 'tempname'].map(i => `${i}:liubei`)]],
            Mbaby_machao: ['male', 'shu', 4, ['mashu', 'minitieji']],
            Mbaby_re_machao: ['male', 'shu', 4, ['miniyuma', 'miniretieji'], ['character:Mbaby_machao']],
            Mbaby_zhurong: ['female', 'shu', 4, ['juxiang', 'minilieren'], ['name:null|null']],
            Mbaby_ol_zhurong: ['female', 'shu', 4, ['minijuxiang', 'minirelieren', 'changbiao'], ['name:null|null']],
            Mbaby_zhangfei: ['male', 'shu', 4, ['new_repaoxiao', 'minitishen']],
            Mbaby_re_zhangfei: ['male', 'shu', 4, ['new_repaoxiao', 'miniretishen']],
            Mbaby_zhaoyun: ['male', 'shu', 4, ['longdan', 'miniyajiao']],
            Mbaby_re_zhaoyun: ['male', 'shu', 4, ['ollongdan', 'minireyajiao']],
            Mbaby_huangzhong: ['male', 'shu', 4, ['miniliegong']],
            Mbaby_re_huangzhong: ['male', 'shu', 4, ['minireliegong']],
            Mbaby_weiyan: ['male', 'shu', 4, ['minikuanggu']],
            Mbaby_re_weiyan: ['male', 'shu', 4, ['minikuanggu', 'miniqimou']],
            Mbaby_liaohua: ['male', 'shu', 4, ['minidangxian']],
            Mbaby_re_liaohua: ['male', 'shu', 4, ['minidangxian', 'minifuli'], ['character:Mbaby_liaohua']],
            Mbaby_pangtong: ['male', 'shu', 3, ['minilianhuan', 'oldniepan']],
            Mbaby_ol_pangtong: ['male', 'shu', 3, ['minirelianhuan', 'mininiepan']],
            Mbaby_menghuo: ['male', 'shu', 5, ['minihuoshou', 'minizaiqi']],
            Mbaby_re_menghuo: ['male', 'shu', 5, ['minirehuoshou', 'minirezaiqi']],
            Mbaby_ol_jiangwei: ['male', 'shu', 4, ['minitiaoxin', 'minizhiji']],
            Mbaby_liushan: ['male', 'shu', 4, ['xiangle', 'minifangquan', 'miniruoyu'], ['zhu']],
            Mbaby_ol_liushan: ['male', 'shu', 4, ['minixiangle', 'minirefangquan', 'minireruoyu'], ['zhu']],
            Mbaby_xin_fazheng: ['male', 'shu', 3, ['minienyuan', 'minixuanhuo']],
            Mbaby_re_fazheng: ['male', 'shu', 3, ['minireenyuan', 'minirexuanhuo']],
            Mbaby_madai: ['male', 'shu', 4, ['mashu', 'miniqianxi']],
            Mbaby_guanping: ['male', 'shu', 4, ['minilongyin', 'jiezhong']],
            Mbaby_liufeng: ['male', 'shu', 4, ['minixiansi']],
            Mbaby_guanyinping: ['female', 'shu', 3, ['xueji', 'minihuxiao', 'miniwuji']],
            Mbaby_mb_guanyinping: ['female', 'shu', 3, ['minixueji', 'minirehuxiao', 'minirewuji']],
            Mbaby_dongyun: ['male', 'shu', 3, ['minibingzheng', 'sheyan']],
            Mbaby_sp_sunshangxiang: ['female', 'shu', 3, ['miniliangzhu', 'minifanxiang']],
            Mbaby_xushu: ['male', 'shu', 3, ['xinwuyan', 'minijujian']],
            Mbaby_xin_masu: ['male', 'shu', 3, ['minisanyao', 'minizhiman']],
            Mbaby_re_masu: ['male', 'shu', 3, ['miniresanyao', 'rezhiman'], ['character:Mbaby_xin_masu']],
            Mbaby_qinmi: ['male', 'shu', 3, ['jianzheng', 'minizhuandui', 'tianbian']],
            Mbaby_zhugezhan: ['male', 'shu', 3, ['minizuilun', 'xinfu_fuyin'], ['name:诸葛|瞻']],
            Mbaby_zhangxingcai: ['female', 'shu', 3, ['shenxian', 'miniqiangwu']],
            Mbaby_wuxian: ['female', 'shu', 3, ['minifumian', 'minidaiyan'], ['clan:陈留吴氏']],
            Mbaby_shamoke: ['male', 'shu', 4, ['minijili']],
            Mbaby_xiahoushi: ['female', 'shu', 3, ['miniqiaoshi', 'miniyanyu'], ['name:夏侯|null']],
            Mbaby_guansuo: ['male', 'shu', 4, ['minizhengnan', 'minixiefang']],
            Mbaby_mayunlu: ['female', 'shu', 4, ['minifengpo', 'mashu']],
            Mbaby_wangping: ['male', 'shu', 4, ['minifeijun', 'minibinglve']],
            Mbaby_jianyong: ['male', 'shu', 3, ['miniqiaoshui', 'jyzongshi']],
            Mbaby_zhugeguo: ['female', 'shu', 3, ['miniqirang', 'miniyuhua'], ['name:诸葛|果']],
            Mbaby_sp_zhugeliang: ['male', 'shu', 3, ['minibazhen', 'minihuoji', 'olkanpo'], ['name:诸葛|亮']],
            Mbaby_baosanniang: ['female', 'shu', 3, ['decadewuniang', 'minixushen']],
            Mbaby_huaman: ['female', 'shu', 4, ['manyi', 'mansi', 'minisouying', 'minizhanyuan']],
            Mbaby_zhaoxiang: ['female', 'shu', 4, ['refanghun', 'minifuhan']],
            Mbaby_xiahouba: ['male', 'shu', 4, ['minibaobian'], ['name:夏侯|霸']],
            Mbaby_yanyan: ['male', 'shu', 4, ['minijuzhan']],
            Mbaby_chendao: ['male', 'shu', 4, ['miniwanglie']],
            Mbaby_liyan: ['male', 'shu', 4, ['miniduliang', 'fulin']],
            Mbaby_liuchen: ['male', 'shu', 4, ['minizhanjue', 'miniqinwang'], ['zhu']],
            Mbaby_yangwan: ['female', 'shu', 3, ['miniyouyan', 'zhuihuan']],
            Mbaby_re_huangyueying: ['female', 'shu', 3, ['minijizhi', 'miniqicai']],
            Mbaby_zhoucang: ['male', 'shu', 4, ['minizhongyong', 'minidaopu']],
            Mbaby_lvkai: ['male', 'shu', 3, ['minitunan', 'xinfu_bijing']],
            Mbaby_sunqian: ['male', 'shu', 3, ['miniqianya', 'shuimeng']],
            Mbaby_ganfuren: ['female', 'shu', 3, ['minishushen', 'minihuangsi'], ['name:甘|null']],
            Mbaby_liuyong: ['male', 'shu', 3, ['zhuning', 'minifengxiang']],
            Mbaby_mizhu: ['male', 'shu', 3, ['miniziyuan', 'minijugu']],
            Mbaby_mifuren: ['female', 'shu', 3, ['miniguixiu', 'minicunsi'], ['name:糜|null']],
            Mbaby_wangyue: ['female', 'shu', 3, ['minihuguan', 'minimingluan']],
            Mbaby_xf_yiji: ['male', 'shu', 3, ['minijijie', 'minijiyuan']],
            Mbabysp_zhangfei: ['male', 'shu', 4, ['minipaoxiao', 'minixuhe']],
            Mbaby_wangtao: ['female', 'shu', 3, ['minihuguan', 'miniyaopei']],
            Mbaby_wolongfengchu: ['male', 'shu', 4, ['miniyoulong', 'miniluanfeng'], ['name:诸葛|亮-庞|统']],
            Mbaby_guanzhang: ['male', 'shu', 4, ['minifuhun', 'retongxin'], ['name:关|兴-张|苞']],
            Mbaby_sb_liubei: ['male', 'shu', 4, ['minisbrende', 'minisbzhangwu', 'minisbjijiang'], ['zhu']],
            Mbaby_sb_machao: ['male', 'shu', 4, ['miniyuma', 'minisbtieji']],
            Mbaby_sb_huangzhong: ['male', 'shu', 4, ['minisbliegong']],
            Mbaby_sb_zhaoyun: ['male', 'shu', 4, ['minisblongdan', 'minisbshilve']],
            Mbaby_zhangyi: ['male', 'shu', 5, ['rewurong', 'minishizhi']],
            Mbaby_jiangfei: ['male', 'shu', 3, ['reshengxi', 'minishoucheng']],
            Mbaby_sb_sunshangxiang: ['female', 'wu', 3, ['minisbxiaoji', 'minisbjieyin', 'minisbfanxiang'], ['border:shu']],
            Mbaby_sb_xiahoushi: ['female', 'shu', 3, ['sbqiaoshi', 'minispyanyu'], ['name:夏侯|null']],
            Mbaby_dc_hujinding: ['female', 'shu', '3/6', ['dcdeshi', 'miniwuyuan', 'huaizi']],
            Mbaby_re_dengzhi: ['male', 'shu', 3, ['jianliang', 'miniweimeng']],
            Mbaby_re_mazhong: ['male', 'shu', 4, ['minifuman']],
            Mbaby_ol_sb_guanyu: ['male', 'shu', 4, ['miniweilin', 'miniduoshou']],
            Mbaby_zongyu: ['male', 'shu', 3, ['zyqiao', 'minichengshang']],
            Mbaby_sb_huangyueying: ['female', 'shu', 3, ['miniliuma', 'minisbjizhi', 'minisbqicai']],
            Mbaby_ol_sb_jiangwei: ['male', 'shu', 4, ['olsbzhuri', 'miniranji']],
            Mbaby_leitong: ['male', 'shu', 4, ['minikuiji']],
            Mbaby_wulan: ['male', 'shu', 4, ['minicuorui']],
            Mbaby_zhaotongzhaoguang: ['male', 'shu', 4, ['yizan_use', 'miniqingren', 'dclongyuan'], ['name:赵|统-赵|广']],
            Mbaby_ganfurenmifuren: ['female', 'shu', 3, ['dcchanjuan', 'minixunbie'], ['name:甘|null-糜|null']],
            Mbaby_huanghao: ['male', 'shu', 3, ['miniqinqing', 'huisheng', 'minicunwei']],
            Mbaby_xianglang: ['male', 'shu', 3, ['dckanji', 'miniqianzheng']],
            Mbaby_guanyue: ['male', 'shu', 4, ['dcshouzhi', 'minifenhui']],
            Mbaby_mifangfushiren: ['male', 'shu', 4, ['minifengshi'], ['name:糜|芳-傅|士仁']],
            Mbaby_dc_wuban: ['male', 'shu', 4, ['miniyouzhan'], ['clan:陈留吴氏']],
            //吴
            Mbaby_bulianshi: ['female', 'wu', 3, ['minianxu', 'zhuiyi']],
            Mbaby_chengpu: ['male', 'wu', 4, ['minilihuo', 'minichunlao']],
            Mbaby_daqiao: ['female', 'wu', 3, ['miniguose', 'liuli'], ['name:桥|null']],
            Mbaby_re_daqiao: ['female', 'wu', 3, ['miniwanrong', 'miniguose', 'liuli'], ['name:桥|null']],
            Mbaby_ganning: ['male', 'wu', 4, ['miniqixi']],
            Mbaby_re_ganning: ['male', 'wu', 4, ['minireqixi', 'minifenwei']],
            Mbaby_huanggai: ['male', 'wu', 4, ['minikurou']],
            Mbaby_re_huanggai: ['male', 'wu', 4, ['kurou', 'minizhaxiang']],
            Mbaby_lusu: ['male', 'wu', 3, ['minihaoshi', 'dimeng']],
            Mbaby_ol_lusu: ['male', 'wu', 3, ['miniolhaoshi', 'minidimeng']],
            Mbaby_luxun: ['male', 'wu', 3, ['miniqianxun', 'lianying']],
            Mbaby_re_luxun: ['male', 'wu', 4, ['minireqianxun', 'minilianying']],
            Mbaby_lvmeng: ['male', 'wu', 4, ['minikeji']],
            Mbaby_re_lvmeng: ['male', 'wu', 4, ['minikeji', 'miniqinxue', 'rebotu']],
            Mbaby_sunce: ['male', 'wu', 4, ['jiang', 'minihunzi', 'minizhiba'], ['zhu']],
            Mbaby_re_sunce: ['male', 'wu', 4, ['minijiang', 'miniolhunzi', 'miniolzhiba'], ['zhu']],
            Mbaby_sunluban: ['female', 'wu', 3, ['minizenhui', 'minijiaojin']],
            Mbaby_sunluyu: ['female', 'wu', 3, ['minimeibu', 'remumu']],
            Mbaby_sunquan: ['male', 'wu', 4, ['rezhiheng', 'minijiuyuan'], ['zhu']],
            Mbaby_re_sunquan: ['male', 'wu', 4, ['minirezhiheng', 'minirejiuyuan'], ['zhu']],
            Mbaby_old_sunquan: ['male', 'wu', 4, ['minizhiheng', 'jiuyuan'], ['zhu', 'character:Mbaby_sunquan', ...['die', 'tempname'].map(i => `${i}:sunquan`)]],
            Mbaby_sunshangxiang: ['female', 'wu', 3, ['minijieyin', 'xiaoji']],
            Mbaby_re_sunshangxiang: ['female', 'wu', 3, ['minijieyi', 'xiaoji'], ['zhu']],
            Mbaby_taishici: ['male', 'wu', 4, ['minitianyi'], ['name:太史|慈']],
            Mbaby_re_taishici: ['male', 'wu', 4, ['miniretianyi', 'minihanzhan'], ['name:太史|慈', 'character:Mbaby_taishici']],
            Mbaby_wuguotai: ['female', 'wu', 3, ['miniganlu', 'minibuyi'], ['name:丁|null']],
            Mbaby_ol_wuguotai: ['female', 'wu', 3, ['minireganlu', 'minirebuyi'], ['name:丁|null', 'character:Mbaby_wuguotai']],
            Mbaby_xiaoqiao: ['female', 'wu', 3, ['minitianxiang', 'hongyan'], ['name:桥|null']],
            Mbaby_ol_xiaoqiao: ['female', 'wu', 3, ['miniretianxiang', 'olhongyan'], ['name:桥|null']],
            Mbaby_xusheng: ['male', 'wu', 4, ['minipojun']],
            Mbaby_re_xusheng: ['male', 'wu', 4, ['minirepojun']],
            Mbaby_xin_xusheng: ['male', 'wu', 4, ['minidcpojun', 'miniyicheng'], ['character:bilibili_re_xusheng', 'unseen']],
            Mbaby_old_zhoutai: ['male', 'wu', 4, ['minibuqu', 'fenji'], ['character:Mbaby_zhoutai']],
            Mbaby_zhoutai: ['male', 'wu', 4, ['minirebuqu', 'fenji', 'miniqingchuang']],
            Mbaby_zhouyu: ['male', 'wu', 3, ['reyingzi', 'minifanjian']],
            Mbaby_re_zhouyu: ['male', 'wu', 3, ['minireyingzi', 'minirefanjian']],
            Mbaby_zhugejin: ['male', 'wu', 3, ['huanshi', 'minihongyuan', 'mingzhe'], ['name:诸葛|瑾']],
            Mbaby_zumao: ['male', 'wu', 4, ['miniyinbing', 'minijuedi']],
            Mbabysp_xiaoqiao: ['female', 'wu', 3, ['minixingwu', 'miniluoyan', 'minihuimou'], ['tempname:ol_xiaoqiao', 'name:桥|null']],
            Mbaby_zhuzhi: ['male', 'wu', 4, ['minianguo']],
            Mbaby_sunjian: ['male', 'wu', 4, ['miniyinghun'], ['character:Mbaby_ol_sunjian']],
            Mbaby_ol_sunjian: ['male', 'wu', 4, ['minireyinghun', 'miniwulie']],
            Mbaby_sunliang: ['male', 'wu', 3, ['minikuizhu', 'minichezheng', 'minilijun'], ['zhu']],
            Mbaby_zhangzhang: ['male', 'wu', 3, ['rezhijian', 'miniguzheng']],
            Mbaby_zhoufei: ['female', 'wu', 3, ['miniliangyin', 'kongsheng'], ['name:周|null']],
            Mbaby_zhugeke: ['male', 'wu', 3, ['miniaocai', 'miniduwu'], ['name:诸葛|恪']],
            Mbaby_xushi: ['female', 'wu', 3, ['miniwengua', 'minifuzhu'], ['name:徐|null']],
            Mbaby_buzhi: ['male', 'wu', 3, ['minihongde', 'minidingpan']],
            Mbaby_lukang: ['male', 'wu', 4, ['drlt_qianjie', 'minijueyan', 'minihuairou']],
            Mbabysp_daqiao: ['female', 'wu', 3, ['miniyanxiao', 'miniguose', 'minianxian'], ['name:桥|null']],
            Mbaby_sunhao: ['male', 'wu', 5, ['minicanshi', 'minichouhai', 'guiming'], ['zhu']],
            Mbaby_re_jsp_pangtong: ['male', 'wu', 3, ['miniguolun', 'minisongsang', 'xinfu_zhanji']],
            Mbaby_luyusheng: ['female', 'wu', 3, ['minizhente', 'minizhiwei']],
            Mbaby_zhuhuan: ['male', 'wu', 4, ['minifenli', 'minipingkou']],
            Mbaby_yanjun: ['male', 'wu', 3, ['miniguanchao', 'minixunxian']],
            Mbaby_re_sunyi: ['male', 'wu', 5, ['syjiqiao', 'minisyxiongyi']],
            Mbaby_zhangxuan: ['female', 'wu', 4, ['tongli', 'minishezang']],
            Mbaby_zhoufang: ['male', 'wu', 3, ['xinfu_duanfa', 'miniyoudi']],
            Mbaby_luji: ['male', 'wu', 3, ['nzry_huaiju', 'nzry_yili', 'minizhenglun']],
            Mbaby_re_sundeng: ['male', 'wu', 4, ['minikuangbi']],
            Mbaby_panjun: ['male', 'wu', 3, ['miniguanwei', 'minigongqing']],
            Mbaby_dingfeng: ['male', 'wu', 4, ['miniduanbing', 'minifenxun']],
            Mbaby_xuezong: ['male', 'wu', 3, ['minifunan', 'minijiexun']],
            Mbaby_sb_huanggai: ['male', 'wu', 4, ['minisbkurou', 'minisbzhaxiang']],
            Mbaby_zhangfen: ['male', 'wu', 4, ['miniwanglu', 'minixianzhu', 'minichaixie']],
            Mbaby_sunxiu: ['male', 'wu', 3, ['miniyanzhu', 'minixingxue', 'minizhaofu'], ['zhu']],
            Mbaby_dc_sunru: ['female', 'wu', 3, ['minixiecui', 'youxu']],
            Mbaby_yufan: ['male', 'wu', 3, ['minizongxuan', 'minizhiyan']],
            Mbaby_quancong: ['male', 'wu', 4, ['miniyaoming']],
            Mbaby_re_guyong: ['male', 'wu', 3, ['minishenxing', 'rebingyi']],
            Mbaby_sb_lvmeng: ['male', 'wu', 4, ['minikeji', 'minisbduojing']],
            Mbaby_quanhuijie: ['female', 'wu', 3, ['dchuishu', 'dcyishu', 'miniligong']],
            Mbaby_jiangqing: ['male', 'wu', 4, ['minijianyi', 'minishangyi']],
            Mbaby_lvdai: ['male', 'wu', 4, ['miniqinguo']],
            Mbaby_heqi: ['male', 'wu', 4, ['miniqizhou', 'minishanxi']],
            Mbaby_dc_sunhanhua: ['female', 'wu', 3, ['minihuiling', 'minichongxu']],
            Mbaby_zhangwen: ['male', 'wu', 3, ['minisongshu', 'minisibian']],
            Mbaby_weiwenzhugezhi: ['male', 'wu', 4, ['minifuhai'], ['name:卫|温-诸葛|直']],
            Mbaby_re_panzhangmazhong: ['male', 'wu', 4, ['miniduodao', 'minianjian'], ['name:潘|璋-马|忠']],
            Mbaby_kanze: ['male', 'wu', 4, ['xiashu', 'minikuanshi']],
            Mbaby_sb_ganning: ['male', 'wu', 4, ['minisbqixi', 'minisbfenwei']],
            Mbaby_chendong: ['male', 'wu', 4, ['miniduanxie', 'minifenming']],
            Mbaby_xugong: ['male', 'wu', 4, ['minibiaozhao', 'miniyechou']],
            Mbaby_zhupeilan: ['female', 'wu', 3, ['minicilv', 'dctongdao']],
            Mbaby_sb_sunquan: ['male', 'wu', 4, ['jdsbzhiheng', 'minitongye', 'jdsbjiuyuan'], ['zhu']],
            Mbaby_xielingyu: ['female', 'wu', 3, ['miniyuandi', 'dcxinyou']],
            Mbaby_lvfan: ['male', 'wu', 3, ['minidiaodu', 'minidiancai']],
            Mbaby_gexuan: ['male', 'wu', 3, ['minilianhua', 'zhafu']],
            Mbaby_sunhuan: ['male', 'wu', 4, ['mininiji']],
            //群
            Mbaby_gaoshun: ['male', 'qun', 4, ['minixianzhen', 'minijinjiu']],
            Mbaby_xin_gaoshun: ['male', 'qun', 4, ['minirexianzhen', 'minirejinjiu'], ['character:Mbaby_gaoshun']],
            Mbaby_caifuren: ['female', 'qun', 3, ['miniqieting', 'minixianzhou'], ['name:蔡|null']],
            Mbaby_re_caifuren: ['female', 'qun', 3, ['minireqieting', 'minirexianzhou'], ['name:蔡|null']],
            Mbaby_lijue: ['male', 'qun', '5/6', ['xinfu_langxi', 'xinfu_yisuan']],
            Mbaby_zuoci: ['male', 'qun', 3, ['minishendao', 'minixinsheng']],
            Mbaby_xuyou: ['male', 'qun', 3, ['minichenglve', 'nzry_shicai', 'nzry_cunmu']],
            Mbaby_re_gongsunzan: ['male', 'qun', 4, ['miniqiaomeng', 'miniyicong'], ['name:公孙|瓒']],
            Mbaby_pangde: ['male', 'qun', 4, ['mashu', 'minijianchu']],
            Mbaby_re_pangde: ['male', 'qun', 4, ['mashu', 'minirejianchu']],
            Mbaby_yj_jushou: ['male', 'qun', 3, ['jianying', 'minishibei']],
            Mbaby_liru: ['male', 'qun', 3, ['xinjuece', 'minimieji', 'xinfencheng']],
            Mbaby_dongzhuo: ['male', 'qun', 8, ['minijiuchi', 'roulin', 'minibenghuai', 'baonue'], ['zhu']],
            Mbaby_ol_dongzhuo: ['male', 'qun', 8, ['minirejiuchi', 'miniroulin', 'minirebenghuai', 'olbaonue'], ['zhu']],
            Mbaby_sp_zhangjiao: ['male', 'qun', 3, ['releiji', 'guidao', 'minihuangtian'], ['zhu']],
            Mbaby_re_zhangjiao: ['male', 'qun', 3, ['minileiji', 'xinguidao', 'minixinhuangtian'], ['zhu']],
            Mbaby_huatuo: ['male', 'qun', 3, ['jijiu', 'miniqingnang']],
            Mbaby_re_huatuo: ['male', 'qun', 3, ['minijijiu', 'minireqingnang']],
            Mbaby_lvbu: ['male', 'qun', 5, ['wushuang']],
            Mbaby_re_lvbu: ['male', 'qun', 5, ['miniwushuang', 'miniwuchang']],
            Mbaby_sp_diaochan: ['female', 'qun', 3, ['minilihun', 'minipianyi']],
            Mbaby_huaxiong: ['male', 'qun', 6, ['miniyaowu']],
            Mbaby_sb_huaxiong: ['male', 'qun', 6, ['minireyaowu', 'miniyangwei']],
            Mbaby_yuji: ['male', 'qun', 4, ['miniguhuo']],
            Mbaby_zhangliang: ['male', 'qun', 4, ['minijijun', 'minifangtong']],
            Mbaby_zhangbao: ['male', 'qun', 4, ['minizhoufu', 'miniyingbing']],
            Mbaby_ol_yanwen: ['male', 'qun', 4, ['minishuangxiong']],
            Mbaby_liubiao: ['male', 'qun', 3, ['minizishou', 'minizongshi']],
            Mbaby_re_liubiao: ['male', 'qun', 3, ['rezishou', 'rezongshi'], ['character:Mbaby_liubiao']],
            Mbaby_yuanshao: ['male', 'qun', 4, ['miniluanji', 'minixueyi'], ['zhu', 'tempname:re_yuanshao']],
            Mbaby_xin_yuanshao: ['male', 'qun', 4, ['minireluanji', 'minixueyi'], ['zhu', 'character:Mbaby_yuanshao']],
            Mbaby_yuanshu: ['male', 'qun', 4, ['yongsi', 'miniweidi']],
            Mbaby_yl_yuanshu: ['male', 'qun', 4, ['miniyongsi', 'minireweidi'], ['character:Mbaby_yuanshu']],
            Mbaby_chengong: ['male', 'qun', 3, ['minimingce', 'minizhichi']],
            Mbaby_re_chengong: ['male', 'qun', 3, ['miniremingce', 'minizhichi']],
            Mbaby_jiaxu: ['male', 'qun', 3, ['miniwansha', 'luanwu', 'weimu']],
            Mbaby_re_jiaxu: ['male', 'qun', 3, ['minirewansha', 'reluanwu', 'reweimu']],
            Mbaby_liuzhang: ['male', 'qun', 4, ['miniyinlang', 'minixiusheng', 'minihuaibi'], ['zhu']],
            Mbaby_panfeng: ['male', 'qun', 4, ['minikuangfu']],
            Mbaby_sp_machao: ['male', 'qun', 4, ['minizhuiji', 'minishichou']],
            Mbaby_diaochan: ['female', 'qun', 4, ['minilijian', 'biyue']],
            Mbaby_re_diaochan: ['female', 'qun', 3, ['minirelijian', 'minibiyue']],
            Mbaby_jsp_huangyueying: ['female', 'qun', 3, ['minijiqiao', 'minilinglong']],
            Mbaby_quyi: ['male', 'qun', 4, ['minifuqi', 'minijiaozi']],
            Mbaby_liuxie: ['male', 'qun', 3, ['minitianming', 'minimizhao']],
            Mbaby_ol_caiwenji: ['female', 'qun', 3, ['minibeige', 'duanchang'], ['name:蔡|琰']],
            Mbaby_fuhuanghou: ['female', 'qun', 3, ['minizhuikong', 'miniqiuyuan']],
            Mbaby_zhangqiying: ['female', 'qun', 3, ['xinfu_falu', 'minidianhua', 'zhenyi']],
            Mbaby_chunyuqiong: ['male', 'qun', 4, ['minicangchu', 'miniliangying', 'minishishou']],
            Mbaby_beimihu: ['female', 'qun', 4, ['minizongkui', 'miniguju', 'bmcanshi']],
            Mbaby_dongbai: ['female', 'qun', 3, ['minilianzhu', 'minixiahui']],
            Mbaby_zhangji: ['male', 'qun', 4, ['minilveming', 'minitunjun']],
            Mbaby_sp_taishici: ['male', 'qun', 4, ['minijixu'], ['name:太史|慈']],
            Mbaby_xushao: ['male', 'qun', 4, ['minipingjian']],
            Mbaby_hetaihou: ['female', 'qun', 3, ['minizhendu', 'miniqiluan']],
            Mbaby_wangrong: ['female', 'qun', 3, ['miniminsi', 'minijijing', 'zhuide']],
            Mbaby_sp_menghuo: ['male', 'qun', 4, ['minimanwang']],
            Mbaby_caoxing: ['male', 'qun', 4, ['miniliushi', 'zhanwan']],
            Mbabysp_zhenji: ['female', 'qun', 3, ['minijinghong', 'minispluoshen']],
            Mbaby_liangxing: ['male', 'qun', 4, ['minilulve', 'lxzhuixi']],
            Mbaby_caojie: ['female', 'qun', 3, ['minishouxi', 'minihuimin']],
            Mbaby_tangji: ['female', 'qun', 3, ['minikangge', 'minijielie']],
            Mbaby_libai: ['male', 'qun', 3, ['minishixian']],
            Mbaby_guotufengji: ['male', 'qun', 3, ['minijigong', 'minishifei']],
            Mbaby_re_nanhualaoxian: ['male', 'qun', 4, ['minijinghe', 'minigongxiu']],
            Mbaby_yanfuren: ['female', 'qun', 3, ['minichanni', 'mininifu'], ['name:严|null']],
            Mbaby_gongsunyuan: ['male', 'qun', 4, ['minihuaiyi'], ['name:公孙|渊']],
            Mbaby_re_gongsunyuan: ['male', 'qun', 4, ['minirehuaiyi'], ['name:公孙|渊', 'character:Mbaby_gongsunyuan']],
            Mbaby_sp_zhangliao: ['male', 'qun', 4, ['minimubing', 'miniziqu', 'minidiaoling']],
            Mbaby_sp_ol_zhanghe: ['male', 'qun', 4, ['minizhouxuan']],
            Mbaby_zhujun: ['male', 'qun', 4, ['minigongjian', 'kuimang', 'minizjjuxiang']],
            Mbaby_sp_kongrong: ['male', 'qun', 3, ['minilirang', 'minizhengyi']],
            Mbaby_laiyinger: ['female', 'qun', 3, ['minixiaowu', 'minihuaping']],
            Mbaby_sb_yuanshao: ['male', 'qun', 4, ['minisbluanji', 'minisbxueyi'], ['zhu']],
            Mbaby_tw_mateng: ['male', 'qun', 4, ['miniyuma', 'minixiongzheng', 'miniluannian'], ['zhu']],
            Mbaby_dc_huangchengyan: ['male', 'qun', 3, ['dcjiezhen', 'minizecai', 'dcyinshi']],
            Mbaby_simahui: ['male', 'qun', 3, ['minijianjie', 'xinfu_chenghao', 'miniyinshi'], ['name:司马|徽']],
            Mbaby_zoushi: ['female', 'qun', 3, ['minihuoshui', 'miniqingcheng'], ['name:邹|null']],
            Mbaby_wangyun: ['male', 'qun', 4, ['minilianji', 'minimoucheng'], ['clan:太原王氏']],
            Mbaby_xiaoshan: ['female', 'qun', 4, ['minishanshan', 'minianshi']],
            Mbaby_zhanglu: ['male', 'qun', 3, ['miniyishe', 'minibushi', 'minimidao']],
            Mbaby_zhangning: ['female', 'qun', 3, ['minitianze', 'minidifa']],
            Mbaby_ol_dingyuan: ['male', 'qun', 4, ['minicixiao', 'xianshuai']],
            Mbaby_liubian: ['male', 'qun', 3, ['shiyuan', 'minidushi', 'yuwei'], ['zhu']],
            Mbaby_re_pangdegong: ['male', 'qun', 3, ['miniheqia', 'yinyi']],
            Mbaby_licaiwei: ['female', 'qun', 3, ['yijiao', 'miniqibie'], ['border:wei']],
            Mbaby_dc_huangzu: ['male', 'qun', 4, ['dcjinggong', 'minixiaojuan']],
            Mbaby_yanbaihu: ['male', 'qun', 4, ['minizhidao', 'minybhijili']],
            Mbaby_guosi: ['male', 'qun', 4, ['minitanbei', 'minisidao']],
            Mbaby_fanchou: ['male', 'qun', 4, ['minixingluan']],
            Mbaby_huangfusong: ['male', 'qun', 4, ['xinfenyue', 'minijuxia']],
            Mbaby_wutugu: ['male', 'qun', 15, ['miniranshang', 'hanyong']],
            Mbaby_fuwan: ['male', 'qun', 4, ['minimoukui']],
            Mbaby_dongxie: ['female', 'qun', 4, ['minijiaoxia', 'minihumei']],
            Mbaby_guanning: ['male', 'qun', '3/7', ['minidunshi']],
            Mbaby_re_hansui: ['male', 'qun', 4, ['mininiluan', 'spweiwu']],
            Mbaby_tadun: ['male', 'qun', 4, ['miniluanzhan']],
            Mbaby_re_tadun: ['male', 'qun', 4, ['minireluanzhan'], ['die:tadun', 'character:Mbaby_tadun']],
            Mbaby_dc_gaolan: ['male', 'qun', 4, ['minixizhen']],
            Mbaby_yl_luzhi: ['male', 'qun', 3, ['nzry_mingren', 'minizhenliang']],
            Mbaby_mengjie: ['male', 'qun', 3, ['dcyinlu', 'miniyouqi']],
            Mbaby_caiyong: ['male', 'qun', 3, ['minibizhuan', 'minitongbo']],
            Mbaby_re_chendeng: ['male', 'qun', 3, ['refuyuan', 'miniyingshui', 'rewangzu']],
            Mbaby_duanwei: ['male', 'qun', 4, ['minilangmie']],
            Mbabysp_xuhuang: ['male', 'qun', 4, ['minikuanmeng', 'minixuefeng']],
            Mbaby_zhangrang: ['male', 'qun', 3, ['minitaoluan']],
            Mbabysp_liubei: ['male', 'qun', 4, ['minizhuyi', 'minixiafeng']],
            Mbaby_ol_sb_huaxiong: ['male', 'qun', 6, ['olsbbojue', 'minisbyangwei']],
            Mbaby_jiling: ['male', 'qun', 4, ['minishuangren']],
            Mbaby_star_yuanshu: ['male', 'qun', 4, ['starcanxi', 'ministarpizhi', 'ministarzhonggu'], ['zhu']],
            Mbabysp_sunjian: ['male', 'qun', 4, ['miniyingyi', 'miniliezhi']],
            Mbaby_hejin: ['male', 'qun', 4, ['minimouzhu', 'miniyanhuo']],
            Mbaby_re_taoqian: ['male', 'qun', 3, ['minizhaohuo', 'reyixiang', 'reyirang']],
            Mbaby_xurong: ['male', 'qun', 4, ['minixionghuo', 'minishajue']],
            //神
            Mbaby_shen_zhugeliang: ['male', 'shen', 3, ['qixing', 'minikuangfeng', 'minidawu'], ['shu', 'name:诸葛|亮']],
            Mbaby_shen_lvbu: ['male', 'shen', 6, ['miniwuqian', 'minishenfen'], ['qun']],
            Mbaby_shen_lvmeng: ['male', 'shen', 3, ['minishelie', 'minigongxin'], ['wu']],
            Mbaby_shen_guanyu: ['male', 'shen', 5, ['miniwushen', 'miniwuhun'], ['shu']],
            Mbaby_shen_zhouyu: ['male', 'shen', 4, ['miniqinyin', 'miniyeyan'], ['wu']],
            Mbaby_shen_caocao: ['male', 'shen', 3, ['miniguixin', 'feiying'], ['wei']],
            Mbaby_shen_liubei: ['male', 'shen', 6, ['minilongnu', 'minijieyig'], ['shu']],
            Mbaby_shen_zhangliao: ['male', 'shen', 4, ['miniduorui', 'minizhiti'], ['wei']],
            Mbaby_shen_sunquan: ['male', 'shen', 4, ['miniquanxue', 'minishehu', 'minidingli'], ['wu']],
            Mbaby_shen_simayi: ['male', 'shen', 3, ['minirenjie', 'minijilve', 'lianpo'], ['wei', 'name:司马|懿']],
            Mbaby_shen_zhaoyun: ['male', 'shen', 2, ['minijuejing', 'minilonghun'], ['shu']],
            Mbaby_shen_ganning: ['male', 'shen', '3/6', ['minipoxi', 'drlt_jieying'], ['wu']],
            Mbaby_shen_dianwei: ['male', 'shen', 5, ['minishenwei', 'minielai', 'minikuangxi'], ['wei']],
            Mbaby_shen_huatuo: ['male', 'shen', 1, ['minijishi', 'minitaoxian', 'minishenzhen'], ['qun']],
            Mbaby_shen_guojia: ['male', 'shen', 3, ['reshuishi', 'minigjtianyi', 'minihuishi'], ['wei']],
            Mbaby_shen_zhenji: ['female', 'shen', 3, ['minishenfu', 'minireqixian', 'minifeifu'], ['wei']],
            Mbaby_shen_daxiaoqiao: {
                sex: 'female',
                group: 'shen',
                hp: 3,
                hp2: 3,
                skills: ['minishuangshu1', 'minishutu', 'minitongdi'],
                groupInGuozhan: 'wu',
                names: '桥|null-桥|null',
            },
            Mbaby_old_1_daxiaoqiao: ['female', 'shen', 4, ['minishuangshu', 'miniyizheng', 'minipingting'], ['wu', ...['character', 'die'].map(i => `${i}:Mbaby_shen_daxiaoqiao`)]],
            Mbaby_old_2_daxiaoqiao: ['female', 'shen', 4, ['minishuangshu2', 'miniyizheng2', 'minishutu2'], ['wu', ...['character', 'die'].map(i => `${i}:Mbaby_shen_daxiaoqiao`)]],
            Mbaby_shen_diaochan: ['female', 'shen', 3, ['minimeihun', 'minihuoxin'], ['qun']],
            Mbaby_sunwukong: ['male', 'shen', 4, ['minisevenbian', 'miniruyi', 'miniqitian']],
            Mbaby_dalanmao: ['male', 'shen', 4, ['minizuzhou', 'minimoyu', 'minisanlian']],
            Mbaby_change: ['female', 'shen', '1/4', ['minidaoyao', 'minibenyue']],
            Mbaby_shen_taishici: ['male', 'shen', 4, ['minidulie', 'minichongwei', 'minipowei'], ['wu', 'name:太史|慈']],
            Mbaby_nvwa: ['female', 'shen', '69/159', ['minibutian', 'minilianshi', 'minituantu']],
            Mbaby_tunxingmenglix: ['female', 'shen', 4, ['minitunxing', 'minimengli']],
            Mbaby_shen_zuoci: ['male', 'shen', 3, ['minihuanshu', 'minihuanhua', 'minihuanjing'], ['qun']],
            Mbaby_shen_dengai: ['male', 'shen', 4, ['dctuoyu', 'minixianjin', 'dcqijing'], ['wei']],
            Mbaby_shen_luxun: ['male', 'shen', 4, ['nzry_junlve', 'minicuike', 'nzry_dinghuo'], ['wu']],
            Mbaby_shen_pangtong: ['male', 'shen', 4, ['minilunce', 'minilanhai'], ['shu']],
            Mbaby_jingwei: ['female', 'shen', 4, ['minitianhai', 'minihaiku']],
            Mbaby_shen_lusu: ['male', 'shen', 3, ['minitamo', 'minidingzhou', 'zhimeng'], ['wu']],
            //喵
            Mmiao_caiwenji: ['female', 'qun', 3, ['minimiaobeige', 'minimiaoduanchang', 'minidoumao'], ['name:蔡|琰']],
            Mmiao_diaochan: ['female', 'qun', 3, ['minimiaolijian', 'minimiaobiyue', 'minidoumao']],
            Mmiao_caifuren: ['female', 'qun', 3, ['minimiaoqieting', 'minimiaoxianzhou', 'minidoumao'], ['name:蔡|null']],
            Mmiao_zhangxingcai: ['female', 'shu', 3, ['minimiaoshenxian', 'minimiaoqiangwu', 'minidoumao']],
            Mmiao_zhurong: ['female', 'shu', 4, ['minimiaojuxiang', 'minimiaolieren', 'minidoumao']],
            Mmiao_huangyueying: ['female', 'shu', 3, ['minimiaojizhi', 'minimiaoqicai', 'minidoumao']],
            Mmiao_daqiao: ['female', 'wu', 3, ['minimiaoguose', 'minimiaoliuli', 'minidoumao'], ['name:桥|null']],
            Mmiao_wangyi: ['female', 'wei', 4, ['minimiaozhenlie', 'minimiaomiji', 'minidoumao']],
            Mmiao_zhangchunhua: ['female', 'wei', 3, ['minimiaojueqing', 'minimiaoshangshi', 'minidoumao']],
            Mmiao_zhenji: ['female', 'wei', 3, ['minimiaoluoshen', 'minimiaoqingguo', 'minidoumao']],
            Mmiao_sunshangxiang: ['female', 'wu', 3, ['minimiaojieyin', 'minimiaoxiaoji', 'minidoumao']],
            Mmiao_xiaoqiao: ['female', 'wu', 3, ['minimiaotianxiang', 'minimiaohongyan', 'minidoumao'], ['name:桥|null']],
            Mmiao_lvlingqi: ['female', 'qun', 4, ['minimiaozhuangrong', 'minimiaoguowu', 'minidoumao']],
            Mmiao_caoying: ['female', 'wei', 4, ['minimiaolingren', 'minimiaofujian', 'minidoumao']],
            Mmiao_guanyinping: ['female', 'shu', 4, ['minimiaowuji', 'minimiaohuxiao', 'minidoumao']],
            Mmiao_mayunlu: ['female', 'shu', 4, ['minimiaoyuma', 'minimiaofengpo', 'minidoumao']],
            //念
            Mnian_zhugeliang: ['male', 'shu', 3, ['mininianxinghan', 'mininianliaoyuan', 'mininianying_zgl'], ['name:诸葛|亮']],
            Mnian_lvbu: ['male', 'qun', 5, ['mininiantazhen', 'mininiandoupo', 'mininianying_lb']],
            Mnian_zhouyu: ['male', 'wu', 4, ['mininiansuhui', 'mininianchongzou', 'mininianying_zy']],
            Mnian_caopi: ['male', 'wei', 3, ['mininiandengji', 'mininianchengming', 'mininianying_cp', 'mininiansongwei'], ['zhu']],
            //战
            Mfight_huangzhong: ['male', 'shu', 4, ['minifightdingjun', 'minifightlizhan']],
            Mfight_zhangliao: ['male', 'wei', 4, ['minifightbiaoxi', 'minifightpozhen']],
            Mfight_luxun: ['male', 'wu', 4, ['minifightxurui', 'minifightshijie']],
            Mfight_dianwei: ['male', 'wei', 5, ['minifightchuanglie', 'minifightkuangji']],
            Mfight_machao: ['male', 'qun', 4, ['minifightdangfeng', 'minifighthaiji']],
            Mfight_jiangwei: ['male', 'shu', 4, ['minifightyilve', 'minifightqizhi']],
            // 隐
            Myin_xushu: ['male', 'wei', 3, ['miniyinyinxing', 'miniyinjujian']],
        },
        characterIntro: {
            Mbaby_change: '嫦娥，中国古代神话中的人物，又名恒我、恒娥、姮娥、常娥、素娥，羿之妻，因偷吃了不死药而飞升至月宫。嫦娥的故事最早出现在商朝卦书 《归藏》。而嫦娥奔月的完整故事最早记载于西汉《淮南子·览冥训》。东汉时期，嫦娥与羿的夫妻关系确立，而嫦娥在进入月宫后变成了捣药的蟾蜍。南北朝以后，嫦娥的形象回归为女儿身。汉画像中，嫦娥人头蛇身，头梳高髻，身着宽袖长襦，身后长尾上饰有倒钩状细短羽毛。南北朝以后，嫦娥的形象被描绘成绝世美女。南朝陈后主陈叔宝曾把宠妃张丽华比作嫦娥。唐朝诗人白居易曾用嫦娥夸赞邻家少女不可多得的容貌。',
            Mbaby_nvwa: '女娲，中国上古神话中的创世女神。又称娲皇、女阴，史记女娲氏，是华夏民族人文先始，是福佑社稷之正神。相传女娲造人，一日中七十化变，以黄泥仿照自己抟土造人，创造人类社会并建立婚姻制度；因世间天塌地陷，于是熔彩石以补苍天，斩鳌足以立四极，留下了女娲补天的神话传说。女娲不但是补天救世的英雄和抟土造人的女神，还是一个创造万物的自然之神，神通广大化生万物，每天至少能创造出七十样东西。她开世造物，因此被称为大地之母，是被民间广泛而又长久崇拜的创世神和始母神。',
            Mbaby_tunxingmenglix: '据《王子年拾遗记》记载：蜀先主甘后；生而体貌特异，年至十八，玉质柔肌，态媚容冶…河南献玉人高三尺…甘后与玉人洁白齐润，观者殆相乱惑。刘备非常喜爱这尊玉雕，“夕则用后而玩玉人”。白玉美人怀抱一只白玉狸猫，甘夫人常对玉人倾诉渴望为刘备诞下一子的心愿，然而久盼未果。偶有一日，在梦中化身成一只饥肠辘辘、失去理智的白玉狸猫，闯入到幻境当中，吞掉了幻境中的启明星。事后，梦醒的甘夫人发现已怀有身孕，甚是欣喜。而白玉美人怀抱的玉狸猫则留在了幻境中，化身为吞星梦狸守护着幻境里的星星。',
            Mbaby_jingwei: '精卫，中国古代神话中的一种鸟。上古神话传说里，女娃是炎帝最小的女儿，后溺水而亡，化作精卫鸟；另一说，女娃是上古的一个部落，由于气候变暖，海平面上升，女娃部落遭到灭顶之灾，后化作精卫。据《山海经》记载：精卫婀娜多姿、长发飘逸、背生双翼，花头颅、白嘴壳、红脚爪，样子有点儿像乌鸦。',
        },
        characterFilter: {
        },
        characterTitle: {
        },
        characterSubstitute: {
            Mbaby_tunxingmenglix: [
                ['Mbaby_tunxingmengli', ['img:extension/活动武将/image/character/Mbaby_tunxingmengli.jpg', 'die:ext:活动武将/audio/die/Mbaby_tunxingmenglix.mp3']],
            ],
        },
        card: {
            miniyanxiao_card: {
                type: 'delay',
                judge: 0,
                effect() { },
                ai: {
                    basic: {
                        order: 1,
                        useful: 1,
                        value: 8,
                    },
                    result: { target: 1 },
                },
            },
            minilingren_basic: {
                image: 'ext:活动武将/image/card/minilingren_basic.png',
                fullimage: true,
            },
            minilingren_trick: {
                image: 'ext:活动武将/image/card/minilingren_trick.png',
                fullimage: true,
            },
            minilingren_equip: {
                image: 'ext:活动武将/image/card/minilingren_equip.png',
                fullimage: true,
            },
            miniruyi_jingubang: {
                fullskin: true,
                cardimage: 'ruyijingubang',
                derivation: 'Mbaby_sunwukong',
                type: 'equip',
                subtype: 'equip1',
                ai: { basic: { equipValue: 114514 + 1919810 } },
                skills: ['miniruyi_jingubang', 'miniruyi_jingubang2'],
            },
            minidagongche: {
                fullskin: true,
                cardimage: 'dagongche',
                derivation: 'Mbaby_zhangfen',
                type: 'equip',
                subtype: 'equip1',
                distance: { attackFrom: -1 },
                skills: ['minidagongche_skill'],
                cardPrompt(card) {
                    if (!card.storage) return '出牌阶段开始时，你可以视为使用一张【杀】，且当此【杀】对目标角色造成伤害后，你弃置其一张牌。若此【大攻车】未被强化，则其他角色无法弃置你装备区内的【大攻车】。当此牌离开你的装备区后，销毁之。';
                    var str = '出牌阶段开始时，你可以视为使用一张';
                    if (card.storage.大攻车选项一) str += '无距离限制且无视防具的';
                    str += '【杀】';
                    if (card.storage.大攻车选项二) str += ('（此【杀】的目标上限+' + card.storage.大攻车选项二 + '）');
                    str += '，且当此【杀】对目标角色造成伤害后，你弃置其';
                    var num = 1;
                    if (card.storage.大攻车选项三) num += card.storage.大攻车选项三;
                    str += get.cnNumber(num);
                    str += '张牌。当此牌离开你的装备区后，销毁之。';
                    return str;
                },
                destroy: true,
                ai: { basic: { equipValue: 114514 + 1919810 } },
            },
            minijieyue_junling1: {
                type: 'junling',
                vanish: true,
            },
            minijieyue_junling2: {
                type: 'junling',
                vanish: true,
            },
            minijieyue_junling3: {
                type: 'junling',
                vanish: true,
            },
            minijieyue_junling4: {
                type: 'junling',
                vanish: true,
            },
            mini_zhong: {
                type: 'trick',
                notarget: true,
                wuxieable: true,
                global: 'miniweilin_zhong',
                content() {
                    const evt = event.getParent(2).mini_zhong || event.getParent(3).mini_zhong;
                    if (!evt) return event.finish();
                    player.line(evt.player);
                    player.addExpose(0.2);
                    evt.cancel();
                    player.damage(evt.source ? evt.source : 'nosource', evt.nature, evt.num).set('card', evt.card).set('cards', evt.cards);
                },
                ai: {
                    value: [5, 1],
                    useful: [5, 1],
                    order: 1,
                    wuxie(target, card, player, current, state) {
                        return -state * get.attitude(player, current);
                    },
                    result: {
                        player(player) {
                            const trigger = get.event().getParent().mini_zhong;
                            if (trigger?.player) return get.info('twgonghuan').check(trigger, player) ? 1 : 0;
                            return 0;
                        },
                    },
                },
            },
            mini_yi: {
                type: 'trick',
                enable: true,
                filterTarget(card, player, target) {
                    return target.countCards('he') && target != player;
                },
                content() {
                    target.chooseToGive(player, 'he', true);
                    const evt = event.getParent();
                    if (evt?.name === 'useCard' && evt.cards?.someInD('od')) {
                        target.gain(evt.cards.filterInD('od'), 'gain2');
                    }
                },
                ai: {
                    order: 4,
                    value: [5, 1],
                    result: { target: -1 },
                },
            },
            minipiliche: {
                fullskin: true,
                cardimage: 'ly_piliche',
                derivation: 'Mbaby_dc_liuye',
                type: 'equip',
                subtype: 'equip4',
                distance: { globalFrom: -1 },
                skills: ['minipiliche'],
                destroy: true,
                ai: { basic: { equipValue: 3 } },
            },
            mininiantazhen_sha: {
                fullimage: true,
                image: 'ext:活动武将/image/card/mininiantazhen_sha.png',
            },
            mininiantazhen_horse: {
                fullimage: true,
                image: 'ext:活动武将/image/card/mininiantazhen_horse.png',
            },
            mininiantazhen_jiu: {
                fullimage: true,
                image: 'ext:活动武将/image/card/mininiantazhen_jiu.png',
            },
            zhouyu_宫: {
                fullimage: true,
                image: 'ext:活动武将/image/default/zhouyu_宫.jpg',
            },
            zhouyu_商: {
                fullimage: true,
                image: 'ext:活动武将/image/default/zhouyu_商.jpg',
            },
            zhouyu_角: {
                fullimage: true,
                image: 'ext:活动武将/image/default/zhouyu_角.jpg',
            },
            zhouyu_徵: {
                fullimage: true,
                image: 'ext:活动武将/image/default/zhouyu_徵.jpg',
            },
            zhouyu_羽: {
                fullimage: true,
                image: 'ext:活动武将/image/default/zhouyu_羽.jpg',
            },
        },
        skill: {
            //魏
            minijingce: {
                audio: 'decadejingce',
                trigger: { player: 'phaseJieshuBegin' },
                forced: true,
                content() {
                    player.draw(Math.min(player.getHistory('useCard').reduce((list, evt) => list.add(get.suit(evt.card)), []).length + 1, 3));
                },
            },
            minihuchi: {
                audio: 'ext:活动武将/audio/skill:1',
                group: ['minihuchi_miss', 'minihuchi_draw'],
                trigger: { player: 'phaseJieshuBegin' },
                frequent: true,
                prompt: '是否发动【虎痴】，将手牌摸至两张？',
                filter(event, player) {
                    return player.countCards('h') < 2;
                },
                content() {
                    player.drawTo(2);
                },
                marktext: '痴',
                intro: { name: '虎痴', name2: '痴', content: 'mark' },
                subSkill: {
                    miss: {
                        audio: 'minihuchi',
                        trigger: { player: 'shaMiss' },
                        forced: true,
                        locked: false,
                        content() {
                            player.addMark('minihuchi', 1);
                        },
                    },
                    draw: {
                        audio: 'minihuchi',
                        enable: 'phaseUse',
                        filter(event, player) {
                            return player.countMark('minihuchi');
                        },
                        usable: 1,
                        content() {
                            var num = player.countMark('minihuchi');
                            player.removeMark('minihuchi', num);
                            player.draw(num);
                        },
                        ai: {
                            order: 1,
                            result: { player: 1 },
                        },
                    },
                },
            },
            minixingshang: {
                audio: 'xingshang',
                audioname2: { Mbaby_caoying: 'lingren_xingshang' },
                trigger: { global: 'die' },
                preHidden: true,
                content() {
                    if (trigger.player.countCards('he')) player.gain(trigger.player.getCards('he'), trigger.player, 'giveAuto');
                    player.draw();
                },
            },
            minilingren: {
                derivation: ['minijianxiong', 'minixingshang'],
                audio: 'xinfu_lingren',
                inherit: 'xinfu_lingren',
                filter(event, player) {
                    if (event.getParent().triggeredTargets3.length > 1) return false;
                    if (!player.isPhaseUsing()) return false;
                    if (!['basic', 'trick'].includes(get.type(event.card))) return false;
                    if (get.tag(event.card, 'damage')) return true;
                    return false;
                },
                async content(event, trigger, player) {
                    const { targets: [target] } = event;
                    const list = ['basic', 'trick', 'equip'].map(type => ['', '', `${event.name}_${type}`]);
                    const result = await player.chooseButton(['凌人：猜测其有哪些类别的手牌', [list, 'vcard']], [0, 3], true).set('ai', button => {
                        return get.event().choice.includes(button.link[2].slice(12));
                    }).set('choice', (() => {
                        if (!target.countCards('h')) return [];
                        let choice = [], known = target.getKnownCards(player), unknown = target.getCards('h', i => !known.includes(i));
                        for (let i of known) {
                            choice.add(get.type2(i, target));
                        }
                        if (!unknown.length || choice.length > 2) return choice;
                        let rand = 0.05;
                        if (!choice.includes('basic')) {
                            if (unknown.some(i => get.type(i, null, target) === 'basic')) rand = 0.95;
                            if (Math.random() < rand) choice.push('basic');
                        }
                        if (!choice.includes('trick')) {
                            if (unknown.some(i => get.type(i, 'trick', target) === 'trick')) rand = 0.9;
                            else rand = 0.1;
                            if (Math.random() < rand) choice.push('trick');
                        }
                        if (!choice.includes('equip')) {
                            if (unknown.some(i => get.type(i, null, target) === 'equip')) rand = 0.75;
                            else rand = 0.25;
                            if (Math.random() < rand) choice.push('equip');
                        }
                        return choice;
                    })()).forResult();
                    if (!result?.bool) return;
                    const choices = result.links.map(i => i[2].slice(12));
                    if (!event.isMine() && !event.isOnline()) await game.delayx();
                    let num = 0;
                    ['basic', 'trick', 'equip'].forEach(type => {
                        if (choices.includes(type) == target.hasCard(card => get.type2(card, target) === type, 'h')) num++;
                    });
                    player.popup('猜对' + get.cnNumber(num) + '项');
                    game.log(player, '猜对了' + get.cnNumber(num) + '项');
                    if (num > 0) {
                        const map = trigger.customArgs;
                        const id = target.playerid;
                        map[id] ??= {};
                        if (typeof map[id].extraDamage != "number") map[id].extraDamage = 0;
                        map[id].extraDamage++;
                    }
                    if (num > 1) await player.draw(2);
                    if (num > 2) await player.addTempSkills(get.info(event.name).derivation, { player: "phaseBegin" });
                },
            },
            minifujian: {
                audio: 'xinfu_fujian',
                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                filter(event, player) {
                    return game.hasPlayer(current => {
                        return current != player && current.countCards('h');
                    });
                },
                forced: true,
                logTarget(event, player) {
                    return game.filterPlayer(current => {
                        return player != current && current.countCards('h');
                    }).randomGet();
                },
                async content(event, trigger, player) {
                    const target = event.targets[0];
                    game.log(player, '观看了', target, '的手牌');
                    await player.viewHandcards(target);
                },
            },
            minijiezi: {
                audio: 'jiezi',
                trigger: { global: ['phaseDrawSkipped', 'phaseDrawCancelled'] },
                filter(event, player) {
                    return event.player != player && player.countMark('minijiezi_silent') < 2;
                },
                forced: true,
                logTarget: 'player',
                content() {
                    player.addTempSkill('minijiezi_silent', 'roundStart');
                    player.addMark('minijiezi_silent', 1, false);
                    player.draw(2);
                },
                subSkill: { silent: { onremove: true, charlotte: true } },
            },
            miniyizhong: {
                audio: 'yizhong',
                trigger: { target: 'shaBefore' },
                filter(event, player) {
                    if (!player.hasEmptySlot(2)) return false;
                    return event.card.name == 'sha' && get.suit(event.card) == 'club';
                },
                forced: true,
                content() {
                    trigger.cancel();
                },
                ai: {
                    effect: {
                        target(card, player, target) {
                            if (player == target && get.subtype(card) == 'equip2') {
                                if (get.equipValue(card) <= 5.5) return 0;
                            }
                            if (!target.hasEmptySlot(2)) return;
                            if (card.name == 'sha' && get.suit(card) == 'club') return 'zerotarget';
                        },
                    },
                },
            },
            miniqiangxi: {
                audio: 'qiangxi',
                trigger: { source: 'damageBegin1' },
                filter(event, player) {
                    return game.getGlobalHistory('everything', evt => {
                        return evt.name == 'damage' && evt.source == player;
                    }, event).indexOf(event) == 0 && player.countCards('he', card => get.subtypes(card).includes('equip1')) > 0;
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseToDiscard('he', get.prompt(event.skill, trigger.player), '弃置一张武器牌并令此伤害+1', card => {
                        return get.subtypes(card).includes('equip1');
                    }, 'chooseonly').set('goon', get.damageEffect(trigger.player, player, player) > 0).set('ai', card => {
                        if (_status.event.goon) return 12 - get.value(card);
                        return 0;
                    }).forResult()
                },
                logTarget: 'player',
                async content(event, trigger, player) {
                    await player.discard(event.cards);
                    trigger.num++;
                },
            },
            minireqiangxi: {
                audio: 'reqiangxi',
                trigger: { global: 'damageBegin2' },
                filter(event, player) {
                    return event.player != player && player.countCards('he', { type: 'equip' }) > 0;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseToDiscard('he', get.prompt(event.name, trigger.player), '弃置一张装备牌并令此伤害+1', function (card) {
                        return get.type(card) == 'equip';
                    }).set('goon', get.damageEffect(trigger.player, player, player) > 0).set('ai', function (card) {
                        if (_status.event.goon) return 12 - get.value(card);
                        return 0;
                    }).logSkill = [event.name, trigger.player];
                    'step 1'
                    if (result.bool) trigger.num++;
                },
                ai: { expose: 0.25 },
                group: 'minireqiangxi_qiangxi',
                subSkill: {
                    qiangxi: {
                        audio: 'reqiangxi',
                        enable: 'phaseUse',
                        filter(event, player) {
                            return game.hasPlayer(function (target) {
                                return player.inRange(target) && !target.hasSkill('minireqiangxi_off');
                            });
                        },
                        filterTarget(card, player, target) {
                            if (player == target) return false;
                            if (target.hasSkill('minireqiangxi_off')) return false;
                            return player.inRange(target);
                        },
                        prompt: '失去1点体力并摸一张牌，对一名其他角色造成1点伤害',
                        content() {
                            'step 0'
                            player.loseHp();
                            player.draw();
                            'step 1'
                            target.addTempSkill('minireqiangxi_off');
                            target.damage();
                        },
                        ai: {
                            order: 8.5,
                            result: {
                                target(player, target) {
                                    //主公内奸矜持，其他身份当疯狗
                                    var bool = (lib.translate[player.identity] == '主' || lib.translate[player.identity] == '内' || (get.mode() == 'identity' && player.hasSkill('olzaowang2') && lib.translate[player.identity] != 'nei'));
                                    if (bool && target.hp - player.hp > 1) return 0;
                                    if (!bool && player.hp < 2 && !player.countCards('hs', { name: ['tao', 'jiu'] })) return 0;
                                    return -1;
                                },
                            },
                        },
                    },
                    off: { charlotte: true },
                },
            },
            //甄姬
            miniluoshen: {
                audio: 'luoshen',
                audioname2: {
                    Mmiao_zhenji: 'minimiaoluoshen',
                    wechat_zhenji: 'luoshen',
                },
                trigger: { player: 'phaseZhunbeiBegin' },
                frequent: true,
                content() {
                    'step 0'
                    var next = player.judge(function (card) {
                        if (get.color(card) == 'black') return 1;
                        return -1;
                    });
                    next.set('callback', function () {
                        if (get.position(card, true) == 'o') {
                            let next = player.gain(card, 'gain2');
                            if (event.getParent(2).name == 'minireluoshen') next.gaintag = ['minireluoshen'];
                        }
                    });
                    'step 1'
                    if (result.judge > 0) player.chooseBool('是否再次发动【洛神】？').set('frequentSkill', event.name);
                    else event.finish();
                    'step 2'
                    if (result.bool) event.goto(0);
                },
            },
            minireluoshen: {
                audio: 'reluoshen',
                inherit: 'miniluoshen',
                trigger: {
                    player: ['phaseZhunbeiBegin', 'loseAfter'],
                    global: ['loseAsyncAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'addToExpansionAfter'],
                },
                filter(event, player) {
                    if (event.name == 'phaseZhunbei') return true;
                    return player.getRoundHistory('lose', evt => {
                        if (!evt.cards.some(card => get.color(card) == 'red')) return false;
                        return evt.gaintag_map && Object.keys(evt.gaintag_map).some(i => evt.gaintag_map[i].includes('minireluoshen'));
                    }).indexOf(event) == 0;
                },
            },
            miniqiaobian: {
                audio: 'qiaobian',
                trigger: { player: ['phaseJudgeBefore', 'phaseDrawBefore', 'phaseUseBefore', 'phaseDiscardBefore', 'phaseJieshuBegin'] },
                filter(event, player) {
                    if (event.name == 'phaseJieshu') return player.getHistory('skipped').length >= 3;
                    return player.countCards('h') > 0;
                },
                direct: true,
                preHidden: true,
                content() {
                    'step 0'
                    if (trigger.name == 'phaseJieshu') {
                        player.logSkill('miniqiaobian');
                        player.draw(2);
                        event.finish();
                        return;
                    }
                    var check, str = '弃置一张手牌并跳过';
                    str += ['判定', '摸牌', '出牌', '弃牌'][lib.skill.miniqiaobian.trigger.player.indexOf(event.triggername)];
                    str += '阶段';
                    if (trigger.name == 'phaseDraw') str += '，然后可以获得至多两名角色各一张手牌';
                    if (trigger.name == 'phaseUse') str += '，然后可以移动场上的一张牌';
                    switch (trigger.name) {
                        case 'phaseJudge':
                            var list = player.getHistory('skipped'), num = list.length + 1;
                            if (player.countCards('j')) check = true;
                            if (num >= 3) check = false;
                            else {
                                if (player.countCards('h') > 1) {
                                    if (!list.includes('phaseDraw')) {
                                        var check1 = function () {
                                            var i, num = 0, num2 = 0, players = game.filterPlayer();
                                            for (i = 0; i < players.length; i++) {
                                                if (player != players[i] && players[i].countCards('h')) {
                                                    var att = get.attitude(player, players[i]);
                                                    if (att <= 0) num++;
                                                    if (att < 0) num2++;
                                                }
                                            }
                                            return num >= 2 && num2 > 0;
                                        };
                                        if (check1()) num++;
                                    }
                                    if (!list.includes('phaseUse')) {
                                        var check;
                                        if (!player.canMoveCard(true)) check = false;
                                        else {
                                            check = game.hasPlayer(function (current) {
                                                return get.attitude(player, current) > 0 && current.countCards('j');
                                            });
                                            if (!check) {
                                                if (player.countCards('h') > player.hp + 1) check = false;
                                                else if (player.countCards('h', { name: ['wuzhong'] })) check = false;
                                                else check = true;
                                            }
                                        }
                                        if (check) num++;
                                    }
                                    if (num == 2 && !list.includes('phaseDiscard')) num++;
                                    if (num == 3) check = true;
                                }
                            }
                            break;
                        case 'phaseDraw':
                            var i, num = 0, num2 = 0, players = game.filterPlayer();
                            for (i = 0; i < players.length; i++) {
                                if (player != players[i] && players[i].countCards('h')) {
                                    var att = get.attitude(player, players[i]);
                                    if (att <= 0) {
                                        num++;
                                    }
                                    if (att < 0) {
                                        num2++;
                                    }
                                }
                            }
                            check = (num >= 2 && num2 > 0);
                            break;
                        case 'phaseUse':
                            if (!player.canMoveCard(true)) {
                                check = false;
                            }
                            else {
                                check = game.hasPlayer(function (current) {
                                    return get.attitude(player, current) > 0 && current.countCards('j');
                                });
                                if (!check) {
                                    if (player.countCards('h') > player.hp + 1) {
                                        check = false;
                                    }
                                    else if (player.countCards('h', { name: ['wuzhong'] })) {
                                        check = false;
                                    }
                                    else {
                                        check = true;
                                    }
                                }
                            }
                            break;
                        case 'phaseDiscard':
                            check = (player.needsToDiscard() || player.getHistory('skipped').length == 2);
                            break;
                    }
                    player.chooseToDiscard(get.prompt('miniqiaobian'), str, lib.filter.cardDiscardable).set('ai', card => {
                        if (!_status.event.check) return -1;
                        return 7 - get.value(card);
                    }).set('check', check).set('logSkill', 'miniqiaobian').setHiddenSkill('miniqiaobian');
                    'step 1'
                    if (result.bool) {
                        trigger.cancel();
                        game.log(player, '跳过了', '#y' + ['判定', '摸牌', '出牌', '弃牌'][lib.skill.miniqiaobian.trigger.player.indexOf(event.triggername)] + '阶段');
                        if (trigger.name == 'phaseUse') {
                            if (player.canMoveCard()) player.moveCard();
                            event.finish();
                        }
                        else if (trigger.name == 'phaseDraw') {
                            player.chooseTarget([1, 2], '获得至多两名角色各一张手牌', function (card, player, target) {
                                return target != player && target.countCards('h');
                            }).set('ai', function (target) {
                                return 1 - get.attitude(_status.event.player, target);
                            });
                        }
                        else event.finish();
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        result.targets.sortBySeat();
                        player.line(result.targets, 'green');
                        event.targets = result.targets;
                        if (!event.targets.length) event.finish();
                    }
                    else event.finish();
                    'step 3'
                    player.gainMultiple(event.targets);
                    'step 4'
                    game.delay();
                },
                ai: { threaten: 3 },
            },
            minifangzhu: {
                audio: 'fangzhu',
                trigger: { player: 'damageEnd' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minifangzhu'), '令一名其他角色将武将牌翻面并摸一张牌', lib.filter.notMe).ai = function (target) {
                        if (target.hasSkillTag('noturn')) return 0;
                        var player = _status.event.player, att = get.attitude(player, target);
                        if (att < 0 && target.isTurnedOver()) return 0;
                        if (att > 2 && target.isTurnedOver()) return att * 10;
                        return -att;
                    }
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minifangzhu', result.targets[0]);
                        result.targets[0].turnOver();
                        result.targets[0].draw();
                    }
                    else event.finish();
                },
                ai: {
                    maixie: true,
                    maixie_hp: true,
                    effect: {
                        target(card, player, target) {
                            if (get.tag(card, 'damage')) {
                                if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                if (target.hp <= 1) return;
                                if (!target.hasFriend()) return;
                                var hastarget = false;
                                var turnfriend = false;
                                var players = game.filterPlayer();
                                for (var i = 0; i < players.length; i++) {
                                    if (get.attitude(target, players[i]) < 0 && !players[i].isTurnedOver()) {
                                        hastarget = true;
                                    }
                                    if (get.attitude(target, players[i]) > 0 && players[i].isTurnedOver()) {
                                        hastarget = true;
                                        turnfriend = true;
                                    }
                                }
                                if (get.attitude(player, target) > 0 && !hastarget) return;
                                if (turnfriend || target.hp == target.maxHp) return [0.5, 1];
                                if (target.hp > 1) return [1, 0.5];
                            }
                        }
                    }
                },
            },
            minikangkai: {
                audio: 'kaikang',
                audioname2: { Mnian_caopi: 'minikangkai_Mnian_caopi' },
                trigger: { global: 'useCardToTargeted' },
                filter(event, player) {
                    return event.card.name == 'sha' && get.distance(player, event.target) <= 1;
                },
                usable: 2,
                forced: true,
                content() {
                    'step 0'
                    player.draw();
                    if (trigger.target != player) {
                        player.chooseCard('he', '慷忾：是否交给' + get.translation(trigger.target) + '一张牌？').set('ai', function (card) {
                            if (get.position(card) == 'e') return -1;
                            if (card.name == 'shan' && get.attitude(player, trigger.target) > 0) return 1;
                            if (get.type(card) == 'equip' && get.attitude(player, trigger.target) > 0) return 0.5;
                            if (card.name == 'du' && get.attitude(player, trigger.target) < 0) return 5;
                            return 0;
                        });
                    }
                    else event.finish();
                    'step 1'
                    if (result.bool) {
                        trigger.target.gain(result.cards, player, 'give');
                        game.delayx();
                        event.card = result.cards[0];
                    }
                    else event.finish();
                    'step 2'
                    if (trigger.target.getCards('h').includes(card) && get.type(card) == 'equip') trigger.target.chooseUseTarget(card);
                },
                subSkill: {
                    Mnian_caopi: { audio: 'ext:活动武将/audio/skill:true' },
                }
            },
            minishangshi: {
                audio: 'shangshi',
                audioname2: { Mmiao_zhangchunhua: 'minimiaoshangshi' },
                trigger: {
                    player: ['loseAfter', 'changeHp', 'gainMaxHpAfter', 'loseMaxHpAfter', 'enterGame'],
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter', 'phaseBefore'],
                },
                filter(event, player) {
                    return player.countCards('h') < Math.max(player.getDamagedHp(), 1) && (event.name != 'phase' || game.phaseNumber == 0);
                },
                prompt2(event, player) {
                    return '将手牌摸至' + get.cnNumber(Math.max(player.getDamagedHp(), 1)) + '张';
                },
                frequent: true,
                content() {
                    player.draw(Math.max(player.getDamagedHp(), 1) - player.countCards('h'));
                },
                ai: {
                    noh: true,
                    skillTagFilter(player, tag) {
                        if (tag == 'noh' && Math.max(player.getDamagedHp(), 1) < player.countCards('h')) return false;
                    },
                },
            },
            minijueqing: {
                audio: 'rejueqing',
                trigger: { source: 'damageBefore' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseBool(get.prompt('minijueqing'), '失去1点体力，令即将对其造成的伤害增加1点').set('choice', player.hp > 1 && trigger.player.hp > 1 && get.attitude(player, trigger.player) < 0);
                    'step 1'
                    if (result.bool) {
                        event.logged = true;
                        player.logSkill('minijueqing');
                        player.loseHp();
                        trigger.num++;
                    }
                    'step 2'
                    player.chooseBool(get.prompt('minijueqing'), '防止此伤害，改为令' + get.translation(trigger.player) + '失去' + trigger.num + '点体力');
                    'step 3'
                    if (result.bool) {
                        if (!event.logged) player.logSkill('minijueqing');
                        trigger.cancel();
                        trigger.player.loseHp(trigger.num);
                    }
                },
            },
            minireshangshi: {
                inherit: 'minishangshi',
                group: 'minireshangshi_zhiheng',
                subSkill: {
                    zhiheng: {
                        audio: 'shangshi',
                        trigger: { player: 'logSkill' },
                        filter(event, player) {
                            return event.skill == 'minireshangshi' && player.countDiscardableCards(player, 'h');
                        },
                        usable: 1,
                        async cost(event, trigger, player) {
                            event.result = await player.chooseToDiscard(get.prompt(event.skill), [1, Infinity], 'chooseonly', 'allowChooseAll').set('prompt2', '弃置任意张手牌，若你以此法弃置了所有手牌，则你于下个回合的摸牌阶段额外摸一张牌').set('ai', lib.skill.rezhiheng.check).forResult();
                        },
                        async content(event, trigger, player) {
                            const cardx = player.getCards('h');
                            const { cards } = event;
                            await player.discard(cards);
                            if (!cards.some(card => !cardx.includes(card)) && !cardx.some(card => !cards.includes(card))) {
                                player.addTempSkill('minireshangshi_effect', { player: 'phaseAfter' });
                                player.addMark('minireshangshi_effect', 1, false);
                            }
                        },
                    },
                    effect: {
                        inherit: 'dcduliang2',
                        content() {
                            trigger.num += player.countMark('minireshangshi_effect');
                        },
                    },
                },
            },
            minijushou: {
                audio: 'xinjushou',
                trigger: { player: 'phaseJieshuBegin' },
                content() {
                    'step 0'
                    player.turnOver();
                    player.draw(4);
                    'step 1'
                    player.chooseToUse(function (card) {
                        if (!lib.filter.cardEnabled(card, _status.event.player, _status.event)) return false;
                        return get.type(card) == 'equip';
                    }, '据守：是否使用一张装备牌？');
                },
                ai: {
                    effect: {
                        target(card, player, target) {
                            if (card.name == 'guiyoujie') return [0, 1];
                        },
                    },
                },
            },
            minichenqing: {
                audio: 'chenqing',
                trigger: { global: 'dying' },
                filter(event, player) {
                    return event.player.hp <= 0 && !player.getHistory('useSkill', function (evt) {
                        return evt.skill == 'minichenqing';
                    }).length;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minichenqing'), function (card, player, target) {
                        return target != _status.event.getTrigger().player;
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        var trigger = _status.event.getTrigger();
                        if (get.attitude(player, trigger.player) > 0) {
                            var att1 = get.attitude(target, player);
                            var att2 = get.attitude(target, trigger.player);
                            var att3 = get.attitude(player, target);
                            if (att3 < 0) return 0;
                            return att1 / 2 + att2 + att3;
                        }
                        else return 0;
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minichenqing', target);
                        target.draw(5);
                    }
                    else event.finish();
                    'step 2'
                    var target = event.target;
                    var tosave = trigger.player;
                    var att = get.attitude(target, tosave);
                    var hastao = target.countCards('h', 'tao');
                    target.chooseToDiscard(4, true, 'he').set('ai', function (card) {
                        var hastao = _status.event.hastao;
                        var att = _status.event.att;
                        if (!hastao && att > 0) {
                            var suit = get.suit(card);
                            for (var i = 0; i < ui.selected.cards.length; i++) {
                                if (get.suit(ui.selected.cards[i]) == suit) {
                                    return -4 - get.value(card);
                                }
                            }
                        }
                        if (att < 0 && ui.selected.cards.length == 3) {
                            var suit = get.suit(card);
                            for (var i = 0; i < ui.selected.cards.length; i++) {
                                if (get.suit(ui.selected.cards[i]) == suit) {
                                    return -get.value(card);
                                }
                            }
                            return -10 - get.value(card);
                        }
                        return -get.value(card);
                    }).set('hastao', hastao).set('att', att);
                    'step 3'
                    if (result.cards && result.cards.length == 4) {
                        var suits = [];
                        for (var i = 0; i < result.cards.length; i++) suits.add(get.suit(result.cards[i]));
                        if (suits.length == 4 && game.checkMod({ name: 'tao', isCard: true }, player, trigger.player, 'unchanged', 'cardSavable', player)) target.useCard({ name: 'tao', isCard: true }, trigger.player);
                    }
                },
                ai: { expose: 0.2 },
            },
            minituntian: {
                audio: 'tuntian',
                subSkill: {
                    tuntian: {
                        audio: 'tuntian',
                        inherit: 'tuntian',
                    },
                },
                group: ['minituntian_tuntian', 'tuntian_dist'],
                trigger: { player: 'phaseJieshuBegin' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseToDiscard('he', get.prompt('minituntian'), '弃置一张牌并进行〖屯田〗判定').set('ai', function (card) {
                        var player = _status.event.player;
                        return 7 - get.value(card, player);
                    }).logSkill = 'minituntian';
                    'step 1'
                    if (result.bool) {
                        var next = game.createEvent('minituntian');
                        next.player = player;
                        next.setContent(lib.skill.tuntian.content);
                    }
                },
            },
            minijiushi: {
                audio: 'jiushi1',
                group: ['minijiushi1', 'minijiushi2', 'minijiushi3', 'minijiushi_gain'],
                subfrequent: ['gain'],
                subSkill: {
                    gain: {
                        audio: 'jiushi1',
                        trigger: { player: 'turnOverAfter' },
                        frequent: true,
                        prompt: '是否发动【酒诗】，获得牌堆中的一张锦囊牌？',
                        content() {
                            var card = get.cardPile2(function (card) {
                                return get.type2(card) == 'trick';
                            });
                            if (card) player.gain(card, 'gain2', 'log');
                        },
                    },
                },
            },
            minijiushi1: {
                hiddenCard(player, name) {
                    if (name == 'jiu') return !player.isTurnedOver();
                    return false;
                },
                audio: 'jiushi1',
                enable: 'chooseToUse',
                filter(event, player) {
                    if (player.classList.contains('turnedover')) return false;
                    return event.filterCard({ name: 'jiu', isCard: true }, player, event);
                },
                content() {
                    if (_status.event.getParent(2).type == 'dying') {
                        event.dying = player;
                        event.type = 'dying';
                    }
                    player.turnOver();
                    player.useCard({ name: 'jiu', isCard: true }, player);
                },
                ai: {
                    order: 5,
                    result: {
                        player(player) {
                            if (_status.event.parent.name == 'phaseUse') {
                                if (player.countCards('h', 'jiu') > 0) return 0;
                                if (player.getEquip('zhuge') && player.countCards('h', 'sha') > 1) return 0;
                                if (!player.countCards('h', 'sha')) return 0;
                                var targets = [];
                                var target;
                                var players = game.filterPlayer();
                                for (var i = 0; i < players.length; i++) {
                                    if (get.attitude(player, players[i]) < 0) {
                                        if (player.canUse('sha', players[i], true, true)) {
                                            targets.push(players[i]);
                                        }
                                    }
                                }
                                if (targets.length) {
                                    target = targets[0];
                                }
                                else {
                                    return 0;
                                }
                                var num = get.effect(target, { name: 'sha' }, player, player);
                                for (var i = 1; i < targets.length; i++) {
                                    var num2 = get.effect(targets[i], { name: 'sha' }, player, player);
                                    if (num2 > num) {
                                        target = targets[i];
                                        num = num2;
                                    }
                                }
                                if (num <= 0) return 0;
                                var e2 = target.getEquips(2);
                                if (e2.length) {
                                    if (e2.some(i => i.name == 'tengjia')) {
                                        if (!player.countCards('h', { name: 'sha', nature: 'fire' }) && !player.getEquip('zhuque')) return 0;
                                    }
                                    if (e2.some(i => i.name == 'renwang')) {
                                        if (!player.countCards('h', { name: 'sha', color: 'red' })) return 0;
                                    }
                                    if (e2.some(i => i.name == 'baiyin')) return 0;
                                }
                                if (player.getEquip('guanshi') && player.countCards('he') > 2) return 1;
                                return target.countCards('h') > 3 ? 0 : 1;
                            }
                            if (player == _status.event.dying || player.isTurnedOver()) return 3;
                        }
                    },
                    effect: {
                        target(card, player, target) {
                            if (card.name == 'guiyoujie') return [0, 0.5];
                            if (target.isTurnedOver()) {
                                if (get.tag(card, 'damage')) {
                                    if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                    if (target.hp == 1) return;
                                    return [1, target.countCards('h') / 2];
                                }
                            }
                        },
                    },
                },
            },
            minijiushi2: {
                trigger: { player: 'damageBegin3' },
                silent: true,
                firstDo: true,
                filter(event, player) {
                    return player.classList.contains('turnedover');
                },
                content() {
                    trigger.minijiushi = true;
                },
            },
            minijiushi3: {
                audio: 'jiushi1',
                trigger: { player: 'damageEnd' },
                check(event, player) {
                    return player.isTurnedOver();
                },
                filter(event, player) {
                    return event.minijiushi;
                },
                prompt: '是否发动【酒诗】，将武将牌翻面？',
                content() {
                    delete trigger.minijiushi;
                    player.turnOver();
                },
            },
            miniluoying: {
                mod: {
                    ignoredHandcard(card, player) {
                        if (get.suit(card) == 'club') return true;
                    },
                    cardDiscardable(card, player, name) {
                        if (name == 'phaseDiscard' && get.suit(card) == 'club') return false;
                    },
                },
                locked: false,
                audio: 'luoying',
                audioname2: { Mnian_caopi: 'miniluoying_Mnian_caopi' },
                trigger: { global: ['loseAfter', 'loseAsyncAfter', 'cardsDiscardAfter'] },
                filter(event, player) {
                    if (event.name.startsWith('lose')) {
                        if (event.type != 'discard' || event.getlx === false) return false;
                        const cards = event.cards.slice(0);
                        const evt = event.getl?.(player);
                        if (evt?.cards) cards.removeArray(evt.cards);
                        return cards.some(card => card.original != 'j' && get.suit(card, event.player) == 'club' && get.position(card, true) == 'd');
                    }
                    const evt = event.getParent().relatedEvent;
                    if (!evt || evt.name != 'judge') return false;
                    if (evt.player == player) return false;
                    return event.cards.some(card => get.position(card, true) == 'd' && get.suit(card) == 'club');
                },
                frequent: true,
                async cost(event, trigger, player) {
                    let cards, cards2 = trigger.cards.slice(0);
                    if (trigger.name.startsWith('lose')) {
                        if (trigger.delay == false) await game.delay();
                        const evt = trigger.getl(player);
                        if (evt?.cards) cards2.removeArray(evt.cards);
                        cards = cards2.filter(card => card.original != 'j' && get.suit(card, event.player) == 'club' && get.position(card, true) == 'd');
                    }
                    else cards = trigger.cards.filter(card => get.position(card, true) == 'd' && get.suit(card) == 'club');
                    const result = await player.chooseButton(['落英：选择要获得的牌', cards], [1, cards.length]).set('ai', button => {
                        return get.value(button.link, get.player(), "raw");
                    }).forResult();
                    event.result = {
                        bool: result?.bool,
                        cost_data: result?.links,
                    }
                },
                async content(event, trigger, player) {
                    await player.gain(event.cost_data, 'gain2', 'log');
                },
                subSkill: {
                    Mnian_caopi: { audio: 'ext:活动武将/audio/skill:true' },
                },
            },
            miniquhu: {
                enable: 'phaseUse',
                audio: 'quhu',
                filter(event, player) {
                    return (!player.hasSkill('miniquhu0') && player.countCards('he') > 1) || !player.hasSkill('miniquhu1');
                },
                usable: 1,//纪念传奇各限一次荀彧
                chooseButton: {
                    dialog(event, player) {
                        var list = [
                            '弃置两张牌，对一名其他角色造成1点伤害',
                            '对自己造成1点伤害，然后摸一张牌',
                        ];
                        var choiceList = ui.create.dialog('驱虎：请选择一项', 'forcebutton', 'hidden');
                        for (var i = 0; i < list.length; i++) {
                            var str = '<div class="popup text" style="width:calc(100% - 10px);display:inline-block">';
                            var bool = lib.skill.miniquhu.chooseButton.filter({ link: i }, player);
                            if (!bool) str += '<div style="opacity:0.5">';
                            str += list[i];
                            if (!bool) str += '</div>';
                            str += '</div>';
                            var next = choiceList.add(str);
                            next.firstChild.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.button);
                            next.firstChild.link = i;
                            //for(var j in lib.element.button){
                            //next[j]=lib.element.button[j];
                            //}
                            Object.setPrototypeOf(next, lib.element.Button.prototype);
                            choiceList.buttons.add(next.firstChild);
                        }
                        return choiceList;
                    },
                    filter(button, player) {
                        return !player.hasSkill('miniquhu' + button.link);
                    },
                    check(button) {
                        var player = _status.event.player;
                        if (game.hasPlayer([
                            function (target) {
                                return get.damageEffect(target, player, player) > 0;
                            },
                            function (target) {
                                if (!target.hasSkill('jieming') && !target.hasSkill('minijieming')) return 0;
                                return target.hp > 2 && game.hasPlayer(function (current) {
                                    return get.attitude(current, player) > 0 && current.countCards('h') < current.maxHp - 1;
                                });
                            },
                        ][button.link])) return 1 + button.link;
                        return 0;
                    },
                    backup(links) {
                        return {
                            audio: 'quhu',
                            filterTarget: [
                                function (card, player, target) {
                                    return target != player;
                                },
                                function (card, player, target) {
                                    return target == player;
                                },
                            ][links[0]],
                            selectTarget: [1, -1][links[0]],
                            index: links[0],
                            filterCard: [
                                function (card, player) {
                                    return true;
                                },
                                function (card, player) {
                                    return false;
                                },
                            ][links[0]],
                            selectCard: [2, -1][links[0]],
                            check(card) {
                                return 7 - get.value(card);
                            },
                            position: 'he',
                            content() {
                                player.addTempSkill('miniquhu' + lib.skill[event.name].index, 'phaseUseAfter')
                                target.damage('nocard');
                                if (target == player) player.draw();
                            },
                            ai: {
                                order: 7,
                                result: {
                                    target(player, target) {
                                        return get.damageEffect(target, player, player) * Math.sign(get.attitude(player, target));
                                    },
                                },
                            },
                        }
                    },
                    prompt(links, player) {
                        if (links[0] == 0) return '弃置两张牌，对一名其他角色造成1点伤害';
                        return '对自己造成1点伤害，然后摸一张牌';
                    },
                },
                ai: {
                    order: 7,
                    result: { player: 1 },
                },
                subSkill: { backup: {} },
            },
            miniquhu0: {},
            miniquhu1: {},
            minijieming: {
                audio: 'jieming',
                trigger: { player: 'damageEnd' },
                direct: true,
                content() {
                    'step 0'
                    event.count = trigger.num;
                    'step 1'
                    event.count--;
                    player.chooseTarget(get.prompt2('minijieming')).set('ai', function (target) {
                        var att = get.attitude(_status.event.player, target);
                        if (target.countCards('h') >= Math.min(target.maxHp, 4)) return -1;
                        if (target.hasSkillTag('nogain')) att /= 6;
                        if (att > 0) return Math.min(4, target.maxHp) - target.countCards('h');
                        return -1;
                    });
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('minijieming', target);
                        target.drawTo(Math.min(4, target.maxHp));
                    }
                    else event.finish();
                    'step 3'
                    if (event.count > 0 && player.hasSkill('minijieming')) event.goto(1);
                },
                ai: {
                    maixie: true,
                    maixie_hp: true,
                    effect: {
                        target(card, player, target, current) {
                            if (get.tag(card, 'damage') && target.hp > 1) {
                                if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                var max = 0;
                                var players = game.filterPlayer();
                                for (var i = 0; i < players.length; i++) {
                                    if (get.attitude(target, players[i]) > 0) {
                                        max = Math.max(Math.min(4, players[i].hp) - players[i].countCards('h'), max);
                                    }
                                }
                                switch (max) {
                                    case 0: return 2;
                                    case 1: return 1.5;
                                    case 2: return [1, 2];
                                    default: return [0, max];
                                }
                            }
                            if ((card.name == 'tao' || card.name == 'caoyao') &&
                                target.hp > 1 && target.countCards('h') <= target.hp) return [0, 0];
                        },
                    },
                },
            },
            minimingjian: {
                audio: 'mingjian',
                enable: 'phaseUse',
                usable: 1,
                filterTarget: lib.filter.notMe,
                filter(event, player) {
                    return player.countCards('h');
                },
                filterCard: true,
                selectCard: [1, Infinity],
                check: () => 1,
                discard: false,
                lose: false,
                delay: false,
                content() {
                    target.gain(cards, player, 'giveAuto');
                    target.addTempSkill('mingjian2', { player: 'phaseAfter' });
                    target.storage.mingjian2++;
                    target.updateMarks('mingjian2');
                },
                ai: {
                    order: 1,
                    result: {
                        target(player, target) {
                            if (target.hasSkillTag('nogain')) return 0;
                            if (player.countCards('h') == player.countCards('h', 'du')) return -1;
                            if (target.hasJudge('lebu')) return 0;
                            if (get.attitude(player, target) > 3) {
                                var basis = get.threaten(target);
                                if (player == get.zhu(player) && player.hp <= 2 && player.countCards('h', 'shan') && !game.hasPlayer(function (current) {
                                    return get.attitude(current, player) > 3 && current.countCards('h', 'tao') > 0;
                                })) return 0;
                                if (target.countCards('h') + player.countCards('h') > target.hp + 2) return basis * 0.8;
                                return basis;
                            }
                            return 0;
                        },
                    },
                },
            },
            minixingshuai: {
                audio: 'xingshuai',
                trigger: { player: 'dying' },
                zhuSkill: true,
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current != player && current.group == 'wei';
                    });
                },
                mark: true,
                limited: true,
                skillAnimation: true,
                animationColor: 'thunder',
                content() {
                    'step 0'
                    player.awakenSkill(event.name);
                    player.addSkill(`${event.name}_restore`);
                    var targets = game.filterPlayer();
                    targets.remove(player);
                    event.targets = targets;
                    event.damages = [];
                    'step 1'
                    if (event.targets.length) {
                        var current = event.targets.shift();
                        if (current.group == 'wei') {
                            current.chooseBool('是否令' + get.translation(player) + '回复1点体力？').set('ai', function () {
                                return get.attitude(_status.event.player, _status.event.target) > 2;
                            }).set('target', player);
                            event.current = current;
                        }
                        else event.redo();
                    }
                    else event.goto(3);
                    'step 2'
                    if (result.bool) {
                        event.damages.push(event.current);
                        event.current.line(player, 'green');
                        game.log(event.current, '令', player, '回复1点体力');
                        player.recover();
                    }
                    if (event.targets.length) event.goto(1);
                    'step 3'
                    if (event.damages.length) {
                        var next = game.createEvent('minixingshuai_next');
                        event.next.remove(next);
                        trigger.after.push(next);
                        next.targets = event.damages;
                        next.setContent(function () {
                            for (var target of targets) {
                                target.damage();
                                target.draw();
                            }
                        });
                    }
                },
                subSkill: {
                    restore: {},
                },
            },
            minihuituo: {
                audio: 'huituo',
                audioname: ['re_caorui'],
                trigger: { player: ['damageEnd', 'miniremingjian'] },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill)).set('ai', target => {
                        const player = get.player();
                        if (get.attitude(player, target) > 0) return get.recoverEffect(target, player, player) + 1;
                        return 0;
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const target = event.targets[0];
                    const result = await target.judge(card => {
                        if (get.color(card) === 'red') return target.isDamaged() ? 2 : -1;
                        return 1;
                    }).forResult();
                    const color = result.color;
                    if (color === 'red') await target.recover();
                    else if (color === 'black') await target.draw(1 + (trigger.name === 'damage' ? trigger : trigger._trigger).num);
                },
            },
            miniremingjian: {
                audio: 'remingjian',
                trigger: { global: 'damageSource' },
                filter(event, player) {
                    return event.source && (event.source === player || event.source.getStorage('miniremingjian_buff').includes(player));
                },
                prompt2(event, player) {
                    return `触发一次伤害为${event.num}的【${get.translation('minihuituo')}】`;
                },
                round: 1,
                async content(event, trigger, player) {
                    await event.trigger('miniremingjian');
                },
                group: 'miniremingjian_mingjian',
                subSkill: {
                    mingjian: {
                        inherit: 'minimingjian',
                        prompt: () => lib.translate['minimingjian_info'],
                        async content(event, trigger, player) {
                            const { target, cards } = event;
                            await player.give(cards, target);
                            target.addTempSkill("miniremingjian_buff", { player: "phaseAfter" });
                            target.storage.miniremingjian_buff ??= [];
                            target.storage.miniremingjian_buff.push(player);
                            target.storage.miniremingjian_buff.sortBySeat();
                            target.markSkill("miniremingjian_buff");
                        },
                    },
                    buff: {
                        charlotte: true,
                        onremove: true,
                        marktext: "鉴",
                        intro: {
                            content(storage, player) {
                                const num = storage.length;
                                return `<li>被${get.translation(storage.toUniqued())}鉴识<li>手牌上限+${num}，出杀次数+${num}`;
                            },
                        },
                        mod: {
                            maxHandcard(player, num) {
                                return num + player.getStorage("miniremingjian_buff").length;
                            },
                            cardUsable(card, player, num) {
                                if (card.name === "sha") return num + player.getStorage("miniremingjian_buff").length;
                            },
                        },
                    },
                },
            },
            minirexingshuai: {
                audio: 'rexingshuai',
                inherit: 'minixingshuai',
                subSkill: {
                    restore: {
                        charlotte: true,
                        audio: 'xingshuai',
                        trigger: { global: 'dieAfter' },
                        filter(event, player) {
                            return event.player.group === 'wei';
                        },
                        forced: true,
                        locked: false,
                        content() {
                            player.removeSkill(event.name);
                            player.restoreSkill('minirexingshuai');
                            player.popup('minirexingshuai');
                            game.log(player, '重置了技能', `#g【${get.translation('minirexingshuai')}】`);
                        },
                    },
                },
            },
            //戏志才
            minichouce: {
                audio: 'chouce',
                trigger: { player: 'damageEnd' },
                content() {
                    'step 0'
                    event.num = trigger.num;
                    'step 1'
                    player.judge();
                    'step 2'
                    event.color = result.color;
                    if (event.color == 'black') {
                        player.chooseTarget('获得一名角色区域内的一张牌', function (card, player, target) {
                            return target.countCards('hej');
                        }).set('ai', function (target) {
                            var player = _status.event.player;
                            var att = get.attitude(player, target);
                            if (att < 0) att = -Math.sqrt(-att);
                            else att = Math.sqrt(att);
                            return att * lib.card.shunshou.ai.result.target(player, target);
                        });
                    }
                    else {
                        var next = player.chooseTarget('令一名角色摸一张牌');
                        if (player.storage.xianfu2 && player.storage.xianfu2.length) {
                            next.set('prompt2', '（若目标为' + get.translation(player.storage.xianfu2) + '则改为摸两张牌）');
                        }
                        next.set('ai', function (target) {
                            var player = _status.event.player;
                            var att = get.attitude(player, target) / Math.sqrt(1 + target.countCards('h'));
                            if (target.hasSkillTag('nogain')) att /= 10;
                            if (player.storage.xianfu2 && player.storage.xianfu2.includes(target)) return att * 2;
                            return att;
                        })
                    }
                    'step 3'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target, 'green');
                        if (event.color == 'black') player.gainPlayerCard(target, 'hej', true);
                        else {
                            if (player.storage.xianfu2 && player.storage.xianfu2.includes(target)) {
                                if (!target.storage.xianfu_mark) target.storage.xianfu_mark = [];
                                target.storage.xianfu_mark.add(player);
                                target.storage.xianfu_mark.sortBySeat();
                                target.markSkill('xianfu_mark');
                                target.draw(2);
                            }
                            else target.draw();
                        }
                    }
                    'step 4'
                    if (--event.num > 0) player.chooseBool(get.prompt2('minichouce'));
                    else event.finish();
                    'step 5'
                    if (result.bool) {
                        player.logSkill('minichouce');
                        event.goto(1);
                    }
                },
                ai: {
                    maixie: true,
                    maixie_hp: true,
                    effect: {
                        target(card, player, target) {
                            if (get.tag(card, 'damage')) {
                                if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                if (!target.hasFriend()) return;
                                if (target.hp >= 4) return [1, get.tag(card, 'damage') * 1.5];
                                if (target.hp == 3) return [1, get.tag(card, 'damage') * 1];
                                if (target.hp == 2) return [1, get.tag(card, 'damage') * 0.5];
                            }
                        },
                    },
                },
            },
            minishensu: {
                audio: 'shensu1',
                audioname: ['xiahouba', 'ol_xiahouyuan'],
                trigger: { player: ['phaseJudgeBefore', 'phaseUseBefore', 'phaseDiscardBefore'] },
                direct: true,
                content() {
                    'step 0'
                    var check;
                    switch (trigger.name) {
                        case 'phaseJudge': check = player.countCards('h') > 2; break;
                        case 'phaseUse': check = player.needsToDiscard(); break;
                        case 'phaseDiscard': check = player.needsToDiscard() || player.isTurnedOver() || (['shensu', 'minishensu'].some(skill => player.hasSkill(skill)) && player.canMoveCard(true, true)); break;
                    }
                    var str = ['判定阶段和摸牌', '出牌', '弃牌'][lib.skill.minishensu.trigger.player.indexOf(event.triggername)];
                    player.chooseTarget(get.prompt('minishensu'), '跳过' + str + '阶段' + (trigger.name == 'phaseDiscard' ? '并翻面' : '') + '，视为对一名其他角色使用一张雷【杀】', function (card, player, target) {
                        if (player == target) return false;
                        return player.canUse({ name: 'sha', nature: 'thunder', isCard: true }, target, false);
                    }).set('check', check).set('ai', function (target) {
                        if (!_status.event.check) return 0;
                        return get.effect(target, { name: 'sha', nature: 'thunder', isCard: true }, _status.event.player);
                    }).setHiddenSkill('minishensu');
                    'step 1'
                    if (result.bool) {
                        trigger.cancel();
                        if (trigger.name == 'phaseJudge') player.skip('phaseDraw');
                        player.logSkill('minishensu', result.targets);
                        if (trigger.name == 'phaseDiscard') player.turnOver();
                        player.useCard({ name: 'sha', nature: 'thunder', isCard: true }, result.targets[0], false).audio = false;
                    }
                },
            },
            minishebian: {
                audio: 'shebian',
                trigger: { player: 'turnOverEnd' },
                check(event, player) {
                    return player.canMoveCard(true, true);
                },
                filter(event, player) {
                    return player.canMoveCard(null, true);
                },
                content() {
                    'step 0'
                    player.moveCard().nojudge = true;
                    'step 1'
                    player.recover();
                },
            },
            minizhongjian: {
                audio: 'zhongjian',
                inherit: 'rezhongjian',
                filter(event, player) {
                    return game.hasPlayer(current => lib.skill.minizhongjian.filterTarget(null, player, current));
                },
                filterTarget(card, player, target) {
                    if (!player.storage.minizhongjian_effect) return true;
                    return !player.storage.minizhongjian_effect[0]?.includes(target) && !player.storage.minizhongjian_effect[1]?.includes(target);
                },
                line: true,
                log: true,
                subSkill: {
                    rewrite: { charlotte: true },
                    effect: {
                        init(player, skill) {
                            player.storage[skill] ??= [[], []];
                        },
                        charlotte: true,
                        onremove: true,
                        trigger: { global: ["damageSource", "damageEnd"] },
                        filter(event, player, name) {
                            const index = name == 'damageSource' ? 0 : 1;
                            const target = name == 'damageSource' ? event.source : event.player;
                            return target?.isIn() && player.storage['minizhongjian_effect'][index].includes(target);
                        },
                        forced: true,
                        logTarget(event, player, name) {
                            return name == 'damageSource' ? event.source : event.player;
                        },
                        async content(event, trigger, player) {
                            const [target] = event.targets;
                            const index = event.triggername == 'damageSource' ? 0 : 1;
                            const storage = player.storage[event.name];
                            storage[index].remove(target);
                            if (storage[0].length + storage[1].length) {
                                player.markSkill(event.name);
                            } else {
                                player.removeSkill(event.name);
                            }
                            await target[event.triggername == 'damageSource' ? 'chooseToDiscard' : 'draw'](2, true, 'he');
                            await player.draw();
                        },
                        intro: {
                            markcount(storage) {
                                if (!storage) return 0;
                                return storage[0].length + storage[1].length;
                            },
                            mark(dialog, storage, player) {
                                if (!storage) return '尚未选择';
                                if (player == game.me || player.isUnderControl()) {
                                    if (storage?.[0]?.length) {
                                        dialog.addText('弃牌');
                                        dialog.add([storage[0], 'player']);
                                    }
                                    if (storage?.[1]?.length) {
                                        dialog.addText('摸牌');
                                        dialog.add([storage[1], 'player']);
                                    }
                                } else {
                                    dialog.addText(`${get.translation(player)}共选择了${get.cnNumber(storage[0].length + storage[1].length)} 人`);
                                }
                            },
                        },
                    },
                },
            },
            minicaishi: {
                inherit: 'recaishi',
                filter(event, player) {
                    const isSame = lib.skill.recaishi.isSame(event);
                    if (isSame == 'nogain') {
                        return false;
                    }
                    return isSame || (player.isDamaged() && player.hasCard(card => {
                        if (_status.connectMode) return true;
                        return lib.filter.cardDiscardable(card, player);
                    }, 'he'));
                },
                async cost(event, trigger, player) {
                    const isSame = lib.skill.recaishi.isSame(trigger);
                    if (isSame) {
                        event.result = {
                            bool: true,
                            cost_data: 'rewrite',
                        };
                    } else if (player.isDamaged()) {
                        event.result = await player.chooseToDiscard(get.prompt(event.skill), '弃置一张牌，然后回复1点体力', 'he', 'chooseonly').set('ai', card => {
                            const goon = get.event();
                            return goon ? 7 - get.value(card) : 0;
                        }).set('goon', get.recoverEffect(player, player, player) > 0).forResult();
                    }
                },
                async content(event, trigger, player) {
                    if (event.cost_data === 'rewrite') {
                        player.addTempSkill('minizhongjian_rewrite');
                        game.log(player, '修改了技能', '#g【忠鉴】');
                    } else {
                        await player.discard(event.cards);
                        await player.recover();
                    }
                },
            },
            minijiaozhao: {
                derivation: ['minijiaozhao_1', 'minijiaozhao_2'],
                audio: 'jiaozhao',
                enable: 'phaseUse',
                filter(event, player) {
                    if (!player.hasCard(card => lib.skill.minijiaozhao.filterCard(card, player), 'h')) return false;
                    var num = player.getStat('skill').minijiaozhao;
                    return !num || num < player.countMark('minidanxin') + 1;
                },
                filterCard(card, player) {
                    return !player.storage.minijiaozhao2?.[card.cardid];
                },
                discard: false,
                lose: false,
                delay: false,
                check(card) {
                    return 7 - get.value(card);
                },
                content() {
                    'step 0'
                    player.addTempSkill('minijiaozhao2', 'phaseUseAfter');
                    player.showCards(cards, get.translation(player) + '发动了【矫诏】');
                    'step 1'
                    var list = get.inpileVCardList(info => {
                        const name = info[2];
                        if (player.hasMark('minidanxin')) {
                            const str = ['type', 'name'][player.countMark('minidanxin') - 1];
                            if (player.storage.minijiaozhao_used?.[str]?.includes([get.type(name), name][player.countMark('minidanxin') - 1])) return false;
                        }
                        return get.type(name) === 'basic' || get.type(name) === 'trick';
                    });
                    if (!list.length) {
                        player.popup('杯具');
                        game.log('但是', player, '已经没有可以声明的牌了！');
                        event.finish();
                        return;
                    }
                    var str = '###矫诏(' + (player.countMark('minidanxin') + 1) + '级)';
                    str += '###请选择并声明' + get.translation(cards[0]) + '视为的牌';
                    if (player.countMark('minidanxin') < 2) str += '，且此牌不能指定你为目标';
                    player.chooseButton([str, [list, 'vcard']], true).set('ai', function (button) {
                        var player = _status.event.player;
                        return player.getUseValue({ name: button.link[2], nature: button.link[3], storage: { minijiaozhao: true } });
                    });
                    'step 2'
                    var card = { name: result.links[0][2], nature: result.links[0][3], storage: { minijiaozhao: true } };
                    player.storage.minijiaozhao2[cards[0].cardid] = card;
                    var chosen = card.name, nature = card.nature, tag = 'minijiaozhao2_' + chosen + nature;
                    player.storage.minijiaozhao2.cardid.add(tag);
                    player.storage.minijiaozhao_used.type.add(get.type(card));
                    player.storage.minijiaozhao_used.name.add(chosen);
                    player.updateMarks('minijiaozhao2');
                    player.updateMarks('minijiaozhao_used');
                    if (!lib.skill[tag]) {
                        game.broadcastAll((tag, nature, chosen) => {
                            lib.skill[tag] = {};
                            lib.translate[tag] = "矫诏<br>" + (get.translation(nature) || '') + get.translation(chosen);
                        }, tag, nature, chosen);
                    }
                    player.addGaintag(cards, tag);
                    player.showCards(game.createCard({
                        name: chosen,
                        nature: nature,
                        suit: cards[0].suit,
                        number: cards[0].number,
                    }), get.translation(player) + '声明了' + (get.translation(nature) || '') + '【' + get.translation(chosen) + '】');
                },
                ai: {
                    order: 8,
                    result: { player: 1 },
                },
            },
            minijiaozhao2: {
                mod: {
                    playerEnabled(card, player, target) {
                        if (target != player || player.countMark('minidanxin') >= 2) return;
                        if (card.storage?.minijiaozhao2) return false;
                    },
                },
                charlotte: true,
                init(player, skill) {
                    if (!player.storage[skill]) player.storage[skill] = { cardid: [] };
                    if (!player.storage.minijiaozhao_used) player.storage.minijiaozhao_used = { type: [], name: [] };
                },
                onremove(player, skill) {
                    let tags = player.storage[skill].cardid;
                    delete player.storage[skill];
                    delete player.storage.minijiaozhao_used;
                    if (tags?.length) tags.forEach(tag => player.removeGaintag(tag));
                },
                enable: 'phaseUse',
                filter(event, player) {
                    return player.hasCard(card => lib.skill.minijiaozhao2.filterCard(card, player), 'h');
                },
                filterCard(card, player) {
                    const map = player.storage.minijiaozhao2;
                    if (!map[card.cardid]) return false;
                    return player.hasUseTarget(get.autoViewAs(map[card.cardid], [card]), true, true);
                },
                filterTarget(cardx, player, target) {
                    const cards = ui.selected.cards, map = player.storage.minijiaozhao2;
                    if (!cards.length) return false;
                    const card = get.autoViewAs(map[cards[0].cardid], cards);
                    const filterTarget = lib.card[card.name].filterTarget;
                    return filterTarget && (typeof filterTarget === 'boolean' ? filterTarget : filterTarget.apply(this, arguments));
                },
                selectTarget() {
                    const player = get.player(), cards = ui.selected.cards, map = player.storage.minijiaozhao2;
                    if (!cards.length) return -1;
                    const card = get.autoViewAs(map[cards[0].cardid], cards);
                    let range, select = get.copy(get.info(card).selectTarget);
                    if (select == undefined) range = [1, 1];
                    else if (typeof select == 'number') range = [select, select];
                    else if (get.itemtype(select) == 'select') range = select;
                    else if (typeof select == 'function') range = select(card, player);
                    game.checkMod(card, player, range, 'selectTarget', player);
                    return range;
                },
                lose: false,
                discard: false,
                delay: false,
                check(card) {
                    const player = get.player(), map = player.storage.minijiaozhao2;
                    return player.getUseValue(get.autoViewAs(map[card.cardid], [card]), true, true);
                },
                multiline: true,
                multitarget: true,
                prompt: '选择一张“矫诏”牌当作声明的牌使用',
                content() {
                    const map = player.storage.minijiaozhao2;
                    player.useCard(get.autoViewAs(map[cards[0].cardid], cards), targets).set('cards', cards);
                },
                ai: {
                    order: 7.9,
                    result: {
                        player(player, target) {
                            const cards = ui.selected.cards, map = player.storage.minijiaozhao2;
                            if (cards.length) {
                                const card = get.autoViewAs(map[cards[0].cardid], cards);
                                return get.effect(target, card, player, player);
                            }
                            return 1;
                        },
                    },
                },
            },
            minidanxin: {
                audio: 'danxin',
                trigger: { player: 'damageEnd' },
                frequent: true,
                content() {
                    'step 0'
                    player.draw();
                    'step 1'
                    if (player.countMark('minidanxin') < 2) {
                        player.addMark('minidanxin', 1, false);
                        player.popup('矫诏');
                        game.log(player, '升级了技能', '#g【矫诏】');
                    }
                },
            },
            miniqingjian: {
                audio: 'qingjian',
                trigger: { player: 'gainAfter' },
                filter(event, player) {
                    if (event.parent.parent.name == 'phaseDraw') return false;
                    return event.cards?.length > 0
                },
                usable: 1,
                direct: true,
                content() {
                    'step 0'
                    player.chooseCardTarget({
                        position: 'he',
                        filterCard: true,
                        selectCard: [1, Infinity],
                        filterTarget: lib.filter.notMe,
                        ai1(card) {
                            if (get.attitude(_status.event.player, _status.currentPhase) < 0 && _status.currentPhase.needsToDiscard() && card.name != 'du') return -1;
                            for (var i = 0; i < ui.selected.cards.length; i++) {
                                if (get.type(ui.selected.cards[i]) == get.type(card) || (ui.selected.cards[i].name == 'du' && card.name != 'du')) return -1;
                            };
                            if (card.name == 'du') return 20;
                            return (_status.event.player.countCards('h') - _status.event.player.hp);
                        },
                        ai2(target) {
                            if (get.attitude(_status.event.player, _status.currentPhase) < 0) return -1;
                            var att = get.attitude(_status.event.player, target);
                            if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') {
                                if (target.hasSkillTag('nodu')) return 0;
                                return 1 - att;
                            }
                            if (target.countCards('h') > _status.event.player.countCards('h')) return 0;
                            return att - 4;
                        },
                        prompt: get.prompt2('miniqingjian'),
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0], cards = result.cards;
                        player.logSkill('miniqingjian', target);
                        target.gain(cards, player, 'giveAuto');
                        player.draw();
                    }
                    else player.storage.counttrigger.miniqingjian--;
                },
                ai: { expose: 0.3 },
            },
            minisidi: {
                audio: 'residi',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return player.countCards('he', function (card) {
                        if (_status.connectMode) return true;
                        return get.type(card) != 'basic';
                    }) > 0;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseCard('he', get.prompt('minisidi'), [1, 2], '将至多两张非基本牌置于武将牌上作为“司”', function (card, player) {
                        return get.type(card) != 'basic';
                    }).set('ai', function (card) {
                        if (get.position(card) == 'e') return 5 + player.hp - get.value(card);
                        return 7 - get.value(card);
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minisidi');
                        player.addToExpansion(result.cards, 'give', player).gaintag.add('minisidi');
                    }
                },
                intro: {
                    content: 'expansion',
                    markcount: 'expansion',
                },
                onremove(player, skill) {
                    var cards = player.getExpansions(skill);
                    if (cards.length) player.loseToDiscardpile(cards);
                },
                group: 'minisidi_push',
                ai: { notemp: true },
                subSkill: {
                    push: {
                        trigger: { global: 'phaseUseBegin' },
                        direct: true,
                        filter(event, player) {
                            return event.player != player && player.getExpansions('minisidi').length > 0;
                        },
                        content() {
                            'step 0'
                            player.chooseButton([get.prompt('minisidi', trigger.player), player.getExpansions('minisidi')]).set('ai', function (button) {
                                var player = _status.event.player;
                                var target = _status.event.getTrigger().player;
                                if (get.attitude(player, target) > -1) return 0;
                                var card = button.link;
                                var color = get.color(button.link, false);
                                var eff = target.countCards('h', function (card) {
                                    return get.color(card, target) == color && target.hasValueTarget(card);
                                });
                                if (!target.countCards('h', function (card) {
                                    return get.color(card, target) == color && get.name(card, target) == 'sha' && target.hasValueTarget(card);
                                })) eff += 1.5;
                                if (!target.countCards('h', function (card) {
                                    return get.color(card, target) == color && get.type2(card, target) == 'trick' && target.hasValueTarget(card);
                                })) eff += 1.5;
                                return eff - 1;
                            });
                            'step 1'
                            if (result.bool) {
                                if (!trigger.residi) trigger.residi = [];
                                trigger.residi.push(player);
                                var card = result.links[0];
                                var target = trigger.player;
                                player.logSkill('minisidi', target);
                                player.loseToDiscardpile(card);
                                var color = get.color(card, false);
                                if (!target.storage.residi2) target.storage.residi2 = [];
                                target.storage.residi2.add(color);
                                target.addTempSkill('residi2', 'phaseUseAfter');
                                target.markSkill('residi2');
                                player.addTempSkill('residi3', 'phaseUseAfter');
                            }
                        },
                    },
                },
            },
            //homo（难视
            minihomo: {
                audio: 'huomo',
                enable: 'chooseToUse',
                hiddenCard(player, name) {
                    return get.type(name) == 'basic' && player.hasCard(function (card) {
                        return get.color(card) == 'black' && get.type(card) != 'basic';
                    }, 'he');
                },
                filter(event, player) {
                    for (var i of lib.inpile) {
                        if (get.type(i) != 'basic') continue;
                        if (event.filterCard({ name: i }, player, event)) {
                            return player.hasCard(function (card) {
                                return get.color(card) == 'black' && get.type(card) != 'basic';
                            }, 'he');
                        }
                    }
                    return false;
                },
                usable: 2,
                chooseButton: {
                    dialog(event, player) {
                        var list = [];
                        for (var i of lib.inpile) {
                            if (get.type(i) != 'basic') continue;
                            if (event.filterCard({ name: i }, player, event)) {
                                list.push(['基本', '', i]);
                                if (i == 'sha') for (var j of lib.inpile_nature) list.push(['基本', '', i, j]);
                            }
                        }
                        return ui.create.dialog('活墨', [list, 'vcard'], 'hidden');
                    },
                    check(button) {
                        var player = _status.event.player;
                        var card = { name: button.link[2], nature: button.link[3] };
                        if (game.hasPlayer(function (current) {
                            return player.canUse(card, current) && get.effect(current, card, player, player) > 0;
                        })) {
                            switch (button.link[2]) {
                                case 'tao': return 5;
                                case 'jiu': return 3.01;
                                case 'shan': return 3.01;
                                case 'sha':
                                    if (button.link[3] == 'fire') return 2.95;
                                    else if (button.link[3] == 'fire') return 2.92;
                                    else return 2.9;
                            }
                        }
                        return 0;
                    },
                    backup(links, player) {
                        return {
                            check(card) {
                                return 1 / Math.max(0.1, get.value(card));
                            },
                            filterCard(card) {
                                return get.type(card) != 'basic' && get.color(card) == 'black';
                            },
                            viewAs: {
                                name: links[0][2],
                                nature: links[0][3],
                                suit: 'none',
                                number: null,
                                isCard: true,
                            },
                            position: 'he',
                            popname: true,
                            ignoreMod: true,
                            precontent() {
                                'step 0'
                                player.logSkill('minihomo');
                                var card = event.result.cards[0];
                                event.card = card;
                                player.$throw(card, 1000);
                                game.log(player, '将', card, '置于牌堆顶');
                                event.result.card = { name: event.result.card.name, nature: event.result.card.nature };
                                event.result.cards = [];
                                player.lose(card, ui.cardPile, 'visible', 'insert');
                                'step 1'
                                game.delay();
                            },
                        }
                    },
                    prompt(links, player) {
                        return '将一张黑色非基本牌置于牌堆顶并视为使用一张' + get.translation(links[0][3] || '') + get.translation(links[0][2]);
                    }
                },
                ai: {
                    order() {
                        var player = _status.event.player;
                        var event = _status.event;
                        if (event.filterCard({ name: 'jiu' }, player, event) && get.effect(player, { name: 'jiu' }) > 0) {
                            return 3.1;
                        }
                        return 2.9;
                    },
                    respondSha: true,
                    fireAttack: true,
                    respondShan: true,
                    skillTagFilter(player, tag, arg) {
                        if (player.hasCard(function (card) {
                            return get.color(card) == 'black' && get.type(card) != 'basic';
                        }, 'he')) {
                            if (tag == 'respondSha' || tag == 'respondShan') {
                                if (arg != 'use') return false;
                            }
                            return true;
                        }
                        else return false;
                    },
                    result: { player: 1 },
                },
            },
            minizuoding: {
                audio: 'zuoding',
                trigger: { global: 'useCardToPlayered' },
                filter(event, player) {
                    if (event.getParent().triggeredTargets3.length > 1) return false;
                    return get.suit(event.card) == 'spade' && _status.currentPhase == event.player && event.targets && event.targets.length && game.countPlayer2(function (current) {
                        return current.getHistory('damage').length > 0;
                    }) == 0;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minizuoding'), '令一名目标角色摸一张牌', function (card, player, target) {
                        return _status.event.targets.includes(target);
                    }).set('ai', function (target) {
                        return get.attitude(_status.event.player, target);
                    }).set('targets', trigger.targets);
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minizuoding', result.targets);
                        result.targets[0].draw();
                        if (result.targets[0] != player) player.addExpose(0.2);
                    }
                },
            },
            minixunxun: {
                audio: 'xunxun',
                inherit: 'xunxun',
                group: 'minixunxun_biyue',
                subSkill: {
                    biyue: {
                        audio: 'xunxun',
                        trigger: { player: 'phaseJieshuBegin' },
                        forced: true,
                        locked: false,
                        content() {
                            var cards = get.bottomCards(2);
                            if (cards.length) {
                                player.gain(cards);
                                player.$draw(cards.length);
                                game.log(player, '从牌堆底获得了' + get.cnNumber(cards.length) + '张牌');
                            }
                        },
                    },
                },
            },
            minizhengbing: {
                mod: {
                    ignoredHandcard(card, player) {
                        if (card.hasGaintag('minizhengbing')) return true;
                    },
                    cardDiscardable(card, player, name) {
                        if (name == 'phaseDiscard' && card.hasGaintag('minizhengbing')) return false;
                    },
                },
                group: 'minizhengbing_mark',
                audio: 'ext:活动武将/audio/skill:1',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h', function (card) {
                        return card.hasGaintag('minizhengbing') && player.canRecast(card);
                    });
                },
                filterCard(card, player) {
                    return card.hasGaintag('minizhengbing') && player.canRecast(card);
                },
                discard: false,
                lose: false,
                delay: false,
                content() {
                    'step 0'
                    player.recast(cards);
                    'step 1'
                    if (!player.countCards('h', function (card) {
                        return card.hasGaintag('minizhengbing');
                    })) player.draw();
                },
                ai: {
                    order: 10,
                    result: { player: 1 },
                },
                subSkill: {
                    mark: {
                        charlotte: true,
                        trigger: { player: 'gainBegin' },
                        filter(event, player) {
                            return lib.translate[event.getParent(3).name] == '突袭' || event.getParent(3).name == 'minifightbiaoxi_effect';
                        },
                        direct: true,
                        firstDo: true,
                        content() {
                            trigger.gaintag.add('minizhengbing');
                        },
                    },
                },
            },
            miniqice: {
                audio: 'qice',
                inherit: 'qice',
                filter(event, player) {
                    const hs = player.getCards('h');
                    if (!hs.length) return false;
                    if (hs.every(card => {
                        const mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                        return mod2 === false;
                    })) return false;
                    return lib.inpile.some(name => {
                        if (get.type(name) != 'trick') return false;
                        const card = get.autoViewAs({ name }, hs);
                        return event.filterCard(card, player, event);
                    });
                },
                get chooseButton() {
                    let chooseButton = {
                        filter(button, player) {
                            const event = get.event().getParent();
                            return player.hasCard(card => event.filterCard(get.autoViewAs({ name: button.link[2] }, [card]), player, event), 'h');
                        },
                        backup(links, player) {
                            return {
                                audio: 'qice',
                                filterCard: true,
                                selectCard: [1, Infinity],
                                check(card) {
                                    if (ui.selected.cards.length) return -1;
                                    return 7 - get.value(card);
                                },
                                complexCard: true,
                                position: 'h',
                                popname: true,
                                viewAs: { name: links[0][2] },
                            }
                        },
                        prompt(links, player) {
                            return '将任意张手牌当作' + get.translation(links[0][2]) + '使用';
                        },
                    };
                    const info = get.info('qice').chooseButton;
                    for (const i in info) {
                        if (!chooseButton[i]) chooseButton[i] = info[i];
                    }
                    return chooseButton;
                },
            },
            minizhiyu: {
                audio: 'zhiyu',
                trigger: { player: 'damageEnd' },
                preHidden: true,
                frequent: true,
                content() {
                    'step 0'
                    player.draw(2);
                    'step 1'
                    var att = undefined;
                    if (trigger.source && trigger.source.countCards('h') > player.countCards('h') - 1) att = get.attitude(player, trigger.source);
                    if (!player.countCards('h')) event.finish();
                    else player.chooseToDiscard('he', true).set('ai', function (card) {
                        var list = [0, 0];
                        for (var i of player.getCards('h')) {
                            list[get.color(card) == 'red' ? 0 : 1]++;
                        }
                        if (typeof att == 'number') {
                            if (att < 0) {
                                if (get.color(card) == 'red' && list[0] == 1) return 10 - get.value(card);
                                if (get.color(card) == 'black' && list[1] == 1) return 10 - get.value(card);
                            }
                        }
                        return -get.value(card);
                    });
                    'step 2'
                    if (player.countCards('h')) player.showHandcards();
                    if (!trigger.source) event.finish();
                    'step 3'
                    var stop = false;
                    var cards = player.getCards('h');
                    if (cards.length) {
                        var color = get.color(cards[0], player);
                        for (var i = 1; i < cards.length; i++) {
                            if (get.color(cards[i], player) != color) {
                                stop = true;
                                break;
                            }
                        }
                    }
                    if (trigger.source.countCards('h') <= player.countCards('h')) stop = true;
                    if (stop) event.finish();
                    else player.chooseBool('智愚：是否令' + get.translation(trigger.source) + '将手牌数弃置至' + get.cnNumber(player.countCards('h')) + '张')
                    'step 4'
                    if (result.bool) {
                        player.line(trigger.source);
                        trigger.source.chooseToDiscard(trigger.source.countCards('h') - player.countCards('h'), true);
                    }
                },
                ai: {
                    maixie_defend: true,
                    threaten: 0.7,
                },
            },
            miniqingxi: {
                audio: 'qingxi',
                inherit: 'reqingxi',
                init(player, skill) {
                    player.addSkill(`${skill}_draw`);
                },
                subSkill: {
                    draw: {
                        charlotte: true,
                        trigger: { global: 'judgeAfter' },
                        filter(event, player) {
                            const evt = event.getParent();
                            return event.result?.color == 'black' && evt.name == 'miniqingxi' && evt.player == player;
                        },
                        silent: true,
                        content() {
                            const next = player.draw(2);
                            event.next.remove(next);
                            trigger.next.push(next);
                        },
                    },
                },
            },
            minikunfen: {
                audio: 'kunfen',
                audioname2: { Mbaby_ol_sb_jiangwei: 'kunfen_ol_sb_jiangwei' },
                trigger: { player: 'phaseJieshuBegin' },
                check(event, player) {
                    if (player.hp > 3) return true;
                    if (player.hp == 3 && player.countCards('h') < 3) return true;
                    if (player.hp == 2 && player.countCards('h') == 0) return true;
                    return false;
                },
                content() {
                    'step 0'
                    player.loseHp();
                    'step 1'
                    player.draw(2);
                    'step 2'
                    player.chooseUseTarget('huogong', false);
                },
            },
            minifengliang: {
                derivation: 'minitiaoxin',
                audio: 'fengliang',
                trigger: { player: 'dying' },
                juexingji: true,
                forced: true,
                skillAnimation: true,
                animationColor: 'thunder',
                content() {
                    'step 0'
                    player.awakenSkill('minifengliang');
                    'step 1'
                    player.loseMaxHp();
                    'step 2'
                    if (player.hp < 3) player.recover(3 - player.hp);
                    'step 3'
                    player.addSkills('minitiaoxin');
                },
            },
            //钟会
            miniquanji: {
                group: 'miniquanji_phase',
                audio: 'quanji',
                trigger: { player: 'damageEnd' },
                filter(event, player) {
                    return event.num > 0;
                },
                frequent: true,
                prompt2: '摸两张牌',
                content() {
                    'step 0'
                    event.count = trigger.num;
                    'step 1'
                    event.count--;
                    player.draw(2);
                    'step 2'
                    if (event.count > 0 && player.hasSkill('miniquanji')) player.chooseBool(get.prompt('miniquanji'), '摸两张牌').set('frequentSkill', 'miniquanji');
                    else event.finish();
                    'step 3'
                    if (result.bool) {
                        player.logSkill('miniquanji');
                        event.goto(1);
                    }
                },
                onremove(player, skill) {
                    var cards = player.getExpansions('quanji');
                    if (cards.length) player.loseToDiscardpile(cards);
                },
                mod: {
                    maxHandcard(player, num) {
                        return num + Math.min(5, player.getExpansions('quanji').length);
                    },
                },
                locked: false,
                subSkill: {
                    phase: {
                        audio: 'quanji',
                        enable: 'phaseUse',
                        filter(event, player) {
                            return player.countCards('h');
                        },
                        prompt: '将任意张手牌置于武将牌上',
                        selectCard: [1, Infinity],
                        filterCard: true,
                        delay: 0,
                        discard: false,
                        lose: false,
                        delay: false,
                        check(card) {
                            var player = _status.event.player, num = player.needsToDiscard();
                            if (!player.getExpansions('quanji').length || num - ui.selected.cards.length - Math.min(5, player.getExpansions('quanji').length + ui.selected.cards.length) > 0) return 5 - get.value(card);
                            return -1;
                        },
                        content() {
                            player.addToExpansion(cards, player, 'give').gaintag.add('quanji');
                        },
                        ai: {
                            order: 5,
                            result: { player: 1 },
                        },
                    },
                },
            },
            //杨修
            minijilei: {
                audio: 'jilei',
                inherit: 'jilei',
                content() {
                    'step 0'
                    player.chooseControl('basic', 'trick', 'equip', 'cancel2', function () {
                        var source = _status.event.source;
                        if (get.attitude(_status.event.player, source) > 0) return 'cancel2';
                        var list = ['basic', 'trick', 'equip'].filter(function (name) {
                            return (!source.storage.jilei2 || !source.storage.jilei2.includes(name));
                        });
                        if (!list.length) return 'cancel2';
                        if (list.includes('trick') && source.countCards('h', function (card) {
                            return get.type(card, source) == 'trick' && source.hasValueTarget(card);
                        }) > 1) return 'trick';
                        return list[0];
                    }).set('prompt', get.prompt2('minijilei', trigger.source)).set('source', trigger.source);
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('minijilei', trigger.source);
                        player.popup(get.translation(result.control) + '牌');
                        var card = get.cardPile2(function (card) {
                            return get.type2(card) == result.control;
                        });
                        if (card) player.gain(card, 'gain2');
                        trigger.source.addTempSkill('jilei2', { player: 'phaseBegin' });
                        trigger.source.storage.jilei2.add(result.control);
                        trigger.source.updateMarks('jilei2');
                    }
                },
            },
            //张昌蒲
            miniyanjiao: {
                audio: 'yanjiao',
                enable: 'phaseUse',
                filterTarget: true,
                usable: 1,
                content() {
                    'step 0'
                    var num = 3;
                    if (player.storage.xingshen) {
                        num += player.storage.xingshen;
                        player.storage.xingshen = 0;
                        player.unmarkSkill('xingshen');
                    }
                    if (player.storage.olxingshen) {
                        num += player.storage.olxingshen;
                        player.storage.olxingshen = 0;
                        player.unmarkSkill('olxingshen');
                    }
                    event.cards = get.cards(num);
                    game.cardsGotoOrdering(event.cards);
                    target.showCards(event.cards, get.translation(player) + '发动了【严教】');
                    'step 1'
                    var num = 0;
                    for (var i of cards) num += get.number(i, false);
                    num = Math.max(1, Math.floor(num / 2));
                    var str = '选择获得任意张总点数不大于' + num + '的牌';
                    if (target != player) str += '，然后' + get.translation(player) + '获得剩余的牌';
                    target.chooseButton([str, cards], [1, cards.length], true).set('filterButton', function (button) {
                        var summer = 0, num = _status.event.num;
                        for (var i = 0; i < ui.selected.buttons.length; i++) summer += get.number(ui.selected.buttons[i].link, false);
                        return summer + get.number(button.link, false) <= num;
                    }).set('num', num);
                    'step 2'
                    if (result.bool) {
                        cards.removeArray(result.links);
                        target.gain(result.links, 'gain2');
                    }
                    'step 3'
                    if (cards.length) {
                        if (target != player) player.gain(cards, 'gain2');
                        else {
                            player.$throw(cards, 1000);
                            game.cardsDiscard(cards);
                            game.log(cards, '被置入了弃牌堆');
                        }
                    }
                    else event.finish();
                    'step 4'
                    game.delayx();
                },
                ai: {
                    order: 10,
                    result: {
                        target(player, target) {
                            return target == player ? 1 : 2;
                        },
                    },
                },
            },
            minifankui: {
                audio: 'refankui',
                trigger: { player: 'damageEnd' },
                frequent: true,
                content() {
                    'step 0'
                    event.count = trigger.num;
                    'step 1'
                    event.count--;
                    player.judge();
                    'step 2'
                    if (!game.hasPlayer(function (current) {
                        return current.countGainableCards(player, 'he');
                    })) {
                        event.goto(4);
                        return;
                    }
                    if (result.suit != 'heart' && (!trigger.source || !trigger.source.countCards('he'))) {
                        event.goto(4);
                        return;
                    }
                    if (result.suit != 'heart') event._result = { bool: true, targets: [trigger.source] };
                    else player.chooseTarget('请选择【反馈】的目标', '获得一名角色的一张牌', true, function (card, player, target) {
                        return target.countGainableCards(player, 'he');
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        return get.effect(target, { name: 'guohe_copy2' }, player, player);
                    });
                    'step 3'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target);
                        player.gainPlayerCard(target, 'he', true);
                    }
                    else event.finish();
                    'step 4'
                    if (event.count > 0 && player.hasSkill('minifankui')) player.chooseBool(get.prompt2('minifankui')).set('frequentSkill', 'minifankui');
                    else event.finish();
                    'step 5'
                    if (result.bool) {
                        player.logSkill('minifankui');
                        event.goto(1);
                    }
                },
                ai: {
                    maixie_defend: true,
                    effect: {
                        target(card, player, target) {
                            if (player.countCards('he') > 1 && get.tag(card, 'damage')) {
                                if (player.hasSkillTag('jueqing', false, target)) return [1, -1.5];
                                if (get.attitude(target, player) < 0) return [1, 1];
                            }
                        },
                    },
                },
            },
            miniguicai: {
                audio: 'reguicai',
                trigger: { global: 'judge' },
                filter(event, player) {
                    return player.countCards('hes');
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseCard(get.translation(trigger.player) + '的' + (trigger.judgestr || '') + '判定为' +
                        get.translation(trigger.player.judging[0]) + '，' + get.prompt('miniguicai'), 'hes', function (card) {
                            var player = _status.event.player;
                            var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                            if (mod2 != 'unchanged') return mod2;
                            var mod = game.checkMod(card, player, 'unchanged', 'cardRespondable', player);
                            if (mod != 'unchanged') return mod;
                            return true;
                        }).set('ai', function (card) {
                            var trigger = _status.event.getTrigger();
                            var player = _status.event.player;
                            var judging = _status.event.judging;
                            var result = trigger.judge(card) - trigger.judge(judging);
                            var attitude = get.attitude(player, trigger.player);
                            if (attitude == 0) {
                                if (player.isDamaged() && get.suit(card, player) == 'heart') return 10;
                                if (get.suit(card, player) == 'club') return 8;
                                return 0;
                            }
                            if (attitude > 0) {
                                if (result == 0) {
                                    if (player.isDamaged() && get.suit(card, player) == 'heart') return 10;
                                    if (get.suit(card, player) == 'club') return 8;
                                    return 0;
                                }
                                return result - get.value(card) / 2;
                            }
                            else {
                                if (result == 0) {
                                    if (player.isDamaged() && get.suit(card) == 'heart') return 10;
                                    if (get.suit(card) == 'club') return 8;
                                    return 0;
                                }
                                return -result - get.value(card) / 2;
                            }
                        }).set('judging', trigger.player.judging[0]);
                    'step 1'
                    if (result.bool) {
                        player.respond(result.cards, 'miniguicai', 'highlight', 'noOrdering');
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        if (trigger.player.judging[0].clone) {
                            trigger.player.judging[0].clone.classList.remove('thrownhighlight');
                            game.broadcast(function (card) {
                                if (card.clone) {
                                    card.clone.classList.remove('thrownhighlight');
                                }
                            }, trigger.player.judging[0]);
                            game.addVideo('deletenode', player, get.cardsInfo([trigger.player.judging[0].clone]));
                        }
                        game.cardsDiscard(trigger.player.judging[0]);
                        trigger.player.judging[0] = result.cards[0];
                        trigger.orderingCards.addArray(result.cards);
                        game.log(trigger.player, '的判定牌改为', result.cards[0]);
                        game.delay(2);
                        event.card = result.cards[0];
                    }
                    else event.finish();
                    'step 3'
                    if (get.suit(card, player) == 'heart') player.recover();
                    if (get.suit(card, player) == 'club') player.draw(2);
                },
                ai: {
                    rejudge: true,
                    tag: { rejudge: 1 },
                },
            },
            //杜夫人
            miniyise: {
                audio: 'yise',
                trigger: { global: 'gainAfter', player: 'loseAsyncAfter' },
                filter(event, player) {
                    if (event.name == 'loseAsync') {
                        if (event.type != 'gain') return false;
                    }
                    var cards = event.getl(player).cards2;
                    return game.hasPlayer(function (current) {
                        if (current == player) return false;
                        var cardsx = event.getg(current);
                        for (var i of cardsx) {
                            if (cards.includes(i)) return true;
                        }
                        return false;
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    var cards = trigger.getl(player).cards2;
                    event.cards = cards;
                    event.targets = game.filterPlayer(function (current) {
                        if (current == player) return false;
                        var cardsx = trigger.getg(current);
                        for (var i of cardsx) {
                            if (cards.includes(i)) return true;
                        }
                        return false;
                    }).sortBySeat();
                    'step 1'
                    var target = targets.shift();
                    var cardsx = trigger.getg(target);
                    var next = game.createEvent('miniyise_insert');
                    next.player = player;
                    next.target = target;
                    next.cards = cardsx;
                    next.setContent(lib.skill.miniyise.contentx);
                    if (targets.length > 0) event.redo();
                },
                contentx() {
                    'step 0'
                    event.logged = false;
                    for (var i of cards) {
                        event[get.color(i, player)] = true;
                        if (event.red && event.black) break;
                    }
                    if (event.red) {
                        var list = ['摸牌'], choiceList = [
                            '令自己摸一张牌',
                            '令' + get.translation(target) + '回复1点体力'
                        ];
                        if (target.isDamaged()) list.push('回复体力');
                        else choiceList[1] = '<span style="opacity:0.5">' + choiceList[1] + '</span>';
                        list.push('cancel2');
                        player.chooseControl(list).set('prompt', get.prompt('miniyise', target)).set('ai', function () {
                            if (list.includes('回复体力') && get.recoverEffect(_status.event.getParent().target, _status.event.player, _status.event.player) > 0) return '回复体力';
                            return '摸牌';
                        }).set('choiceList', choiceList);
                    }
                    'step 1'
                    if (event.red && result.control != 'cancel2') {
                        event.logged = true;
                        player.logSkill('miniyise', target);
                        if (result.control == '摸牌') player.draw();
                        else target.recover();
                    }
                    if (!event.black) event.finish();
                    'step 2'
                    player.chooseBool(get.prompt('miniyise', target), '令' + get.translation(target) + '下次受到【杀】造成的伤害+1').set('choice', get.attitude(player, target) < 0);
                    'step 3'
                    if (result.bool) {
                        if (!event.logged) player.logSkill('miniyise', target);
                        else player.line(target);
                        target.addMark('yise_damage', 1, false);
                        target.addSkill('yise_damage');
                    }
                },
            },
            minishunshi: {
                audio: 'shunshi',
                trigger: { player: ['damageEnd', 'phaseZhunbeiBegin'] },
                filter(event, player) {
                    return player.countCards('he');
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseCardTarget({
                        prompt: get.prompt2('minishunshi'),
                        filterTarget: lib.filter.notMe,
                        filterCard: true,
                        position: 'he',
                        ai1(card) {
                            var player = _status.event.player;
                            if (player.hasSkill('miniyise')) {
                                if (get.color(card, player) == 'red' && game.hasPlayer(function (current) {
                                    return current != player && current.isDamaged() && get.recoverEffect(current, player, player) > 0;
                                })) return 10 - get.value(card);
                                if (get.color(card, player) == 'black') return 4 - get.value(card);
                            }
                            return 8 - get.value(card);
                        },
                        ai2(target) {
                            var player = _status.event.player, card = ui.selected.cards[0];
                            var att = get.attitude(player, target);
                            if (player.hasSkill('miniyise')) {
                                if (get.color(card) == 'red' && target.isDamaged()) return 2 * get.recoverEffect(target, player, player) + Math.sign(att);
                                if (get.color(card) == 'black') return -att;
                            }
                            if (get.value(card, target) < 0) return -att;
                            if (get.value(card, target) < 1) return 0.01 * -att;
                            return Math.max(1, get.value(card, target) - get.value(card, player)) * att;
                        },
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('minishunshi', target);
                        player.give(result.cards, target);
                        for (var phase of ['phaseDraw', 'phaseUse', 'phaseDiscard']) {
                            player.addTempSkill('minishunshi_' + phase, { player: phase + 'After' });
                            player.addMark('minishunshi_' + phase, 1, false);
                        }
                    }
                },
                subSkill: {
                    phaseDraw: {
                        charlotte: true,
                        onremove: true,
                        mark: true,
                        marktext: '摸',
                        intro: { content: '下个摸牌阶段多摸#张牌' },
                        trigger: { player: 'phaseDrawBegin2' },
                        filter(event, player) {
                            return !event.numFixed;
                        },
                        direct: true,
                        content() {
                            trigger.num += player.countMark('minishunshi_phaseDraw');
                        },
                    },
                    phaseUse: {
                        charlotte: true,
                        onremove: true,
                        mark: true,
                        marktext: '出',
                        intro: { content: '下个出牌阶段使用【杀】的次数上限+#，且使用【杀】无视防具' },
                        mod: {
                            cardUsable(card, player, num) {
                                if (player.isPhaseUsing() && card.name == 'sha') return num + player.countMark('minishunshi_phaseUse');
                            },
                        },
                        ai: {
                            unequip: true,
                            skillTagFilter(player, tag, arg) {
                                if (!arg || !arg.card || arg.card.name != 'sha' || !player.isPhaseUsing()) return false;
                            },
                        },
                    },
                    phaseDiscard: {
                        charlotte: true,
                        onremove: true,
                        mark: true,
                        marktext: '弃',
                        intro: { content: '下个弃牌阶段手牌上限+#' },
                        mod: {
                            maxHandcard(player, num) {
                                if (player.hasSkill('minishunshi_phaseDiscard2')) return num + player.countMark('minishunshi_phaseDiscard');
                            },
                        },
                        trigger: { player: 'phaseDiscardBefore' },
                        direct: true,
                        content() {
                            player.addTempSkill('minishunshi_phaseDiscard2', { player: 'phaseDiscardAfter' });
                        },
                    },
                    phaseDiscard2: { charlotte: true },
                },
            },
            minijiangchi: {
                audio: 'jiangchi',
                audioname2: { Mnian_caopi: 'minijiangchi_Mnian_caopi' },
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    var list = [
                        '摸一张牌，直到你的下个回合开始，受到伤害后摸一张牌',
                        '摸三张牌，本回合内不能使用或打出【杀】且手牌上限+2',
                        '本回合可以多使用一张【杀】且无距离限制',
                    ];
                    player.chooseControl('cancel2').set('prompt', get.prompt('xinjiangchi')).set('choiceList', list).set('ai', function () {
                        var player = _status.event.player;
                        var num = player.countCards('hs', function (card) {
                            return get.name(card) == 'sha' && player.hasValueTarget(card, false);
                        });
                        if (num == 0) return 1;
                        if (num > 1) return 2;
                        return 0;
                    });
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('minijiangchi');
                        switch (result.index) {
                            case 0: {
                                player.draw();
                                player.addTempSkill('minijiangchi_draw', { player: 'phaseBegin' });
                                break;
                            }
                            case 1: {
                                player.draw(3);
                                player.addTempSkill('xinjiangchi_less');
                                player.addTempSkill('minijiangchi_hand');
                                break;
                            }
                            case 2: {
                                player.addTempSkill('xinjiangchi_more');
                                break;
                            }
                        }
                    }
                },
                subSkill: {
                    draw: {
                        charlotte: true,
                        audio: 'jiangchi',
                        audioname2: { Mnian_caopi: 'minijiangchi_Mnian_caopi' },
                        trigger: { player: 'damageEnd' },
                        forced: true,
                        content() {
                            player.draw();
                        },
                    },
                    hand: {
                        charlotte: true,
                        mod: {
                            maxHandcard(player, num) {
                                return num + 2;
                            },
                        },
                    },
                    Mnian_caopi: { audio: 'ext:活动武将/audio/skill:true' },
                },
            },
            //曹操
            minijianxiong: {
                audio: 'rejianxiong',
                audioname2: {
                    Mbaby_caoying: 'lingren_jianxiong',
                    Mmiao_caoying: 'minijianxiong_caoying',
                },
                trigger: { player: 'damageEnd' },
                getIndex: event => event.num,
                async cost(event, trigger, player) {
                    const choice = ['摸两张牌', '拿牌摸牌'];
                    const result = await player.chooseControl(choice, 'cancel2').set('ai', () => {
                        const { player, controls } = get.event(), trigger = get.event().getTrigger();
                        if (controls.length === 2 || !trigger.cards?.someInD('od')) return '摸两张牌';
                        return trigger.cards.filterInD('od').reduce((sum, card) => sum + get.value(card), 0) > get.effect(player, { name: 'draw' }, player, player) ? '拿牌摸牌' : '摸两张牌';
                    }).set('prompt', get.prompt2(event.skill)).forResult();
                    const control = result.control;
                    event.result = {
                        bool: control && control !== 'cancel2',
                        cost_data: control,
                    };
                },
                async content(event, trigger, player) {
                    if (event.cost_data === '摸两张牌') {
                        await player.draw(2);
                    }
                    else {
                        if (trigger.cards?.someInD('od')) await player.gain(trigger.cards.filterInD('od'), 'gain2');
                        await player.draw();
                    }
                },
                ai: {
                    maixie: true,
                    maixie_hp: true,
                    effect: {
                        target(card, player, target) {
                            if (player.hasSkillTag('jueqing', false, target)) return [1, -1];
                            if (get.tag(card, 'damage') && player != target) return [1, 0.6];
                        },
                    },
                },
                subSkill: {
                    caoying: { audio: 'ext:活动武将/audio/skill:true' },
                },
            },
            minihujia: {
                audio: 'hujia',
                trigger: { player: ['chooseToRespondBefore', 'chooseToUseBefore'] },
                filter(event, player) {
                    if (event.responded) return false;
                    if (player.storage.minihujiaing) return false;
                    if (!event.filterCard({ name: 'shan' }, player, event)) return false;
                    return game.hasPlayer(function (current) {
                        return current != player && current.group == 'wei';
                    });
                },
                check(event, player) {
                    return get.damageEffect(player, event.player, player) < 0;
                },
                zhuSkill: true,
                content() {
                    'step 0'
                    if (!event.current) event.current = player.next;
                    if (event.current == player) event.finish();
                    else if (event.current.group == 'wei') {
                        if ((event.current == game.me && !_status.auto) || (
                            get.attitude(event.current, player) > 2) ||
                            event.current.isOnline()) {
                            player.storage.minihujiaing = true;
                            var next = event.current.chooseToRespond('是否替' + get.translation(player) + '打出一张闪？', { name: 'shan' });
                            next.set('ai', function () {
                                var event = _status.event;
                                return (get.attitude(event.player, event.source) - 2);
                            });
                            next.set('skillwarn', '替' + get.translation(player) + '打出一张闪');
                            next.autochoose = lib.filter.autoRespondShan;
                            next.set('source', player);
                        }
                    }
                    'step 1'
                    player.storage.minihujiaing = false;
                    if (result.bool) {
                        event.target = event.current;
                        trigger.result = { bool: true, card: { name: 'shan', isCard: true } };
                        trigger.responded = true;
                        trigger.animate = false;
                        if (typeof event.current.ai.shown == 'number' && event.current.ai.shown < 0.95) {
                            event.current.ai.shown += 0.3;
                            if (event.current.ai.shown > 0.95) event.current.ai.shown = 0.95;
                        }
                    }
                    else {
                        event.current = event.current.next;
                        event.goto(0);
                    }
                    'step 2'
                    target.chooseBool('是否令' + get.translation(player) + '摸一张牌？');
                    'step 3'
                    if (result.bool) {
                        target.line(player);
                        player.draw();
                    }
                },
                ai: {
                    respondShan: true,
                    skillTagFilter(player) {
                        if (player.storage.minihujiaing) return false;
                        return game.hasPlayer(function (current) {
                            return current != player && current.group == 'wei';
                        });
                    },
                },
            },
            //庞德
            minijuesi: {
                audio: 'juesi',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h', { name: 'sha' });
                },
                filterTarget(card, player, target) {
                    return target != player && target.countCards('he') > 0 && player.inRange(target);
                },
                filterCard: { name: 'sha' },
                content() {
                    'step 0'
                    target.chooseToDiscard('he', true);
                    'step 1'
                    if (result.bool) {
                        if (target.hp >= player.hp && result.cards[0].name != 'sha') player.draw(2);
                        if (result.cards[0].name == 'sha' && player.canUse({ name: 'juedou', isCard: true }, target, false)) player.useCard({ name: 'juedou', isCard: true }, target, false);
                    }
                },
                ai: {
                    order: 2,
                    result: {
                        target(player, target) {
                            if (get.effect(target, { name: 'juedou' }, player, player) <= 0) {
                                return 0;
                            }
                            if (target.hp < player.hp) {
                                if (player.countCards('h') > player.hp) return -0.1;
                                return 0;
                            }
                            var hs1 = target.getCards('h', 'sha');
                            var hs2 = player.getCards('h', 'sha');
                            if (hs1.length > hs2.length) {
                                return 0;
                            }
                            var hsx = target.getCards('h');
                            if (hsx.length > 2 && hs2.length <= 1 && hsx[0].number < 6) {
                                return 0;
                            }
                            if (hsx.length > 3 && hs2.length <= 1) {
                                return 0;
                            }
                            if (hs1.length > hs2.length - 1 && hs1.length > 0 && (hs2.length <= 1 || hs1[0].number > hs2[0].number)) {
                                return 0;
                            }
                            return -1;
                        },
                    },
                },
            },
            minichoujue: {
                derivation: ['minibeishui', 'miniqingjiao'],
                audio: 'choujue',
                trigger: { global: 'phaseAfter' },
                filter(event, player) {
                    return Math.abs(player.hp - player.countCards('h')) >= 3;
                },
                forced: true,
                juexingji: true,
                skillAnimation: true,
                animationColor: 'water',
                content() {
                    'step 0'
                    player.awakenSkill('minichoujue');
                    player.storage.choujue = true;
                    player.loseMaxHp();
                    'step 1'
                    player.addSkills('minibeishui');
                },
            },
            minibeishui: {
                audio: 'beishui',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return Math.min(player.hp, player.countCards('h')) <= 2;
                },
                forced: true,
                juexingji: true,
                skillAnimation: 'epic',
                animationColor: 'thunder',
                content() {
                    'step 0'
                    player.awakenSkill('minibeishui');
                    player.storage.beishui = true;
                    player.loseMaxHp();
                    'step 1'
                    player.addSkills('miniqingjiao');
                },
            },
            miniqingjiao: {
                audio: 'qingjiao',
                inherit: 'qingjiao',
                filter(event, player) {
                    if (!ui.cardPile.hasChildNodes() && !ui.discardPile.hasChildNodes()) return false;
                    var hs = player.getCards('h');
                    if (!hs.length) return false;
                    return hs.every(i => lib.filter.cardDiscardable(i, player, 'miniqingjiao'));
                },
                content() {
                    'step 0';
                    player.chooseToDiscard(true, 'h', player.countCards('h'));
                    'step 1';
                    var evt = trigger.getParent();
                    if (evt?.getParent && !evt.miniqingjiao) {
                        evt.miniqingjiao = true;
                        var next = game.createEvent('miniqingjiao_discard', false, evt.getParent());
                        next.player = player;
                        next.setContent(function () {
                            var hs = player.getCards('h');
                            if (hs.length) player.discard(hs);
                        });
                    }
                    'step 2';
                    var list = [];
                    var typelist = [];
                    var getType = function (card) {
                        var sub = get.subtype(card);
                        if (sub) return sub;
                        return card.name;
                    };
                    for (var i = 0; i < ui.cardPile.childElementCount; i++) {
                        var node = ui.cardPile.childNodes[i];
                        var typex = getType(node);
                        if (!typelist.includes(typex)) {
                            list.push(node);
                            typelist.push(typex);
                            if (list.length >= 8) break;
                        }
                    }
                    if (list.length < 8) {
                        for (var i = 0; i < ui.discardPile.childElementCount; i++) {
                            var node = ui.discardPile.childNodes[i];
                            var typex = getType(node);
                            if (!typelist.includes(typex)) {
                                list.push(node);
                                typelist.push(typex);
                                if (list.length >= 8) break;
                            }
                        }
                    }
                    player.gain(list, 'gain2');
                },
            },
            //夏侯令女
            miniweilie: {
                audio: 'weilie',
                inherit: 'weilie',
                filter(event, player) {
                    if (player.countMark('miniweilie') > player.getStorage('fuping').length) return false;
                    return player.countCards('he') && game.hasPlayer(current => current.isDamaged());
                },
                content() {
                    player.addMark('miniweilie', 1, false);
                    target.recover();
                    target.draw();
                },
            },
            minifaen: {
                audio: 'faen',
                trigger: { global: ['turnOverAfter', 'linkAfter', 'damageBegin4'] },
                filter(event, player) {
                    if (event.name == 'damage' && !player.countCards('he')) return false;
                    return event.name == 'turnOver' || event.player.isLinked();
                },
                direct: true,
                content() {
                    'step 0'
                    var target = trigger.player;
                    event.target = target;
                    if (trigger.name == 'damage') {
                        player.chooseToDiscard(get.prompt('minifaen', target), '弃置一张牌，防止即将对' + get.translation(target) + '造成的伤害', 'he').set('ai', function (card) {
                            if (!_status.event.check()) return -1;
                            return 7 - get.value(card);
                        }).set('check', function () {
                            if (get.attitude(player, target) <= 0) return false;
                            if (player.countCards('h', function (card) {
                                var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                                if (mod2 != 'unchanged') return mod2;
                                var mod = game.checkMod(card, player, target, 'unchanged', 'cardSavable', player);
                                if (mod != 'unchanged') return mod;
                                var savable = get.info(card).savable;
                                if (typeof savable == 'function') savable = savable(card, player, target);
                                return savable;
                            }) >= 1 + trigger.num - target.hp) return false;
                            if (target == player || target == get.zhu(player)) return true;
                            return !player.hasUnknown();
                        }).logSkill = ['minifaen', target];
                    }
                    else player.chooseBool(get.prompt('minifaen', target), '令' + get.translation(target) + '摸一张牌').set('choice', get.attitude(player, target) > 0);
                    'step 1'
                    if (result.bool) {
                        if (trigger.name != 'damage') {
                            player.logSkill('minifaen', target);
                            target.draw();
                        }
                        else trigger.cancel();
                    }
                },
                ai: { expose: 0.2 },
            },
            //王基
            miniqizhi: {
                audio: 'qizhi',
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    if (!event.targets || !event.isFirstTarget) return false;
                    if (_status.currentPhase != player) return false;
                    var type = get.type(event.card, 'trick');
                    if (type != 'basic' && type != 'trick') return false;
                    return game.hasPlayer(function (target) {
                        return !event.targets.includes(target) && target.countCards('he') > 0;
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('miniqizhi'), '弃置一名角色的一张牌，然后若弃置的牌与使用的牌类型相同，你摸一张牌；类型不同，其摸一张牌', function (card, player, target) {
                        return !_status.event.targets.includes(target) && target.countCards('he') > 0;
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        if (target == player) return 2;
                        if (get.attitude(player, target) <= 0) {
                            return 1
                        }
                        return 0.5;
                    }).set('targets', trigger.targets);
                    'step 1'
                    if (result.bool) {
                        player.logSkill('miniqizhi', result.targets);
                        player.discardPlayerCard(result.targets[0], true, 'he');
                        event.target = result.targets[0];
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool && get.type2(result.cards[0]) == get.type2(trigger.card)) player.draw();
                    else target.draw();
                },
            },
            minijinqu: {
                audio: 'jinqu',
                trigger: { player: 'phaseDiscardBefore' },
                prompt(event, player) {
                    var num = player.getHistory('useSkill', function (evt) {
                        return evt.skill == 'miniqizhi';
                    }).length + 1;
                    return '进趋：是否摸两张牌并跳过弃牌阶段，然后将手牌弃置至' + get.cnNumber(num) + '张？';
                },
                check(event, player) {
                    var num = player.getHistory('useSkill', function (evt) {
                        return evt.skill == 'miniqizhi';
                    }).length + 1;
                    var numx = player.countCards('h') + 2 - num;
                    return num >= 2 || player.needsToDiscard() >= numx;
                },
                content() {
                    'step 0'
                    trigger.cancel();
                    player.draw(2);
                    'step 1'
                    var num = player.getHistory('useSkill', function (evt) {
                        return evt.skill == 'miniqizhi';
                    }).length + 1;
                    if (player.countCards('h') > num) player.chooseToDiscard(player.countCards('h') - num, true);
                },
                ai: { combo: 'miniqizhi' },
            },
            //SP甄姬
            minijinghong: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current != player && current.countCards('h');
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    var num = Math.min(game.countPlayer(function (current) {
                        return current != player && current.countCards('h');
                    }), game.countPlayer() - 1, 4);
                    player.chooseTarget(get.prompt2('minijinghong'), [1, num], lib.filter.notMe).set('ai', function (target) {
                        var player = _status.event.player;
                        if (!target.countCards('h')) return 0;
                        return (1 - Math.sign(get.attitude(player, target))) / target.countCards('h');
                    });
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        event.targets = targets;
                        player.logSkill('minijinghong', targets);
                        player.addTempSkill('minijinghong_effect');
                    }
                    else event.finish();
                    'step 2'
                    var target = event.targets.shift();
                    event.target = target;
                    player.line(target);
                    if (!target.countCards('h')) event[event.targets.length > 0 ? 'redo' : 'finish']();
                    'step 3'
                    var card = target.getCards('h').randomGet();
                    player.showCards(card, get.translation(player) + '展示的' + get.translation(target) + '的手牌');
                    if (get.color(card, target) == 'black') player.gain(card, target, 'giveAuto', 'bySelf').gaintag.add('minijinghong');
                    if (get.color(card, target) == 'red') target.discard(card);
                    'step 4'
                    if (event.targets.length) event.goto(2);
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove(player) {
                            player.removeGaintag('minijinghong');
                        },
                        mod: {
                            ignoredHandcard(card, player) {
                                if (card.hasGaintag('minijinghong')) return true;
                            },
                            cardDiscardable(card, player, name) {
                                if (name == 'phaseDiscard' && card.hasGaintag('minijinghong')) return false;
                            },
                        },
                    },
                },
            },
            minispluoshen: {
                mod: {
                    aiValue(player, card, num) {
                        if (get.name(card) != 'shan' && get.color(card) != 'black') return;
                        var cards = player.getCards('hs', function (card) {
                            return get.name(card) == 'shan' || get.color(card) == 'black';
                        });
                        cards.sort(function (a, b) {
                            return (get.name(b) == 'shan' ? 1 : 2) - (get.name(a) == 'shan' ? 1 : 2);
                        });
                        var geti = function () {
                            if (cards.includes(card)) {
                                return cards.indexOf(card);
                            }
                            return cards.length;
                        };
                        if (get.name(card) == 'shan') return Math.min(num, [6, 4, 3][Math.min(geti(), 2)]) * 0.6;
                        return Math.max(num, [6.5, 4, 3][Math.min(geti(), 2)]);
                    },
                    aiUseful() {
                        return lib.skill.minispluoshen.mod.aiValue.apply(this, arguments);
                    },
                },
                audio: 'ext:活动武将/audio/skill:2',
                enable: ['chooseToRespond', 'chooseToUse'],
                filterCard(card) {
                    return get.color(card) == 'black';
                },
                frequent: true,
                locked: false,
                position: 'hes',
                viewAs: { name: 'shan' },
                viewAsFilter(player) {
                    if (!player.countCards('hes', { color: 'black' })) return false;
                },
                onuse(links, player) {
                    player.addTempSkill('minispluoshen_effect');
                },
                onrespond(links, player) {
                    player.addTempSkill('minispluoshen_effect');
                },
                prompt: '将一张黑色牌当作【闪】使用或打出',
                check: () => 1,
                ai: {
                    order(item, player) {
                        if (!player.hasSkill('minispluoshen_used')) return 1145141919810
                        return 2;
                    },
                    respondShan: true,
                    skillTagFilter(player) {
                        if (!player.countCards('hes', { color: 'black' })) return false;
                    },
                    effect: {
                        target(card, player, target, current) {
                            if (get.tag(card, 'respondShan') && current < 0) return 0.6
                        },
                    },
                },
                subSkill: {
                    used: { charlotte: true },
                    effect: {
                        charlotte: true,
                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                        filter(event, player) {
                            return event.skill == 'minispluoshen' && !player.hasSkill('minispluoshen_used');
                        },
                        prompt2: '进行一次判定并获得判定牌，若结果为黑色，你可以重复此流程',
                        content() {
                            'step 0'
                            player.addTempSkill('minispluoshen_used', 'roundStart');
                            event.cards = [];
                            'step 1'
                            var next = player.judge(function (card) {
                                var color = get.color(card);
                                return color == 'black' ? 1 : -1;
                            });
                            next.judge2 = function (result) {
                                return result.bool;
                            };
                            next.set('callback', function () {
                                if (get.position(card, true) == 'o') player.gain(card, 'gain2');
                            });
                            'step 2'
                            if (result.judge > 0) player.chooseBool('是否继续进行【洛神】判定？').set('frequentSkill', 'minispluoshen');
                            else event.finish();
                            'step 3'
                            if (result.bool) event.goto(1);
                        },
                    },
                },
            },
            minispwusheng: {
                group: ['minispwusheng_wusheng', 'minispwusheng_effect'],
                audio: 'wusheng',
                audioname: ['jsp_guanyu'],
                audioname2: {
                    guanzhang: "wusheng_guanzhang",
                    guansuo: "wusheng_guansuo",
                },
                trigger: { player: 'phaseBegin' },
                forced: true,
                locked: false,
                content() {
                    var card = get.cardPile(function (card) {
                        return get.color(card) == 'red';
                    });
                    if (card) player.gain(card, 'gain2');
                },
                subSkill: {
                    wusheng: {
                        audio: 'wusheng',
                        audioname: ['jsp_guanyu'],
                        audioname2: {
                            guanzhang: "wusheng_guanzhang",
                            guansuo: "wusheng_guansuo",
                        },
                        enable: ['chooseToRespond', 'chooseToUse'],
                        filterCard(card, player) {
                            return get.color(card) == 'red';
                        },
                        position: 'hes',
                        viewAs: { name: 'sha' },
                        viewAsFilter(player) {
                            if (!player.countCards('hes', { color: 'red' })) return false;
                        },
                        prompt: '武圣：将一张红色牌当作【杀】使用或打出',
                        check(card) {
                            var val = get.value(card);
                            if (_status.event.name == 'chooseToRespond') return 1 / Math.max(0.1, val);
                            return 5 - val;
                        },
                        ai: {
                            respondSha: true,
                            skillTagFilter(player) {
                                if (!player.countCards('hes', { color: 'red' })) return false;
                            },
                        },
                    },
                    effect: {
                        mod: {
                            aiOrder(player, card, num) {
                                if (get.itemtype(card) == 'card' && card.name == 'sha' && get.color(card) == 'red') return num + 0.1;
                            },
                            targetInRange(card) {
                                if (get.suit(card) == 'diamond' && card.name == 'sha') return true;
                            },
                        },
                        audio: 'wusheng',
                        audioname: ['jsp_guanyu'],
                        audioname2: {
                            guanzhang: "wusheng_guanzhang",
                            guansuo: "wusheng_guansuo",
                        },
                        inherit: 'jie',
                        filter(event, player) {
                            return lib.skill.jie.filter(event) && event.card.isCard;
                        },
                    },
                },
            },
            minidanji: {
                derivation: ['miniyuma', 'mininuzhan'],
                audio: 'danji',
                trigger: { player: ['useCard', 'respond'], source: 'damageSource' },
                filter(event, player) {
                    if (event.name != 'damage') return player.getAllHistory('useCard').length + player.getAllHistory('respond').length >= 5;
                    var num = 0;
                    player.getAllHistory('sourceDamage', evt => num += evt.num);
                    return num >= 6;
                },
                forced: true,
                juexingji: true,
                skillAnimation: true,
                animationColor: 'water',
                content() {
                    'step 0'
                    player.awakenSkill('minidanji');
                    if (player.isDamaged()) player.recover(player.maxHp - player.hp);
                    'step 1'
                    player.addSkills(lib.skill.minidanji.derivation);
                },
            },
            mininuzhan: {
                audio: 'dcnuchen',
                trigger: { player: 'useCard1', source: 'damageBegin1' },
                filter(event, player) {
                    if (!(event.card && event.card.name == 'sha' && event.cards?.length && !event.card.isCard)) return false;
                    if (event.name == 'useCard') return event.addCount !== false && get.type2(event.cards[0]) != 'trick';
                    return get.type2(event.cards[0]) == 'trick';
                },
                forced: true,
                content() {
                    var card = trigger.cards[0];
                    if (get.type2(card) != 'trick') {
                        trigger.addCount = false;
                        if (player.stat[player.stat.length - 1].card.sha > 0) {
                            player.stat[player.stat.length - 1].card.sha--;
                        }
                        game.log(event.card, '不计入次数限制');
                    }
                    else trigger.num++;
                },
            },
            //筷子
            minishenshi: {
                audio: 'nzry_shenshi',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he') > 0;
                },
                discard: false,
                line: true,
                lose: false,
                delay: false,
                position: 'he',
                filterCard: true,
                filterTarget: lib.filter.notMe,
                check(card) {
                    return 5 - get.value(card);
                },
                usable: 1,
                prompt: '将一张牌交给一名其他角色，然后对其造成1点伤害，若该角色因此死亡，则你可以令一名角色将手牌摸至四张',
                content() {
                    'step 0'
                    player.give(cards, target);
                    target.damage('nocard');
                    'step 1'
                    if (!target.isIn()) {
                        player.chooseTarget('审时：令一名角色将手牌摸至四张', function (card, player, target) {
                            return target.countCards('h') < 4;
                        }).set('ai', function (target) {
                            var player = _status.event.player;
                            return get.attitude(player, target);
                        });
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        player.line(result.targets);
                        result.targets[0].drawTo(4)
                    };
                },
                ai: {
                    order: 1,
                    result: { target: -1 },
                },
                group: 'minishenshi_2',
                subSkill: {
                    '2': {
                        audio: 'nzry_shenshi',
                        trigger: { player: 'damageEnd' },
                        filter(event, player) {
                            return player.countCards('he') > 0 && event.source?.isIn() && event.source != player;
                        },
                        logTarget: 'source',
                        prompt2: '观看该角色的手牌，然后交给其一张牌，其失去此牌后，你将手牌摸至四张',
                        content() {
                            'step 0'
                            player.viewHandcards(trigger.source);
                            player.chooseCard('he', true, '交给' + get.translation(trigger.source) + '一张牌').set('ai', function (card) {
                                return 5 - get.value(card);
                            });
                            'step 1'
                            if (result.bool) {
                                const skill = 'minishenshi_' + player.playerid;
                                if (!lib.skill[skill]) {
                                    game.broadcastAll((initSkill, skill) => {
                                        initSkill(skill);
                                        _status.postReconnect['minishenshi'] ??= [initSkill, []];
                                        _status.postReconnect['minishenshi'][1].add(skill);
                                    }, skill => {
                                        lib.skill[skill] = {};
                                        lib.translate[skill] = '审时';
                                    }, skill);
                                }
                                player.addSkill('minishenshi_3');
                                player.give(result.cards, trigger.source).gaintag.add(skill);
                            }
                        },
                    },
                    '3': {
                        charlotte: true,
                        audio: 'nzry_shenshi',
                        trigger: { global: ['equipAfter', 'addJudgeAfter', 'loseAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'] },
                        filter(event, player) {
                            if (player.countCards('h') >= 4) return false;
                            return game.hasPlayer2(current => {
                                const evt = event.getl(current);
                                if (evt?.gaintag_map) {
                                    return Object.values(evt.gaintag_map).flat().includes(`minishenshi_${player.playerid}`);
                                }
                                return false;
                            });
                        },
                        forced: true,
                        content() {
                            player.drawTo(4);
                        },
                    },
                },
            },
            //魏贾诩
            minijianshu: {
                audio: 'jianshu',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h');
                },
                filterTarget(card, player, target) {
                    if (target == player) return false;
                    if (ui.selected.targets.length) {
                        return ui.selected.targets[0] != target && !ui.selected.targets[0].hasSkillTag('noCompareSource') && target.countCards('h') && !target.hasSkillTag('noCompareTarget');
                    }
                    return true;
                },
                usable: 1,
                targetprompt: ['发起者', '拼点目标'],
                filterCard: true,
                discard: false,
                lose: false,
                delay: false,
                check(card) {
                    if (_status.event.player.hp == 1) return 8 - get.value(card);
                    return 6 - get.value(card);
                },
                selectTarget: 2,
                multitarget: true,
                content() {
                    'step 0'
                    player.give(cards, targets[0], 'give');
                    'step 1'
                    targets[0].chooseToCompare(targets[1]);
                    'step 2'
                    player.addTempSkill('dcjianshu_check', 'phaseUseAfter');
                    if (result.bool) {
                        var cards = targets[0].getCards('he');
                        if (cards.length) player.gain(cards.randomGet(), targets[0], 'giveAuto');
                        targets[1].loseHp();
                    }
                    else if (result.tie) {
                        targets[0].loseHp();
                        targets[1].loseHp();
                    }
                    else {
                        var cards = targets[1].getCards('he');
                        if (cards.length) player.gain(cards.randomGet(), targets[1], 'giveAuto');
                        targets[0].loseHp();
                    }
                },
                subSkill: {
                    check: {
                        trigger: { global: 'dieAfter' },
                        charlotte: true,
                        forced: true,
                        popup: false,
                        filter(event, player) {
                            return event.getParent(3).name == 'minijianshu';
                        },
                        content() {
                            delete player.getStat('skill').minijianshu;
                        },
                    },
                },
                ai: {
                    expose: 0.4,
                    order: 4,
                    result: {
                        target(player, target) {
                            if (ui.selected.targets.length) return -1;
                            return -0.5;
                        },
                    },
                },
            },
            miniyongdi: {
                audio: 'yongdi',
                mark: true,
                limited: true,
                enable: 'phaseUse',
                filterTarget: true,
                animationColor: 'thunder',
                skillAnimation: 'legend',
                content() {
                    'step 0'
                    player.awakenSkill('miniyongdi');
                    if (!game.hasPlayer(current => current.maxHp < target.maxHp)) target.gainMaxHp();
                    'step 1'
                    if (target.isMinHp()) target.recover();
                    'step 2'
                    if (target.isMinHandcard()) target.draw(Math.min(5, target.maxHp));
                    'step 3'
                    game.delayx();
                },
                ai: {
                    expose: 0.3,
                    order: 1,
                    result: {
                        target(player, target) {
                            var val = 0;
                            var bool1 = !game.hasPlayer(current => current.maxHp < target.maxHp), bool2 = target.isMinHp(), bool3 = target.isMinHandcard();
                            if (bool1) val += 5;
                            if (bool2) {
                                if (bool1) target.maxHp++;
                                val += Math.max(0, get.recoverEffect(target, player, player));
                                if (bool1) target.maxHp--;
                            }
                            if (bool3) {
                                var num = Math.max(0, Math.min(5, target.maxHp + (bool1 ? 1 : 0)));
                                val += 5 * num;
                            }
                            return val;
                        },
                    },
                },
            },
            //尹夫人
            miniyongbi: {
                audio: 'dcyongbi',
                inherit: 'dcyongbi',
                filter(event, player) {
                    return player.countCards('h') > 0;
                },
                filterTarget: lib.filter.notMe,
                selectCard: [1, Infinity],
                complexCard: true,
                complexSelect: true,
                check(card) {
                    var player = _status.event.player;
                    if (!ui.selected.cards.some(cardx => get.suit(card, player) == get.suit(cardx, player))) return 8 - get.value(card);
                    return 0;
                },
                content() {
                    'step 0'
                    player.awakenSkill('miniyongbi');
                    if (player.hasSkill('dcyingyu', null, null, false)) player.storage.dcyingyu = true;
                    player.give(cards, target);
                    'step 1'
                    var list = [];
                    for (var i of cards) {
                        list.add(get.suit(i, player));
                        if (list.length >= 3) break;
                    }
                    if (list.length >= 2) {
                        player.addMark('dcyongbi_eff1', 2, false);
                        player.addSkill('dcyongbi_eff1');
                        target.addMark('dcyongbi_eff1', 2, false);
                        target.addSkill('dcyongbi_eff1');
                    }
                    if (list.length >= 3) {
                        player.addMark('dcyongbi_eff2', 1, false);
                        player.addSkill('dcyongbi_eff2');
                        target.addMark('dcyongbi_eff2', 1, false);
                        target.addSkill('dcyongbi_eff2');
                    }
                },
            },
            //SP曹仁
            miniweikui: {
                audio: 'weikui',
                enable: 'phaseUse',
                filterTarget(card, player, target) {
                    return target != player && target.countCards('h');
                },
                usable: 1,
                content() {
                    'step 0'
                    player.loseHp();
                    player.viewHandcards(target);
                    'step 1'
                    if (target.countCards('h', { name: 'shan' })) player.gainPlayerCard(target, 'visible', true, 'h').set('ai', function (button) {
                        return get.value(button.link, _status.event.target);
                    });
                    else {
                        if (player.canUse({ name: 'sha', isCard: true }, target, false)) player.useCard({ name: 'sha', isCard: true }, target, false);
                        player.storage.weikui2 = target;
                        player.addTempSkill('weikui2');
                        event.finish();
                    }
                    'step 2'
                    player.recover();
                },
                ai: {
                    order: 8,
                    result: {
                        target(player, target) {
                            if (!target.countCards('h', { name: 'shan' })) {
                                if (player.hp <= 2) return 0;
                                if (player.hp == 3) return target.hp <= 2 ? -1 : 0;
                            }
                            return -1;
                        },
                    },
                },
            },
            minilizhan: {
                audio: 'lizhan',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return game.hasPlayer(current => current.isDamaged());
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minilizhan'), [1, Infinity], function (card, player, target) {
                        return target.isDamaged();
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        return get.attitude(player, target);
                    });
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        event.targets = targets;
                        player.logSkill('minilizhan', targets);
                        game.asyncDraw(targets);
                    }
                    else event.finish();
                    'step 2'
                    var num = targets.filter(target => target.countCards('h') == target.getHp()).length;
                    if (num) player.draw(num);
                    else game.delayx();
                },
                ai: { threaten: 1.5 },
            },
            //郭嘉
            minishenglun: {
                audio: 'ext:活动武将/audio/skill:1',
                enable: 'phaseUse',
                filterTarget: lib.filter.notMe,
                selectTarget: [1, 2],
                usable: 1,
                content() {
                    'step 0'
                    var list = [
                        Math.sign(player.hp - target.hp),
                        Math.sign(player.countCards('h') - target.countCards('h')),
                        Math.sign(player.countCards('e', card => get.subtype(card) == 'equip1') - target.countCards('e', card => get.subtype(card) == 'equip1')),
                        Math.sign(player.countCards('e', card => get.subtype(card) == 'equip2') - target.countCards('e', card => get.subtype(card) == 'equip2')),
                        Math.sign(player.countCards('e', card => ['equip3', 'equip4'].includes(get.subtype(card))) - target.countCards('e', card => ['equip3', 'equip4'].includes(get.subtype(card)))),
                    ], num = 0;
                    while (num < 5) {
                        game.log('第' + get.cnNumber(num + 1, true) + '局', list[num] > 0 ? '#g成功' : '#y失败');
                        player.addMark('minishenglun_' + (list[num] > 0 ? 'win' : 'lose'), 1, false);
                        num++;
                    }
                    'step 1'
                    if (player.countMark('minishenglun_win') >= 10) {
                        player.recover();
                        var next = game.createEvent('minishenglun_result');
                        next.player = player;
                        next.setContent(lib.skill.minishenglun.content_yiji);
                        player.removeMark('minishenglun_win', player.countMark('minishenglun_win'), false);
                    }
                    'step 2'
                    if (player.countMark('minishenglun_lose') >= 10) {
                        player.chooseTarget('请选择【胜论】的目标', '对一名角色造成1点伤害', true).set('ai', target => get.damageEffect(target, _status.event.player, _status.event.player));
                    }
                    else event.finish();
                    'step 3'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target);
                        target.damage();
                    }
                    var next = game.createEvent('minishenglun_result');
                    next.player = player;
                    next.setContent(lib.skill.minishenglun.content_yiji);
                    player.removeMark('minishenglun_lose', player.countMark('minishenglun_lose'), false);
                },
                ai: {
                    order: 1,
                    result: {
                        target(player, target) {
                            var att = get.attitude(player, target);
                            var num = Math.sign(att);
                            var ref = get.recoverEffect(player, player, player);
                            var def = game.filterPlayer().reduce((list, current) => {
                                list.push(get.damageEffect(current, player, player));
                                return list;
                            }, []).sort((a, b) => b - a)[0];
                            var sum = Math.sign(player.hp - target.hp) + Math.sign(player.countCards('h') - target.countCards('h')) +
                                Math.sign(player.countCards('e', card => get.subtype(card) == 'equip1') - target.countCards('e', card => get.subtype(card) == 'equip1')) +
                                Math.sign(player.countCards('e', card => get.subtype(card) == 'equip2') - target.countCards('e', card => get.subtype(card) == 'equip2')) +
                                Math.sign(player.countCards('e', card => ['equip3', 'equip4'].includes(get.subtype(card))) - target.countCards('e', card => ['equip3', 'equip4'].includes(get.subtype(card))));
                            if (((ref - def) * sum) > 0) return 2 * num;
                            return num;
                        },
                    },
                },
                content_yiji() {
                    'step 0'
                    player.logSkill('new_reyiji');
                    player.draw(2);
                    if (_status.connectMode) game.broadcastAll(function () { _status.noclearcountdown = true });
                    event.given_map = {};
                    event.num = 2;
                    'step 1'
                    player.chooseCardTarget({
                        filterCard(card) {
                            return get.itemtype(card) == 'card' && !card.hasGaintag('reyiji_tag');
                        },
                        filterTarget: lib.filter.notMe,
                        selectCard: [1, event.num],
                        prompt: '请选择要分配的卡牌和目标',
                        ai1(card) {
                            if (!ui.selected.cards.length) return 1;
                            return 0;
                        },
                        ai2(target) {
                            var player = _status.event.player, card = ui.selected.cards[0];
                            var val = target.getUseValue(card);
                            if (val > 0) return val * get.attitude(player, target) * 2;
                            return get.value(card, target) * get.attitude(player, target);
                        },
                    });
                    'step 2'
                    if (result.bool) {
                        var res = result.cards, target = result.targets[0].playerid;
                        player.addGaintag(res, 'reyiji_tag');
                        event.num -= res.length
                        if (!event.given_map[target]) event.given_map[target] = [];
                        event.given_map[target].addArray(res);
                        if (event.num > 0) event.goto(1);
                    }
                    else if (event.num == 2) {
                        if (_status.connectMode) game.broadcastAll(function () { delete _status.noclearcountdown; game.stopCountChoose() });
                        event.finish();
                    }
                    'step 3'
                    if (_status.connectMode) game.broadcastAll(function () { delete _status.noclearcountdown; game.stopCountChoose() });
                    var map = [], cards = [];
                    for (var i in event.given_map) {
                        var source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                        player.line(source, 'green');
                        map.push([source, event.given_map[i]]);
                        cards.addArray(event.given_map[i]);
                    }
                    game.loseAsync({
                        gain_list: map,
                        player: player,
                        cards: cards,
                        giver: player,
                        animate: 'giveAuto',
                    }).setContent('gaincardMultiple');
                },
                subSkill: {
                    win: {
                        charlotte: true,
                        onremove: true,
                        marktext: '胜',
                        intro: { content: '已胜利#次' },
                    },
                    lose: {
                        charlotte: true,
                        onremove: true,
                        marktext: '败',
                        intro: { content: '已失败#次' },
                    },
                },
            },
            //曹洪
            miniyuanhu: {
                audio: 'yuanhu',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.hasCard({ type: 'equip' }, 'he');
                },
                filterCard: { type: 'equip' },
                filterTarget(card, player, target) {
                    var card = ui.selected.cards[0];
                    return target.canEquip(card);
                },
                usable: 2,
                discard: false,
                lose: false,
                prepare: 'give',
                position: 'he',
                check(card) {
                    if (get.position(card) == 'h') return 9 - get.value(card);
                    return 7 - get.value(card);
                },
                content() {
                    'step 0'
                    target.equip(cards[0]);
                    player.draw();
                    'step 1'
                    event.goto(3);
                    switch (get.subtype(cards[0])) {
                        case 'equip1':
                            if (game.hasPlayer(function (current) {
                                return current != target && get.distance(target, current) == 1 && current.countCards('hej') > 0;
                            })) {
                                player.chooseTarget(true, '弃置一名距离' + get.translation(target) + '为1的角色区域内的一张牌', function (card, player, target) {
                                    var current = _status.event.current;
                                    return current != target && get.distance(current, target) == 1 && current.countCards('hej') > 0;
                                }).set('current', target).set('ai', function (target) {
                                    var player = _status.event.player;
                                    return get.effect(target, { name: 'guohe_copy' }, player, player);
                                });
                                event.goto(2);
                            }
                            break;
                        case 'equip2':
                            target.draw();
                            break;
                        case 'equip3': case 'equip4':
                            target.recover();
                            break;
                    }
                    'step 2'
                    var target = result.targets[0];
                    player.line(target);
                    player.discardPlayerCard(target, true, 'hej');
                },
                group: 'miniyuanhu_biyue',
                ai: {
                    order: 10,
                    result: {
                        player(player, target) {
                            if (get.attitude(player, target) == 0) return 0;
                            if (!ui.selected.cards.length) return;
                            var eff = get.effect(target, ui.selected.cards[0], player, player), sub = get.subtype(ui.selected.cards[0], false);
                            if (target == player) eff += 4;
                            else {
                                var hp = player.hp, hs = player.countCards('h', (card) => card != ui.selected.cards[0]);
                                var tp = target.hp, ts = target.countCards('h');
                                if (sub == 'equip2') ts++;
                                if (tp < target.maxHp && (sub == 'equip3' || sub == 'equip4')) tp++;
                                if (tp <= hp || ts <= hs) eff += 2;
                            }
                            if (sub == 'equip1') {
                                var list = game.filterPlayer(function (current) {
                                    return current != target && get.distance(target, current) == 1 && current.countCards('hej') < 0;
                                }).map(function (i) {
                                    return get.effect(i, { name: 'guohe_copy' }, player, player);
                                }).sort((a, b) => b - a);
                                if (list.length) eff += list[0];
                            }
                            return eff;
                        },
                        target(player, target) {
                            if (!ui.selected.cards.length) return 0;
                            var sub = get.subtype(ui.selected.cards[0], false);
                            var eff = get.effect(target, ui.selected.cards[0], player, target);
                            if (sub == 'equip2') eff += (get.effect(target, { name: 'wuzhong' }, target, target) / 2);
                            if (target.isDamaged() && (sub == 'equip3' || sub == 'equip4')) eff += get.recoverEffect(target, player, player);
                            return eff;
                        },
                    },
                },
                subSkill: {
                    biyue: {
                        audio: 'yuanhu',
                        trigger: { player: 'phaseEnd' },
                        filter(event, player) {
                            return !player.getHistory('useSkill', evt => evt.skill == 'miniyuanhu').length;
                        },
                        forced: true,
                        locked: false,
                        content() {
                            var card = get.cardPile2(card => get.type(card) == 'equip');
                            if (card) player.gain(card, 'gain2');
                        },
                    },
                },
            },
            minijuezhu: {
                limited: true,
                audio: 'twjuezhu',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.hasEnabledSlot(3) || player.hasEnabledSlot(4);
                },
                skillAnimation: true,
                animationColor: 'water',
                filterTarget: true,
                async content(event, trigger, player) {
                    const target = event.target;
                    player.awakenSkill('minijuezhu');
                    let list = [], control;
                    for (let i = 3; i <= 4; i++) {
                        if (player.hasEnabledSlot(i)) list.push('equip' + i);
                    }
                    if (list.length == 1) control = list[0];
                    else control = (await player.chooseControl(list).set('prompt', '决助：请选择废除一个坐骑栏').forResult()).control;
                    if (control) {
                        await player.disableEquip(control);
                        player.addSkill('twjuezhu_restore');
                        player.markAuto('twjuezhu_restore', [[target, control]]);
                    }
                    await target.addSkills('feiying');
                    await target.disableJudge();
                },
                ai: {
                    order: (item, player) => player.hasUnknown() ? 0 : 10,
                    result: { target: 1 },
                },
                derivation: 'feiying',
            },
            //谋曹操
            minisbjianxiong: {
                audio: 'sbjianxiong',
                inherit: 'sbjianxiong',
                filter(event, player) {
                    return get.itemtype(event.cards) == 'cards' && event.cards.some(i => get.position(i, true) == 'o') || 2 - player.countMark('sbjianxiong') > 0;
                },
                prompt2(event, player) {
                    var gain = get.itemtype(event.cards) == 'cards' && event.cards.some(i => get.position(i, true) == 'o');
                    var str = '', draw = 2 - player.countMark('sbjianxiong');
                    if (gain) str += '获得' + get.translation(event.cards);
                    if (gain && draw > 0) str += '并';
                    if (draw > 0) str += '摸' + get.cnNumber(draw) + '张牌';
                    if (player.countMark('sbjianxiong')) str += '，然后可以弃1枚“治世”标记';
                    return str;
                },
                content() {
                    'step 0'
                    if (get.itemtype(trigger.cards) == 'cards' && trigger.cards.some(i => get.position(i, true) == 'o')) player.gain(trigger.cards, 'gain2');
                    var num = player.countMark('sbjianxiong');
                    if (2 - num > 0) player.draw(2 - num, 'nodelay');
                    'step 1'
                    var controls = [];
                    if (player.countMark('sbjianxiong') < 2) controls.push('获得标记');
                    if (player.hasMark('sbjianxiong')) controls.push('失去标记');
                    player.chooseControl(controls, 'cancel2').set('prompt', '是否获得或失去1枚“治世”标记？').set('ai', () => {
                        if (_status.event.controls.includes('失去标记')) {
                            var player = _status.event.player, current = _status.currentPhase;
                            if (get.distance(current, player, 'absolute') > 3 && player.hp <= 2) return '失去标记';
                        }
                        return (_status.event.controls.includes('获得标记') && Math.random() < 0.5) ? '获得标记' : 'cancel2';
                    });
                    'step 2'
                    if (result.control != 'cancel2') player[result.control == '失去标记' ? 'removeMark' : 'addMark']('sbjianxiong', 1);
                },
            },
            minisbqingzheng: {
                audio: 'sbqingzheng',
                enable: 'phaseUse',
                filter(event, player) {
                    return lib.suit.filter(suitx => player.countCards('h', { suit: suitx })).length >= (3 - player.countMark('sbjianxiong'));
                },
                usable: 1,
                chooseButton: {
                    dialog(event, player) {
                        return ui.create.dialog(
                            '###清正###<div class="text center">弃置' + get.cnNumber(3 - player.countMark('sbjianxiong')) + '种花色的所有手牌并观看一名有手牌的其他角色的手牌，你弃置其中一种花色的所有牌。若其被弃置的牌数小于你以此法弃置的牌数，你对其造成1点伤害，然后你可获得或失去1枚“治世”标记。</div>',
                            [lib.suit.map(i => ['', '', 'lukai_' + i]), 'vcard'], 'hidden');
                    },
                    select: () => 3 - _status.event.player.countMark('sbjianxiong'),
                    /*
                    filter:function(button){
                    var player=_status.event.player;
                    return player.countCards('h',card=>get.suit(card,player)==button.link[2].slice(6));
                    },
                    */
                    check(button) {
                        var player = _status.event.player;
                        return player.countMark('sbjianxiong') * 15 - player.getCards('h', { suit: button.link[2].slice(6) }).map(i => get.value(i)).reduce((p, c) => p + c, 0);
                    },
                    backup(links, player) {
                        return {
                            audio: 'sbqingzheng',
                            suits: links.map(i => i[2].slice(6)),
                            filterTarget(card, player, target) {
                                return target != player && target.countCards('h');
                            },
                            filterCard: () => false,
                            selectCard: -1,
                            content() {
                                'step 0'
                                var suits = lib.skill.minisbqingzheng_backup.suits;
                                const popup = suits.slice().sort((a, b) => lib.suit.indexOf(a) - lib.suit.indexOf(b)).reduce((str, suit) => str + get.translation(suit), '');
                                player.popup(popup);
                                game.log(player, '选择了花色', '#g' + popup);
                                var cards = player.getCards('h', card => suits.includes(get.suit(card, player)));
                                event.cards = cards;
                                if (cards.length) player.discard(cards);
                                'step 1'
                                var list = [];
                                var dialog = ['清正：弃置' + get.translation(target) + '一种花色的所有牌'];
                                for (var suit of lib.suit.concat('none')) {
                                    if (target.countCards('h', { suit: suit })) {
                                        dialog.push('<div class="text center">' + get.translation(suit + '2') + '牌</div>');
                                        dialog.push(target.getCards('h', { suit: suit }));
                                        list.push(suit);
                                    }
                                }
                                if (list.length) {
                                    player.chooseControl(list).set('dialog', dialog).set('ai', () => {
                                        return _status.event.control;
                                    }).set('control', (() => {
                                        var getv = (cards) => cards.map(i => get.value(i)).reduce((p, c) => p + c, 0);
                                        return list.sort((a, b) => getv(target.getCards('h', { suit: b })) - getv(target.getCards('h', { suit: a })))[0];
                                    })());
                                }
                                else {
                                    event.cards2 = [];
                                    event.goto(3);
                                }
                                'step 2'
                                var cards2 = target.getCards('h', { suit: result.control });
                                event.cards2 = cards2;
                                target.discard(cards2, 'notBySelf').set('discarder', player);
                                'step 3'
                                if (event.cards2.length < cards.length) target.damage();
                                'step 4'
                                var controls = [];
                                if (player.countMark('sbjianxiong') < 2) controls.push('获得标记');
                                if (player.hasMark('sbjianxiong')) controls.push('失去标记');
                                player.chooseControl(controls, 'cancel2').set('prompt', '是否获得或失去1枚“治世”标记？').set('ai', () => {
                                    if (_status.event.controls.includes('失去标记')) {
                                        var player = _status.event.player, current = _status.currentPhase;
                                        if (get.distance(current, player, 'absolute') > 3 && player.hp <= 2) return '失去标记';
                                    }
                                    return (_status.event.controls.includes('获得标记') && Math.random() < 0.5) ? '获得标记' : 'cancel2';
                                });
                                'step 5'
                                if (result.control != 'cancel2') player[result.control == '失去标记' ? 'removeMark' : 'addMark']('sbjianxiong', 1);
                            },
                            ai: {
                                result: {
                                    target(player, target) {
                                        var att = get.attitude(player, target);
                                        return att > 0 ? 0 : (1 - (Math.sign(get.effect(target, { name: 'guohe_copy2' }, player, player)) * Math.sqrt(target.countCards('h'))));
                                    },
                                },
                            },
                        }
                    },
                    prompt(links, player) {
                        const popup = links.map(i => i[2].slice(6)).sort((a, b) => lib.suit.indexOf(a) - lib.suit.indexOf(b)).reduce((str, suit) => str + get.translation(suit), '');
                        return '###清正###弃置' + popup + '花色的所有手牌并观看一名有手牌的其他角色的手牌，你弃置其中一种花色的所有牌。若其被弃置的牌数小于你以此法弃置的牌数，你对其造成1点伤害，然后你可获得或失去1枚“治世”标记';
                    },
                },
                ai: {
                    combo: 'minisbjianxiong',
                    order(item, player) {
                        var getNum = function (player, target) {
                            return get.attitude(player, target) > 0 ? 0 : (Math.sign(get.effect(target, { name: 'guohe_copy2' }, player, player)) * Math.sqrt(target.countCards('h')));
                        };
                        var targets = game.filterPlayer(current => current != player && current.countCards('h'));
                        if (!targets.length) return 0;
                        targets.sort((a, b) => getNum(player, b) - getNum(player, a));
                        if (getNum(player, targets[0]) <= 0) return 0;
                        return targets[0].countCards('h') + 3;
                    },
                    result: { player: 1 },
                },
            },
            //蛋神
            minigongao: {
                audio: 'gongao',
                inherit: 'regongao',
                filter(event, player) {
                    return event.player != player;
                },
            },
            minijuyi: {
                audio: 'juyi',
                trigger: {
                    player: 'phaseZhunbeiBegin',
                },
                filter(event, player) {
                    return player.maxHp > game.countPlayer();
                },
                limited: true,
                skillAnimation: true,
                animationColor: 'thunder',
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    await player.drawTo(player.maxHp);
                    await player.addSkills(get.info(event.name).derivation);
                },
                derivation: ['minibenghuai', 'reweizhong'],
            },
            //卞夫人
            miniwanwei: {
                audio: 'wanwei',
                trigger: { global: 'dying' },
                filter(event, player) {
                    return event.player != player && player.countCards('he');
                },
                round: 1,
                async cost(event, trigger, player) {
                    const target = trigger.player;
                    event.result = await player.chooseCard(get.prompt2(event.skill, target), 'he', [1, 5], 'allowChooseAll').set('ai', cardx => {
                        const { player, target } = get.event();
                        if (get.attitude(player, target) <= 0) return 0;
                        let sum = target.countCards('hs', card => target.canSaveCard(card, target)) + target.hp;
                        if ((player.hasSkill('fh_yuejian') && !player.hasSkill('fh_yuejian_used') && !get.is.blocked('fh_yuejian', player))) sum++;
                        if (player.countCards('hs', card => target.canSaveCard(card, target)) + sum <= 0) return 0;
                        if (target.canSaveCard(cardx, target) && ui.selected.cards.filter(card => target.canSaveCard(card, target)).length + sum > 0) return 12 - get.value(cardx);
                        return 7 - get.value(cardx);
                    }).set('target', target).forResult();
                },
                logTarget: 'player',
                async content(event, trigger, player) {
                    const { cards, targets: [target] } = event;
                    await player.give(cards, target);
                    target.when('dyingAfter').filter(evt => evt == trigger).step(async () => {
                        if (player.isIn()) {
                            await player.draw(cards.length);
                            await player.recover();
                        }
                    });
                },
            },
            miniyuejian: {
                audio: 'yuejian',
                mod: { maxHandcard: (player, num) => num + player.maxHp },
                locked: false,
                enable: 'chooseToUse',
                hiddenCard(player, name) {
                    if (get.type(name) == 'basic' && lib.inpile.includes(name) && !player.hasSkill('miniyuejian_used')) return true;
                },
                filter(event, player) {
                    if (event.type == 'wuxie') return false;
                    if (player.hasSkill('miniyuejian_used')) return false;
                    for (var i of lib.inpile) {
                        if (get.type(i) != 'basic') continue;
                        var card = { name: i, isCard: true };
                        if (event.filterCard(card, player, event)) return true;
                        if (i == 'sha') {
                            for (var j of lib.inpile_nature) {
                                card.nature = j;
                                if (event.filterCard(card, player, event)) return true;
                            }
                        }
                    }
                    return false;
                },
                chooseButton: {
                    dialog(event, player) {
                        var list = [];
                        for (var i of lib.inpile) {
                            if (get.type(i) != 'basic') continue;
                            var card = { name: i, isCard: true };
                            if (event.filterCard(card, player, event)) list.push(['基本', '', i]);
                            if (i == 'sha') {
                                for (var j of lib.inpile_nature) {
                                    card.nature = j;
                                    if (event.filterCard(card, player, event)) list.push(['基本', '', i, j]);
                                }
                            }
                        }
                        return ui.create.dialog('约俭', [list, 'vcard'], 'hidden');
                    },
                    check(button) {
                        if (button.link[2] == 'shan') return 3;
                        var player = _status.event.player;
                        if (button.link[2] == 'jiu') {
                            if (player.getUseValue({ name: 'jiu' }) <= 0) return 0;
                            if (player.countCards('h', 'sha')) return player.getUseValue({ name: 'jiu' });
                            return 0;
                        }
                        return player.getUseValue({ name: button.link[2], nature: button.link[3], isCard: true });
                    },
                    backup(links, player) {
                        return {
                            selectCard: -1,
                            filterCard: () => false,
                            viewAs: {
                                name: links[0][2],
                                nature: links[0][3],
                                isCard: true,
                            },
                            precontent() {
                                player.logSkill('miniyuejian');
                                delete event.result.skill;
                            },
                        }
                    },
                    prompt(links, player) {
                        var name = links[0][2];
                        var nature = links[0][3];
                        return '视为使用' + (get.translation(nature) || '') + get.translation(name);
                    },
                },
                ai: {
                    order(item, player) {
                        if (player && _status.event.type == 'phase') {
                            var max = 0, add = false;
                            var list = lib.inpile.filter(name => get.type(name) == 'basic');
                            if (list.includes('sha')) add = true;
                            list = list.map(namex => { return { name: namex, isCard: true } });
                            if (add) {
                                lib.inpile_nature.forEach(naturex => list.push({ name: 'sha', nature: naturex, isCard: true }));
                            }
                            for (var card of list) {
                                if (player.getUseValue(card) > 0) {
                                    var temp = get.order(card);
                                    if (temp > max) max = temp;
                                }
                            }
                            if (max > 0) max += 0.3;
                            return max;
                        }
                        return 10;
                    },
                    respondShan: true,
                    respondSha: true,
                    skillTagFilter(player, tag, arg) {
                        if (arg == 'respond') return false;
                        return !player.hasSkill('miniyuejian_used');
                    },
                    result: {
                        player(player) {
                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                            return 1;
                        },
                    },
                },
                group: 'miniyuejian_count',
                //联机の痛！！！！！！
                init(player) {
                    if (!player.hasSkill('miniyuejian_used') && player.getHistory('useCard', evt => get.type(evt.card) == 'basic').length) player.addTempSkill('miniyuejian_used');
                },
                subSkill: {
                    used: { charlotte: true },
                    count: {
                        charlotte: true,
                        trigger: { player: 'useCard1' },
                        filter(event, player) {
                            return !player.hasSkill('miniyuejian_used') && get.type(event.card) == 'basic';
                        },
                        forced: true,
                        popup: false,
                        firstDo: true,
                        content() {
                            player.addTempSkill('miniyuejian_used');
                        },
                    },
                },
            },
            //于禁
            minixiayuan: {
                audio: 'sbxiayuan',
                trigger: { global: 'dying' },
                filter(event, player) {
                    return event.player != player && !player.hasSkill('minixiayuan_used') && player.countCards('he');
                },
                direct: true,
                async content(event, trigger, player) {
                    var target = trigger.player;
                    var result = await player.chooseToDiscard(get.prompt2('minixiayuan', target), 'he', [1, 2]).set('ai', card => {
                        var player = _status.event.player, target = _status.event.target;
                        if (get.attitude(player, target) <= 0) return 0;
                        return 7 - get.value(card);
                    }).set('target', target).set('logSkill', ['minixiayuan', target]).forResult();
                    if (result.bool) {
                        player.addTempSkill('minixiayuan_used', 'roundStart');
                        target.recover(result.cards.length);
                    }
                },
                subSkill: { used: { charlotte: true } },
            },
            minijieyue: {
                derivation: ['minijieyue_junling1', 'minijieyue_junling2', 'minijieyue_junling3', 'minijieyue_junling4'],
                getJunLingEffect: (player, target, junling) => {
                    var att = get.attitude(player, target);
                    switch (junling) {
                        case 'minijieyue_junling1':
                            return game.filterPlayer().map(aim => get.damageEffect(aim, target, player) * (2 - Math.sign(att))).sort((a, b) => b - a)[0];
                            break;
                        case 'minijieyue_junling2':
                            if (att > 0) return 0;
                            var num = 0;
                            if (target.countCards('h', card => get.value(card) >= 7 && lib.filter.cardDiscardable(card, target))) {
                                player.addSkill('minijieyue_checkh');
                                num += get.effect(target, { name: 'guohe_copy2' }, player, player);
                                player.removeSkill('minijieyue_checkh');
                            }
                            if (target.countCards('e', card => get.value(card) >= 7 && lib.filter.cardDiscardable(card, target))) {
                                player.addSkill('minijieyue_checke');
                                num += get.effect(target, { name: 'guohe_copy2' }, player, player);
                                player.removeSkill('minijieyue_checke');
                            }
                            return num;
                            break;
                        case 'minijieyue_junling3':
                            if (att > 0) return 0;
                            return Math.max(0, 3 - target.getHp());
                            break;
                        case 'minijieyue_junling4':
                            if (att > 0) return 0;
                            return Math.sqrt(target.countCards('h'));
                            break;
                    }
                },
                audio: 'sbjieyue',
                trigger: { player: 'phaseZhunbeiBegin' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minijieyue'), lib.filter.notMe).set('ai', target => {
                        var player = _status.event.player;
                        return function (player, target) {
                            var max = 0;
                            for (var i = 1; i <= 4; i++) {
                                var temp = lib.skill.minijieyue.getJunLingEffect(player, target, 'minijieyue_junling' + i);
                                if (temp > max) max = temp;
                            }
                            return max;
                        }(player, target);
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minijieyue', target);
                        target.draw();
                        event.cards = [1, 2, 3, 4]/*.randomGets(2).sort((a,b)=>a-b)*/.map(num => 'minijieyue_junling' + num);
                    }
                    else event.finish();
                    'step 2'
                    player.chooseButton(['###节钺###请选择' + get.translation(target) + '执行的军令', [cards, 'vcard']], true).set('ai', button => {
                        var player = _status.event.player, target = _status.event.target;
                        return lib.skill.minijieyue.getJunLingEffect(player, target, button.link[2]);
                    }).set('target', target);
                    'step 3'
                    if (result.bool) {
                        var junling = result.links[0][2];
                        event.junling = junling;
                        game.log(player, '选择了', '#y' + get.translation(junling));
                        if (event.junling == 'minijieyue_junling1') {
                            player.chooseTarget('军令一：请选择' + get.translation(target) + '造成伤害的目标', true).set('ai', aim => {
                                var player = _status.event.player, target = _status.event.target;
                                return get.damageEffect(aim, target, player);
                            }).set('target', target);
                        }
                    }
                    'step 4'
                    if (event.junling == 'minijieyue_junling1') {
                        if (result.bool) event.aim = result.targets[0];
                        else {
                            event._result = { bool: false };
                            return;
                        }
                    }
                    var str = [
                        '对' + get.translation(event.aim) + '造成1点伤害',
                        '随机弃置一张手牌和装备牌',
                        '本回合不能回复体力',
                        '本回合不能使用或打出手牌且所有非锁定技失效',
                    ][parseInt(event.junling.slice('minijieyue_junling'.length)) - 1];
                    target.chooseBool('节钺：是否执行' + get.translation(event.junling) + '？', str).set('choice', function () {
                        switch (event.junling) {
                            case 'minijieyue_junling1':
                                return get.damageEffect(event.aim, target, target) >= 0;
                                break;
                            case 'minijieyue_junling2':
                                if (!target.countCards('he')) return true;
                                var cards1 = target.getCards('h', card => get.value(card) >= 7 && lib.filter.cardDiscardable(card, target));
                                var cards2 = target.getCards('e', card => get.value(card) >= 7 && lib.filter.cardDiscardable(card, target));
                                return cards1.length * 2 < target.countCards('h', card => lib.filter.cardDiscardable(card, target)) && cards2.length * 2 < target.countCards('e', card => lib.filter.cardDiscardable(card, target));
                                break;
                            case 'minijieyue_junling3': case 'minijieyue_junling4':
                                if (target.hp > 3) return true;
                                return !target.countCards('hes', card => {
                                    if (target.canSaveCard(card, target)) return true;
                                    if (event.junling == 'minijieyue_junling4' && (get.name(card) == 'wuxie' || get.name(card) == 'caochuanjiejian')) return true;
                                    return false;
                                });
                                break;
                            default:
                                return false;
                                break;
                        }
                    }());
                    'step 5'
                    if (result.bool) {
                        game.log(target, '#g选择执行', '#y' + get.translation(event.junling));
                        switch (event.junling) {
                            case 'minijieyue_junling1':
                                target.line(event.aim);
                                event.aim.damage(1, target);
                                break;
                            case 'minijieyue_junling2':
                                var cards = [];
                                var cards1 = target.getCards('h', card => lib.filter.cardDiscardable(card, target));
                                if (cards1.length) cards.push(cards1.randomGet());
                                var cards2 = target.getCards('he', card => get.type(card) == 'equip' && !cards.includes(card) && lib.filter.cardDiscardable(card, target));
                                if (cards2.length) cards.push(cards2.randomGet());
                                if (cards.length) target.discard(cards);
                                break;
                            case 'minijieyue_junling3':
                                target.addTempSkill('minijieyue_junling3');
                                break;
                            case 'minijieyue_junling4':
                                target.addTempSkill('minijieyue_junling4');
                                target.addTempSkill('fengyin');
                                break;
                        }
                        player.draw();
                    }
                    else {
                        target.chat('拒绝');
                        game.log(target, '#y拒绝执行', '#g' + get.translation(event.junling));
                        player.draw(3);
                        target.addTempSkill('minijieyue_damage');
                        target.addMark('minijieyue_damage', 1, false);
                    }
                    target.addExpose(0.15);
                },
                subSkill: {
                    checkh: {
                        charlotte: true,
                        global: 'minijieyue_check1',
                    },
                    checke: {
                        charlotte: true,
                        global: 'minijieyue_check2',
                    },
                    check1: {
                        mod: {
                            canBeDiscarded(card, player, target) {
                                if (player.hasSkill('minijieyue_checkh') && get.position(card) == 'h') return false;
                            },
                        },
                    },
                    check2: {
                        mod: {
                            canBeDiscarded(card, player, target) {
                                if (player.hasSkill('minijieyue_checke') && get.position(card) == 'e') return false;
                            },
                        },
                    },
                    junling3: {
                        charlotte: true,
                        mark: true,
                        intro: '令',
                        intro: { content: '不能回复体力' },
                        trigger: { player: 'recoverBefore' },
                        forced: true,
                        content() {
                            trigger.cancel();
                        },
                        ai: {
                            threaten: 10,
                            effect: {
                                target(card, player, target) {
                                    if (get.tag(card, 'recover')) return 'zeroplayertarget';
                                },
                            },
                        },
                    },
                    junling4: {
                        charlotte: true,
                        mark: true,
                        intro: '令',
                        intro: { content: '不能使用或打出手牌' },
                        trigger: { player: 'recoverBefore' },
                        mod: {
                            cardEnabled2(card) {
                                if (get.position(card) == 'h') return false;
                            },
                        },
                        ai: { threaten: 10 },
                    },
                    damage: {
                        charlotte: true,
                        onremove: true,
                        trigger: { player: 'damageBegin3' },
                        forced: true,
                        content() {
                            trigger.num += player.countMark('minijieyue_damage');
                        },
                        ai: { threaten: 10 },
                        intro: { content: '受到的伤害+#' },
                    },
                },
            },
            //乐进
            minixiaoguo: {
                audio: 'xiaoguo',
                trigger: { global: 'phaseJieshuBegin' },
                filter(event, player) {
                    return event.player.isIn() && event.player != player && player.countCards('he', card => {
                        if (_status.connectMode && get.position(card) == 'h') return true;
                        return lib.filter.cardDiscardable(card, player);
                    });
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseToDiscard(get.prompt2(event.skill, trigger.player), 'he').set('ai', card => {
                        return _status.event.eff - get.useful(card);
                    }, 'chooseonly').set('eff', (() => {
                        if (trigger.player.hasSkillTag('noe')) return get.attitude(_status.event.player, trigger.player);
                        return get.damageEffect(trigger.player, player, _status.event.player);
                    })()).forResult();
                },
                logTarget: 'player',
                async content(event, trigger, player) {
                    await player.discard(event.cards);
                    if (get.mode() !== 'identity' || player.identity !== 'nei') player.addExpose(0.15);
                    const result = await trigger.player.chooseToDiscard('he', '骁果：请选择一项', { type: 'equip' }).set('prompt2', ((source) => {
                        let target = get.translation(source);
                        let str = '①弃置一张装备牌，令' + target + '摸一张牌，直到你的下个结束阶段，' + target + '对你造成伤害时摸一张牌。';
                        str += '<br>②受到' + target + '对你造成的1点伤害，直到你的下个结束阶段，' + target + '对你使用【杀】造成的伤害+1。';
                        return '<span class="text center">' + str + '</span>';
                    })(player)).set('ai', card => {
                        if (_status.event.damage > 0) return 0;
                        if (_status.event.noe) return 12 - get.value(card);
                        return 2 * _status.event.damage - get.value(card);
                    }).set('damage', get.damageEffect(trigger.player, player, trigger.player)).set('noe', trigger.player.hasSkillTag('noe')).forResult();
                    if (result?.bool) {
                        await player.draw();
                        player.addSkill('minixiaoguo_buff1');
                        player.markAuto('minixiaoguo_buff1', [trigger.player]);
                    }
                    else {
                        await trigger.player.damage();
                        player.addSkill('minixiaoguo_buff2');
                        player.markAuto('minixiaoguo_buff2', [trigger.player]);
                    }
                    player.when({ global: 'phaseJieshuBefore' })
                        .filter(evt => player.getStorage('minixiaoguo_buff1').concat(player.getStorage('minixiaoguo_buff2')).includes(evt.player))
                        .then(() => {
                            const target = trigger.player;
                            for (const skill of ['minixiaoguo_buff1', 'minixiaoguo_buff2']) {
                                if (player.getStorage(skill).includes(target)) {
                                    player.unmarkAuto(skill, [target]);
                                    if (!player.getStorage(skill).length) player.removeSkill(skill);
                                }
                            }
                        });
                },
                subSkill: {
                    buff1: {
                        charlotte: true,
                        onremove: true,
                        marktext: '骁',
                        intro: { content: '对$造成伤害时摸一张牌' },
                        trigger: { source: 'damageBegin2' },
                        filter(event, player) {
                            return player.getStorage('minixiaoguo_buff1').includes(event.player);
                        },
                        forced: true,
                        logTarget: 'player',
                        content() {
                            player.draw();
                        },
                    },
                    buff2: {
                        charlotte: true,
                        onremove: true,
                        marktext: '果',
                        intro: { content: '使用【杀】对$造成的伤害+1' },
                        trigger: { player: 'useCardToTargeted' },
                        filter(event, player) {
                            return event.card.name == 'sha' && player.getStorage('minixiaoguo_buff2').includes(event.target);
                        },
                        forced: true,
                        logTarget: 'target',
                        content() {
                            var id = trigger.target.playerid;
                            var map = trigger.getParent().customArgs;
                            if (!map[id]) map[id] = {};
                            if (typeof map[id].extraDamage != 'number') map[id].extraDamage = 0;
                            map[id].extraDamage++;
                        },
                    },
                },
            },
            //蒋干
            miniweicheng: {
                audio: 'weicheng',
                inherit: 'weicheng',
                filter(event, player) {
                    if (player.getHp() < player.countCards('h')) return false;
                    if (event.name == 'loseAsync') {
                        if (event.type != 'gain') return false;
                        var cards = event.getl(player).hs;
                        return game.hasPlayer(function (current) {
                            if (current == player) return false;
                            var cardsx = event.getg(current);
                            for (var i of cardsx) {
                                if (cards.includes(i)) return true;
                            }
                            return false;
                        });
                    }
                    if (event.player == player) return false;
                    var evt = event.getl(player);
                    return evt?.hs?.length > 0;
                },
            },
            minidaoshu: {
                audio: 'daoshu',
                inherit: 'daoshu',
                filter(event, player) {
                    return !player.hasSkill('minidaoshu_used');
                },
                async content(event, trigger, player) {
                    const target = event.target;
                    const result = await player.chooseControl(lib.suit).set('prompt', '请选择一个花色').set('ai', () => lib.suit.randomGet()).forResult();
                    if (!result?.control) return;
                    const suit = result.control;
                    player.popup(suit + 2);
                    game.log(player, '选择了', event.suit + 2);
                    const result2 = await player.gainPlayerCard(target, true, 'h', 'visibleMove').forResult();
                    if (result2?.cards?.length) {
                        const suit2 = get.suit(result2.cards[0]);
                        if (suit2 == suit) target.damage();
                        else {
                            player.addTempSkill('minidaoshu_used', 'phaseUseEnd');
                            if (player.countCards('h')) {
                                const result = await player.chooseCardTarget({
                                    prompt: '盗书：将一张手牌交给一名其他角色',
                                    filterCard: true,
                                    position: 'h',
                                    forced: true,
                                    filterTarget: lib.filter.notMe,
                                    ai1(card) {
                                        if (card.name == 'du') return 10;
                                        var player = _status.event.player;
                                        if (!game.hasPlayer(current => {
                                            return get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                                        })) return 0;
                                        return 1 / Math.max(0.1, get.value(card));
                                    },
                                    ai2(target) {
                                        var player = _status.event.player, att = get.attitude(player, target);
                                        if (ui.selected.cards[0].name == 'du') return -att;
                                        if (target.hasSkillTag('nogain')) att /= 6;
                                        return att;
                                    },
                                }).forResult();
                                if (result?.targets?.length && result.cards?.length) {
                                    player.line(result.targets[0]);
                                    await result.targets[0].gain(result.cards, player, 'giveAuto');
                                }
                            }
                        }
                    }
                },
            },
            minishefu: {
                audio: 'shefu',
                trigger: { player: ['phaseJieshuBegin', 'damageEnd'] },
                filter(event, player) {
                    return player.countCards('he');
                },
                async cost(event, trigger, player) {
                    const list = get.inpileVCardList(info => {
                        if (info[2] == 'sha' && info[3]) return false;
                        return ['basic', 'trick'].includes(get.type2(info[2]));
                    });
                    let dialog = [get.prompt('minishefu'), '<div class="text center">选择一个牌名和一张牌组成「伏兵」</div>'];
                    dialog.addArray(['<div class="text center">牌名选择</div>', [list, 'vcard']]);
                    if (player.countCards('h')) dialog.addArray(['<div class="text center">你的手牌</div>', player.getCards('h')]);
                    if (player.countCards('e')) dialog.addArray(['<div class="text center">你的装备</div>', player.getCards('e')]);
                    const result = await player.chooseButton(dialog, 2).set('ai', button => {
                        const player = get.event().player;
                        if (!get.owner(button.link)) {
                            switch (button.link[2]) {
                                case 'sha': return 5 + Math.random();
                                case 'tao': return 4 + Math.random();
                                case 'lebu': return 3 + Math.random();
                                case 'shan': return 4.5 + Math.random();
                                case 'wuzhong': return 4 + Math.random();
                                case 'shunshou': return 3 + Math.random();
                                case 'nanman': return 2 + Math.random();
                                case 'wanjian': return 2 + Math.random();
                                default: return Math.random();
                            }
                        }
                        return 7.5 - get.value(button.link);
                    }).set('filterButton', button => {
                        const player = get.event().player;
                        if (!get.owner(button.link) && player.getStorage('minishefu').map(i => i[1]).includes(button.link[2])) return false;
                        return !ui.selected.buttons.length || get.owner(ui.selected.buttons[0].link) != get.owner(button.link);
                    }).forResult();
                    event.result = {
                        bool: result?.bool,
                        cost_data: result?.links,
                    }
                },
                async content(event, trigger, player) {
                    let fjks = event.cost_data.slice();//伏击狂神[doge]
                    if (get.owner(fjks[0])) fjks.reverse();
                    const next = player.addToExpansion([fjks[1]], player, 'give');
                    next.gaintag.add(event.name);
                    await next;
                    player.markAuto(event.name, [[[get.translation(fjks[0][2]), '', fjks[1].name, fjks[1].nature], fjks[0][2], fjks[1]]]);
                },
                onremove(player, skill) {
                    const cards = player.getExpansions(skill);
                    if (cards.length) player.loseToDiscardpile(cards);
                },
                marktext: '伏',
                intro: {
                    name: '伏兵',
                    content: 'expansion',
                    markcount: 'expansion',
                    mark(dialog, content, player) {
                        if (content?.length) {
                            if (player.isUnderControl(true)) dialog.addSmall([content.map(i => i[0]), 'vcard']);
                            else dialog.addAuto(player.getExpansions('minishefu'));
                        }
                    },
                },
                ai: { threaten: 2 },
                group: 'minishefu_kanpo',
                subSkill: {
                    kanpo: {
                        audio: 'shefu',
                        trigger: { global: 'useCard' },
                        filter(event, player) {
                            return _status.currentPhase != player && event.player != player && player.getStorage('minishefu').some(i => i[1] == event.card.name) && !event.all_excluded;
                        },
                        check(event, player) {
                            return get.info('sbkanpo').subSkill.kanpo.check(event, player);
                        },
                        prompt2(event, player) {
                            return '令' + get.translation(event.card) + '无效' + (event.player == _status.currentPhase ? ('，然后本回合' + get.translation(event.player) + '所有技能失效') : '');
                        },
                        logTarget: 'player',
                        content() {
                            const removes = player.getStorage('minishefu').filter(i => i[1] == trigger.card.name);
                            const cards = removes.map(i => i[2]);
                            player.unmarkAuto('minishefu', removes);
                            player.loseToDiscardpile(cards);
                            trigger.targets.length = 0;
                            trigger.all_excluded = true;
                            if (trigger.player == _status.currentPhase) trigger.player.addTempSkill('baiban');
                        },
                        ai: { expose: 0.3 },
                    },
                },
            },
            minibenyu: {
                audio: 'benyu',
                trigger: { player: 'damageEnd' },
                filter(event, player) {
                    const target = event.source;
                    if (!target || !target.isIn()) return false;
                    return player.countCards('h') < Math.min(5, target.countCards('h')) || player.countCards('h');
                },
                direct: true,
                async content(event, trigger, player) {
                    const target = trigger.source;
                    const num = Math.min(5, target.countCards('h')) - player.countCards('h');
                    let choice = [], choiceList = [];
                    if (num > 0) {
                        choice.push('摸牌');
                        choiceList.push('摸' + get.cnNumber(num) + '张牌');
                    }
                    if (player.countDiscardableCards(player, 'h')) {
                        choice.push('弃牌');
                        choiceList.push('弃置一张手牌，对' + get.translation(target) + '造成1点伤害');
                    }
                    const result = await player.chooseControl(choice, 'cancel2')
                        .set('prompt', get.prompt('benyu', target)).set('choiceList', choiceList)
                        .set('ai', () => {
                            const player = get.event().player, target = get.event().target;
                            const num = get.event().num, controls = get.event().controls.filter(i => i != 'cancel2');
                            const def = get.damageEffect(target, player, player);
                            if (controls.length == 1) {
                                if (controls[0] == '摸牌') return '摸牌';
                                return def > 0 ? '弃牌' : 'cancel2';
                            }
                            return get.effect(player, { name: 'draw' }, player, player) * num > def ? '摸牌' : '弃牌';
                        }).set('num', num).set('target', target).forResult();
                    if (result?.control != 'cancel2') {
                        const { control } = result;
                        if (control == '摸牌') {
                            player.logSkill('minibenyu', target);
                            await player.draw(num);
                        }
                        else {
                            await player.chooseToDiscard('h', true).set('logSkill', ['minibenyu', target]);
                            await target.damage();
                        }
                    }
                },
            },
            //徐晃
            minisbduanliang: {
                audio: 'sbduanliang',
                enable: 'phaseUse',
                usable: 2,
                logAudio: () => 1,
                filterTarget: lib.filter.notMe,
                async content(event, trigger, player) {
                    const target = event.target;
                    player.removeGaintag('minisbduanliang_tag');
                    await player.draw().set('gaintag', ['minisbduanliang_tag']);
                    const card = player.getCards('he', card => card.hasGaintag('minisbduanliang_tag'))[0];
                    const result = await player.chooseToDuiben(target).set('namelist', [
                        '固守城池', '突出重围', '围城断粮', '擂鼓进军'
                    ]).set('ai', button => {
                        const source = _status.event.getParent().player, target = _status.event.getParent().target;
                        if (get.effect(target, { name: 'juedou' }, source, source) >= 10 && button.link[2] == 'db_def2' && Math.random() < 0.5) return 10;
                        return 1 + Math.random();
                    }).set('sourceSkill', 'sbduanliang').forResult();
                    if (result?.bool) {
                        if (result.player == 'db_def1') {
                            if (target.hasJudge('bingliang')) await player.gainPlayerCard(target, 'he', true);
                            else if (card && player.canUse(get.autoViewAs({ name: 'bingliang' }, [card]), target, false)) await player.useCard({ name: 'bingliang' }, target, [card], false);
                        }
                        else {
                            const juedou = { name: 'juedou', isCard: true };
                            if (player.canUse(juedou, target, false)) await player.useCard(juedou, target, false);
                        }
                    }
                },
                get ai() {
                    return get.info('sbduanliang').ai || {};
                },
                init() {
                    if (!_status.miniMouYi) {
                        _status.miniMouYi = true;
                        lib.skill.minisbtieji.initMouYi();
                    }
                },
            },
            //阮瑀
            minixingzuo: {
                audio: 'xingzuo',
                inherit: 'xingzuo',
                async content(event, trigger, player) {
                    player.addTempSkill('minixingzuo_effect');
                    const next = game.cardsGotoOrdering(get.bottomCards(3));
                    await next;
                    const result = await (() => {
                        const cards = next.cards, next2 = player.chooseToMove('兴作：将三张牌置于牌堆底');
                        const list = [['牌堆底', cards]], hs = player.getCards('h');
                        if (hs.length) {
                            list.push(['手牌', hs]);
                            next2.set('filterMove', (_, to) => typeof to !== 'number');
                        }
                        next2.set('list', list);
                        next2.set('processAI', list => {
                            const player = get.player(), getv = button => {
                                if (button.name == 'sha' && allcards.filter(function (card) {
                                    return card.name == 'sha' && !cards.filter(function () {
                                        return button == card;
                                    }).length;
                                }).length > player.getCardUsable({ name: 'sha' })) return 10;
                                return -player.getUseValue(button, player);
                            };
                            let allcards = list[0][1].slice(0), cards = [];
                            if (list.length > 1) allcards = allcards.concat(list[1][1]);
                            let canchoose = allcards.slice(0);
                            while (cards.length < 3) {
                                canchoose.sort((a, b) => getv(b) - getv(a));
                                cards.push(canchoose.shift());
                            }
                            return [cards, canchoose];
                        });
                        return next2;
                    })().forResult();
                    if (result.bool) {
                        event.forceDie = true;
                        const hs = player.getCards('h'), cards = result.moved[0];
                        player.storage.minixingzuo_effect = cards;
                        const lose = cards.filter(i => hs.includes(i)), gain = next.cards.slice().removeArray(cards.filter(i => !hs.includes(i)));
                        if (lose.length) await player.lose(lose, ui.cardPile);
                        if (gain.length) await player.gain(gain, 'draw');
                        for (const i of cards) {
                            if (!(('hejsdx').includes(get.position(i, true)))) {
                                i.fix();
                                ui.cardPile.appendChild(i);
                            }
                        }
                        game.updateRoundNumber();
                    }
                },
                subSkill: {
                    effect: {
                        audio: 'xingzuo',
                        inherit: 'xingzuo2',
                        content() {
                            'step 0'
                            player.chooseTarget(function (card, player, target) {
                                return target.countCards('h') > 0;
                            }, '兴作：是否令一名角色将其手牌与牌堆底的三张牌替换？').set('ai', function (target) {
                                var player = _status.event.player, att = get.attitude(player, target), hs = target.getCards('h'), num = hs.length;
                                var getv = function (list, target) {
                                    var num = 0;
                                    for (var i of list) num += get.value(i, target);
                                    return num;
                                }, val = getv(hs, target) - getv(player.storage.minixingzuo_effect, target);
                                if (num < 3) return att * Math.sqrt(Math.max(0, -val)) * 1.5;
                                if (num == 3) return -att * Math.sqrt(Math.max(0, val));
                                return -att * Math.sqrt(Math.max(0, val));
                            });
                            'step 1'
                            if (result.bool) {
                                var target = result.targets[0];
                                player.logSkill('minixingzuo', target);
                                var cards = get.bottomCards(3);
                                game.cardsGotoOrdering(cards);
                                var hs = target.getCards('h');
                                target.lose(hs, ui.cardPile);
                                target.gain(cards, 'draw');
                            }
                            else event.finish();
                            'step 2'
                            game.updateRoundNumber();
                        },
                    },
                },
            },
            //羊祜
            minideshao: {
                audio: 'dcdeshao',
                inherit: 'dcdeshao',
                filter(event, player) {
                    return get.color(event.card) == 'black';
                },
                check: () => true,
                async content(event, trigger, player) {
                    await player.draw();
                    const target = trigger.player;
                    if (player.countCards('h') < target.countCards('h') && target.countCards('he') > 0) {
                        await player.discardPlayerCard(target, 'he');
                        player.addExpose(0.2);
                    }
                },
            },
            //阎柔
            minixiangshu: {
                audio: 'xiangshu',
                inherit: 'xiangshu',
                async content(event, trigger, player) {
                    const num = Math.min(5, player.getAllHistory('sourceDamage').reduce((sum, evt) => sum + evt.num, 0));
                    const result = await player.chooseTarget(get.prompt('minixiangshu'), '令一名已受伤角色回复' + event.num + '点体力并摸' + get.cnNumber(event.num) + '张牌', (card, player, target) => {
                        return target.isDamaged();
                    }).set('ai', target => {
                        const num = get.event().getParent().num, player = get.event().player, att = get.attitude(player, target);
                        if (att > 0 && num >= Math.min(player.hp, 2)) return att * Math.sqrt(target.getDamagedHp());
                        return 0;
                    }).set('num', num).forResult();
                    if (result.bool) {
                        const target = result.targets[0];
                        player.awakenSkill('minixiangshu');
                        await player.logSkill('minixiangshu', target);
                        if (player != target) player.addExpose(0.2);
                        await target.recover(num);
                        await target.draw(num);
                    }
                },
            },
            //王双
            minizhuilie: {
                audio: 'spzhuilie',
                inherit: 'spzhuilie',
                async content(event, trigger, player) {
                    if (trigger.getParent().addCount !== false) {
                        trigger.getParent().addCount = false;
                        const stat = player.getStat();
                        if (stat?.card?.sha) stat.card.sha--;
                    }
                    const next = player.judge(card => {
                        return ['equip1', 'equip4', 'equip3', 'equip6'].includes(get.subtype(card)) || get.type2(card) == 'trick' ? 6 : -6;
                    });
                    next.judge2 = result => result.bool == false;
                    const { card } = await next.forResult();
                    if (['equip1', 'equip4', 'equip3', 'equip6'].includes(get.subtype(card))) {
                        const map = trigger.customArgs;
                        const id = trigger.target.playerid;
                        if (!map[id]) map[id] = {};
                        if (typeof map[id].extraDamage != 'number') map[id].extraDamage = 0;
                        map[id].extraDamage += trigger.target.hp - 1;
                    }
                    else if (get.type2(card) == 'trick') await player.gain(card, 'gain2');
                    else if (get.type(card) == 'basic') await player.loseHp();
                },
            },
            //陈琳
            minisongci: {
                audio: 'songci',
                inherit: 'songci',
                filter(event, player) {
                    return game.hasPlayer(current => {
                        return !player.getStorage("minisongci").includes(current);
                    });
                },
                filterTarget(card, player, target) {
                    return !player.getStorage("minisongci").includes(target);
                },
                async content(event, trigger, player) {
                    const target = event.target, goon = target.countCards("h") > target.getHp();
                    player.markAuto("minisongci", [target]);
                    if (goon) await target.chooseToDiscard(2, "he", true);
                    else await target.draw(2);
                },
                group: 'minisongci_draw',
                subSkill: {
                    draw: {
                        inherit: 'songci_draw',
                        locked: false,
                        filter: () => true,
                    },
                },
            },
            //刘晔
            minipoyuan: {
                audio: 'dcpoyuan',
                trigger: {
                    global: 'phaseBefore',
                    player: ['phaseZhunbeiBegin', 'enterGame'],
                },
                filter(event, player) {
                    if (event.name == 'phase' && game.phaseNumber > 0) return false;
                    if (player.getEquip('minipiliche')) {
                        return game.hasPlayer(current => {
                            return current != player && current.countDiscardableCards(player, 'he') > 0;
                        });
                    }
                    return player.hasEquipableSlot(4);
                },
                frequent: true,
                async cost(event, trigger, player) {
                    if (player.getEquip('minipiliche')) {
                        event.result = await player.chooseTarget(get.prompt('minipoyuan'), '弃置一名其他角色的至多两张牌', (card, player, target) => {
                            return target != player && target.countDiscardableCards(player, 'he') > 0;
                        }).set('ai', target => {
                            var player = _status.event.player, cards = target.getDiscardableCards(player, 'he');
                            var att = get.attitude(player, target);
                            if (att < 0 && target.hasSkillTag('noe')) att /= 2;
                            var zheng = [], fu = [];
                            for (var i of cards) {
                                var val = get.value(i, target);
                                if (val > 0) zheng.push(i);
                                else fu.push(i);
                            }
                            zheng.sort((a, b) => get.value(b, target) - get.value(a, target));
                            fu.sort((a, b) => get.value(b, target) - get.value(a, target));
                            zheng = zheng.slice(0, 2);
                            fu = fu.slice(0, 2);
                            var eff1 = 0, eff2 = 0;
                            for (var i of zheng) eff1 += get.value(i, target);
                            for (var i of fu) {
                                if (get.position(i) == 'e') eff2 += (1 - get.value(i, target));
                            }
                            return -att * Math.max(eff1, eff2);
                        }).forResult();
                    }
                    else {
                        event.result = await player.chooseBool(get.prompt('minipoyuan'), '装备一张【霹雳投石车】').set('frequentSkill', 'minipoyuan').forResult();
                    }
                },
                content() {
                    if (event.targets?.length) {
                        const target = event.targets[0];
                        player.discardPlayerCard(target, true, 'he', [1, 2]);
                    }
                    else {
                        const card = game.createCard('minipiliche', 'diamond', 9);
                        player.$gain2(card);
                        game.delayx();
                        player.equip(card);
                    }
                },
            },
            minipiliche: {
                inherit: 'pilitoushiche',
            },
            minihuiqi: {
                audio: 'olhuiqi',
                inherit: 'olhuiqi',
                derivation: 'minixieju',
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    if (player.isDamaged()) await player.recover();
                    await player.addSkills('minixieju');
                },
            },
            minixieju: {
                audio: 'olxieju',
                inherit: 'olxieju',
                filterTarget(card, player, target) {
                    return get.event().olxieju.includes(target);
                },
                async content(event, trigger, player) {
                    const next = event.target.chooseToUse();
                    next.set('openskilldialog', '偕举：是否将一张黑色牌当作【杀】使用？');
                    next.set('norestore', true);
                    next.set('_backupevent', event.name + '_backup');
                    next.set('custom', {
                        add: {},
                        replace: { window() { } },
                    });
                    next.backup(event.name + '_backup');
                    await next;
                },
                subSkill: {
                    backup: {
                        filterCard(card) {
                            return get.itemtype(card) == 'card' && get.color(card) == 'black';
                        },
                        position: 'hes',
                        viewAs: { name: 'sha' },
                        check(card) {
                            return 7 - get.value(card);
                        },
                    }
                },
            },
            //毌丘俭
            minizhengrong: {
                audio: 'drlt_zhenrong',
                inherit: 'drlt_zhenrong',
                filter(event, player) {
                    return event.player !== player && event.player.countCards('he') && event.player.countCards('h') > player.countCards('h');
                },
                onremove(player) {
                    const cards = player.getExpansions('drlt_zhenrong');
                    if (cards.length) player.loseToDiscardpile(cards);
                },
            },
            minihongju: {
                audio: 'drlt_hongju',
                inherit: 'drlt_hongju',
                async content(event, trigger, player) {
                    'step 0'
                    player.awakenSkill(event.name);
                    var cards = player.getExpansions('drlt_zhenrong');
                    if (cards.length && player.countCards('h')) {
                        const next = player.chooseToMove('征荣：是否交换“荣”和手牌？');
                        next.set('list', [
                            [get.translation(player) + '（你）的“荣”', cards],
                            ['手牌区', player.getCards('h')],
                        ]);
                        next.set('filterMove', (from, to) => typeof to != 'number');
                        next.set('processAI', list => {
                            var player = _status.event.player, cards = list[0][1].concat(list[1][1]).sort((a, b) => {
                                return get.value(a) - get.value(b);
                            }), cards2 = cards.splice(0, player.getExpansions('drlt_zhenrong').length);
                            return [cards2, cards];
                        });
                        const result = await next.forResult();
                        if (result.bool) {
                            var pushs = result.moved[0], gains = result.moved[1];
                            pushs.removeArray(player.getExpansions('drlt_zhenrong'));
                            gains.removeArray(player.getCards('h'));
                            if (pushs.length && pushs.length === gains.length) {
                                const next2 = player.addToExpansion(pushs, player, 'give');
                                next2.gaintag.add('drlt_zhenrong');
                                await next2;
                                await player.gain(gains, 'gain2');
                            }
                        }
                    }
                    await player.addSkills('drlt_qingce');
                },
            },
            //管辂
            minibusuan: {
                audio: 'busuan',
                inherit: 'busuan',
                filterTarget: true,
                async content(event, trigger, player) {
                    const { target } = event;
                    const list = get.inpileVCardList(info => {
                        return info[0] != 'basic';
                    });
                    if (!list.length) return;
                    const result = await player.chooseButton(['选择至多两种牌', [list, 'vcard']], true, [1, 2]).set('ai', function (button) {
                        const player = get.player(), target = get.event().getParent().target;
                        const card = { name: button.link[2], nature: button.link[3] };
                        if (get.type(card) == 'basic' || !target.hasUseTarget(card)) return false;
                        return get.attitude(player, target) * (target.getUseValue(card) - 0.1);
                    }).forResult();
                    if (result?.links?.length) {
                        target.addSkill(event.name + '_effect');
                        target.storage[event.name + '_effect'] = result.links.slice(0);
                    }
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        mark: true,
                        intro: {
                            mark(dialog, content, player) {
                                if (content?.length) dialog.add([content, 'vcard']);
                            },
                        },
                        trigger: { player: 'drawBefore' },
                        filter(event, player) {
                            return event.getParent().name == 'phaseDraw';
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const list = player.storage[event.name], cards = [];
                            for (let i = 0; i < Math.min(trigger.num, list.length); i++) {
                                const card = get.cardPile(cardx => {
                                    if (cards.includes(cardx)) return false;
                                    if (cardx.name != list[Math.min(i, list.length - 1)][2]) return false;
                                    if (get.nature(cardx, false) != list[Math.min(i, list.length - 1)][3]) return false;
                                    return true;
                                });
                                if (card) {
                                    player.storage[event.name].splice(i--, 1);
                                    trigger.num--;
                                    cards.push(card);
                                }
                            }
                            if (cards.length) await player.gain(cards, 'gain2', 'log');
                            if (!trigger.num) trigger.cancel();
                            if (!list.length) player.removeSkill(event.name);
                        },
                    }
                }
            },
            minimingjie: {
                audio: 'mingjie',
                trigger: { player: 'phaseJieshuBegin' },
                frequent: true,
                async content(event, trigger, player) {
                    let cards = [], count = 0;
                    while (true) {
                        const result = await player.draw().forResult();
                        if (get.itemtype(result) != 'cards') return;
                        count += result.length;
                        cards.addArray(result)
                        if (get.color(result) == 'black' || count > 2) break;
                        const { bool } = await player.chooseBool('是否继续发动【命戒】？').set('choice', player.isHealthy() || (lib.skill.mingjie.check() && get.recoverEffect(player, player, player) > 0)).forResult();
                        if (!bool) break;
                    }
                    if (cards.every(card => get.color(card) == 'red') && player.isDamaged()) await player.recover();
                },
            },
            //郑浑
            miniqiangzhi: {
                audio: 'dcqiangzhi',
                inherit: 'dcqiangzhi',
                async content(event, trigger, player) {
                    let { target } = event, discarded = [], num = 0;
                    while (num < 3 && get.info(event.name).filterTarget(null, player, target)) {
                        const result = await player.chooseTarget('强峙：弃置你或' + get.translation(target) + '的一张牌', (card, player, target) => {
                            if (!target.countDiscardableCards(player, 'he')) return false;
                            return target === player || target === get.event().getParent().target;
                        }, '当前进度：' + (num + 1) + '/3', true).set('ai', aim => {
                            const { player, damage } = get.event(), { target } = get.event().getParent();
                            if (aim === player) {
                                if (damage) return 15 - Math.min(...player.getDiscardableCards(player, 'he').map(card => get.value(card)));
                                if (player.hp >= 3 || get.damageEffect(player, target, player) >= 0 || player.hasSkill('dcpitian') && player.getHandcardLimit() - player.countCards('h') >= 1 && player.hp > 1) return 0;
                                return 10 - Math.min(...player.getDiscardableCards(player, 'he').map(card => get.value(card)));
                            }
                            else {
                                if (damage) return 0;
                                return -(get.sgnAttitude(player, target) || 1) * Math.max(...target.getDiscardableCards(player, 'he').map(card => get.value(card)));
                            }
                        }).set('damage', (() => {
                            if (discarded.includes(target)) return false;
                            return get.damageEffect(target, player, player) > 10 && player.countCards('he', card => {
                                return lib.filter.canBeDiscarded(card, player, player) && get.value(card) < 5;
                            }) >= 3;
                        })()).forResult();
                        if (result?.bool && result.targets?.length) {
                            const [discarder] = result.targets;
                            discarded.add(discarder);
                            player.line(discarder);
                            const resultx = await player.discardPlayerCard(discarder, 'he', true).forResult();
                            if (resultx?.bool && resultx.cards?.length) num += resultx.cards.length;
                            else break;
                        }
                        else break;
                    }
                    if (discarded.length === 1 && [player, target].every(i => i.isIn())) {
                        const damaged = [player, target].removeArray(discarded)[0];
                        discarded = discarded[0];
                        discarded.line(damaged);
                        await damaged.damage(discarded);
                    }
                },
            },
            //陈泰
            minijiuxian: {
                audio: 'dcctjiuxian',
                inherit: 'dcctjiuxian',
                selectCard() {
                    const player = get.player();
                    return [1, Math.ceil(player.countCards('h') / 2)];
                },
            },
            //韩史
            miniyonglve: {
                audio: 'yonglve',
                trigger: { global: 'phaseJudgeBegin' },
                filter(event, player) {
                    return event.player !== player && event.player.countCards('j') > 0;
                },
                async cost(event, trigger, player) {
                    const target = trigger.player;
                    let list = [
                        get.prompt2('miniyonglve', target),
                        '<div class="text center">' + get.translation(target) + '的判定牌</div>',
                        target.getCards('j'),
                    ];
                    if (player.countCards('h')) {
                        list.addArray([
                            '<div class="text center">你的手牌</div>',
                            player.getCards('h'),
                        ]);
                    }
                    if (player.countCards('e')) {
                        list.addArray([
                            '<div class="text center">你的装备牌</div>',
                            player.getCards('he'),
                        ]);
                    }
                    event.result = await player.chooseButton(list).set('filterButton', button => {
                        return lib.filter.canBeDiscarded(button.link, get.player(), get.owner(button.link));
                    }).set('ai', button => {
                        const player = get.player(), trigger = get.event().getTrigger();
                        let att = get.attitude(player, trigger.player), nh = trigger.player.countCards('h');
                        let eff = get.effect(trigger.player, { name: 'sha', isCard: true }, player, player);
                        if (player.inRange(trigger.player) || !player.canUse({ name: 'sha', isCard: true }, trigger.player, false)) eff = 0;
                        if (get.owner(button.link) === trigger.player) {
                            const name = button.link.viewAs || button.link.name;
                            if (att > 0 && eff >= 0) return 10;
                            if (att >= 0 && eff > 0) return 10;
                            if (att > 0 && (trigger.player.getHp() >= 3 || trigger.player.hasSkillTag('freeShan', false, {
                                player: _status.event.player,
                                card: new lib.element.VCard({ name: 'sha', isCard: true })
                            }) || trigger.player.countCards('h', 'shan'))) {
                                if (name == 'lebu' && nh > trigger.player.hp) return 10;
                                if (name == 'bingliang' && nh < trigger.player.hp) return 10;
                            }
                            return 0;
                        }
                        else {
                            if (player.inRange(trigger.player)) return get.info('zhiheng').check(button.link);
                            else if (player.canUse({ name: 'sha', isCard: true }, trigger.player, false)) return eff;
                            else return 0;
                        }
                    }).forResult();
                    event.result.cards = event.result?.links;
                },
                logTarget: 'player',
                async content(event, trigger, player) {
                    const [card] = event.cards;
                    await get.owner(card).discard(event.cards).set('discarder', player);
                    if (!player.inRange(trigger.player)) {
                        if (player.canUse({ name: 'sha', isCard: true }, trigger.player, false)) {
                            await player.useCard({ name: 'sha', isCard: true }, trigger.player);
                        }
                    }
                    else await player.draw();
                },
            },
            //谋甄姬
            minisbluoshen: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    player: 'loseAfter',
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                },
                filter(event, player) {
                    if (player.countCards('h', { color: 'red' })) return false;
                    const evt = event.getl(player);
                    return evt?.hs?.some(card => get.color(card) == 'red');
                },
                frequent: true,
                async content(event, trigger, player) {
                    while (true) {
                        const card = get.cards()[0];
                        await game.cardsGotoOrdering(card);
                        await player.showCards(card, get.translation(player) + '发动了【洛神】');
                        const color = get.color(card);
                        if (color == 'red') {
                            await player.gain(card, 'gain2');
                            break;
                        }
                        else if (color == 'black' && player.hasUseTarget(card)) await player.chooseUseTarget(card, false);
                    }
                },
            },
            minisbqingguo: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                usable: 2,
                filterCard: { color: 'red' },
                filterTarget: lib.filter.notMe,
                discard: false,
                lose: false,
                delay: false,
                check(card) {
                    return 6.5 - get.value(card);
                },
                async content(event, trigger, player) {
                    const { cards, target } = event;
                    await player.give(cards, target);
                    if (!target.countCards('he', { color: 'black' })) return;
                    await target.chooseToGive(player, 'he', { color: 'black' }, true);
                },
                ai: {
                    order: 10,
                    result: {
                        target(player, target) {
                            if (target.hasSkillTag('nogain')) return 0;
                            if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') {
                                if (target.hasSkillTag('nodu')) return 0;
                                return -10;
                            }
                            const att = get.attitude(player, target);
                            if (att > 0) return 1;
                            if (target.countCards('he', { color: 'black' }) && player.hasSkill('minisbluoshen')) return -1;
                            return 0;
                        },
                    }
                },
                group: 'minisbqingguo_effect',
                subSkill: {
                    effect: {
                        audio: 'minisbqingguo',
                        trigger: { target: 'useCardToTarget' },
                        filter(event, player) {
                            const { player: target, card } = event;
                            if (player == target) return false;
                            return (get.type(card) == 'trick' || card.name == 'sha') && player.hasCard(card => {
                                if (_status.connectMode) return true;
                                return get.color(card) == 'black' && lib.filter.cardDiscardable(card, player);
                            }, 'he');
                        },
                        async cost(event, trigger, player) {
                            event.result = await player.chooseToDiscard(get.prompt(event.skill), `弃置一张黑色牌令${get.translation(trigger.card)}对你无效`, (card, player) => {
                                return get.color(card) == 'black';
                            }, 'chooseonly', 'he').set('ai', card => {
                                const { goon } = get.event();
                                if (goon) return 7 - get.value(card);
                                return 0;
                            }).set('goon', get.effect(player, trigger.card, trigger.player, player) < 0).forResult();
                        },
                        async content(event, trigger, player) {
                            await player.discard(event.cards);
                            trigger.excluded.add(player);
                        },
                    }
                }
            },
            //司马朗
            miniquji: {
                audio: 'quji',
                inherit: 'quji',
                filter(event, player) {
                    return game.hasPlayer(current => current.isDamaged());
                },
                filterCard: lib.filter.cardRecastable,
                selectCard() {
                    const player = get.player();
                    return player.getDamagedHp() + 1;
                },
                check(card) {
                    return 6.5 - get.value(card);
                },
                multitarget: true,
                multiline: true,
                discard: false,
                lose: false,
                delay: false,
                async content(event, trigger, player) {
                    const { cards, targets } = event;
                    await player.recast(cards);
                    for (const target of targets.sortBySeat()) {
                        if (target.isDamaged()) await target.recover();
                    }
                    if (targets.some(target => target.isDamaged())) await game.asyncDraw(targets.filter(target => target.isDamaged()).sortBySeat())
                },
            },
            //张恭
            miniqianxin: {
                audio: 'xinfu_qianxin',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h') && game.hasPlayer(target => target !== player);
                },
                usable: 2,
                filterCard: true,
                filterTarget: lib.filter.notMe,
                check(card) {
                    return 6 - get.value(card);
                },
                discard: false,
                lose: false,
                delay: false,
                content() {
                    target.addSkill('miniqianxin_effect');
                    target.storage.miniqianxin_effect.push([cards[0], player]);
                    player.give(cards, target).gaintag.add('miniqianxin_effect');
                },
                ai: {
                    order: 1,
                    result: {
                        player(player, target) {
                            return 2 + Math.sign(get.attitude(player, target));
                        },
                    },
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        init(player, skill) {
                            if (!player.storage[skill]) player.storage[skill] = [];
                        },
                        onremove: true,
                        audio: 'miniqianxin',
                        trigger: { player: 'phaseZhunbeiBegin' },
                        getIndex(event, player) {
                            const list = player.storage.miniqianxin_effect;
                            return Array.isArray(list) ? list : false;
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const list = event.indexedData;
                            player.storage[event.name].remove(list);
                            if (!player.storage[event.name].length) player.removeSkill(event.name);
                            const [card, source] = list;
                            if (source.isIn() && player.getCards('h').includes(card)) {
                                source.logSkill(event.name, player);
                                const result = await player.chooseControl().set('choiceList', [
                                    '令' + get.translation(source) + '摸两张牌',
                                    '令自己本回合的手牌上限-2',
                                ]).set('prompt', get.translation(source) + '发动了【遣信】，请选择一项').set('ai', function () {
                                    const { player, source } = get.event();
                                    if (get.attitude(player, source) > 0) return 0;
                                    if (player.maxHp - player.countCards('h') > 1) return 1;
                                    return Math.random() > 0.5 ? 0 : 1;
                                }).set('source', source).forResult();
                                if (result.index == 0) await source.draw(2);
                                else {
                                    player.addTempSkill('reqianxin3')
                                    player.addMark('reqianxin3', 2, false);
                                }
                            }
                        },
                    },
                },
            },
            // 赵昂
            minisushou: {
                audio: 'dcsushou',
                inherit: 'dcsushou',
                async content(event, trigger, player) {
                    const { player: target } = trigger;
                    await player.loseHp();
                    const num = player.getDamagedHp();
                    if (num > 0) await player.draw(num);
                    let ts = target.getCards('h');
                    if (player == target || !ts.length || [player, target].some(current => !current.isIn())) return;
                    const hs = player.getCards('h');
                    ts = ts.randomGets(Math.ceil(ts.length / 2));
                    if (!hs.length || player.isHealthy()) await player.viewCards(get.translation(target) + '的部分手牌', ts);
                    else {
                        const next = player.chooseToMove('夙守：交换至多' + get.cnNumber(Math.min(hs.length, ts.length, player.getDamagedHp())) + '张牌');
                        next.set('list', [
                            [get.translation(target) + '的部分手牌', ts, 'dcsushou_tag'],
                            ['你的手牌', hs],
                        ]);
                        next.set('filterMove', (from, to, moved) => {
                            if (typeof to == 'number') return false;
                            const player = _status.event.player;
                            const hs = player.getCards('h');
                            const changed = hs.filter(card => {
                                return !moved[1].includes(card);
                            });
                            const changed2 = moved[1].filter(card => {
                                return !hs.includes(card);
                            });
                            if (changed.length < player.getDamagedHp()) return true;
                            const pos1 = moved[0].includes(from.link) ? 0 : 1, pos2 = moved[0].includes(to.link) ? 0 : 1;
                            if (pos1 == pos2) return true;
                            if (pos1 == 0) {
                                if (changed.includes(from.link)) return true;
                                return changed2.includes(to.link);
                            }
                            if (changed2.includes(from.link)) return true;
                            return changed.includes(to.link);
                        });
                        next.set('max', Math.min(hs.length, ts.length, player.getDamagedHp()));
                        next.set('processAI', list => {
                            if (_status.event.max) {
                                let gain = list[0][1].sort((a, b) => {
                                    return player.getUseValue(b, null, true) - player.getUseValue(a, null, true);
                                }).slice(0, _status.event.max), give = list[1][1].sort((a, b) => {
                                    return get.value(a, player) - get.value(b, player);
                                }).slice(0, _status.event.max);
                                for (let i of gain) {
                                    if (get.value(i, player) < get.value(give[0], player)) continue;
                                    let j = give.shift();
                                    list[0][1].remove(i);
                                    list[0][1].push(j);
                                    list[1][1].remove(j);
                                    list[1][1].push(i);
                                    if (!give.length) break;
                                }
                            }
                            return [list[0][1], list[1][1]];
                        });
                        const result = await next.forResult();
                        if (result?.moved?.length) {
                            const { moved } = result;
                            const hs = player.getCards('h'), ts = target.getCards('h');
                            const cards1 = [], cards2 = [];
                            for (const i of result.moved[0]) {
                                if (!ts.includes(i)) cards1.push(i);
                            }
                            for (const i of result.moved[1]) {
                                if (!hs.includes(i)) cards2.push(i);
                            }
                            if (cards1.length) await player.swapHandcards(target, cards1, cards2);
                        }
                    }
                },
            },
            // 曹安民
            minixianwei: {
                audio: 'xianwei',
                inherit: 'xianwei',
                content() {
                    'step 0';
                    player.chooseToDisable().ai = function (event, player, list) {
                        var getVal = function (num) {
                            var card = player.getEquip(num);
                            if (card) {
                                var val = get.value(card);
                                if (val > 0) return 0;
                                return 5 - val;
                            }
                            switch (num) {
                                case 'equip3':
                                    return 4.5;
                                case 'equip4':
                                    return 4.4;
                                case 'equip5':
                                    return 4.3;
                                case 'equip2':
                                    return (3 - player.hp) * 1.5;
                                case 'equip1': {
                                    if (
                                        game.hasPlayer(function (current) {
                                            return (get.realAttitude || get.attitude)(player, current) < 0 && get.distance(player, current) > 1;
                                        })
                                    )
                                        return 0;
                                    return 3.2;
                                }
                            }
                        };
                        list.sort(function (a, b) {
                            return getVal(b) - getVal(a);
                        });
                        return list[0];
                    };
                    'step 1';
                    var cardType = result.control;
                    event.cardType = cardType;
                    var num = player.countDisabledSlot();
                    if (num < 5) player.draw(6 - num);
                    if (!game.hasPlayer(current => current != player)) return;
                    player
                        .chooseTarget(lib.filter.notMe, true, '令一名其他角色从牌堆中使用一张' + get.translation(cardType) + '牌')
                        .set('ai', function (target) {
                            var player = _status.event.player,
                                type = _status.event.cardType;
                            var card = get.cardPile2(function (card) {
                                return get.subtype(card) == type && target.canUse(card, target);
                            });
                            if (!card) return 0;
                            return get.effect(target, card, target, player);
                        })
                        .set('cardType', event.cardType);
                    'step 2';
                    if (!result.bool) return;
                    var target = result.targets[0];
                    player.line(target, 'green');
                    var card = get.cardPile2(function (card) {
                        return get.subtype(card) == event.cardType && target.canUse(card, target);
                    });
                    if (card) target.chooseUseTarget(card, 'nopopup', true);
                    else target.draw();
                },
                group: 'minixianwei_all',
                subSkill: {
                    all: {
                        trigger: { player: 'disableEquipAfter' },
                        forced: true,
                        filter(event, player) {
                            return !player.hasEnabledSlot();
                        },
                        content() {
                            player.gainMaxHp(2);
                            player.addSkill('minixianwei_effect');
                        },
                    },
                    effect: {
                        charlotte: true,
                        mark: true,
                        intro: { content: '和其他角色视为在彼此的攻击范围内' },
                        mod: {
                            inRange: () => true,
                            inRangeOf: () => true,
                        },
                    },
                },
            },
            //卞玥
            miniwuxie: {
                audio: 'dcwuxie',
                inherit: 'dcwuxie',
                async content(event, trigger, player) {
                    const target = event.targets[0], cards1 = player.getCards('h', card => get.tag(card, 'damage')), cards2 = target.getCards('h', card => get.tag(card, 'damage'));
                    if (cards1.length) {
                        player.$throw(cards1.length, 1000);
                        await player.lose(cards1, ui.cardPile);
                        for (let i = 0; i < cards1.length; i++) {
                            const card = cards1[i];
                            card.fix();
                            ui.cardPile.appendChild(card);
                        }
                    }
                    if (cards2.length) {
                        target.$throw(cards2.length, 1000);
                        await target.lose(cards2, ui.cardPile);
                        for (let i = 0; i < cards2.length; i++) {
                            const card = cards2[i];
                            card.fix();
                            ui.cardPile.appendChild(card);
                        }
                    }
                    await game.delayx();
                    if ([player, target].some(current => current.isDamaged())) {
                        const result = await player.chooseTarget('令其中一名角色回复1点体力', (card, player, target) => {
                            return get.event().targetsx.includes(target) && target.isDamaged();
                        }).set('ai', target => {
                            const player = get.player();
                            return get.recoverEffect(target, player, player)
                        }).set('targetsx', [player, target]).forResult();
                        if (result?.bool && result?.targets?.length) await result.targets[0].recover();
                    }
                },
            },
            //谋郭嘉
            minisbxianmou: {
                audio: 'ext:活动武将/audio/skill:2',
                inherit: 'xianmou',
                getNum(player) {
                    let num = 0;
                    player.getHistory('lose', evt => {
                        const evt2 = evt.relatedEvent || evt.getParent();
                        if (evt2.name == 'useCard' && evt2.player == player && get.type(evt2.card, null, false) == 'equip') return;
                        if (evt.cards2?.length) num += evt.cards2.length;
                    });
                    return num;
                },
                zhuanhuanji(player, skill) {
                    player.storage[skill] = !player.storage[skill];
                },
                intro: {
                    content(storage) {
                        let str = '你不因使用装备牌而失去过牌的回合结束时，你可以观看';
                        if (!storage) str += '牌堆顶五张牌并获得至多X张牌，若未获得X张牌则获得〖遗计〗直到再发动此项（X为你本回合失去牌数）';
                        else str += '一名角色手牌并弃置其中至多X张牌，若弃置X张牌则你进行一次【闪电】判定（X为你本回合失去牌数）';
                        return str;
                    },
                },
                filter(event, player) {
                    return get.info('minisbxianmou').getNum(player);
                },
                derivation: 'minisbyiji',
                group: 'minisbxianmou_change',
                subSkill: {
                    change: {
                        audio: 'minisbxianmou',
                        trigger: {
                            global: 'phaseBefore',
                            player: 'enterGame',
                        },
                        filter(event, player) {
                            return event.name != 'phase' || game.phaseNumber == 0;
                        },
                        prompt2(event, player) {
                            return '切换【先谋】为状态' + (player.storage.minisbxianmou ? '阳' : '阴');
                        },
                        check: () => Math.random() > 0.5,
                        content() {
                            player.changeZhuanhuanji('minisbxianmou');
                        },
                    },
                },
            },
            minisbyiji: {
                audio: 'ext:活动武将/audio/skill:2',
                inherit: 'new_reyiji',
                trigger: { player: ['damageEnd', 'dying'] },
                filter(event, player, name) {
                    if (event.name == 'damage') return event.num > 0;
                    return game.getRoundHistory('everything', evt => evt.name == 'dying' && evt.player == player).indexOf(event) == 0;
                },
                getIndex(event, player, triggername) {
                    return event.num || 1;
                },
            },
            //蔡瑁张允
            minilianzhou: {
                audio: 'minijilang',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    if (!player.isLinked()) return true;
                    return game.hasPlayer(current => current !== player && current.getHp() >= player.getHp() && !current.isLinked());
                },
                forced: true,
                async content(event, trigger, player) {
                    if (!player.isLinked()) await player.link();
                    if (game.hasPlayer(current => current !== player && current.getHp() >= player.getHp() && !current.isLinked())) {
                        const result = await player.chooseTarget(`${get.translation(event.name)}：选择横置任意名体力值等于你的其他角色`, (card, player, current) => {
                            return current !== player && current.getHp() >= player.getHp() && !current.isLinked();
                        }, [1, Infinity], true).set('ai', target => {
                            const player = get.player();
                            return get.effect(target, { name: 'tiesuo' }, player, player);
                        }).forResult();
                        if (result?.bool && result.targets?.length) {
                            const targets = result.targets.sortBySeat();
                            player.line(targets, 'green');
                            for (const i of targets) await i.link();
                        }
                    }
                },
                ai: { halfneg: true },
            },
            minijilang: {
                audio: 'jinglan',
                trigger: { source: 'damageSource' },
                forced: true,
                content() {
                    switch (Math.sign(player.countCards('h') - player.getHp())) {
                        case 1:
                            player.chooseToDiscard('h', 3, true);
                            break;
                        case 0:
                            player.chooseToDiscard('he', true);
                            player.recover();
                            break;
                        case -1:
                            player.damage('fire');
                            player.draw(5);
                            break;
                    }
                },
                ai: { halfneg: true },
            },
            //辛毗
            minichijie: {
                audio: 'xpchijie',
                inherit: 'xpchijie',
                usable: 2,
                group: 'minichijie_2',
                subSkill: {
                    '2': {
                        inherit: 'xpchijie2',
                        sourceSkill: 'minichijie',
                        usable: 2,
                    },
                },
            },
            // 杜夔
            minifanyin: {
                audio: 'dcfanyin',
                enable: 'phaseUse',
                usable: 1,
                async content(event, trigger, player) {
                    while (true) {
                        let card = false;
                        if (typeof event.numx != 'number') {
                            let num = false;
                            for (let i = 0; i < ui.cardPile.childNodes.length; i++) {
                                const cardx = ui.cardPile.childNodes[i], numc = get.number(cardx, false);
                                if (!num || numc < num) {
                                    num = numc;
                                    card = cardx;
                                    if (num == 1) break;
                                }
                            }
                            event.numx = num;
                        } else {
                            card = get.cardPile2(card => {
                                return get.number(card, false) == event.numx;
                            });
                        }
                        if (!card) return;
                        event.card = card;
                        await game.cardsGotoOrdering(card);
                        await player.showCards(card, get.translation(player) + '发动了【泛音】');
                        let result = !player.hasUseTarget(card, false) ? { index: 1 } : await player.chooseControl().set('choiceList', [`使用${get.translation(card)}（无距离和次数限制）`, '令本回合使用的下一张牌可以多选择一个目标']).set('ai', () => {
                            const player = get.player(), { card } = get.event().getParent();
                            if (player.hasValueTarget(card, false)) return 0;
                            return 1;
                        }).forResult();
                        if (typeof result?.index == 'number') {
                            if (result.index == 0) {
                                const cardx = get.autoViewAs(card);
                                await player.chooseUseTarget(cardx, [card], true, false, 'nodistance');
                            } else {
                                player.addTempSkill(event.name + '_effect');
                                player.addMark(event.name + '_effect', 1, false);
                            }
                            event.numx *= 2;
                            if (event.numx > 13) break;
                        }
                        else break;
                    }
                },
                ai: {
                    order: 7,
                    result: { player: 1 },
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        audio: 'dcfanyin',
                        trigger: { player: 'useCard2' },
                        filter(event, player) {
                            return ['basic', 'trick'].includes(get.type(event.card));
                        },
                        async cost(event, trigger, player) {
                            const num = player.countMark(event.skill);
                            player.removeSkill(event.skill);
                            let goon = false;
                            const info = get.info(trigger.card);
                            if (info.allowMultiple == false) return;
                            if (trigger.targets && !info.multitarget) {
                                if (game.hasPlayer(current => {
                                    return !trigger.targets.includes(current) && lib.filter.targetEnabled2(trigger.card, player, current);
                                })) {
                                    goon = true;
                                }
                            }
                            if (!goon) return;
                            event.result = await player.chooseTarget(get.prompt(event.skill), `为${get.translation(trigger.card)}增加至多${get.cnNumber(num)}个目标`, [1, num], (card, player, target) => {
                                const evt = get.event().getTrigger();
                                return !evt.targets.includes(target) && lib.filter.targetEnabled2(evt.card, player, target);
                            }).set('ai', target => {
                                return get.effect(target, get.event().getTrigger().card, get.player());
                            }).forResult();
                        },
                        async content(event, trigger, player) {
                            if (!event.isMine() && !event.isOnline()) await game.delayx();
                            game.log(event.targets, '也成为了', trigger.card, '的目标');
                            trigger.targets.addArray(event.targets);
                        },
                        intro: { content: '使用下一张牌选择目标后，可以增加#个目标' },
                    }
                }
            },
            minipeiqi: {
                audio: 'dcpeiqi',
                inherit: 'dcpeiqi',
                async content(event, trigger, player) {
                    let num = 2;
                    while (num--) {
                        await player.moveCard(num == 1);
                    }
                    await player.draw();
                },
            },
            // 诸葛若雪
            miniqiongying: {
                audio: 'dcqiongying',
                inherit: 'dcqiongying',
                async content(event, trigger, player) {
                    event.pushHandler('onNextMoveCard', (event, option) => {
                        if (_status.connectMode && event.step == 1 && event._result.bool && option.state == 'end') {
                            game.broadcastAll(() => {
                                delete _status.noclearcountdown;
                                game.stopCountChoose();
                            });
                        }
                    });
                    const result = await player.moveCard(false, `###琼英###移动场上的一张牌`).set('logSkill', event.name).set('custom', {
                        add: {},
                        replace: {
                            window: () => {
                                if (get.event().name == 'chooseTarget') {
                                    ui.click.cancel();
                                }
                            },
                        },
                    }).forResult();
                    if (!result?.bool && typeof player.getStat('skill')[event.name] == 'number' && player.getStat('skill')[event.name] > 0) {
                        player.getStat('skill')[event.name]--;
                    }
                },
            },
            //星荀彧
            minianshu: {
                audio: 'staranshu',
                trigger: { global: 'roundStart' },
                filter(event, player) {
                    return player.hasUseTarget(new lib.element.VCard({ name: 'wugu', isCard: true, anshu: true }));
                },
                async cost(event, trigger, player) {
                    const cards = Array.from(ui.discardPile.childNodes).filter(card => get.type(card) == 'basic');
                    const result = await player.chooseButton([get.prompt2(event.skill), cards], [0, Infinity]).set('filterButton', button => {
                        return !ui.selected.buttons?.some(buttonx => buttonx.link.name == button.link.name);
                    }).set('ai', () => 1 + Math.random()).forResult();
                    event.result = {
                        bool: result?.bool,
                        cards: result?.links ?? [],
                    };
                },
                async content(event, trigger, player) {
                    game.players.forEach(current => current.addTempSkill('minianshu_remove', 'roundStart'));
                    if (event.cards?.length) await game.cardsGotoPile(event.cards, 'insert');
                    player.when({ global: 'useCardToTargeted' }).filter(evt => {
                        return evt.card?.anshu && evt?.targets?.length == evt.getParent()?.triggeredTargets4?.length;
                    }).then(() => {
                        delete trigger.card.anshu;
                        if (trigger.targets.length > 1) {
                            player.chooseTarget('请选择【五谷丰登】的起点', (card, player, target) => {
                                return get.event().getTrigger().targets.includes(target);
                            }, true).set('ai', target => {
                                const player = get.player(), trigger = get.event().getTrigger();
                                return target.getUseValue(trigger.card) * Math.sign(get.attitude(player, target));
                            });
                        }
                    }).then(() => {
                        let target = player;
                        if (result?.targets) target = result.targets[0];
                        trigger.getParent().targets = trigger.getParent().targets.sortBySeat(target);
                        trigger.getParent().triggeredTargets4 = trigger.getParent().triggeredTargets4.sortBySeat(target);
                    });
                    if (player.hasUseTarget(new lib.element.VCard({ name: 'wugu', isCard: true, anshu: true }))) {
                        await player.chooseUseTarget({ name: 'wugu', isCard: true, anshu: true }, true);
                    }
                },
                group: 'minianshu_draw',
                subSkill: {
                    draw: {
                        audio: 'staranshu',
                        trigger: { global: 'phaseEnd' },
                        getIndex(event, player) {
                            return game.filterPlayer(current => {
                                return current.hasHistory('lose', evt => Object.values(evt.gaintag_map).flat().includes('minianshu'));
                            }).sortBySeat();
                        },
                        filter(event, player, name, target) {
                            return target.countCards('h') !== Math.min(5, target.maxHp);
                        },
                        logTarget(event, player, name, target) {
                            return target;
                        },
                        check(event, player, name, target) {
                            return get.attitude(player, target) * (Math.min(5, target.maxHp) - target.countCards('h')) > 0;
                        },
                        prompt2(event, player, name, target) {
                            const num = Math.min(5, target.maxHp);
                            return `令其将手牌${num - target.countCards('h') > 0 ? '摸' : '弃'}至${get.cnNumber(num)}张`;
                        },
                        async content(event, trigger, player) {
                            const target = event.targets[0];
                            const num = Math.min(5, target.maxHp) - target.countCards('h');
                            if (num > 0) await target.draw(num);
                            else if (num < 0) await target.chooseToDiscard('h', -num, true);
                        },
                    },
                    remove: {
                        charlotte: true,
                        onremove(player) {
                            player.removeGaintag('minianshu');
                        },
                        trigger: { player: 'gainAfter' },
                        filter(event, player) {
                            return event.getParent('minianshu', true) && event.getParent('wugu', true);
                        },
                        silent: true,
                        async content(event, trigger, player) {
                            player.addGaintag(trigger.cards, 'minianshu');
                        },
                    },
                },
            },
            //圣甲虫（bushi）
            minibeini: {
                audio: 'dcbeini',
                inherit: 'dcbeini',
                filterCard(card, player) {
                    return player.countCards('h') - (player.maxHp + 1) > 0;
                },
                selectCard() {
                    const player = get.player(), delt = player.countCards('h') - (player.maxHp + 1);
                    return delt > 0 ? delt : -1;
                },
                promptfunc: () => {
                    const player = get.player(), delt = player.countCards('h') - (player.maxHp + 1);
                    return `${[`弃置${get.cnNumber(delt)}张牌`, '点击“确定”', `摸${get.cnNumber(-delt)}张牌`][1 - Math.sign(delt)]}，然后选择两名角色，前者视为对后者使用一张【杀】，且这两者的非锁定技失效。`;
                },
                allowChooseAll: true,
                async content(event, trigger, player) {
                    await player.drawTo(player.maxHp + 1);
                    if (game.countPlayer() < 2) return;
                    const result = await player.chooseTarget('悖逆：请选择两名角色', '前者视为对后者使用一张【杀】，且这两名角色的非锁定技失效直到回合结束。', (card, player, target) => {
                        const targetx = ui.selected.targets[0], sha = new lib.element.VCard({ name: 'sha', isCard: true });
                        return targetx ? targetx.canUse(sha, target, false) : target.hasUseTarget(sha, false);
                    }, 2, true).set('targetprompt', ['打人', '被打']).set('multitarget', true).set('ai', target => {
                        const aiTargets = get.event().aiTargets;
                        if (aiTargets) return aiTargets[ui.selected.targets.length] == target ? 10 : 0;
                        return 0;
                    }).set('aiTargets', (() => {
                        let targets = [], eff = 0;
                        const sha = new lib.element.VCard({ name: 'sha', isCard: true });
                        for (const user of game.filterPlayer()) {
                            for (const target of game.filterPlayer()) {
                                if (user === target) continue;
                                const targetsx = [user, target];
                                targetsx.forEach(i => i.addSkill('minibeini_fengyin2'));
                                let effx = get.effect(target, sha, user, player);
                                targetsx.forEach(i => i.removeSkill('minibeini_fengyin2'));
                                if (user === player) effx += 1;
                                if (get.attitude(player, user) > 0) effx -= 0.1;
                                if (effx > eff) {
                                    eff = effx;
                                    targets = targetsx;
                                }
                            }
                        }
                        if (targets.length) return targets;
                        return null;
                    })()).forResult();
                    if (result?.bool && result.targets?.length) {
                        const [user, target] = result.targets;
                        player.line2(result.targets);
                        await game.delayx();
                        result.targets.forEach(i => i.addTempSkill('minibeini_fengyin'));
                        const sha = new lib.element.VCard({ name: 'sha', isCard: true });
                        if (user.canUse(sha, target, false)) user.useCard(sha, target, false, 'noai');
                    }
                },
                ai: {
                    order: 0.1,
                    result: {
                        player(player) {
                            if (player.countCards('h') - (player.maxHp + 1) >= 3) return 1;
                            return game.hasPlayer(current => get.attitude(player, current) <= 0) ? 1 : 0;
                        },
                    },
                },
            },
            minishizong: {
                audio: 'dcshizong',
                enable: 'chooseToUse',
                hiddenCard(player, name) {
                    if (get.type(name) !== 'basic') return false;
                    return player.countCards('he') >= player.countMark('minishizong_count') + 1;
                },
                filter(event, player) {
                    if (event.type === 'wuxie' || event.minishizong) return false;
                    if (player.countCards('he') < player.countMark('minishizong_count') + 1) return false;
                    return get.inpileVCardList(info => get.type(info[2]) === 'basic').some(info => {
                        return event.filterCard(new lib.element.VCard({ name: info[2], nature: info[3], isCard: true }), player, event);
                    });
                },
                chooseButton: {
                    dialog(event, player) {
                        const vcards = get.inpileVCardList(info => get.type(info[2]) === 'basic').filter(info => {
                            return event.filterCard(new lib.element.VCard({ name: info[2], nature: info[3], isCard: true }), player, event);
                        });
                        return ui.create.dialog('恃纵', [vcards, 'vcard'], 'hidden');
                    },
                    check(button) {
                        if (get.event().getParent().type !== 'phase') return 1;
                        const player = get.player(), card = { name: button.link[2], nature: button.link[3] };
                        if (game.hasPlayer(current => {
                            return player.canUse(card, current) && get.effect(current, card, player, player) > 0;
                        })) {
                            switch (button.link[2]) {
                                case 'tao':
                                    return 5;
                                case 'jiu':
                                    return 3.01;
                                case 'sha':
                                    switch (button.link[3]) {
                                        case 'fire':
                                            return 2.95;
                                        case 'thunder':
                                            return 2.92;
                                        default:
                                            return 2.9;
                                    }
                            }
                        }
                        return 0;
                    },
                    backup(links, player) {
                        return {
                            filterCard: true,
                            filterTarget: lib.filter.notMe,
                            selectTarget: 1,
                            selectCard: () => get.player().countMark('minishizong_count') + 1,
                            viewAs: {
                                name: links[0][2],
                                nature: links[0][3],
                                suit: 'none',
                                number: null,
                                isCard: true,
                            },
                            position: 'he',
                            popname: true,
                            ignoreMod: true,
                            ai1(card) {
                                return 1 / (1.1 + Math.max(-1, get.value(card)));
                            },
                            ai2(target) {
                                return get.attitude(get.player(), target);
                            },
                            async precontent(event, trigger, player) {
                                const { cards, targets: [target] } = event.result;
                                player.logSkill('minishizong', target);
                                player.addTempSkill('minishizong_count');
                                player.addMark('minishizong_count', 1, false);
                                await player.give(cards.slice(), target);
                                const viewAs = new lib.element.VCard({
                                    name: event.result.card.name,
                                    nature: event.result.card.nature,
                                    isCard: true,
                                });
                                const result = await target.chooseCard('恃纵：是否将一张牌置于牌堆底？', `若如此做，${get.translation(player)}视为使用一张${get.translation(viewAs.nature)}【${get.translation(viewAs.name)}】`, 'he').set('ai', card => {
                                    if (get.event().goon) return 7 - get.value(card);
                                    return 0;
                                }).set('goon', get.attitude(target, player) * (player.getUseValue(viewAs) || 1) >= 1).forResult();
                                if (result.bool) {
                                    const card = result.cards[0];
                                    await game.delayex();
                                    const next = target.loseToDiscardpile(card, ui.cardPile);
                                    next.log = false;
                                    if (get.position(card) === 'e') {
                                        target.$throw(card, 1000);
                                        game.log(target, '将', card, '置于了牌堆底');
                                    }
                                    else {
                                        next.blank = true;
                                        target.$throw(1, 1000);
                                        game.log(target, '将一张牌置于了牌堆底');
                                    }
                                    await next;
                                    game.broadcastAll(viewAs => {
                                        lib.skill.minishizong_backup2.viewAs = viewAs;
                                    }, lib.skill.minishizong_backup.viewAs);
                                    const evt = event.getParent();
                                    evt.set('_backupevent', 'minishizong_backup2');
                                    evt.set('openskilldialog', `请选择${get.translation(viewAs.nature)}${get.translation(viewAs.name)}的目标`);
                                    evt.backup('minishizong_backup2');
                                    evt.set('norestore', true);
                                    evt.set('custom', {
                                        add: {},
                                        replace: { window() { } },
                                    });
                                    evt.goto(0);
                                }
                                else {
                                    target.chat('不放！');
                                    game.log(target, '选择不将牌置于牌堆底');
                                    const evt = event.getParent();
                                    evt.set('minishizong', true);
                                    evt.goto(0);
                                }
                                await game.delayx();
                            },
                            ai: { order: 10 },
                        };
                    },
                    prompt(links, player) {
                        return `###恃纵：选择要交出的牌和目标角色###将${get.cnNumber(player.countMark('minishizong') + 1)}张牌交给一名其他角色，其可以选择将一张牌置于牌堆底，视为你使用一张${get.translation(links[0][3] || '')}${get.translation(links[0][2])}。`;
                    },
                },
                ai: {
                    order() {
                        const player = get.player(),
                            event = get.event();
                        if (event.filterCard({ name: 'jiu' }, player, event) && get.effect(player, { name: 'jiu' }) > 0) {
                            return get.order({ name: 'jiu' }) + 0.1;
                        }
                        return get.order({ name: 'sha' }) + 0.1;
                    },
                    respondSha: true,
                    fireAttack: true,
                    respondShan: true,
                    skillTagFilter(player, tag, arg) {
                        if (arg === 'respond' || player.countCards('he') < player.countMark('minishizong') + 1) return false;
                    },
                    result: {
                        player(player) {
                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                            return 1;
                        },
                    },
                },
                subSkill: {
                    backup: {},
                    backup2: {
                        filterCard: () => false,
                        selectCard: -1,
                        log: false,
                    },
                    count: {
                        charlotte: true,
                        onremove: true,
                    },
                },
            },
            // 界荀彧
            minirequhu: {
                audio: 'quhu',
                audioname: ['ol_xunyu'],
                inherit: 'quhu',
                filter(event, player) {
                    return game.hasPlayer(current => player.canCompare(current));
                },
                filterTarget(card, player, target) {
                    return player.canCompare(target);
                },
                async content(event, trigger, player) {
                    const { target } = event;
                    const result = await player.chooseToCompare(target).forResult();
                    if (!result?.bool) {
                        await game.asyncDraw([player, target].sortBySeat());
                    }
                    else {
                        const result = await player.chooseTarget(true, `驱虎：请选择${get.translation(target)}造成伤害的角色`).set('ai', target => {
                            const { player, source } = get.event();
                            return get.damageEffect(target, source, player);
                        }).set('source', target).forResult();
                        if (result?.targets?.length) {
                            target.line(result.targets[0], 'green');
                            await result.targets[0].damage(target);
                        }
                    }
                },
                ai: {
                    order: 0.5,
                    result: {
                        target(player, target) {
                            const att = get.attitude(player, target);
                            const oc = target.countCards('h') == 1;
                            if (att > 0 && oc) {
                                return 0;
                            }
                            if (game.hasPlayer(current => get.damageEffect(current, target, player) > 0)) {
                                return att > 0 ? att / 2 : att - (oc ? 5 : 0);
                            }
                            return 0;
                        },
                        player: 1,
                    },
                    expose: 0.2,
                },
            },
            minirejieming: {
                audio: 'oljieming',
                inherit: 'oljieming',
                async content(event, trigger, player) {
                    const { targets: [target] } = event;
                    await target.draw(Math.min(5, target.maxHp));
                    let num = target.countCards('h') - Math.min(5, target.maxHp);
                    if (num > 0) {
                        let result = await target.chooseToDiscard('h', true, num, 'allowChooseAll').forResult();
                        let cards = result?.cards?.filterInD('d');
                        if (!cards?.length) return;
                        const maxNumber = Math.max(...cards.map(card => get.number(card)));
                        cards = cards.filter(card => get.number(card) === maxNumber);
                        result = cards.length == 1 ? { bool: true, links: cards } : await player.chooseButton(['节命：获得其中一张牌', cards], true).set('ai', button => {
                            return get.value(button.link);
                        }).forResult();
                        if (result?.links?.length) await player.gain(result.links, 'gain2');
                    }
                },
            },
            //谋程昱
            minigaojian: {
                audio: 'dcgaojian',
                trigger: { global: 'cardsDiscardAfter' },
                filter(event, player) {
                    if (!player.isPhaseUsing()) return false;
                    const evt = event.getParent();
                    if (evt.name !== 'orderingDiscard') return false;
                    const evtx = evt.relatedEvent || evt.getParent();
                    return evtx.name === 'useCard' && evtx.player === player && get.type2(evtx.card) === 'trick';
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill)).set('ai', target => {
                        const player = get.player();
                        return get.attitude(player, target) * (target === player ? 1 : 3);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const target = event.targets[0];
                    let showCards = [], useCard;
                    while (showCards.length < 5) {
                        const cards = game.cardsGotoOrdering(get.cards()).cards;
                        showCards.addArray(cards);
                        target.showCards(cards, get.translation(player) + '发动了【告谏】');
                        if (get.type2(cards[0]) == 'trick') {
                            useCard = cards[0];
                            break;
                        }
                    }
                    const goon1 = useCard && target !== player && target.hasUseTarget(useCard);
                    const goon2 = showCards.length > 0 && target.countCards('h') > 0;
                    if (!goon1 && !goon2) return;
                    let resultx;
                    if (!goon1) resultx = { control: '交换牌' };
                    else if (!goon2) resultx = { control: '使用牌' };
                    else {
                        resultx = await target.chooseControl('使用牌', '交换牌').set('choiceList', [
                            `使用${get.translation(useCard)}`,
                            `使用任意张手牌与${get.translation(showCards)}中的等量牌交换`,
                        ]).set('ai', () => {
                            return get.event().useValue > 2 ? '使用牌' : '交换牌';
                        }).set('useValue', target.getUseValue(useCard)).forResult();
                    }
                    if (resultx.control === '使用牌') await target.chooseUseTarget(useCard, true);
                    else {
                        const result = await target.chooseToMove('告谏：是否交换其中任意张牌？').set('list', [
                            ['你的手牌', target.getCards('h'), 'minigaojian_tag'],
                            ['展示牌', showCards],
                        ]).set('filterMove', (from, to) => {
                            return typeof to !== 'number';
                        }).set('filterOk', moved => {
                            return moved[1].some(card => get.owner(card));
                        }).set('processAI', list => {
                            const num = Math.min(list[0][1].length, list[1][1].length);
                            const cards1 = list[0][1].slice().sort((a, b) => get.value(a, 'raw') - get.value(b, 'raw'));
                            const cards2 = list[1][1].slice().sort((a, b) => get.value(b, 'raw') - get.value(a, 'raw'));
                            return [cards1.slice().addArray(cards2.slice(0, num)), cards2.slice().addArray(cards1.slice(0, num))];
                        }).forResult();
                        if (result.bool) {
                            const lose = result.moved[1].slice();
                            const gain = result.moved[0].slice().filter(i => !get.owner(i));
                            if (lose.some(i => get.owner(i))) await target.lose(lose.filter(i => get.owner(i)), ui.special);
                            await game.cardsGotoPile(lose.reverse(), 'insert')
                            if (gain.length) await target.gain(gain, 'draw');
                        }
                        else {
                            if (!showCards.length) return;
                            await game.cardsGotoPile(showCards.reverse(), 'insert')
                        }
                    }
                },
                subSkill: { tag: {} },
            },
            //曹纯曹冲
            minichengxiang: {
                audio: 'chengxiang',
                audioname2: { Mnian_caopi: 'chengxiang_Mnian_caopi' },
                inherit: 'chengxiang',
                forced: true,
            },
            minishanjia: {
                init(player, skill) {
                    player.addSkill(`${skill}_count`);
                    if (typeof player.storage[skill] !== 'number') {
                        player.addMark('minishanjia', 3, false);
                        player.addTip(skill, `${get.translation(skill)}弃牌：3`);
                    }
                },
                onremove(player, skill) {
                    player.removeSkill(`${skill}_count`);
                    player.removeTip(skill);
                    player.unmarkSkill(skill);
                    delete player.storage[skill];
                },
                audio: 'shanjia',
                trigger: { player: 'phaseUseBegin' },
                frequent: true,
                async content(event, trigger, player) {
                    await player.draw(3);
                    let result;
                    if (player.hasMark('minishanjia')) result = await player.chooseToDiscard('he', true, player.countMark('minishanjia')).set('ai', get.disvalue).forResult();
                    let bool1 = true, bool2 = true;
                    if (result?.cards?.length) {
                        result.cards.forEach(card => {
                            const type = get.type2(card, player);
                            if (type === 'basic') bool1 = false;
                            if (type === 'trick') bool2 = false;
                        });
                    }
                    if (bool1) {
                        player.addTempSkill('minishanjia_sha', 'phaseUseAfter');
                        player.addMark('minishanjia_sha', 1, false);
                    }
                    if (bool2) player.addTempSkill('xinshanjia_nodis', 'phaseUseAfter');
                    if (bool1 && bool2) await player.chooseUseTarget({ name: "sha" }, false);
                },
                ai: {
                    threaten: 3,
                    noe: true,
                    reverseOrder: true,
                    skillTagFilter(player) {
                        if (!player.hasMark('minishanjia')) return false;
                    },
                    effect: {
                        target(card, player, target) {
                            if (target.hasMark('minishanjia') && get.type(card) === 'equip' && !get.cardtag(card, 'gifts')) return [1, 3];
                        },
                    },
                },
                marktext: '甲',
                intro: {
                    content(storage = 0) {
                        return `本局游戏已失去${3 - storage}张装备牌`;
                    },
                },
                locked: false,
                mod: {
                    aiValue(player, card, num) {
                        if (player.hasMark('minishanjia') && get.type(card) === 'equip' && !get.cardtag(card, 'gifts')) return num / (player.getHp() + 1);
                    },
                },
                subSkill: {
                    sha: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '使用【杀】的次数上限+#' },
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name === 'sha') return num + player.countMark('minishanjia_sha');
                            },
                        },
                    },
                    count: {
                        charlotte: true,
                        trigger: {
                            player: 'loseEnd',
                            global: ['loseAsyncEnd', 'gainEnd', 'equipEnd', 'addJudgeEnd', 'addToExpansionEnd'],
                        },
                        filter(event, player) {
                            if (!player.hasMark('minishanjia')) return false;
                            return event.getl?.(player).cards2.some(card => get.type2(card, player) === 'equip');
                        },
                        silent: true,
                        firstDo: true,
                        content() {
                            const skill = 'minishanjia';
                            player.removeMark(skill, trigger.getl(player).cards2.filter(card => get.type2(card, player) === 'equip').length, false);
                            const num = player.countMark(skill);
                            if (num > 0) player.addTip(skill, `${get.translation(skill)}弃牌：${num}`);
                            else player.removeTip(skill);
                        },
                    },
                },
            },
            //蜀
            //关羽
            miniwusheng: {
                group: 'miniwusheng_damage',
                audio: 'wusheng',
                audioname2: {
                    guanzhang: 'wusheng_guanzhang',
                    guansuo: 'wusheng_guansuo',
                },
                trigger: { player: 'phaseBegin' },
                forced: true,
                locked: false,
                content() {
                    var card = get.cardPile(function (card) {
                        return card.name == 'sha' && get.color(card) == 'red';
                    });
                    if (card) player.gain(card, 'gain2');
                },
                subSkill: {
                    damage: {
                        mod: {
                            aiOrder(player, card, num) {
                                if (get.itemtype(card) == 'card' && card.name == 'sha' && get.color(card) == 'red') return num + 0.1;
                            },
                        },
                        audio: 'wusheng',
                        audioname2: {
                            guanzhang: "wusheng_guanzhang",
                            guansuo: "wusheng_guansuo",
                        },
                        inherit: 'jie',
                    },
                },
            },
            miniguanxing: {
                audio: 'guanxing',
                audioname: ['ol_jiangwei'],
                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                filter(event, player) {
                    return event.name !== 'phaseJieshu' || player.hasSkill('miniguanxing_on');
                },
                frequent: true,
                async content(event, trigger, player) {
                    const result = await player.chooseToGuanxing(game.countPlayer() <= 2 ? 3 : 5).set('prompt', "观星：点击或拖动将牌移动到牌堆顶或牌堆底").forResult();
                    if ((!result.bool || !result.moved[0].length) && trigger.name == 'phaseZhunbei') player.addTempSkill('miniguanxing_on');
                },
                subSkill: { on: { charlotte: true } },
            },
            minireguanxing: {
                audio: 'guanxing',
                audioname: ['ol_jiangwei', 're_zhugeliang'],
                audioname2: { gexuan: 'guanxing_gexuan' },
                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                frequent: true,
                preHidden: true,
                async content(event, trigger, player) {
                    const num = Math.min(game.countPlayer() <= 2 ? 3 : 5);
                    const goon = player.getExpansions('minireguanxing').length < num;
                    let cards = get.cards(num);
                    let list = [['牌堆顶', cards], ['牌堆底']], str = '观星：点击将牌移动到牌堆顶或牌堆底';
                    if (goon) {
                        list.push(['置于武将牌上的“星”']);
                        str += '，并可以将一张牌称为“星”置于武将牌上';
                    }
                    let result = await player.chooseToMove().set('filterMove', (from, to, moved) => {
                        if (moved[2] && !moved[2].includes(from.link)) {
                            if (typeof to == 'number') {
                                if (to == 2 && moved[2].length) return false;
                                return true;
                            }
                        }
                        return true;
                    }).set('processAI', list => {
                        const cards = list[0][1], player = _status.event.player;
                        let top = [], bottom;
                        const judges = player.getCards('j');
                        let stopped = false;
                        if (!player.hasWuxie()) {
                            for (let i = 0; i < judges.length; i++) {
                                const judge = get.judge(judges[i]);
                                cards.sort((a, b) => judge(b) - judge(a));
                                if (judge(cards[0]) < 0) { stopped = true; break; }
                                else top.unshift(cards.shift());
                            }
                        }
                        if (!stopped) {
                            cards.sort((a, b) => get.value(b, player) - get.value(a, player));
                            while (cards.length) {
                                if (get.value(cards[0], player) <= 5) break;
                                top.unshift(cards.shift());
                            }
                        }
                        bottom = cards;
                        if (!_status.event.goon) return [top, bottom];
                        let cardx = top.slice().concat(bottom).slice(player.hasWuxie() ? 0 : judges.length);
                        if (!cardx.length) return [top, bottom, []];
                        let card = cardx.sort((a, b) => get.value(b) / get.useful(b) - get.value(a) / get.useful(b))[0];
                        top.remove(card);
                        bottom.remove(card);
                        return [top, bottom, [card]];
                    }).set('goon', goon).set('list', list).set('prompt', str).forResult();
                    if (result.bool) {
                        const top = result.moved[0], bottom = result.moved[1], put = result.moved[2];
                        top.reverse();
                        game.cardsGotoPile(
                            top.concat(bottom),
                            ['top_cards', top],
                            (event, card) => {
                                if (event.top_cards.includes(card)) return ui.cardPile.firstChild;
                                return null;
                            }
                        );
                        player.popup(get.cnNumber(top.length) + '上' + get.cnNumber(bottom.length) + '下');
                        game.log(player, '将' + get.cnNumber(top.length) + '张牌置于牌堆顶');
                        if (put?.length) player.addToExpansion(put, 'gain2').gaintag.add('minireguanxing');
                        game.updateRoundNumber();
                        game.delayx();
                    }
                },
                marktext: '星',
                intro: {
                    content: 'expansion',
                    markcount: 'expansion',
                },
                onremove(player, skill) {
                    var cards = player.getExpansions(skill);
                    if (cards.length) player.loseToDiscardpile(cards);
                },
                group: ['minireguanxing_gain'/*,'minireguanxing_lose'*/],
                subSkill: {
                    gain: {
                        audio: 'guanxing',
                        audioname: ['ol_jiangwei', 're_zhugeliang'],
                        audioname2: { gexuan: 'guanxing_gexuan' },
                        enable: 'phaseUse',
                        filter(event, player) {
                            return player.getExpansions('minireguanxing').length;
                        },
                        prompt() {
                            const player = _status.event.player;
                            let str = '获得武将牌上的所有“星”';
                            if (player.getExpansions('minireguanxing').length >= Math.min(game.countPlayer() <= 2 ? 3 : 5)) str += '，本回合获得如下效果：若你有空置的装备栏，则你视为装备【诸葛连弩】';
                            return str;
                        },
                        content() {
                            const cards = player.getExpansions('minireguanxing');
                            player.gain(cards, 'gain2');
                            if (cards.length >= Math.min(game.countPlayer() <= 2 ? 3 : 5)) player.addTempSkill('minireguanxing_liannu');
                        },
                        ai: {
                            order: 9,
                            result: { player: player => player.getExpansions('minireguanxing').length >= Math.min(game.countPlayer() <= 2 ? 3 : 5) || player.hp < 2 ? 1 : 0 },
                        },
                    },
                    liannu: {
                        charlotte: true,
                        mark: true,
                        markimage: 'image/card/zhuge.png',
                        nobracket: true,
                        intro: { content: '视为装备【诸葛连弩】' },
                        group: 'minireguanxing_zhuge',
                        init(player, skill) {
                            player.addExtraEquip(skill, 'zhuge', true, player => lib.card['zhuge']);
                        },
                        onremove(player, skill) {
                            player.removeExtraEquip(skill);
                        },
                    },
                    zhuge: {
                        inherit: 'zhuge_skill',
                        audio: 'guanxing',
                        audioname: ['ol_jiangwei', 're_zhugeliang'],
                        audioname2: { gexuan: 'guanxing_gexuan' },
                        nobracket: true,
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name != 'sha'/*||player.getEquips('zhuge').length||player.hasSkill('zhuge_skill',null,false)*/) return;
                                //if(get.is.versus()||get.is.changban()) return num+3;
                                return Infinity;
                            },
                        },
                    },
                    lose: {
                        audio: 'guanxing',
                        audioname: ['ol_jiangwei', 're_zhugeliang'],
                        audioname2: { gexuan: 'guanxing_gexuan' },
                        trigger: { global: ['phaseBefore', 'dieAfter'], player: 'enterGame' },
                        filter(event, player) {
                            const num = Math.min(game.countPlayer() <= 2 ? 3 : 5);
                            return player.getExpansions('minireguanxing').length > num;
                        },
                        forced: true,
                        locked: false,
                        async content(event, trigger, player) {
                            const num = player.getExpansions('minireguanxing').length - Math.min(game.countPlayer() <= 2 ? 3 : 5);
                            let result = await player.chooseButton(['观星：请移去' + get.cnNumber(num) + '张多余的“星”', player.getExpansions('minireguanxing')], true, num).forResult();
                            if (result.bool) player.loseToDiscardpile(result.links);
                        },
                    },
                },
            },
            minikongcheng: {
                mod: {
                    targetEnabled(card, player, target, now) {
                        if (target.countCards('h') == 0) {
                            if (card.name == 'sha' || card.name == 'juedou' || card.name == 'shunshou') return false;
                        }
                    },
                },
                audio: 'kongcheng1',
                audioname: ['re_zhugeliang'],
                trigger: { player: 'loseEnd' },
                forced: true,
                firstDo: true,
                filter(event, player) {
                    if (player.countCards('h')) return false;
                    return event.cards.some(card => card.original == 'h');
                },
                content() { },
                ai: {
                    noh: true,
                    skillTagFilter(player, tag) {
                        return player.countCards('h') == 1;
                    },
                },
            },
            //刘备
            minirende: {
                audio: 'rende',
                trigger: { player: 'phaseUseEnd' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minirende'), [1, 2]).set('ai', function (target) {
                        return Math.sqrt(5 - Math.min(4, target.countCards('h'))) * get.attitude(_status.event.player, target);
                    });
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        player.logSkill('minirende', targets);
                        if (targets.length == 1) {
                            targets[0].draw();
                            event.finish();
                        }
                        else game.asyncDraw(targets);
                    }
                    else event.finish();
                    'step 2'
                    game.delayx();
                },
            },
            minirerende: {
                audio: 'rerende',
                enable: 'phaseUse',
                filterCard: true,
                selectCard: [1, Infinity],
                discard: false,
                lose: false,
                delay: false,
                filterTarget(card, player, target) {
                    return player != target && !player.getStorage('minirerende2').includes(target);
                },
                check(card) {
                    if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') return 0;
                    if (!ui.selected.cards.length && card.name == 'du') return 20;
                    var player = get.owner(card);
                    if (ui.selected.cards.length >= Math.max(2, player.countCards('h') - player.hp)) return 0;
                    if (player.hp == player.maxHp || player.storage.minirerende < 0 || player.countCards('h') <= 1) {
                        var players = game.filterPlayer();
                        for (var i = 0; i < players.length; i++) {
                            if (players[i].hasSkill('haoshi') &&
                                !players[i].isTurnedOver() &&
                                !players[i].hasJudge('lebu') &&
                                get.attitude(player, players[i]) >= 3 &&
                                get.attitude(players[i], player) >= 3) {
                                return 11 - get.value(card);
                            }
                        }
                        if (player.countCards('h') > player.hp) return 10 - get.value(card);
                        if (player.countCards('h') > 2) return 6 - get.value(card);
                        return -1;
                    }
                    return 10 - get.value(card);
                },
                content() {
                    'step 0'
                    var evt = _status.event.getParent('phaseUse');
                    if (evt?.name == 'phaseUse' && !evt.minirerende) {
                        var next = game.createEvent('minirerende_clear');
                        _status.event.next.remove(next);
                        evt.after.push(next);
                        evt.minirerende = true;
                        next.player = player;
                        next.setContent(function () {
                            player.storage.minirerende = 0;
                            delete player.storage.minirerende2;
                        });
                    }
                    player.markAuto('minirerende2', [target]);
                    player.give(cards, target);
                    player.addTempSkill('minirerende_sha', { player: 'phaseBegin' });
                    player.markAuto('minirerende_sha', [target]);
                    if (typeof player.storage.minirerende != 'number') player.storage.minirerende = 0;
                    if (player.storage.minirerende >= 0) {
                        player.storage.minirerende += cards.length;
                        if (player.storage.minirerende >= 2) {
                            var list = [];
                            for (var i of lib.inpile) {
                                if (get.type({ name: i }) != 'basic' && get.type({ name: i }) != 'trick') continue;
                                if (lib.filter.cardUsable({ name: i }, player, event.getParent('chooseToUse')) && player.hasUseTarget({ name: i })) {
                                    list.push([get.translation(get.type({ name: i })), '', i]);
                                    if (i == 'sha') {
                                        for (var i of lib.inpile_nature) {
                                            if (lib.filter.cardUsable({ name: 'sha', nature: i }, player, event.getParent('chooseToUse')) && game.hasPlayer(function (current) {
                                                return player.canUse({ name: 'sha', nature: i }, current);
                                            })) list.push(['基本', '', 'sha', i]);
                                        }
                                    }
                                }
                            }
                            if (list.length) {
                                player.chooseButton(['是否视为使用一张基本牌或普通锦囊牌？', [list, 'vcard']]).set('ai', function (button) {
                                    var player = _status.event.player;
                                    var card = { name: button.link[2], nature: button.link[3] };
                                    return player.getUseValue(card);
                                });
                            }
                            else event.finish();
                            player.storage.minirerende = -1;
                        }
                        else event.finish();
                    }
                    else event.finish();
                    'step 1'
                    if (result?.bool && result.links[0]) {
                        var card = { name: result.links[0][2], nature: result.links[0][3] };
                        player.chooseUseTarget(card, true);
                    }
                },
                ai: {
                    threaten: 0.8,
                    fireAttack: true,
                    order(skill, player) {
                        if (player.hp < player.maxHp && player.storage.minirerende < 2 && player.countCards('h') > 1) return 10;
                        return 4;
                    },
                    result: {
                        target(player, target) {
                            if (target.hasSkillTag('nogain')) return 0;
                            if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') {
                                if (target.hasSkillTag('nodu')) return 0;
                                return -10;
                            }
                            if (target.hasJudge('lebu')) return 0;
                            var nh = target.countCards('h');
                            var np = player.countCards('h');
                            if (player.hp == player.maxHp || player.storage.minirerende < 0 || player.countCards('h') <= 1) {
                                if (nh >= np - 1 && np <= player.hp && !target.hasSkill('haoshi')) return 0;
                            }
                            return Math.max(1, 5 - nh);
                        }
                    },
                    effect: {
                        target(card, player, target) {
                            if (player == target && get.type(card) == 'equip') {
                                if (player.countCards('e', { subtype: get.subtype(card) })) {
                                    if (game.hasPlayer(function (current) {
                                        return current != player && get.attitude(player, current) > 0;
                                    })) return 0;
                                }
                            }
                        },
                    },
                },
                subSkill: {
                    sha: {
                        charlotte: true,
                        onremove: true,
                        mark: true,
                        marktext: "<span style='text-decoration: line-through;'>杀</span>",
                        intro: { content: '$使用红色【杀】无法指定你为目标' },
                        mod: {
                            targetEnabled(card, player, target) {
                                if (card.name == 'sha' && get.color(card) == 'red' && target.getStorage('minirerende_sha').includes(player)) return false;
                            },
                        },
                    },
                },
            },
            minijijiang: {
                zhuSkill: true,
                audio: 'jijiang1',
                audioname: ['ol_liushan', 're_liubei'],
                filter(event, player) {
                    if (!game.hasPlayer(current => current !== player && current.group == 'shu')) return false;
                    return !event.jijiang && (event.type != 'phase' || !player.hasSkill('jijiang3'));
                },
                enable: ['chooseToUse', 'chooseToRespond'],
                viewAs: { name: 'sha' },
                filterCard() { return false },
                selectCard: -1,
                ai: {
                    order() {
                        return get.order({ name: 'sha' }) + 0.3;
                    },
                    respondSha: true,
                    skillTagFilter(player) {
                        if (player.hasSkill('jijiang3') && !game.hasPlayer(current => current !== player && current.group == 'shu')) return false;
                    },
                },
                group: 'minirejijiang1',
            },
            minirejijiang: {
                inherit: 'minijijiang',
                group: ['minirejijiang1', 'minirejijiang3'],
            },
            minirejijiang1: {
                audio: 'jijiang1',
                audioname: ['ol_liushan', 're_liubei'],
                trigger: { player: ['useCardBegin', 'respondBegin'] },
                logTarget: 'targets',
                filter(event, player) {
                    return event.skill == 'minirejijiang';
                },
                forced: true,
                content() {
                    'step 0'
                    delete trigger.skill;
                    trigger.getParent().set('jijiang', true);
                    'step 1'
                    if (event.current == undefined) event.current = player.next;
                    if (event.current == player) {
                        player.addTempSkill('jijiang3');
                        event.finish();
                        trigger.cancel();
                        trigger.getParent().goto(0);
                    }
                    else if (event.current.group == 'shu') {
                        var next = event.current.chooseToRespond('是否替' + get.translation(player) + '打出一张杀？', { name: 'sha' });
                        next.set('ai', function () {
                            var event = _status.event;
                            return (get.attitude(event.player, event.source) - 2);
                        });
                        next.set('source', player);
                        next.set('jijiang', true);
                        next.set('skillwarn', '替' + get.translation(player) + '打出一张杀');
                        next.noOrdering = true;
                        next.autochoose = lib.filter.autoRespondSha;
                    }
                    else {
                        event.current = event.current.next;
                        event.redo();
                    }
                    'step 2'
                    if (result.bool) {
                        game.asyncDraw([player, event.current]);
                        trigger.card = result.card;
                        trigger.cards = result.cards;
                        trigger.throw = false;
                        if (typeof event.current.ai.shown == 'number' && event.current.ai.shown < 0.95) {
                            event.current.ai.shown += 0.3;
                            if (event.current.ai.shown > 0.95) event.current.ai.shown = 0.95;
                        }
                        event.finish();
                    }
                    else {
                        event.current = event.current.next;
                        event.goto(1);
                    }
                }
            },
            minirejijiang3: {
                audio: 'jijiang1',
                audioname: ['ol_liushan', 're_liubei'],
                trigger: { global: ['useCard', 'respond'] },
                filter(event, player) {
                    return event.card.name == 'sha' && event.player != player && event.player.group == 'shu' && event.player.isIn() &&
                        player != _status.currentPhase;
                },
                usable: 1,
                direct: true,
                content() {
                    'step 0'
                    trigger.player.chooseBool('激将：是否令' + get.translation(player) + '摸一张牌？').set('ai', function () {
                        var evt = _status.event;
                        return get.attitude(evt.player, evt.getParent().player) > 0;
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minirejijiang');
                        trigger.player.line(player, 'fire');
                        player.draw();
                    }
                    else player.storage.counttrigger.minirejijiang3--;
                },
            },
            //马超
            miniyuma: {
                group: 'mashu',
                trigger: {
                    player: 'loseAfter',
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                },
                filter(event, player) {
                    var evt = event.getl(player);
                    if (!evt || evt.player != player || !evt.es || !evt.es.length) return false;
                    return evt.es.some(card => get.type(card) == 'equip' && ['equip3', 'equip4'].includes(get.subtype(card)));
                },
                forced: true,
                content() {
                    player.draw(2 * trigger.getl(player).es.filter(card => get.type(card) == 'equip' && ['equip3', 'equip4'].includes(get.subtype(card))).length);
                },
            },
            minitieji: {
                audio: 'tieji',
                trigger: { player: 'useCardToPlayered' },
                check(event, player) {
                    return get.attitude(player, event.target) <= 0;
                },
                filter(event, player) {
                    return event.card.name === 'sha';
                },
                logTarget: 'target',
                preHidden: true,
                async content(event, trigger, player) {
                    const { color } = await player.judge().forResult();
                    if (color === 'red') trigger.getParent().directHit.add(trigger.target);
                    if (color === 'black') player.draw();
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (!arg?.target) return false;
                        const target = arg.target;
                        return get.attitude(player, target) <= 0 && arg.card && arg.card.name === 'sha' && ui.cardPile.firstChild && get.color(ui.cardPile.firstChild, player) === 'red';
                    },
                },
            },
            miniretieji: {
                audio: 'retieji',
                inherit: 'minitieji',
                async content(event, trigger, player) {
                    const target = trigger.target;
                    target.addTempSkill('fengyin');
                    const { color } = await player.judge().forResult();
                    if (color === 'red') trigger.getParent().directHit.add(target);
                    if (color === 'black') player.draw(2);
                },
                ai: {
                    ignoreSkill: true,
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (!arg?.target) return false;
                        const target = arg.target;
                        if (tag === 'directHit_ai') {
                            return get.attitude(player, target) <= 0 && arg.card && arg.card.name === 'sha' && ui.cardPile.firstChild && get.color(ui.cardPile.firstChild, player) === 'red';
                        }
                        if (!arg.skill) return false;
                        const skill = arg.skill, info = lib.skill[skill];
                        return info && !info.charlotte && !info.persevereSkill && !get.is.locked(skill, arg.target) && target.getSkills(true, false).includes(skill);
                    },
                },
            },
            minijuxiang: {
                group: 'juxiang1',
                audio: 'juxiang1',
                preHidden: ['juxiang1', 'minijuxiang'],
                trigger: { global: ['useCardAfter', 'loseAfter'] },
                filter(event, player) {
                    if (event.name == 'useCard') return (event.cards.filterInD().length || game.hasPlayer2(function (current) {
                        return current.getHistory('damage', function (evt) {
                            return evt.card && evt.card == event.card;
                        }).length;
                    })) && event.card.name == 'nanman' && event.player != player;
                    if (event.type != 'discard' || event.getlx === false) return false;
                    var cards = event.cards2.slice(0);
                    var evt = event.getl(player);
                    if (evt?.cards) cards.removeArray(evt.cards);
                    return cards.filter(function (card) {
                        return card.name == 'nanman' && get.position(card, true) == 'd';
                    }).length;
                },
                forced: true,
                content() {
                    'step 0'
                    if (trigger.name == 'lose') {
                        var cards = trigger.cards2.slice(0);
                        var evt = trigger.getl(player);
                        if (evt?.cards) cards.removeArray(evt.cards);
                        player.gain(cards.filter(function (card) {
                            return card.name == 'nanman' && get.position(card, true) == 'd';
                        }), 'gain2');
                        event.finish();
                        return;
                    }
                    if (trigger.cards.filterInD().length) player.gain(trigger.cards.filterInD(), 'gain2');
                    'step 1'
                    if (game.hasPlayer2(function (current) {
                        return current.getHistory('damage', function (evt) {
                            return evt.card && evt.card == trigger.card;
                        }).length;
                    })) player.draw();
                },
                ai: {
                    effect: {
                        target(card) {
                            if (card.name == 'nanman') return [0, 1];
                        },
                    },
                },
            },
            minilieren: {
                audio: 'lieren',
                trigger: { source: 'damageSource' },
                filter(event, player) {
                    if (event._notrigger.includes(event.player)) return false;
                    return event.card && event.card.name == 'sha' && event.getParent().name == 'sha' &&
                        event.player.isIn() && event.player.countCards('h');
                },
                forced: true,
                usable: 2,
                check(event, player) {
                    return get.attitude(player, event.player) < 0;
                },
                content() {
                    'step 0'
                    player.discardPlayerCard('h', trigger.player, true);
                    'step 1'
                    if (get.number(result.cards[0]) < get.number(trigger.cards[0])) player.gain(result.cards, 'gain2', 'log');
                },
            },
            minirelieren: {
                audio: 'lieren',
                audioname: ['ol_zhurong'],
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    return event.card.name == 'sha' && player.canCompare(event.target);
                },
                check(event, player) {
                    return get.attitude(player, event.target) < 0;
                },
                content() {
                    'step 0'
                    player.chooseToCompare(trigger.target).clear = false;
                    'step 1'
                    if (result) {
                        if (result.target && get.position(result.target) === 'd') player.gain(result.target, 'gain2');
                        if (result.bool && trigger.target.countGainableCards(player, 'he')) player.gainPlayerCard(trigger.target, true, 'he');
                        ui.clear();
                    }
                },
            },
            minitishen: {
                audio: 'retishen',
                trigger: { target: 'shaUnhirt' },
                filter(event, player) {
                    if (player.isPhaseUsing()) return false;
                    if (get.itemtype(event.cards) !== 'cards') return false;
                    return event.cards.someInD('od');
                },
                forced: true,
                locked: false,
                content() {
                    player.gain(trigger.cards.filterInD('od'), 'gain2');
                },
            },
            miniretishen: {
                inherit: 'minitishen',
                group: 'miniretishen_tieji',
                subSkill: {
                    tieji: {
                        audio: 'retishen',
                        trigger: { player: 'shaMiss' },
                        filter(event, player) {
                            return player.isPhaseUsing();
                        },
                        forced: true,
                        locked: false,
                        content() {
                            player.addTempSkill('miniretishen_tieji2', ['phaseBefore', 'phaseZhunbeiAfter', 'phaseJudgeAfter', 'phaseDrawAfter', 'phaseUseAfter', 'phaseDiscardAfter', 'phaseJieshuAfter', 'phaseAfter']);
                        },
                    },
                    tieji2: {
                        charlotte: true,
                        audio: 'retishen',
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            return event.card.name == 'sha';
                        },
                        forced: true,
                        content() {
                            player.removeSkill('miniretishen_tieji2');
                            trigger.directHit.addArray(game.players);
                            trigger.baseDamage++;
                        },
                    },
                },
            },
            miniyajiao: {
                audio: 'reyajiao',
                trigger: { player: ['useCard', 'respond'] },
                filter(event, player) {
                    return player !== _status.currentPhase && ['sha', 'shan'].includes(event.card.name);
                },
                forced: true,
                round: 1,
                content() {
                    player.draw();
                },
            },
            minireyajiao: {
                audio: 'reyajiao',
                trigger: { player: ['useCard', 'respond'] },
                filter(event, player) {
                    return player != _status.currentPhase && get.itemtype(event.cards) == 'cards';
                },
                frequent: true,
                content() {
                    'step 0'
                    var card = get.cards()[0];
                    event.card = card;
                    player.showCards(card, get.translation(player) + '发动了【涯角】');
                    player.chooseTarget('是否令一名角色获得' + get.translation(card) + '？').set('ai', function (target) {
                        var att = get.attitude(_status.event.player, target);
                        if (_status.event.du) {
                            if (target.hasSkillTag('nodu')) return 0;
                            return -att;
                        }
                        if (att > 0) return att + Math.max(0, 5 - target.countCards('h'));
                        return att;
                    }).set('du', event.card.name == 'du');
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target);
                        target.gain(card, 'gain2');
                    }
                    else {
                        player.$throw(card, 1000);
                        game.delayx();
                        game.cardsDiscard(card);
                        game.log(card, '进入了弃牌堆');
                    }
                },
                ai: {
                    effect: {
                        target(card, player, target) {
                            if (get.tag(card, 'respond') && target.countCards('h') > 1) return [1, 0.2];
                        },
                    },
                },
                group: 'minireyajiao_draw',
                subSkill: {
                    draw: {
                        audio: 'reyajiao',
                        trigger: { player: 'phaseJieshuBegin' },
                        filter(event, player) {
                            return player.hasHistory('useSkill', evt => evt.skill === 'ollongdan');
                        },
                        forced: true,
                        locked: false,
                        content() {
                            player.draw();
                        },
                    },
                },
            },
            miniliegong: {
                audio: 'liegong',
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    if (event.card.name !== 'sha') return false;
                    return event.target.getHp() >= player.getHp() || event.target.countCards('h') >= player.countCards('h');
                },
                forced: true,
                locked: false,
                preHidden: true,
                logTarget: 'target',
                content() {
                    trigger.getParent().directHit.push(trigger.target);
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (!arg?.target || !arg.card || arg.card.name !== 'sha') return false;
                        const filter = card => !ui.selected.cards.includes(card) && !arg.card.cards?.includes(card);
                        return arg.target.getHp() >= player.getHp() || arg.target.countCards('h', filter) >= player.countCards('h', filter);
                    },
                },
            },
            minireliegong: {
                mod: {
                    targetInRange(card, player, target) {
                        if (card.name == 'sha') return true;
                    },
                },
                audio: 'liegong',
                audioname: ['re_huangzhong'],
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    if (event.card.name != 'sha') return false;
                    return event.target.countCards('h') <= player.countCards('h') || event.target.hp >= player.hp;
                },
                check(event, player) {
                    return get.attitude(player, event.target) <= 0;
                },
                forced: true,
                locked: false,
                preHidden: true,
                logTarget: 'target',
                content() {
                    if (trigger.target.countCards('h') <= player.countCards('h')) trigger.getParent().directHit.push(trigger.target);
                    if (trigger.target.hp >= player.hp) {
                        var id = trigger.target.playerid;
                        var map = trigger.getParent().customArgs;
                        if (!map[id]) map[id] = {};
                        if (typeof map[id].extraDamage != 'number') {
                            map[id].extraDamage = 0;
                        }
                        map[id].extraDamage++;
                    }
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (!arg?.target || !arg.card || arg.card.name !== 'sha') return false;
                        const filter = card => !ui.selected.cards.includes(card) && !arg.card.cards?.includes(card);
                        return arg.target.countCards('h', filter) <= player.countCards('h', filter);
                    },
                },
            },
            minikuanggu: {
                audio: 'kuanggu',
                audioname: ['re_weiyan'],
                trigger: { source: 'damageSource' },
                frequent: true,
                content() {
                    'step 0'
                    event.count = trigger.num;
                    'step 1'
                    event.count--;
                    player.chooseDrawRecover(true);
                    'step 2'
                    if (event.count > 0 && player.hasSkill('minikuanggu')) event.goto(1);
                },
            },
            minidangxian: {
                audio: 'dangxian',
                audioname: ['re_liaohua', 'xin_liaohua'],
                audioname2: { guansuo: 'dangxian_guansuo' },
                trigger: { player: 'phaseBegin' },
                forced: true,
                locked: false,
                content() {
                    const next = player.phaseUse();
                    event.next.remove(next);
                    trigger.next.push(next);
                    const card = get.cardPile(card => card.name === 'sha');
                    if (card) player.gain(card, 'gain2');
                },
            },
            minifuli: {
                audio: 'xinfuli',
                skillAnimation: true,
                animationColor: 'soil',
                limited: true,
                enable: 'chooseToUse',
                mark: true,
                filter(event, player) {
                    if (event.type != 'dying') return false;
                    if (player != event.dying) return false;
                    return true;
                },
                content() {
                    'step 0'
                    player.awakenSkill('minifuli');
                    event.num = game.countGroup();
                    player.recover(event.num - player.hp);
                    'step 1'
                    var num2 = num - player.countCards('h');
                    if (num2) player.draw(num2);
                    'step 2'
                    if (num > 3) player.turnOver();
                    player.storage.minifuli = true;
                },
                ai: {
                    save: true,
                    skillTagFilter(player, arg, target) {
                        return player == target;
                    },
                    result: {
                        player: 10
                    },
                },
                intro: { content: 'limited' },
            },
            miniqimou: {
                limited: true,
                audio: 'qimou',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.hp >= 1;
                },
                mark: true,
                intro: { content: 'limited' },
                skillAnimation: true,
                animationColor: 'orange',
                content() {
                    'step 0'
                    var shas = player.getCards('h', 'sha');
                    var num, map = {}, list = [];
                    if (player.hp >= 4 && shas.length >= 3) num = 3;
                    else if (player.hp >= 3 && shas.length >= 2) num = 2;
                    else num = 1;
                    for (var i = 1; i <= player.hp; i++) {
                        var cn = get.cnNumber(i, true);
                        map[cn] = i;
                        list.push(cn);
                    }
                    event.map = map;
                    player.awakenSkill('miniqimou');
                    player.storage.miniqimou = true;
                    player.chooseControl(list, function () {
                        return get.cnNumber(_status.event.goon, true);
                    }).set('prompt', '奇谋：选择失去任意点体力').set('goon', num);
                    'step 1'
                    var num = event.map[result.control] || 1;
                    player.storage.miniqimou2 = num;
                    player.loseHp(num);
                    player.draw();
                    player.addTempSkill('miniqimou2');
                },
                ai: {
                    order: 2,
                    result: {
                        player(player) {
                            if (player.hp == 1) return 0;
                            var shas = player.getCards('h', 'sha');
                            if (!shas.length) return 0;
                            var card = shas[0];
                            if (!lib.filter.cardEnabled(card, player)) return 0;
                            if (lib.filter.cardUsable(card, player)) return 0;
                            var mindist;
                            if (player.hp >= 4 && shas.length >= 3) mindist = 4;
                            else if (player.hp >= 3 && shas.length >= 2) mindist = 3;
                            else mindist = 2;
                            if (game.hasPlayer(function (current) {
                                return (current.hp <= mindist - 1 &&
                                    get.distance(player, current, 'attack') <= mindist &&
                                    player.canUse(card, current, false) &&
                                    get.effect(current, card, player, player) > 0);
                            })) return 1;
                            return 0;
                        },
                    },
                },
            },
            miniqimou2: {
                onremove: true,
                mod: {
                    cardUsable(card, player, num) {
                        if (typeof player.storage.miniqimou2 == 'number' && card.name == 'sha') return num + player.storage.miniqimou2;
                    },
                    globalFrom(from, to, distance) {
                        if (typeof from.storage.miniqimou2 == 'number') return distance - from.storage.miniqimou2;
                    },
                },
            },
            minilianhuan: {
                audio: 'lianhuan',
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minilianhuan'), [1, 2]).set('ai', function (target) {
                        var player = _status.event.player, eff = get.effect(target, { name: 'tiesuo' }, player, player);
                        if (target == player) return eff * 5;
                        return eff;
                    });
                    'step 1'
                    if (result.bool) {
                        result.targets.sortBySeat()
                        player.logSkill('minilianhuan', result.targets);
                        for (var target of result.targets) target.link();
                        if (result.targets.includes(player)) player.draw();
                    }
                },
            },
            minirelianhuan: {
                audio: 'xinlianhuan',
                audioname: ['ol_pangtong'],
                trigger: { player: ['phaseUseBegin', 'useCard2', 'useCardToPlayered'] },
                filter(event, player, name) {
                    const card = new lib.element.VCard({ name: 'tiesuo' });
                    if (event.name == 'phaseUse') return player.hasUseTarget(card, false);
                    if (event.card.name != 'tiesuo') return false;
                    if (name == 'useCard2') return game.hasPlayer(current => !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current));
                    return event.target != player && !event.target.isLinked() && event.target.countCards('h');
                },
                direct: true,
                async content(event, trigger, player) {
                    const card = new lib.element.VCard({ name: 'tiesuo' });
                    if (trigger.name == 'phaseUse') player.chooseUseTarget('###' + get.prompt('minirelianhuan') + '###视为使用【铁索连环】', card, false).set('logSkill', 'minirelianhuan');
                    else if (event.triggername == 'useCardToPlayered') {
                        const target = trigger.target;
                        player.logSkill('minirelianhuan', target);
                        const cards = target.getDiscardableCards(player, 'h');
                        if (cards.length) await target.discard(cards.randomGet()).set('discarder', player);
                    }
                    else {
                        const result = await player.chooseTarget(get.prompt('minirelianhuan'), (card, player, target) => {
                            const trigger = get.event().getTrigger();
                            if (trigger.targets.includes(target)) return false;
                            return lib.filter.targetEnabled2(trigger.card, player, target) && lib.filter.targetInRange(trigger.card, player, target);
                        }, [1, Infinity]).set('prompt2', '为' + get.translation(trigger.card) + '选择任意额外目标').set('ai', target => {
                            const player = get.event().player, trigger = get.event().getTrigger();
                            return get.effect(target, trigger.card, player, player) * (trigger.targets.includes(target) ? -1 : 1);
                        }).forResult();
                        if (result?.targets?.length) {
                            const { targets } = result;
                            player.logSkill('minirelianhuan', targets);
                            trigger.targets.addArray(targets);
                            if (targets.includes(player)) await player.draw();
                        }
                    }
                },
            },
            mininiepan: {
                limited: true,
                audio: 'olniepan',
                enable: 'chooseToUse',
                filter(event, player) {
                    return event.type == 'dying' && event.dying == player;
                },
                skillAnimation: true,
                animationColor: 'orange',
                async content(event, trigger, player) {
                    player.awakenSkill('mininiepan');
                    await player.discard(player.getCards('hej'));
                    await player.link(false);
                    await player.turnOver(false);
                    await player.draw(3);
                    if (player.hp < 3) await player.recover(3 - player.hp);
                    const map = { '八阵': 'minibazhen', '火计＆看破': ['minihuoji', 'olkanpo'] };
                    const result = await player.chooseControl(Object.keys(map)).set('prompt', '涅槃：请选择获得其中一个选项的技能').set('ai', () => {
                        return Object.keys(get.event().map).randomGet();
                    }).set('map', map).forResult();
                    if (result?.control) await player.addSkills(map[result.control]);
                },
                derivation: ['minibazhen', 'minihuoji', 'olkanpo'],
                ai: {
                    order: 1,
                    save: true,
                    skillTagFilter(player, tag, target) {
                        if (player != target || player.storage.mininiepan) return false;
                    },
                    result: {
                        player(player) {
                            if (player.hp <= 0) return 10;
                            if (player.hp <= 2 && player.countCards('he') <= 1) return 10;
                            return 0;
                        }
                    },
                },
            },
            minitiaoxin: {
                audio: 'tiaoxin',
                audioname: ['ol_jiangwei', 'sp_jiangwei', 'xiahouba'],
                audioname2: { Mfight_jiangwei: 'minifightyilve' },
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return game.hasPlayer(current => {
                        return current.countDiscardableCards(player, 'h') && current != player;
                    });
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), (card, player, target) => {
                        return target.countDiscardableCards(player, 'h') && target != player;
                    }).set('ai', target => {
                        const player = get.player();
                        if (target.countDiscardableCards(player, 'h') >= 2) return get.effect(target, { name: 'guohe_copy2' }, player, player) * 2;
                        return get.effect(target, { name: 'guohe_copy2' }, player, player);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const [target] = event.targets;
                    if (target.countDiscardableCards(player, 'h')) {
                        const result = await player.discardPlayerCard(target, 'h', [1, 2], true).forResult();
                        if (result?.cards?.some(card => card.name == 'sha')) {
                            event.minitiaoxin = true;
                            if (player.countCards('he')) await player.chooseToDiscard(true, 'he');
                        }
                    }
                },
            },
            minizhiji: {
                audio: 'olzhiji',
                juexingji: true,
                trigger: { player: 'phaseZhunbeiBegin' },
                forced: true,
                filter(event, player) {
                    return player.countCards('h') == 0;
                },
                skillAnimation: true,
                animationColor: 'fire',
                content() {
                    'step 0'
                    player.awakenSkill('minizhiji');
                    player.chooseDrawRecover(2, true);
                    'step 1'
                    player.loseMaxHp();
                    'step 2'
                    player.addSkills(lib.skill[event.name].derivation);
                },
                derivation: 'minireguanxing',
            },
            minihuoshou: {
                audio: 'huoshou1',
                audioname: ['re_menghuo'],
                trigger: { global: 'useCard' },
                filter(event, player) {
                    return event.card.name == 'nanman' && event.player !== player;
                },
                forced: true,
                content() {
                    trigger.customArgs.default.customSource = player;
                    player.draw();
                },
                ai: {
                    halfneg: true,
                    effect: {
                        target(card, player, target) {
                            if (card.name === 'nanman') return 0;
                        },
                    },
                },
                group: 'huoshou1',
            },
            minirehuoshou: {
                onremove: true,
                inherit: 'minihuoshou',
                group: ['huoshou1', 'minirehuoshou_gain', 'minirehuoshou_nanmaned'],
                subSkill: {
                    gain: {
                        audio: 'huoshou1',
                        audioname: ['re_menghuo'],
                        trigger: { player: 'phaseUseBegin' },
                        forced: true,
                        async content(event, trigger, player) {
                            const card = get.discardPile(card => card.name == 'nanman');
                            if (card) {
                                await player.gain(card, 'gain2');
                            } else {
                                game.log('但是弃牌堆里并没有', '#y南蛮入侵', '！');
                                player.addMark(event.name, 1, false);
                                if (player.countMark(event.name) >= 5 && Math.random() < 0.25) player.chat('我南蛮呢');
                            }
                        },
                    },
                    nanmaned: {
                        charlotte: true,
                        trigger: { player: 'useCard1' },
                        filter(event, player) {
                            return event.card.name == 'nanman';
                        },
                        silent: true,
                        firstDo: true,
                        content() {
                            player.addTempSkill('minirehuoshou_ban', 'phaseUseAfter');
                        },
                    },
                    ban: {
                        charlotte: true,
                        mark: true,
                        marktext: '<span style="text-decoration: line-through;">蛮</span>',
                        intro: { content: '不能使用【南蛮入侵】' },
                        mod: {
                            cardEnabled(card, player) {
                                if (card.name === 'nanman') return false;
                            },
                        },
                    },
                },
            },
            minizaiqi: {
                audio: 'zaiqi',
                trigger: { player: 'phaseDrawBegin1', },
                filter(event, player) {
                    return !event.numFixed && player.isDamaged();
                },
                check(event, player) {
                    if (player.getDamagedHp() < 2) {
                        return false;
                    } else if (player.getDamagedHp() == 2) {
                        return player.countCards('h') >= 2;
                    }
                    return true;
                },
                async content(event, trigger, player) {
                    trigger.changeToZero();
                    if (player.isHealthy()) return;
                    let cards = get.cards(player.getDamagedHp(), true);
                    await player.showCards(event.cards);
                    let num = cards.filter(card => get.suit(card) == 'heart');
                    cards = cards.filter(card => get.suit(card) != 'heart');
                    if (num) await player.recover(num);
                    if (cards.length) await player.gain(cards, 'gain2');
                },
                ai: {
                    threaten(player, target) {
                        if (target.hp == 1) return 2;
                        if (target.hp == 2) return 1.5;
                        return 1;
                    },
                },
            },
            minirezaiqi: {
                audio: 'rezaiqi',
                trigger: { player: ['phaseDrawBegin1', 'phaseJieshuBegin'] },
                filter(event, player) {
                    if (event.name == 'phaseJieshu') return player.hasHistory('sourceDamage');
                    return !event.numFixed && player.isDamaged();
                },
                check(event, player) {
                    if (event.name == 'phaseJieshu') return true;
                    if (player.getDamagedHp() < 2) {
                        return false;
                    } else if (player.getDamagedHp() == 2) {
                        return player.countCards('h') >= 2;
                    }
                    return true;
                },
                async content(event, trigger, player) {
                    if (trigger.name == 'phaseDraw') trigger.changeToZero();
                    const number = player.getHistory('sourceDamage').reduce((sum, evt) => sum + evt.num, 0);
                    event.cards = get.cards(trigger.name == 'phaseJieshu' ? number : player.getDamagedHp());
                    await game.cardsGotoOrdering(event.cards);
                    await player.showCards(event.cards);
                    let num = 0;
                    for (let i = 0; i < event.cards.length; i++) {
                        if (get.suit(event.cards[i]) == 'heart') {
                            num++;
                            event.cards.splice(i--, 1);
                        }
                    }
                    if (num) await player.recover(num);
                    if (event.cards.length) {
                        await player.gain(event.cards, 'gain2');
                    }
                },
                ai: {
                    threaten(player, target) {
                        if (target.hp == 1) return 2;
                        if (target.hp == 2) return 1.5;
                        return 1;
                    },
                },
            },
            minifangquan: {
                audio: 'fangquan',
                trigger: { player: 'phaseUseBefore' },
                filter(event, player) {
                    return !player.hasSkill('minifangquan2');
                },
                direct: true,
                preHidden: true,
                content() {
                    'step 0'
                    var fang = player.countMark('minifangquan2') == 0 && player.hp >= 2 && player.countCards('h') <= player.hp + 1;
                    player.chooseBool(get.prompt2('minifangquan')).set('ai', function () {
                        if (!_status.event.fang) return false;
                        return game.hasPlayer(function (target) {
                            if (target.hasJudge('lebu') || target == player) return false;
                            if (get.attitude(player, target) > 4) {
                                return (get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards('h') + 1) > 0);
                            }
                            return false;
                        });
                    }).set('fang', fang).setHiddenSkill(event.name);
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minifangquan');
                        trigger.cancel();
                        player.addTempSkill('minifangquan2');
                    }
                },
            },
            minifangquan2: {
                trigger: { player: 'phaseEnd' },
                forced: true,
                popup: false,
                audio: false,
                onremove: true,
                content() {
                    'step 0'
                    player.chooseTarget('放权：请选择进行额外回合的目标角色', lib.filter.notMe).ai = function (target) {
                        if (target.hasJudge('lebu')) return -1;
                        if (get.attitude(player, target) > 4) {
                            return get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards('h') + 1);
                        }
                        return -1;
                    };
                    'step 1'
                    var target = result.targets[0];
                    player.line(target, 'fire');
                    target.markSkillCharacter('minifangquan', player, '放权', '进行一个额外回合');
                    target.insertPhase();
                    target.addSkill('minifangquan3');
                }
            },
            minifangquan3: {
                trigger: { player: ['phaseAfter', 'phaseCancelled'] },
                forced: true,
                popup: false,
                audio: false,
                content() {
                    player.unmarkSkill('minifangquan');
                    player.removeSkill('minifangquan3');
                },
            },
            miniruoyu: {
                keepSkill: true,
                derivation: 'minirejijiang',
                audio: 'ruoyu',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return player.isMinHp();
                },
                forced: true,
                juexingji: true,
                zhuSkill: true,
                skillAnimation: true,
                animationColor: 'fire',
                content() {
                    'step 0'
                    player.awakenSkill('miniruoyu');
                    player.gainMaxHp();
                    'step 1'
                    player.recover();
                    'step 2'
                    player.addSkills('minirejijiang');
                    'step 3'
                    if (player.isZhu2()) event.trigger('zhuUpdate');
                },
            },
            //小胖
            minixiangle: {
                audio: 'xiangle',
                inherit: 'xiangle',
                group: 'minixiangle_fangquan',
                subSkill: {
                    fangquan: {
                        audio: 'xiangle',
                        audioname: ['ol_liushan'],
                        trigger: { global: 'roundEnd' },
                        filter(event, player) {
                            if (!player.hasSkill('minirefangquan')) return false;
                            return !player.getRoundHistory('useCard', lib.filter.all).length && game.hasPlayer(current => current != player);
                        },
                        async cost(event, trigger, player) {
                            const num = Math.floor(player.getSeatNum() / 2);
                            event.result = await player.chooseCardTarget({
                                prompt: get.prompt('minixiangle_fangquan'),
                                prompt2: (num > 0 ? ('弃置' + get.cnNumber(num) + '张牌，') : '') + '令一名其他角色进行一个额外回合',
                                position: 'he',
                                filterTarget: lib.filter.notMe,
                                filterCard(card, player) {
                                    if (get.event().num <= 0) return false;
                                    return lib.filter.cardDiscardable(card, player);
                                },
                                selectCard() {
                                    return get.event().num <= 0 ? -1 : get.event().num;
                                },
                                ai1(card) {
                                    return 3 / (Math.abs(get.value(card)) + 0.1);
                                },
                                ai2(target) {
                                    const player = get.player();
                                    if (target.hasJudge('lebu')) return -1;
                                    if (get.attitude(player, target) > 4) {
                                        return get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards('h') + 1);
                                    }
                                    return -1;
                                },
                            }).set('num', num).forResult();
                        },
                        async content(event, trigger, player) {
                            const target = event.targets[0];
                            await player.logSkill('minirefangquan', target);
                            if (event.cards?.length) await player.discard(event.cards);
                            await player.turnOver();
                            if (player.countCards('he')) {
                                await player.chooseToGive(target, 'he', [1, Infinity]).set('prompt', '放权：是否交给' + get.translation(target) + '任意张牌？');
                            }
                            target.markSkillCharacter('minirefangquan', player, '放权', '进行一个额外回合');
                            target.insertPhase();
                            target.addSkill('minirefangquan3');
                        },
                    },
                },
            },
            minirefangquan: {
                audio: 'olfangquan',
                trigger: { player: 'phaseUseBefore' },
                filter(event, player) {
                    return !player.hasSkill('minirefangquan3');
                },
                async cost(event, trigger, player) {
                    const fang = player.countMark('minirefangquan2') == 0 && player.hp >= 2 && player.countCards('h') <= player.hp + 2;
                    event.result = await player.chooseBool(get.prompt2(event.name.slice(0, -5))).set('ai', function () {
                        if (!_status.event.fang) return false;
                        return game.hasPlayer(function (target) {
                            if (target.hasJudge('lebu') || target == player) return false;
                            if (get.attitude(player, target) > 4) {
                                return get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards('h') + 1) > 0;
                            }
                            return false;
                        });
                    }).set('fang', fang).forResult();
                },
                async content(event, trigger, player) {
                    trigger.cancel();
                    player.addTempSkill('minirefangquan2');
                    player.addMark('minirefangquan2', 1, false);
                },
            },
            minirefangquan2: {
                inherit: 'olfangquan2',
                async content(event, trigger, player) {
                    let num = player.countMark(event.name);
                    player.removeMark(event.name, num, false);
                    while (num--) {
                        const result = await player.chooseTarget('请选择进行额外回合的目标角色', lib.filter.notMe).set('ai', target => {
                            const player = get.player();
                            if (target.hasJudge('lebu')) return -1;
                            if (get.attitude(player, target) > 4) {
                                return get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards("h") + 1);
                            }
                            return -1;
                        }).forResult();
                        if (result?.targets?.length) {
                            const target = result.targets[0];
                            player.line(target, 'fire');
                            if (player.countCards('he')) {
                                await player.chooseToGive(target, 'he', [1, Infinity]).set('prompt', '放权：是否交给' + get.translation(target) + '任意张牌？');
                            }
                            target.markSkillCharacter('minirefangquan', player, '放权', '进行一个额外回合');
                            target.insertPhase();
                            target.addSkill('minirefangquan3');
                        }
                    }
                },
            },
            minirefangquan3: {
                inherit: 'olfangquan3',
                async content(event, trigger, player) {
                    player.unmarkSkill('minirefangquan');
                    player.removeSkill('minirefangquan3');
                },
            },
            minireruoyu: {
                audio: 'olruoyu',
                inherit: 'olruoyu',
                derivation: ['minirejijiang', 'sishu'],
                filter(event, player) {
                    if (!player.hasZhuSkill('minireruoyu')) return false;
                    return player.isMinHp();
                },
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    await player.gainMaxHp();
                    await player.recover();
                    await player.addSkills(get.info(event.name).derivation);
                },
            },
            minixuanhuo: {
                audio: 'xinxuanhuo',
                trigger: { player: 'phaseDrawBegin1' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minixuanhuo'), function (card, player, target) {
                        return player != target;
                    }).set('ai', function (target) {
                        var att = get.attitude(_status.event.player, target);
                        if (target.countCards('he') == 0) return 0;
                        if (att < 0) return -att * 2;
                        return att / 3;
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minixuanhuo', result.targets);
                        event.target = result.targets[0];
                    }
                    else event.finish();
                    'step 2'
                    player.chooseTarget('眩惑：请选择' + get.translation(target) + '出杀的目标', true, function (card, player, target) {
                        return _status.event.target.canUse('sha', target);
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        if (!_status.event.target.canUse('sha', target) && get.attitude(player, _status.event.target) < 0) return 8 + get.attitude(player, target);
                        if (!_status.event.target.inRange(target) && get.attitude(player, _status.event.target) < 0) return 5 + get.attitude(player, target);
                        return get.effect(target, { name: 'sha' }, _status.event.target, player);
                    }).set('target', event.target);
                    'step 3'
                    if (result.bool && result.targets.length) {
                        game.log(player, '指定的出杀目标为', result.targets[0]);
                        event.target.line(result.targets[0]);
                        target.chooseToUse(function (card, player, event) {
                            if (get.name(card) != 'sha') return false;
                            return lib.filter.filterCard.apply(this, arguments);
                        }, '眩惑：对' + get.translation(result.targets[0]) + '使用一张杀，或令' + get.translation(player) + '获得你的一张牌').set('targetRequired', true).set('complexSelect', true).set('filterTarget', function (card, player, target) {
                            if (target != _status.event.sourcex && !ui.selected.targets.includes(_status.event.sourcex)) return false;
                            return lib.filter.filterTarget.apply(this, arguments);
                        }).set('sourcex', result.targets[0]);
                    }
                    else event.bool = true;
                    'step 4'
                    if (event.bool || result.bool == false) player.gainPlayerCard('he', event.target, true);
                },
            },
            minienyuan: {
                group: 'minienyuan_draw',
                subfrequent: ['draw'],
                audio: 'xinenyuan',
                trigger: { player: 'gainEnd' },
                filter(event, player) {
                    return event.source && event.source.isIn() && event.source != player;
                },
                logTarget: 'source',
                check(event, player) {
                    return get.attitude(player, event.source) > 0;
                },
                content() {
                    trigger.source.draw();
                },
                subSkill: {
                    draw: {
                        audio: 'xinenyuan',
                        trigger: { global: 'gainAfter' },
                        filter(event, player) {
                            if (event.player != player) {
                                var evt = event.getl(player);
                                return evt?.hs?.length > 0;
                            }
                            return false;
                        },
                        preHidden: true,
                        forced: true,
                        locked: false,
                        content() {
                            player.draw();
                        },
                    },
                },
            },
            minireenyuan: {
                audio: 'reenyuan',
                inherit: 'minienyuan',
                group: ['minienyuan_draw', 'minireenyuan_damage'],
                subSkill: {
                    damage: {
                        audio: 'reenyuan',
                        trigger: { player: 'damageEnd' },
                        logTarget: 'source',
                        filter(event, player) {
                            return event.source && event.source != player && event.source.isIn() && event.num > 0;
                        },
                        getIndex(event, player, triggername) {
                            return event.num;
                        },
                        check(event, player) {
                            const att = get.attitude(player, event.source);
                            const num = event.source.countCards("h");
                            if (att <= 0) return true;
                            if (num > 2) return true;
                            if (num) return att < 4;
                            return false;
                        },
                        prompt2: '令该角色选择一项：①失去1点体力。②交给你一张红色手牌。若此牌不为♥，则你摸一张牌。',
                        async content(event, trigger, player) {
                            const { source } = trigger;
                            const result = !source.countCards('h', { color: 'red' }) ? { bool: false } : await source.chooseToGive('h', player, `恩怨：将一张红色手牌交给${get.translation(player)}，否则失去1点体力`, { color: 'red' }).set('ai', card => {
                                const { player, target } = get.event();
                                if (get.attitude(player, target) > 0) {
                                    if (get.suit(card) != 'heart') return 15 - get.value(card);
                                    return 11 - get.value(card);
                                } else {
                                    let num = 12 - player.hp * 2;
                                    if (get.suit(card) != 'heart') num -= 2;
                                    return num - get.value(card);
                                }
                            }).forResult();
                            if (!result.bool) await source.loseHp();
                            else if (get.suit(result.cards[0]) != 'heart') await player.draw();
                        }
                    }
                }
            },
            minirexuanhuo: {
                audio: 'rexuanhuo',
                trigger: { player: 'phaseDrawEnd' },
                filter(event, player) {
                    return player.countCards('h') /* && game.countPlayer() > 2 */;
                },
                async cost(event, trigger, player) {
                    const ai2 = function (target) {
                        const player = get.player();
                        const goon = game.hasPlayer(current => get.attitude(player, current) > 0 && player != current);
                        if (get.attitude(player, target) <= 0 && goon) return 0;
                        const list = [null, 'juedou'].concat(lib.inpile_nature);
                        if (target.hasSkill('ayato_zenshen')) list.push('kami');
                        let num = Math.max.apply(Math, list.map(i => {
                            if (i == 'juedou') return target.getUseValue({ name: 'juedou', isCard: true }, false);
                            const card = { name: 'sha', nature: i, isCard: true };
                            return target.getUseValue(card, false);
                        }));
                        if (goon) num += 1;
                        if (target.hasSkillTag('nogain')) num /= 4;
                        return num;
                    };
                    event.result = await player.chooseCardTarget({
                        prompt: get.prompt2(event.name.slice(0, -5)),
                        filterCard: true,
                        selectCard: [1, 2],
                        position: 'h',
                        filterTarget: lib.filter.notMe,
                        goon: game.hasPlayer(current => current != player && ai2(player, current) > 0) || game.countPlayer() == 2,
                        ai1(card) {
                            if (!_status.event.goon) return 0;
                            return 7 - get.value(card);
                        },
                        ai2: ai2,
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const { targets: [target], cards } = event;
                    await player.give(cards, target);
                    const targetsx = game.filterPlayer(current => {
                        if (current == player || current == target) return false;
                        const list = lib.inpile_nature.slice(0);
                        list.unshift(null);
                        if (target.hasSkill('ayato_zenshen')) list.add('kami');
                        return list.some(nature => target.canUse({ name: 'sha', isCard: true, nature: nature }, current, false)) || target.canUse({ name: 'juedou', isCard: true }, current, false);
                    });
                    const goon = targetsx.length > 0;
                    if (!goon && !target.countCards('h')) return;
                    let result;
                    if (goon && target.countCards('h')) {
                        result = await target.chooseControl().set('choiceList', [`视为对${get.translation(player)}选择的另一名其他角色使用任意一种【杀】或【决斗】`, `${get.translation(player)}观看并获得你任意张牌`]).set('ai', () => {
                            return [0, 1].randomGet();
                        }).forResult();
                    }
                    else result = { index: goon ? 0 : 1 };
                    if (result.index == 1) await player.gainPlayerCard(target, 'h', [1, Infinity], true, 'visible').set('ai', button => {
                        const { player, target } = get.event(), { link } = button;
                        const att = get.attitude(player, target);
                        if (att > 0) {
                            if (ui.selected.buttons.length > 1) return 0;
                            return 6 - get.value(link);
                        }
                        return 1;
                    });
                    else {
                        const result = await player.chooseTarget((card, player, target) => {
                            return get.event().targetsx.includes(target);
                        }, `选择${get.translation(target)}使用【杀】或【决斗】的目标`, true).set('target', target).set('ai', target => {
                            const evt = _status.event;
                            const list = [null, 'juedou'].concat(lib.inpile_nature);
                            if (evt.target.hasSkill('ayato_zenshen')) list.push('kami');
                            return Math.max.apply(Math, list.map(i => {
                                const card = { name: 'sha', isCard: true };
                                if (i == 'juedou') card.name = 'juedou';
                                else if (i) card.nature = i;
                                if (!evt.target.canUse(card, target, false)) return 0;
                                return get.effect(target, card, evt.target, evt.player);
                            }));
                        }).set('targetsx', targetsx).forResult();
                        if (!result?.targets?.length) return;
                        const target2 = result.targets[0];
                        player.line(target2);
                        game.log(player, '选择了', target2);
                        const list = lib.inpile_nature.slice(0);
                        list.unshift(null);
                        const vcards = [];
                        if (target.hasSkill('ayato_zenshen')) list.add('kami');
                        for (const i of list) {
                            if (target.canUse({ name: 'sha', isCard: true, nature: i }, target2, false)) vcards.push(['基本', '', 'sha', i]);
                        }
                        if (target.canUse({ name: 'juedou', isCard: true }, target2, false)) vcards.push(['基本', '', 'juedou']);
                        if (!vcards.length) return;
                        const links = vcards.length == 1 ? vcards : (await target.chooseButton([`请选择要对${get.translation(target2)}使用的牌`, [vcards, 'vcard']], true).set("ai", button => {
                            const player = get.player();
                            return get.effect(get.event().target2, { name: button.link[2], isCard: true, nature: button.link[3] }, player, player);
                        }).set('target2', target2).forResult().links);
                        if (!links?.length) return;
                        await target.useCard({ name: links[0][2], isCard: true, nature: links[0][3] }, false, target2);
                    }
                },
            },
            miniqianxi: {
                audio: 'qianxi',
                trigger: { player: 'phaseZhunbeiBegin' },
                preHidden: true,
                content() {
                    'step 0'
                    player.draw(2).gaintag = ['miniqianxi'];
                    player.chooseToDiscard('hes', true, function (card, player) {
                        return card.hasGaintag('miniqianxi');
                    });
                    'step 1'
                    player.removeGaintag('miniqianxi');
                    if (!result.bool) {
                        event.finish();
                        return;
                    }
                    event.color = get.color(result.cards[0]);
                    player.chooseTarget(function (card, player, target) {
                        return player != target && get.distance(player, target) <= 1;
                    }, true).set('ai', function (target) {
                        return -get.attitude(_status.event.player, target);
                    });
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target, 'green');
                        game.log(player, '选择了', target);
                        target.storage.miniqianxi2 = event.color;
                        target.addTempSkill('miniqianxi2');
                        //game.addVideo('storage',target,['miniqianxi2',event.color]);
                    }
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (!arg.target.hasSkill('miniqianxi2')) return false;
                        if (arg.card.name == 'sha') return arg.target.storage.miniqianxi2 == 'red' && (!arg.target.getEquip('bagua') || player.hasSkillTag('unequip', false, {
                            name: arg.card ? arg.card.name : null,
                            target: arg.target,
                            card: arg.card
                        }) || player.hasSkillTag('unequip_ai', false, {
                            name: arg.card ? arg.card.name : null,
                            target: arg.target,
                            card: arg.card
                        }));
                        return arg.target.storage.miniqianxi2 == 'black';
                    }
                },
            },
            miniqianxi2: {
                forced: true,
                mark: true,
                audio: false,
                content() {
                    player.removeSkill('miniqianxi2');
                    delete player.storage.miniqianxi2;
                },
                mod: {
                    cardEnabled2(card, player) {
                        if (get.color(card) == player.storage.miniqianxi2 && get.position(card) == 'h') return false;
                    },
                },
                intro: {
                    content(color) {
                        return '不能使用或打出' + get.translation(color) + '手牌';
                    },
                },
            },
            minilongyin: {
                audio: 'relongyin',
                trigger: { global: 'useCard' },
                direct: true,
                filter(event, player) {
                    return event.card.name == 'sha' && player.countCards('he') && event.player.isPhaseUsing();
                },
                content() {
                    'step 0'
                    game.delayx();
                    var go = false;
                    if (get.attitude(player, trigger.player) > 0) {
                        if (get.color(trigger.card) == 'red') {
                            go = true;
                        }
                        else if (trigger.addCount === false || !trigger.player.isPhaseUsing()) go = false;
                        else if (!trigger.player.hasSkill('paoxiao') &&
                            !trigger.player.hasSkill('tanlin3') &&
                            !trigger.player.hasSkill('zhaxiang2') &&
                            !trigger.player.hasSkill('fengnu') &&
                            !trigger.player.getEquip('zhuge')) {
                            var nh = trigger.player.countCards('h');
                            if (player == trigger.player) {
                                go = (player.countCards('h', 'sha') > 0);
                            }
                            else if (nh >= 4) {
                                go = true;
                            }
                            else if (player.countCards('h', 'sha')) {
                                if (nh == 3) {
                                    go = Math.random() < 0.8;
                                }
                                else if (nh == 2) {
                                    go = Math.random() < 0.5;
                                }
                            }
                            else if (nh >= 3) {
                                if (nh == 3) {
                                    go = Math.random() < 0.5;
                                }
                                else if (nh == 2) {
                                    go = Math.random() < 0.2;
                                }
                            }
                        }
                    }
                    var next = player.chooseToDiscard(get.prompt('minilongyin'), '弃置一张牌' + (get.color(trigger.card) == 'red' ? '并摸一张牌' : '') + '，令' + get.translation(trigger.player) + '本次使用的【杀】不计入使用次数', 'he');
                    next.logSkill = ['minilongyin', trigger.player];
                    next.set('ai', function (card) {
                        if (_status.event.go) {
                            return 6 - get.value(card);
                        }
                        return 0;
                    });
                    next.set('go', go);
                    'step 1'
                    if (result.bool) {
                        if (trigger.addCount !== false) {
                            trigger.addCount = false;
                            trigger.player.getStat().card.sha--;
                        }
                        if (get.color(trigger.card) == 'red') {
                            player.draw();
                        }
                        if (get.suit(result.cards[0], player) == get.suit(trigger.card)) player.restoreSkill('jiezhong');
                    }
                },
                ai: { expose: 0.2 },
            },
            minixiansi: {
                audio: 'xiansi',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current != player && current.countDiscardableCards(player, 'he');
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    event.bilibili = false;
                    player.chooseTarget(get.prompt2('minixiansi'), [1, 2], function (card, player, target) {
                        return target != player && target.countDiscardableCards(player, 'he');
                    }).set('ai', function (target) {
                        var num = 1, player = _status.event.player;
                        if (!target.inRange(player) || !target.canUse({ name: 'sha', isCard: true }, player, false)) num = 3;
                        return get.effect(target, { name: 'guohe_copy2' }, player, player) * num;
                    });
                    'step 1'
                    if (result.bool) {
                        if (result.targets.length == 1) event.bilibili = true;
                        result.targets.sortBySeat();
                        player.logSkill('minixiansi', result.targets);
                        event.targets = result.targets;
                    }
                    else event.finish();
                    'step 2'
                    if (event.targets.length) {
                        var target = event.targets.shift();
                        event.target = target;
                        player.discardPlayerCard(target, 'he', true);
                    }
                    else event.goto(4);
                    'step 3'
                    if (result.bool) {
                        if (result.cards[0].original == 'e' && target.inRange(player) && target.canUse({ name: 'sha', isCard: true }, player, false)) target.useCard({ name: 'sha', isCard: true }, player, false);
                        event.goto(2);
                    }
                    'step 4'
                    if (event.bilibili) player.draw();
                },
            },
            minibingzheng: {
                audio: 'bingzheng',
                trigger: { player: 'phaseUseEnd' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minibingzheng')).set('ai', function (target) {
                        var player = _status.event.player;
                        var att = get.attitude(player, target);
                        var nh = target.countCards('h');
                        if (att > 0) {
                            if (nh == target.hp - 1) {
                                if (player == target) return att + 1;
                                return att + 2;
                            }
                            if (player == target && player.needsToDiscard()) return att / 3;
                            return att;
                        }
                        else {
                            if (nh == target.hp + 1) return -att;
                            if (nh == 0) return 0;
                            return -att / 2;
                        }
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minibingzheng', target);
                        if (target.countCards('h')) {
                            player.chooseControl().set('choiceList', [
                                '令' + get.translation(target) + '摸一张牌',
                                '令' + get.translation(target) + '弃置一张手牌'
                            ]).set('ai', function () {
                                return get.attitude(player, target) > 0 ? 0 : 1;
                            });
                        }
                        else event._result = { index: 0 };
                    }
                    else event.finish();
                    'step 2'
                    if (result.index == 0) target.draw();
                    else target.chooseToDiscard('h', true);
                    'step 3'
                    if (target.countCards('h') == target.hp) {
                        player.draw();
                        if (target == player) { event.finish(); return; }
                        var next = player.chooseCard('是否交给' + get.translation(target) + '一张牌？', 'he');
                        next.set('ai', function (card) {
                            if (_status.event.du && card.name == 'du') return 114514 + 1919810;
                            if (get.position(card) != 'h') return 0;
                            if (_status.event.shan && card.name == 'shan') return 11;
                            if (_status.event.goon) return 10 - get.value(card);
                            return -get.value(card);
                        });
                        if (get.attitude(player, target) > 1 && player.countCards('h', 'shan') > 1 && player.countCards('h') > target.countCards('h')) next.set('shan', true);
                        if (get.attitude(player, target) > 0 && player.needsToDiscard()) next.set('goon', true);
                        if (get.attitude(player, target) <= 0) next.set('du', true);
                    }
                    else event.finish();
                    'step 4'
                    if (result.bool) target.gain(result.cards, player, 'giveAuto');
                },
            },
            miniliangzhu: {
                audio: 'liangzhu',
                trigger: { global: 'recoverAfter' },
                filter(event, player) {
                    return event.player.isPhaseUsing();
                },
                direct: true,
                content() {
                    'step 0'
                    var list = ['摸一张', '摸两张'];
                    if (trigger.player.getEquips(1).length) list.push('拿武器');
                    list.push('cancel2');
                    player.chooseControl(list).set('prompt', get.prompt2('miniliangzhu')).set('ai', function () {
                        var player = _status.event.player;
                        var trigger = _status.event.getTrigger();
                        if (get.attitude(player, trigger.player) > 0) return '摸两张';
                        return '摸一张';
                    });
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('miniliangzhu', trigger.player);
                        switch (result.control) {
                            case '摸一张':
                                player.draw();
                                break;
                            case '摸两张':
                                trigger.player.draw(2);
                                break;
                            case '拿武器':
                                player.gain(trigger.player.getEquips(1), trigger.player, 'give');
                                break;
                        }
                    }
                },
            },
            minifanxiang: {
                skillAnimation: true,
                animationColor: 'fire',
                audio: 'fanxiang',
                juexingji: true,
                forceunique: true,
                derivation: ['xiaoji', 'miniwujian'],
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return player.getAllHistory('useSkill', function (evt) {
                        return evt.skill == 'miniliangzhu';
                    }).length;
                },
                forced: true,
                content() {
                    'step 1'
                    player.awakenSkill('minifanxiang');
                    player.gainMaxHp();
                    player.recover();
                    'step 2'
                    player.addSkills(lib.skill[event.name].derivation);
                    'step 3'
                    player.removeSkills('miniliangzhu');
                },
            },
            miniwujian: {
                audio: 'ext:活动武将/audio/skill:2',
                audioname2: { Mbaby_sb_sunshangxiang: 'miniwujian_Mbaby_sb_sunshangxiang' },
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('e', function (card) {
                        return !player.getStorage('miniwujian_alka').includes(get.subtype(card));
                    });
                },
                filterTarget(card, player, target) {
                    return target != player && player.canUse({ name: 'sha' }, target);
                },
                position: 'e',
                filterCard(card, player) {
                    return !player.getStorage('miniwujian_alka').includes(get.subtype(card));
                },
                check(card) {
                    return 1 / (get.value(card) || 0.5);
                },
                content() {
                    player.addTempSkill('miniwujian_alka');
                    player.markAuto('miniwujian_alka', [get.subtype(cards[0])]);
                    player.useCard({ name: 'sha' }, target, false);
                },
                ai: {
                    order(item, player) {
                        return get.order({ name: 'sha' }, player) + 1;
                    },
                    result: {
                        target(player, target) {
                            return get.effect(target, { name: 'sha' }, player, target);
                        },
                    },
                },
                subSkill: {
                    alka: { charlotte: true, onremove: true },
                    Mbaby_sb_sunshangxiang: { audio: 'ext:活动武将/audio/skill:2' },
                },
            },
            minijujian: {
                audio: 'xinjujian',
                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                filter(event, player) {
                    return player.countCards('he') > player.countCards('he', { type: 'basic' });
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseCardTarget({
                        filterTarget: true,
                        filterCard(card, player) {
                            return get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player);
                        },
                        ai1(card) {
                            if (get.tag(card, 'damage') && get.type(card) == 'trick') {
                                return 20;
                            }
                            return 9 - get.value(card);
                        },
                        ai2(target) {
                            var att = get.attitude(_status.event.player, target);
                            if (att > 0) {
                                if (target.isTurnedOver()) att += 3;
                                if (target.hp == 1) att += 3;
                            }
                            return att;
                        },
                        position: 'he',
                        prompt: get.prompt2('minijujian')
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minijujian', target);
                        player.discard(result.cards);
                        if (target.hp == target.maxHp &&
                            !target.isTurnedOver() &&
                            !target.isLinked()) {
                            target.draw(2);
                            event.finish();
                        }
                        else {
                            var controls = ['draw_card'];
                            if (target.hp < target.maxHp) {
                                controls.push('recover_hp');
                            }
                            if (target.isLinked() | target.isTurnedOver()) {
                                controls.push('reset_character');
                            }
                            target.chooseControl(controls).ai = function () {
                                if (target.isTurnedOver()) {
                                    return 'reset_character';
                                }
                                else if (target.hp == 1 && target.maxHp > 2) {
                                    return 'recover_hp';
                                }
                                else if (target.hp == 2 && target.maxHp > 2 && target.countCards('h') > 1) {
                                    return 'recover_hp';
                                }
                                else {
                                    return 'draw_card';
                                }
                            }
                        }
                    }
                    else event.finish();
                    'step 2'
                    event.control = result.control;
                    switch (event.control) {
                        case 'recover_hp': event.target.recover(); event.finish(); break;
                        case 'draw_card': event.target.draw(2); event.finish(); break;
                        case 'reset_character': if (event.target.isTurnedOver()) event.target.turnOver(); break;
                    }
                    'step 3'
                    if (event.control == 'reset_character' && event.target.isLinked()) event.target.link();
                },
            },
            //关银屏
            minihuxiao: {
                audio: 'huxiao',
                inherit: 'huxiao',
                async content(event, trigger, player) {
                    player.addTempSkill(event.name + '_effect');
                    player.markAuto(event.name + '_effect', [trigger.player]);
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        mod: {
                            cardUsableTarget(card, player, target) {
                                if (player.getStorage('minihuxiao_effect').includes(target)) return true;
                            },
                        },
                        intro: { content: '本回合对$使用牌无次数限制' },
                    },
                },
            },
            miniwuji: {
                audio: 'wuji',
                inherit: 'wuji',
                filter(event, player) {
                    return player.getStat('damage') >= 3;
                },
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    await player.gainMaxHp();
                    await player.recover();
                    player.storage.minirehuxiao = true;
                    const card = get.cardPile('qinglong', 'field');
                    if (card) await player.gain(card, 'gain2');
                },
            },
            minixueji: {
                audio: 'xueji',
                inherit: 'xueji',
                selectTarget() {
                    const player = get.player();
                    return [1, 1 + player.getDamagedHp()];
                },
            },
            minirehuxiao: {
                audio: 'huxiao',
                inherit: 'huxiao',
                async content(event, trigger, player) {
                    await player.draw();
                    player.addTempSkill(event.name + '_effect');
                    player.markAuto(event.name + '_effect', [trigger.player]);
                },
                group: 'minirehuxiao_gain',
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        mod: {
                            cardUsableTarget(card, player, target) {
                                if (player.getStorage('minirehuxiao_effect').includes(target)) return true;
                            },
                        },
                        intro: { content: '本回合对$使用牌无次数限制' },
                    },
                    gain: {
                        audio: 'huxiao',
                        trigger: { player: 'phaseBegin' },
                        filter(event, player) {
                            return player.storage.minirehuxiao;
                        },
                        forced: true,
                        async content(event, trigger, player) {
                            const card = get.cardPile(card => get.color(card) == 'red' && card.name == 'sha');
                            if (card) await player.gain(card, 'gain2');
                        }
                    }
                },
            },
            minirehuxiao_rewrite: { nopop: true },
            minirewuji: {
                audio: 'wuji',
                inherit: 'wuji',
                filter(event, player) {
                    return player.getStat('damage') >= 3;
                },
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    player.storage.minirehuxiao = true;
                    await player.gainMaxHp();
                    await player.recover();
                    const card = get.cardPile('qinglong', 'field');
                    if (card) await player.gain(card, 'gain2');
                },
                derivation: 'minirehuxiao_rewrite',
            },
            // 马参军
            miniresanyao: {
                audio: 'resanyao',
                enable: 'phaseUse',
                usable: 1,
                selectCard() {
                    var player = _status.event.player;
                    return [Math.max(1, ui.selected.targets.length), Math.min(4, game.players.length - 1)];
                },
                selectTarget() {
                    return ui.selected.cards.length;
                },
                filterTarget: lib.filter.notMe,
                check(card) {
                    var player = _status.event.player;
                    if (game.countPlayer(function (target) {
                        return target != player && get.effect(target, 'sanyao', player, player) > 0;
                    }) <= ui.selected.cards.length) return 0;
                    return 7 - get.value(card);
                },
                position: 'he',
                filterCard: true,
                content() {
                    target.damage('nocard');
                },
                ai: {
                    result: {
                        target(player, target) {
                            var disbool = false;
                            if (player.hasSkill('rezhiman')) {
                                if (target.countCards('j') && get.attitude(player, target) > 0) {
                                    return 1;
                                }
                                if (target.countCards('he', function (card) {
                                    return card.name == 'tengjia' || get.value(card) > 0;
                                })) {
                                    disbool = true;
                                }
                            }
                            var damage = get.damageEffect(target, player);
                            if (disbool && get.attitude(player, target) < 0) return Math.min(-1, damage);
                            return damage;
                        },
                    },
                    order: 7,
                },
            },
            minisanyao: {
                audio: 'sanyao',
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    return player != event.target && event.target.isMaxHp(false, false, target => target != player);
                },
                forced: true,
                usable: 1,
                logTarget: 'target',
                async content(event, trigger, player) {
                    await event.targets[0].damage();
                },
            },
            minizhiman: {
                audio: 'rezhiman',
                inherit: 'rezhiman',
                async content(event, trigger, player) {
                    trigger.cancel();
                    if (trigger.player.countGainableCards(player, 'ej')) await player.gainPlayerCard(trigger.player, 'ej', true);
                },
            },
            minizhuandui: {
                audio: 'zhuandui',
                group: ['zhuandui_use', 'zhuandui_respond'],
                trigger: { player: ['chooseToCompareAfter', 'compareMultipleAfter'], target: ['chooseToCompareAfter', 'compareMultipleAfter'] },
                filter(event, player) {
                    if (event.preserve) return false;
                    if (player == event.player) return event.num1 > event.num2;
                    return event.num2 > event.num1;
                },
                forced: true,
                locked: false,
                content() {
                    player.draw();
                },
            },
            minizuilun: {
                audio: 'xinfu_zuilun',
                trigger: { player: 'phaseEnd' },
                check(event, player) {
                    var num = 0;
                    if (player.hasHistory('lose', function (evt) {
                        return evt.type == 'discard';
                    })) num++;
                    if (!player.isMinHandcard()) num++;
                    if (!player.getStat('damage')) num++;
                    if (num == 0) return player.hp >= 2;
                    return true;
                },
                prompt(event, player) {
                    var num = 3;
                    if (player.hasHistory('lose', function (evt) {
                        return evt.type == 'discard';
                    })) num--;
                    if (!player.isMinHandcard()) num--;
                    if (!player.getStat('damage')) num--;
                    return get.prompt('minizuilun') + '（可获得' + get.cnNumber(num) + '张牌）';
                },
                content() {
                    'step 0'
                    event.num = 0;
                    event.cards = get.cards(4);
                    game.cardsGotoOrdering(cards);
                    if (!player.hasHistory('lose', function (evt) {
                        return evt.type == 'discard';
                    })) event.num++;
                    if (player.isMinHandcard()) event.num++;
                    if (player.getStat('damage')) event.num++;
                    'step 1'
                    var prompt = '罪论：将' + get.cnNumber(4 - num) + '牌置于牌堆顶';
                    if (num > 0) prompt += '，并获得其余的牌';
                    var next = player.chooseToMove(prompt, true);
                    if (num > 0) {
                        next.set('list', [
                            ['牌堆顶', cards],
                            ['获得'],
                        ]);
                        next.set('filterMove', function (from, to, moved) {
                            if (to == 1 && moved[0].length <= 4 - _status.event.num) return false;
                            return true;
                        });
                        next.set('filterOk', function (moved) {
                            return moved[0].length == 4 - _status.event.num;
                        });
                    }
                    else {
                        next.set('list', [
                            ['牌堆顶', cards],
                        ]);
                    }
                    next.set('num', num);
                    next.set('processAI', function (list) {
                        var check = function (card) {
                            var player = _status.event.player;
                            var next = player.next;
                            var att = get.attitude(player, next);
                            var judge = next.getCards('j')[tops.length];
                            if (judge) return get.judge(judge)(card) * att;
                            return next.getUseValue(card) * att;
                        }
                        var cards = list[0][1].slice(0), tops = [];
                        while (tops.length < 4 - _status.event.num) {
                            list.sort(function (a, b) {
                                return check(b) - check(a);
                            });
                            tops.push(cards.shift());
                        }
                        return [tops, cards];
                    });
                    'step 2'
                    if (result.bool) {
                        var list = result.moved[0];
                        var num = list.length - 1;
                        for (var i = 0; i < list.length; i++) {
                            event.cards.remove(list[num - i]);
                            ui.cardPile.insertBefore(list[num - i], ui.cardPile.firstChild);
                        }
                    }
                    'step 3'
                    game.updateRoundNumber();
                    if (event.cards.length) {
                        player.gain(event.cards, 'draw');
                        game.log(player, '获得了' + get.cnNumber(event.cards.length) + '张牌');
                        event.finish();
                    }
                    else if (game.countPlayer() > 1) {
                        player.chooseTarget('请选择一名角色，与其一同失去1点体力', true, lib.filter.notMe).set('ai', function (target) {
                            return -get.attitude(_status.event.player, target);
                        });
                    }
                    else event.finish();
                    'step 4'
                    if (result.bool) {
                        player.line(result.targets[0], 'fire');
                        player.loseHp();
                        result.targets[0].loseHp();
                    }
                },
            },
            miniqiangwu: {
                audio: 'qiangwu',
                enable: 'phaseUse',
                usable: 1,
                content() {
                    'step 0'
                    player.judge();
                    'step 1'
                    if (get.position(result.card, true) == 'd') player.gain(result.card, 'gain2');
                    player.storage.qiangwu = result.number;
                    player.addTempSkill('qiangwu3', 'phaseUseAfter');
                },
                ai: {
                    order: 11,
                    result: { player: 1 },
                },
            },
            minifumian: {
                audio: 'fumian',
                trigger: { player: 'phaseZhunbeiBegin' },
                direct: true,
                content() {
                    'step 0'
                    if (player.storage.minifumian_choice == 'draw') {
                        player.chooseControlList(get.prompt('minifumian'), '摸牌阶段多摸一张牌', '使用红色牌可以多选择两个目标', function (event, player) {
                            if (player.hp == 1 || player.countCards('h') <= 1) return 0;
                            return 1;
                        });
                    }
                    else if (player.storage.minifumian_choice == 'red') {
                        player.chooseControlList(get.prompt('minifumian'), '摸牌阶段多摸两张牌', '使用红色牌可以多选择一个目标', function (event, player) {
                            return 0;
                        });
                    }
                    else {
                        player.chooseControlList(get.prompt('minifumian'), '摸牌阶段多摸一张牌', '使用红色牌可以多选择一个目标', function (event, player) {
                            if (player.hp == 1 || player.countCards('h') < player.hp) return 0;
                            return 1;
                        });
                    }
                    'step 1'
                    if (player.storage.minifumian_choice == 'draw') {
                        if (result.index == 0) player.storage.minifumian_draw = 1;
                        else if (result.index == 1) {
                            player.storage.minifumian_red = 2;
                            delete player.storage.minifumian_choice;
                        }
                    }
                    else if (player.storage.minifumian_choice == 'red') {
                        if (result.index == 0) {
                            player.storage.minifumian_draw = 2;
                            delete player.storage.minifumian_choice;
                        }
                        else if (result.index == 1) player.storage.minifumian_red = 1;
                    }
                    else {
                        if (result.index == 0) {
                            player.storage.minifumian_draw = 1;
                            player.storage.minifumian_choice = 'draw';
                        }
                        else if (result.index == 1) {
                            player.storage.minifumian_red = 1;
                            player.storage.minifumian_choice = 'red';
                        }
                    }
                    if (result.index == 0) {
                        player.logSkill('minifumian');
                        player.addTempSkill('minifumian_draw');
                    }
                    else if (result.index == 1) {
                        player.logSkill('minifumian');
                        player.addTempSkill('minifumian_red');
                    }
                },
                subSkill: {
                    draw: {
                        trigger: { player: 'phaseDrawBegin2' },
                        forced: true,
                        popup: false,
                        onremove: true,
                        filter(event, player) {
                            return typeof player.storage.minifumian_draw == 'number' && !event.numFixed;
                        },
                        content() {
                            trigger.num += player.storage.minifumian_draw;
                        },
                    },
                    red: {
                        trigger: { player: 'useCard2' },
                        direct: true,
                        mark: true,
                        onremove: true,
                        intro: { content: '使用红色牌可以多选择#个目标' },
                        filter(event, player) {
                            if (get.color(event.card) != 'red') return false;
                            var info = get.info(event.card);
                            if (info.allowMultiple == false) return false;
                            if (event.targets && !info.multitarget) {
                                if (game.hasPlayer(function (current) {
                                    return lib.filter.targetEnabled2(event.card, player, current) && !event.targets.includes(current);
                                })) return true;
                            }
                            return false;
                        },
                        content() {
                            'step 0'
                            var prompt2 = '额外指定';
                            if (player.storage.minifumian_red == 2) prompt2 += '至多两';
                            else prompt2 += '一';
                            prompt2 += '名' + get.translation(trigger.card) + '的目标'
                            player.chooseTarget([1, player.storage.minifumian_red], get.prompt('minifumian'), function (card, player, target) {
                                var player = _status.event.player;
                                if (_status.event.targets.includes(target)) return false;
                                return lib.filter.targetEnabled2(_status.event.card, player, target);
                            }).set('prompt2', prompt2).set('ai', function (target) {
                                var trigger = _status.event.getTrigger();
                                var player = _status.event.player;
                                return get.effect(target, trigger.card, player, player);
                            }).set('targets', trigger.targets).set('card', trigger.card);
                            'step 1'
                            if (result.bool) {
                                if (!event.isMine()) game.delayx();
                                event.targets = result.targets;
                            }
                            else event.finish();
                            'step 2'
                            if (event.targets) {
                                player.logSkill('minifumian', event.targets);
                                trigger.targets.addArray(event.targets);
                            }
                        },
                    },
                },
            },
            minidaiyan: {
                getList(player) {
                    var list = [], history = player.actionHistory;
                    for (var i = history.length - 2; i >= 0; i--) {
                        if (history[i].isSkipped) continue;
                        if (history[i].isMe) {
                            for (var evt of history[i].useSkill) {
                                if (evt.skill == 'minidaiyan') list.addArray(evt.targets);
                            }
                            break;
                        }
                    }
                    return list;
                },
                audio: 'daiyan',
                trigger: { player: 'phaseJieshuBegin' },
                direct: true,
                content() {
                    'step 0'
                    var str = '', list = lib.skill.minidaiyan.getList(player);
                    if (list.length) str += '（上回合对' + get.translation(list) + '发动过此技能）';
                    player.chooseTarget(get.prompt('minidaiyan') + str, lib.translate.minidaiyan_info).set('ai', function (target) {
                        var player = _status.event.player, list = lib.skill.minidaiyan.getList(player);
                        return get.attitude(player, target) * (list.includes(target) ? 1 : 3);
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minidaiyan', target);
                        var tao = get.cardPile2(function (card) {
                            return get.suit(card) == 'heart' && get.type(card) == 'basic';
                        });
                        if (tao) target.gain(tao, 'gain2');
                    }
                    else event.finish();
                    'step 2'
                    if (!lib.skill.minidaiyan.getList(player).includes(target)) player.draw();
                },
            },
            minijili: {
                audio: 'gzjili',
                inherit: 'gzjili',
                group: 'minijili_zhiheng',
                subSkill: {
                    zhiheng: {
                        trigger: { player: 'phaseJieshuBegin' },
                        filter(event, player) {
                            return player.countCards('he');
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseToDiscard('he', get.prompt('minijili'), '弃置一张牌并摸一张牌').set('ai', lib.skill.zhiheng.check).set('complexCard', true).logSkill = 'minijili';
                            'step 1'
                            if (result.bool) player.draw();
                        },
                    },
                },
            },
            miniqiaoshi: {
                audio: 'qiaoshi',
                inherit: 'qiaoshi',
                filter(event, player) {
                    return event.player != player && event.player.countCards('h') >= player.countCards('h') && event.player.isIn();
                },
            },
            miniyanyu: {
                group: 'miniyanyu2',
                audio: 'yanyu',
                inherit: 'yanyu',
            },
            miniyanyu2: {
                trigger: { player: 'phaseEnd' },
                filter(event, player) {
                    return player.getHistory('useSkill', evt => evt.skill == 'miniyanyu').length;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('miniyanyu'), '令一名角色摸两张牌（若该角色为你则改为摸一张牌）').set('ai', function (target) {
                        var player = _status.event.player;
                        return get.attitude(player, target) * (target == player ? 0.7 : 1);
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('miniyanyu', target);
                        target.draw(target == player ? 1 : 2);
                    }
                },
            },
            minizhengnan: {
                derivation: ['minirewusheng', 'minidangxian', 'rezhiman'],
                audio: 'zhengnan',
                trigger: { global: 'dying' },
                filter(event, player) {
                    return !player.getStorage('minizhengnan').includes(event.player);
                },
                frequent: true,
                content() {
                    'step 0'
                    player.markAuto('minizhengnan', [trigger.player]);
                    player.recover(trigger.player == player ? 2 : 1);
                    var list = lib.skill.minizhengnan.derivation.filter(skill => !player.hasSkill(skill));
                    if (list.length) {
                        player.draw(trigger.player == player ? 2 : 1);
                        event.list = list;
                    }
                    else {
                        player.draw(trigger.player == player ? 4 : 3);
                        event.finish();
                    }
                    'step 1'
                    if (event.list.length == 1) event._result = { control: event.list[0] };
                    else player.chooseControl(event.list).set('prompt', '征南：选择获得下列技能中的一个').set('ai', function () {
                        if (event.list.includes('minidangxian')) return 'minidangxian';
                        return 0;
                    });
                    'step 2'
                    player.addSkills(result.control);
                },
                intro: { content: '已因$发动过技能' },
            },
            minixiefang: {
                getNum() {
                    var num = game.countPlayer(function (current) {
                        return current.hasSex('female');
                    });
                    return Math.max(1, num);
                },
                mod: {
                    maxHandcard(player, num) {
                        return num + lib.skill.minixiefang.getNum();
                    },
                    globalFrom(from, to, distance) {
                        return distance - lib.skill.minixiefang.getNum();
                    },
                },
            },
            minifengpo: {
                audio: 'fengpo',
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    if (!['sha', 'juedou'].includes(event.card.name)) return false;
                    if (player != _status.currentPhase) return false;
                    return player.getHistory('useCard', function (evt) {
                        return ['sha', 'juedou'].includes(evt.card.name);
                    }).indexOf(event.getParent()) == 0;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseControl('摸牌', '加伤', 'cancel2').set('prompt', get.prompt2('minifengpo'));
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('minifengpo', trigger.target);
                        var num = Math.min(4, trigger.target.countCards('h', { color: 'red' }));
                        if (result.control == '摸牌') player.draw(num);
                        else {
                            var trigger2 = trigger.getParent();
                            if (typeof trigger2.baseDamage != 'number') trigger2.baseDamage = 1;
                            trigger2.baseDamage += num;
                        }
                    }
                },
            },
            //王平
            minifeijun: {
                intro: { content: '已对$发动过〖飞军〗' },
                audio: 'nzry_feijun',
                enable: 'phaseUse',
                filter(event, player) {
                    if (!player.countCards('he')) return false;
                    var count = player.getStat('skill').minifeijun || 0;
                    if (count > player.countMark('wechatbinglve_count')) return false;
                    return game.hasPlayer(function (current) {
                        if (current == player) return false;
                        return current.countCards('he');
                    });
                },
                chooseButton: {
                    dialog(event, player) {
                        var dialog = ui.create.dialog('飞军：弃置一张牌，然后…', 'hidden');
                        dialog.add([[
                            ['give', '令一名有牌的其他角色交给你一张牌'],
                            ['discard', '令一名装备区有牌的其他角色弃置一张装备区里的牌']
                        ], 'textbutton']);
                        return dialog;
                    },
                    /*
                    //手搓一个框用来对比一下
                    dialog:function(event,player){
                    var list=[
                    '令一名有牌的其他角色交给你一张牌',
                    '令一名装备区有牌的其他角色弃置一张装备区里的牌',
                    ];
                    var buttons=['give','discard'];
                    var choiceList=ui.create.dialog('飞军：弃置一张牌，然后…','forcebutton','hidden');
                    for(var i=0;i<list.length;i++){
                    var str='<div class="popup text" style="width:calc(100% - 10px);display:inline-block">';
                    var bool=lib.skill.minifeijun.chooseButton.filter({link:buttons[i]},player);
                    if(!bool) str+='<div style="opacity:0.5">';
                    str+=list[i];
                    if(!bool) str+='</div>';
                    str+='</div>';
                    var next=choiceList.add(str);
                    next.firstChild.addEventListener(lib.config.touchscreen?'touchend':'click',ui.click.button);
                    next.firstChild.link=buttons[i];
                    for(var j in lib.element.button){
                    next[j]=lib.element.button[j];
                    }
                    choiceList.buttons.add(next.firstChild);
                    }
                    return choiceList;
                    },
                    */
                    filter(button, player) {
                        if (button.link == 'discard') return game.hasPlayer(function (current) {
                            if (current == player) return false;
                            return current.countCards('e');
                        });
                        return true;
                    },
                    check(button, player) {
                        if (button.link == 'discard') return 1;
                        return 2;
                    },
                    backup(links) {
                        return get.copy(lib.skill['minifeijun_' + links[0]]);
                    },
                    prompt(links) {
                        if (links[0] == 'damage') return '弃置一张牌，令一名有牌的其他角色交给你一张牌';
                        return '弃置一张牌，令一名装备区有牌的其他角色弃置一张装备区的牌';
                    },
                },
                ai: {
                    order: 9,
                    result: { player: 1 },
                },
                subSkill: {
                    backup: { audio: 'nzry_feijun' },
                    give: {
                        audio: 'nzry_feijun',
                        filterTarget(card, player, target) {
                            if (target == player) return false;
                            return target.countCards('he');
                        },
                        filterCard: true,
                        position: 'he',
                        content() {
                            'step 0'
                            player.markAuto('minifeijun', [target]);
                            target.chooseCard('he', true, '飞军：请交给' + get.translation(player) + '一张牌').set('ai', function (card) {
                                return -get.value(card);
                            });
                            'step 1'
                            if (result.bool) player.gain(result.cards, target, 'giveAuto');
                        },
                        ai: {
                            result: {
                                player(player, target) {
                                    var list = player.getStorage('minifeijun');
                                    return get.effect(target, { name: 'shunshou_copy2' }, player, player) * (list.includes(target) ? 1 : 3);
                                },
                            },
                        },
                    },
                    discard: {
                        audio: 'nzry_feijun',
                        filterTarget(card, player, target) {
                            if (target == player) return false;
                            return target.countCards('e');
                        },
                        filterCard: true,
                        position: 'he',
                        content() {
                            player.markAuto('minifeijun', [target]);
                            target.chooseToDiscard('e', true, '飞军：请弃置一张装备区的牌');
                        },
                        ai: {
                            result: {
                                player(player, target) {
                                    var list = player.getStorage('minifeijun');
                                    return get.effect(target, { name: 'guohe_copy2' }, player, player) * (list.includes(target) ? 1 : 3);
                                },
                            },
                        },
                    },
                },
            },
            minibinglve: {
                audio: 'nzry_binglve',
                trigger: { player: 'useSkill' },
                filter(event, player) {
                    return event.skill == 'minifeijun_backup';
                },
                forced: true,
                content() {
                    'step 0'
                    player.draw();
                    'step 1'
                    var target = trigger.targets[0];
                    var list = player.getStorage('minifeijun');
                    if (!list.includes(target)) {
                        player.draw(list.filter(function (i) {
                            return i.isIn();
                        }).length + 1);
                    }
                },
                ai: { combo: 'minifeijun' },
            },
            miniqiaoshui: {
                mod: {
                    ignoredHandcard(card, player) {
                        if (get.type2(card) == 'trick') return true;
                    },
                    cardDiscardable(card, player, name) {
                        if (name == 'phaseDiscard' && get.type2(card) == 'trick') return false;
                    },
                },
                audio: 'qiaoshui',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h') && game.hasPlayer(function (target) {
                        return player.canCompare(target);
                    }) && !player.hasSkill('miniqiaoshui_silent');
                },
                filterTarget(card, player, target) {
                    return player.canCompare(target);
                },
                content() {
                    'step 0'
                    player.chooseToCompare(target);
                    'step 1'
                    if (result.bool) player.addTempSkill('qiaoshui3');
                    else player.addTempSkill('miniqiaoshui_silent');
                },
                subSkill: { silent: { charlotte: true } },
                ai: {
                    order(item, player) {
                        if (player.countCards('h', function (card) {
                            return player.hasValueTarget(card);
                        })) return 10;
                        return 1;
                    },
                    result: {
                        target(player, target) {
                            if (player.countCards('h', function (card) {
                                return player.hasValueTarget(card);
                            })) {
                                if (player.hasSkill('qiaoshui3')) return 0;
                                var nd = !player.needsToDiscard();
                                if (player.hasCard(function (card) {
                                    if (get.position(card) != "h") return false;
                                    var val = get.value(card)
                                    if (nd && val < 0) return true;
                                    if (val <= 5) {
                                        return get.number(card) >= 12;
                                    }
                                    if (val <= 6) {
                                        return get.number(card) >= 13;
                                    }
                                    return false;
                                })) return -1;
                                return 0;
                            }
                            return -1;
                        },
                    },
                },
            },
            miniqirang: {
                group: 'miniqirang_gain',
                subfrequent: ['gain'],
                audio: 'qirang',
                trigger: { player: 'useCard2' },
                filter(event, player) {
                    if (get.type(event.card) != 'trick') return false;
                    if (!event.targets || event.targets.length != 1) return false;
                    var info = get.info(event.card);
                    if (info.allowMultiple == false) return false;
                    if (event.targets && !info.multitarget) {
                        if (game.hasPlayer(function (current) {
                            return !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current);
                        })) return true;
                    }
                    return false;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('miniqirang'), '为' + get.translation(trigger.card) + '增加一个目标', function (card, player, target) {
                        var player = _status.event.player;
                        return lib.filter.targetEnabled2(_status.event.card, player, target) && lib.filter.targetInRange(_status.event.card, player, target);
                    }).set('ai', function (target) {
                        var trigger = _status.event.getTrigger();
                        var player = _status.event.player;
                        return get.effect(target, trigger.card, player, player) * (_status.event.targets.includes(target) ? -1 : 1);
                    }).set('targets', trigger.targets).set('card', trigger.card);
                    'step 1'
                    if (result.bool) {
                        if (!event.isMine() && !event.isOnline()) game.delayx();
                        event.targets = result.targets;
                    }
                    else event.finish();
                    'step 2'
                    if (targets) {
                        player.logSkill('miniqirang', targets);
                        trigger.targets.addArray(targets);
                    }
                },
                ai: {
                    effect: {
                        target(card, player, target, current) {
                            if (get.type(card) == 'equip' && !get.cardtag(card, 'gifts')) return [1, 3];
                        },
                    },
                },
                subSkill: {
                    gain: {
                        audio: 'qirang',
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            return get.type(event.card) == 'equip';
                        },
                        frequent: true,
                        content() {
                            var card = get.cardPile(function (card) {
                                return get.type2(card) == 'trick';
                            });
                            if (card) player.gain(card, 'gain2');
                        },
                    },
                },
            },
            miniyuhua: {
                mod: {
                    ignoredHandcard(card, player) {
                        if (get.type(card) != 'basic') return true;
                    },
                    cardDiscardable(card, player, name) {
                        if (name == 'phaseDiscard' && get.type(card) != 'basic') return false;
                    },
                },
                audio: 'yuhua',
                trigger: { player: 'phaseJieshuBegin' },
                forced: true,
                locked: false,
                content() {
                    'step 0'
                    var cards = get.cards(2);
                    game.cardsGotoOrdering(cards);
                    var next = player.chooseToMove();
                    next.set('list', [
                        ['牌堆顶', cards],
                        ['牌堆底'],
                        ['自己获得'],
                    ]);
                    next.set('prompt', '羽化：将一张牌移动到牌堆顶或牌堆底，然后获得另一张牌');
                    next.set('filterOk', function (moved) {
                        return moved[2].length == 1;
                    });
                    next.set('processAI', function (list) {
                        var cards = list[0][1], player = _status.event.player;
                        var target = (_status.event.getTrigger().name == 'phaseZhunbei') ? player : player.next;
                        var att = Math.sign(get.attitude(player, target));
                        var top = [];
                        var judges = target.getCards('j');
                        var stopped = false;
                        if (player != target || !target.hasWuxie()) {
                            for (var i = 0; i < judges.length; i++) {
                                var judge = get.judge(judges[i]);
                                cards.sort(function (a, b) {
                                    return (judge(b) - judge(a)) * att;
                                });
                                if (judge(cards[0]) * att < 0) {
                                    stopped = true; break;
                                }
                                else {
                                    top.unshift(cards.shift());
                                }
                            }
                        }
                        var bottom;
                        if (!stopped) {
                            cards.sort(function (a, b) {
                                return (get.value(b, player) - get.value(a, player)) * att;
                            });
                            while (cards.length) {
                                if ((get.value(cards[0], player) <= 5) == (att > 0)) break;
                                top.unshift(cards.shift());
                            }
                        }
                        bottom = cards;
                        var TempCards1 = top.slice(0);
                        var TempCards2 = bottom.slice(0);
                        var gain = TempCards1.addArray(TempCards2)[TempCards1.addArray(TempCards2).length - 1];
                        top.remove(gain);
                        bottom.remove(gain);
                        return [top, bottom, [gain]];
                    });
                    'step 1'
                    var top = result.moved[0];
                    var bottom = result.moved[1];
                    var gain = result.moved[2];
                    top.reverse();
                    for (var i = 0; i < top.length; i++) {
                        ui.cardPile.insertBefore(top[i], ui.cardPile.firstChild);
                    }
                    for (i = 0; i < bottom.length; i++) {
                        ui.cardPile.appendChild(bottom[i]);
                    }
                    player.popup(get.cnNumber(top.length) + '上' + get.cnNumber(bottom.length) + '下');
                    game.log(player, '将' + get.cnNumber(top.length) + '张牌置于牌堆顶');
                    game.updateRoundNumber();
                    player.gain(gain, 'draw');
                    game.log(player, '获得了一张牌');
                },
            },
            minibazhen: {
                audio: 'bazhen',
                audioname: ['ol_pangtong'],
                group: 'bazhen_bagua',
                trigger: { player: 'judgeEnd' },
                filter(event, player) {
                    return event.skill && event.skill.indexOf('bagua') != -1 && !event.result.bool;
                },
                forced: true,
                content() {
                    player.draw();
                },
                init(player, skill) {
                    player.addExtraEquip(skill, 'bagua', true, player => player.hasEmptySlot(2) && lib.card['bagua']);
                },
                onremove(player, skill) {
                    player.removeExtraEquip(skill);
                },
            },
            minihuoji: {
                audio: 'rehuoji',
                audioname: ['ol_pangtong'],
                audioname2: { Mbaby_sp_zhugeliang: 'huoji' },
                trigger: { player: 'chooseToDiscardBegin' },
                filter(event) {
                    return event.getParent().name == 'huogong';
                },
                direct: true,
                content() {
                    'step 0'
                    var cards = get.cards(4, true);
                    player.chooseButton(['火计：是否选择其中一张牌作为弃置牌？', cards]).set('filterButton', function (button) {
                        var evt = _status.event;
                        _status.event = _status.event.getTrigger();
                        var check = _status.event.filterCard(button.link, _status.event.player);
                        _status.event = evt;
                        return check;
                    }).set('ai', button => 1 + Math.random());
                    'step 1'
                    if (result.bool) {
                        player.logSkill(event.name);
                        trigger.getParent().dialog?.close();
                        game.addVideo('cardDialog', null, trigger.getParent().videoId);
                        game.broadcast('closeDialog', trigger.getParent().videoId);
                        var cards = result.links;
                        player.$throw(cards, 1000);
                        game.delayx();
                        game.cardsDiscard(cards);
                        game.log(player, '弃置了', cards, '#g（源自牌堆）');
                        trigger.finish();
                        trigger.getParent()._result = { bool: true };
                        trigger.result = { bool: true };
                    }
                    'step 2'
                    game.updateRoundNumber();
                },
                ai: { fireAttack: true },
                group: 'minihuoji_viewAs',
                subSkill: {
                    viewAs: {
                        audio: 'rehuoji',
                        audioname: ['ol_pangtong'],
                        audioname2: { Mbaby_sp_zhugeliang: 'huoji' },
                        inherit: 'rehuoji',
                    },
                },
            },
            minixushen: {
                derivation: 'decadezhennan',
                audio: 'xinfu_xushen',
                trigger: { player: 'dying' },
                limited: true,
                skillAnimation: true,
                animationColor: 'orange',
                filter(event, player) {
                    return player.hp < 1;
                },
                content() {
                    'step 0'
                    player.awakenSkill('minixushen');
                    player.addTempSkill('minixushen2');
                    trigger.minixushen = true;
                    player.recover();
                    'step 1'
                    player.addSkills('decadezhennan');
                },
            },
            minixushen2: {
                trigger: { player: 'dyingAfter' },
                forced: true,
                popup: false,
                charlotte: true,
                filter(event, player) {
                    return event.minixushen == true && !game.hasPlayer(function (current) {
                        return current.name == 'Mbaby_guansuo' || current.name2 == 'Mbaby_guansuo';
                    });
                },
                content() {
                    'step 0'
                    player.chooseTarget(lib.filter.notMe, '许身：是否令一名其他角色选择是否将其武将牌替换为“关索”并令其摸三张牌？').set('ai', function (target) {
                        var player = _status.event.player;
                        return get.attitude(player, target);
                    });
                    'step 1'
                    if (!result.bool) {
                        event.finish();
                        return;
                    }
                    var target = result.targets[0];
                    event.target = target;
                    player.line(target, 'fire');
                    target.chooseBool('许身：是否将自己的一张武将牌替换为“关索”并令' + get.translation(player) + '摸三张牌？');
                    'step 2'
                    if (result.bool) {
                        if (target.name2) target.chooseControl(target.name1, target.name2).set('prompt', '请选择要更换的武将牌');
                        else event._result = { control: target.name };
                    }
                    else event.goto(4);
                    'step 3'
                    target.reinitCharacter(result.control, 'Mbaby_guansuo');
                    if (target.name == 'Mbaby_guansuo' && target.group != 'shu') target.changeGroup('shu');
                    if (_status.characterlist) {
                        _status.characterlist.add(result.control);
                        _status.characterlist.remove('Mbaby_guansuo');
                    }
                    'step 4'
                    target.draw(3);
                },
            },
            //花蔓
            minisouying: {
                audio: 'souying',
                trigger: { player: 'useCardToPlayered', target: 'useCardToTargeted' },
                filter(event, player) {
                    if (!player.countCards('he')) return false;
                    if (!event.targets || event.targets.length != 1 || event.player == event.target) return false;
                    if (event.card.name != 'sha' && get.type(event.card) != 'trick') return false;
                    return event.player != event.target;
                },
                direct: true,
                usable: 1,
                content() {
                    'step 0'
                    var next = player.chooseToDiscard('he'), prompt;
                    if (event.triggername == 'useCardToTargeted') {
                        event.target = trigger.player;
                        prompt = '令' + get.translation(trigger.card) + '对你无效';
                        next.set('goon', -get.effect(player, trigger.card, trigger.player, player));
                    }
                    else {
                        event.target = trigger.targets[0];
                        prompt = '弃置一张牌，并获得' + get.translation(trigger.cards.filterInD());
                        next.set('goon', get.value(trigger.cards.filterInD()));
                    }
                    next.set('prompt', get.prompt('minisouying', event.target));
                    next.set('prompt2', prompt)
                    next.set('ai', function (card) {
                        return _status.event.goon - get.value(card);
                    });
                    next.set('logSkill', ['minisouying', event.target]);
                    'step 1'
                    if (result.bool) {
                        if (event.triggername == 'useCardToPlayered') player.gain(trigger.cards.filterInD(), 'gain2');
                        else trigger.excluded.add(player);
                    }
                    else player.storage.counttrigger.minisouying--;
                },
            },
            minizhanyuan: {
                derivation: 'hmxili',
                audio: 'zhanyuan',
                trigger: { player: 'mansiAfter' },
                filter(event, player) {
                    return _status.currentPhase && _status.currentPhase == player && player.countMark('mansi') > 7;
                },
                skillAnimation: true,
                animationColor: 'soil',
                forced: true,
                juexingji: true,
                content() {
                    'step 0'
                    player.awakenSkill('minizhanyuan');
                    'step 1'
                    player.chooseTarget('战缘：是否选择一名其他角色？', '令一名其他角色和自己一同获得〖系力〗，然后失去〖蛮嗣〗', lib.filter.notMe).set('ai', function (target) {
                        var player = _status.event.player;
                        return get.attitude(player, target);
                    });
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target, 'fire');
                        player.addSkills('hmxili');
                        target.addSkills('hmxili');
                        player.removeSkills('mansi');
                    }
                },
            },
            minifuhan: {
                inherit: 'refuhan',
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    const num = player.countMark('fanghun');
                    if (num) {
                        player.clearMark('fanghun');
                        await player.draw(num);
                    }
                    if (!_status.characterlist) game.initCharacterList();
                    const EditList = ((!_status.connectMode && game.getExtensionConfig('活动武将', 'PingJianName')) ? game.getExtensionConfig('活动武将', 'PingJianName') : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                    let list = EditList.filter(i => _status.characterlist.includes(i) && (get.character(i, 1) == 'shu' || (get.is.double(i, true) || []).includes('shu')));
                    for (const current of game.players.concat(game.dead)) {
                        list.removeArray(get.nameList(current));
                    }
                    list = list.randomGets(Math.max(4, game.countPlayer()));
                    const map = {};
                    for (const name of list) {
                        let skills = (lib.character[name][3] || []).filter(skill => {
                            const info = get.info(skill);
                            return info && !info.zhuSkill && !info.limited && !info.juexingji && !info.hiddenSkill && !info.charlotte && !info.dutySkill;
                        });
                        if (skills.length) map[name] = skills;
                    }
                    if (!Object.keys(map).length) return;
                    const result = await player.chooseButton([
                        `扶汉：请选择获得至多两个技能`,
                        [dialog => {
                            dialog.css({ top: get.is.phoneLayout() ? '20%' : '25%' });
                            const { characterMap: map } = get.event();
                            for (const name of Object.keys(map)) {
                                const table = document.createElement('div');
                                table.classList.add('add-setting');
                                table.style.margin = '0';
                                table.style.width = '100%';
                                table.style.position = 'relative';
                                table.style.display = 'flex';
                                table.style.justifyContent = 'flex-start';
                                table.style.alignItems = 'center';
                                const tdc = ui.create.button(name, 'character', table, true);
                                for (const item in tdc.node) {
                                    if (item == 'name') {
                                        tdc.node.name.style.writingMode = 'horizontal-tb';
                                    } else {
                                        tdc.node[item].hide();
                                    }
                                }
                                tdc.style.height = '40px';
                                lib.setIntro(tdc);
                                const skills = map[name];
                                for (let i = 0; i < skills.length; i++) {
                                    const td = ui.create.button([skills[i], get.translation(skills[i])], 'tdnodes', table);
                                    td.setNodeIntro(get.translation(skills[i]), get.skillInfoTranslation(skills[i], get.player()));
                                    dialog.buttons.add(td);
                                }
                                dialog.content.appendChild(table);
                            }
                        }, 'handle'],
                    ], [1, 2], true).set('characterMap', map).set('ai', button => {
                        const { link } = button;
                        const info = get.info(link);
                        if (info?.ai?.neg) return 0;
                        return get.skillRank(link, 'inout');
                    }).forResult();
                    if (result?.links?.length) await player.addSkills(result.links);
                    if (player.isMinHp()) await player.recover();
                },
                derivation: 'Mbaby_characterlist_faq',
            },
            //夏侯霸
            minibaobian: {
                derivation: ['minitiaoxin', 'minipaoxiao', 'minishensu'],
                audio: 'rebaobian',
                trigger: { player: 'damageEnd' },
                filter(event, player) {
                    return lib.skill.minibaobian.derivation.some(i => !player.hasSkill(i, null, null, false));
                },
                forced: true,
                content() {
                    for (var i of lib.skill.minibaobian.derivation) {
                        if (!player.hasSkill(i, null, null, false)) {
                            player.addSkills(i);
                            break;
                        }
                    }
                },
                ai: {
                    maixie: true,
                    effect: {
                        target(card, player, target) {
                            if (get.tag(card, 'damage') && !target.hasSkill('minitiaoxin', null, null, false)) {
                                if (!target.hasFriend()) return;
                                if (target.hp >= 4) return [0, 1];
                            }
                        },
                    },
                },
            },
            //严颜
            //终于摆脱答辩转换技设计了
            minijuzhan: {
                group: 'minijuzhan_gain',
                audio: 'nzry_juzhan',
                trigger: { target: 'useCardToTargeted' },
                prompt2: '当你成为其他角色【杀】的目标后，你可以与其各摸一张牌，然后其本回合内不能再对你使用牌。',
                filter(event, player) {
                    return event.card.name == 'sha';
                },
                logTarget: 'player',
                content() {
                    'step 0'
                    game.asyncDraw([player, trigger.player]);
                    trigger.player.addTempSkill('minijuzhan_use1');
                    trigger.player.markAuto('minijuzhan_use1', [player]);
                    'step 1'
                    game.delayx();
                },
                subSkill: {
                    gain: {
                        audio: 'nzry_juzhan',
                        trigger: { player: 'useCardToPlayered' },
                        prompt2: '当你使用【杀】指定一名角色为目标后，你可以获得其一张牌，然后你本回合内不能再对其使用红色【杀】',
                        filter(event, player) {
                            return event.card.name == 'sha' && event.target.countGainableCards(player, 'he');
                        },
                        check(event, player) {
                            return get.effect(event.target, { name: 'guohe_copy2' }, player, player) > 0;
                        },
                        logTarget: 'target',
                        content() {
                            'step 0'
                            player.gainPlayerCard(trigger.target, 'he', true);
                            'step 1'
                            player.addTempSkill('minijuzhan_use2');
                            player.markAuto('minijuzhan_use2', [trigger.target]);
                        },
                    },
                    use1: {
                        charlotte: true,
                        onremove: true,
                        marktext: '拒',
                        intro: { content: '不能对$使用牌' },
                        mod: {
                            playerEnabled(card, player, target) {
                                if (player.getStorage('minijuzhan_use1').includes(target)) return false;
                            },
                        },
                    },
                    use2: {
                        charlotte: true,
                        onremove: true,
                        marktext: '战',
                        intro: { content: '不能对$使用红色【杀】' },
                        mod: {
                            playerEnabled(card, player, target) {
                                if (player.getStorage('minijuzhan_use2').includes(target) && get.name(card) == 'sha' && get.color(card) == 'red') return false;
                            },
                        },
                    },
                },
            },
            //陈到
            miniwanglie: {
                mod: {
                    targetInRange(card, player, target, now) {
                        if (player.isPhaseUsing()) return true;
                    },
                },
                audio: 'drlt_wanglie',
                trigger: { player: 'useCard' },
                filter(event, player) {
                    return player.isPhaseUsing() && (event.card.name == 'sha' || get.type(event.card) == 'trick');
                },
                preHidden: true,
                check(event, player) {
                    if (['wuzhong', 'kaihua', 'dongzhuxianji'].includes(event.card.name)) return false;
                    player._wanglie_temp = true;
                    var eff = 0;
                    for (var i of event.targets) {
                        eff += get.effect(i, event.card, player, player);
                    }
                    delete player._wanglie_temp;
                    if (eff < 0) return true;
                    if (!player.countCards('h', function (card) {
                        return player.hasValueTarget(card, null, true);
                    })) return true;
                    if (get.tag(event.card, 'damage') && !player.needsToDiscard() && !player.countCards('h', function (card) {
                        return get.tag(card, 'damage') && player.hasValueTarget(card, null, true);
                    })) return true;
                    return false;
                },
                prompt2(event) {
                    return '令' + get.translation(event.card) + '不能被响应，回合结束时摸等同于此牌造成的伤害数的牌，然后本回合不能再使用牌';
                },
                locked: false,
                content() {
                    trigger.nowuxie = true;
                    trigger.directHit.addArray(game.players);
                    player.addTempSkill('miniwanglie2');
                    trigger.card.miniwanglie = true;
                },
                ai: {
                    pretao: true,
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (tag == 'pretao') return true;
                        if (player._wanglie_temp) return false;
                        player._wanglie_temp = true;
                        var bool = function () {
                            if (['wuzhong', 'kaihua', 'dongzhuxianji'].includes(arg.card.name)) return false;
                            if (get.attitude(player, arg.target) > 0 || !player.isPhaseUsing()) return false;
                            var cards = player.getCards('h', function (card) {
                                return card != arg.card && (!arg.card.cards || !arg.card.cards.includes(card));
                            });
                            var sha = player.getCardUsable('sha');
                            if (arg.card.name == 'sha') sha--;
                            cards = cards.filter(function (card) {
                                if (card.name == 'sha' && sha <= 0) return false;
                                return player.hasValueTarget(card, null, true);
                            });
                            if (!cards.length) return true;
                            if (!get.tag(arg.card, 'damage')) return false;
                            if (!player.needsToDiscard() && !cards.filter(function (card) {
                                return get.tag(card, 'damage');
                            }).length) return true;
                            return false;
                        }();
                        delete player._wanglie_temp;
                        return bool;
                    },
                },
            },
            miniwanglie2: {
                charlotte: true,
                group: 'drlt_wanglie2',
                getNum(player) {
                    var num = 0;
                    player.getHistory('sourceDamage', function (evt) {
                        if (evt.card && evt.card.miniwanglie) num += evt.num;
                    });
                    return num;
                },
                trigger: { player: 'phaseEnd' },
                filter(event, player) {
                    return lib.skill.miniwanglie2.getNum(player) > 0;
                },
                forced: true,
                content() {
                    player.draw(lib.skill.miniwanglie2.getNum(player));
                },
            },
            //李严
            miniduliang: {
                audio: 'duliang',
                enable: 'phaseUse',
                filter(event, player) {
                    return game.hasPlayer(function (target) {
                        return lib.skill.miniduliang.filterTarget(null, player, target);
                    });
                },
                filterTarget(card, player, target) {
                    return player != target && target.countCards('h');
                },
                usable: 1,
                content() {
                    'step 0'
                    player.gainPlayerCard(target, 'h', true);
                    'step 1'
                    var name = get.translation(target);
                    player.chooseControl(function () {
                        return '选项二';
                    }).set('prompt', '督粮：请选择一项').set('choiceList', [
                        '你观看牌堆顶的两张牌，然后令' + name + '获得其中的基本牌和装备牌',
                        '令' + name + '于下个摸牌阶段额外摸一张牌，然后其交给你一张牌'
                    ]);
                    'step 2'
                    if (result.control == '选项一') {
                        var cards = get.cards(2);
                        event.cards = cards;
                        target.viewCards('督粮', cards);
                        game.cardsGotoOrdering(cards);
                        event.cardx = cards.filter(function (card) {
                            var type = get.type(card);
                            return type == 'basic' || type == 'equip';
                        });
                        if (!event.cardx.length) event.goto(4);
                    }
                    else {
                        target.addTempSkill('miniduliang2', { player: 'phaseDrawAfter' });
                        target.addMark('miniduliang2', 1, false);
                        player.addSkill('miniduliang3');
                        if (!player.storage.miniduliang3[target.playerid]) player.storage.miniduliang3[target.playerid] = 0;
                        player.storage.miniduliang3[target.playerid]++;
                        event.finish();
                    }
                    'step 3'
                    var cardx = event.cardx;
                    target.gain(cardx, 'draw');
                    game.log(target, '获得了' + get.cnNumber(cardx.length) + '张牌');
                    cards.removeArray(cardx);
                    cards.reverse();
                    'step 4'
                    for (var i = 0; i < cards.length; i++) {
                        ui.cardPile.insertBefore(cards[i], ui.cardPile.firstChild);
                    }
                    game.updateRoundNumber();
                },
                ai: {
                    order: 4,
                    result: {
                        target: -1,
                        player: 0.1
                    },
                },
            },
            miniduliang2: {
                charlotte: true,
                onremove: true,
                marktext: '粮',
                intro: {
                    content(storage, player) {
                        var str = '<li>下回合的摸牌阶段额外摸' + storage + '张牌<br><li>摸牌阶段结束时须交给：';
                        for (var target of game.filterPlayer2()) {
                            if (target.storage.miniduliang3 && target.storage.miniduliang3[player.playerid]) str += '<br>→' + get.translation(target) + '：' + get.translation(target.storage.miniduliang3[player.playerid]) + '张牌';
                        }
                        return str;
                    },
                },
                trigger: { player: 'phaseDrawBegin' },
                forced: true,
                content() {
                    trigger.num += player.countMark('miniduliang2');
                },
            },
            miniduliang3: {
                init(player) {
                    if (!player.storage.miniduliang3) player.storage.miniduliang3 = {};
                },
                charlotte: true,
                trigger: { global: 'phaseDrawEnd' },
                filter(event, player) {
                    if (!event.player.countCards('he')) return false;
                    return player.storage.miniduliang3[event.player.playerid];
                },
                direct: true,
                content() {
                    'step 0'
                    var num = player.storage.miniduliang3[trigger.player.playerid];
                    delete player.storage.miniduliang3[trigger.player.playerid];
                    var cards = trigger.player.getCards('he');
                    if (!cards.length) event.finish();
                    else if (cards.length <= num) event._result = { bool: true, cards: cards };
                    else trigger.player.chooseCard('he', '督粮：将' + get.cnNumber(num) + '张牌交给' + get.translation(player), num, true);
                    'step 1'
                    if (result.bool) player.gain(result.cards, trigger.player, 'giveAuto');
                },
            },
            //刘谌
            minizhanjue: {
                audio: 'zhanjue',
                enable: 'phaseUse',
                filterCard(card) {
                    return !card.hasGaintag('miniqinwang');
                },
                selectCard: -1,
                position: 'h',
                filter(event, player) {
                    var stat = player.getStat().skill;
                    if (stat.minizhanjue_draw && stat.minizhanjue_draw >= 3) return false;
                    var hs = player.getCards('h', function (card) {
                        return !card.hasGaintag('miniqinwang');
                    });
                    if (!hs.length) return false;
                    for (var i = 0; i < hs.length; i++) {
                        var mod2 = game.checkMod(hs[i], player, 'unchanged', 'cardEnabled2', player);
                        if (mod2 === false) return false;
                    }
                    return event.filterCard(get.autoViewAs({ name: 'juedou' }, hs));
                },
                viewAs: { name: 'juedou' },
                onuse(links, player) {
                    player.addTempSkill('minizhanjue_effect', 'phaseUseEnd');
                },
                ai: {
                    order: 1,
                    tag: {
                        respond: 2,
                        respondSha: 2,
                        damage: 1,
                    },
                    result: {
                        target: -1.5,
                        player(player, target) {
                            if (player.hasSkillTag('directHit_ai', true, {
                                target: target,
                                card: { name: 'juedou' },
                            }, true)) {
                                return 0;
                            }
                            if (get.damageEffect(target, player, target) > 0 && get.attitude(player, target) > 0 && get.attitude(target, player) > 0) {
                                return 0;
                            }
                            var hs1 = target.getCards('h', 'sha');
                            var hs2 = player.getCards('h', function (card) {
                                return card.hasGaintag('miniqinwang') && get.name(card) == 'sha';
                            });
                            if (hs1.length > hs2.length + 1) {
                                return -2;
                            }
                            var hsx = target.getCards('h');
                            if (hsx.length > 2 && hs2.length == 0 && hsx[0].number < 6) {
                                return -2;
                            }
                            if (hsx.length > 3 && hs2.length == 0) {
                                return -2;
                            }
                            if (hs1.length > hs2.length && (!hs2.length || hs1[0].number > hs2[0].number)) {
                                return -2;
                            }
                            return -0.5;
                        },
                    },
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove(player) {
                            delete player.getStat().skill.minizhanjue_draw;
                        },
                        trigger: { player: 'useCardAfter' },
                        filter(event, player) {
                            return event.skill == 'minizhanjue';
                        },
                        forced: true,
                        popup: false,
                        content() {
                            'step 0'
                            var stat = player.getStat().skill;
                            if (!stat.minizhanjue_draw) stat.minizhanjue_draw = 0;
                            stat.minizhanjue_draw++;
                            player.draw('nodelay');
                            var list = game.filterPlayer(function (current) {
                                if (current.getHistory('damage', function (evt) {
                                    return evt.card == trigger.card;
                                }).length > 0) {
                                    if (current == player) {
                                        stat.minizhanjue_draw++;
                                    }
                                    return true;
                                }
                                return false;
                            });
                            if (list.length) {
                                list.sortBySeat();
                                game.asyncDraw(list);
                            }
                            'step 1'
                            game.delay();
                            'step 2'
                            if (player.getHistory('damage', function (evt) {
                                return evt.card == trigger.card;
                            }).length) {
                                for (var i of game.filterPlayer().filter(function (target) {
                                    return target.getHistory('sourceDamage', function (evt) {
                                        return evt.card == trigger.card && evt.player == player;
                                    }).length && target.isIn() && target.countCards('he');
                                })) player.discardPlayerCard(i, 'he');
                            }
                        },
                    },
                },
            },
            miniqinwang: {
                audio: 'qinwang1',
                enable: 'phaseUse',
                usable: 1,
                zhuSkill: true,
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current != player && current.group == 'shu' && player.hasZhuSkill('miniqinwang', current);
                    });
                },
                filterTarget(card, player, current) {
                    return current != player && current.group == 'shu' && player.hasZhuSkill('miniqinwang', current);
                },
                selectTarget: -1,
                content() {
                    'step 0'
                    if (target.hasCard(function (card) {
                        return _status.connectMode || get.name(card, target) == 'sha';
                    }, 'h')) {
                        target.chooseCard('是否交给' + get.translation(player) + '一张基本牌？', function (card, player) {
                            return get.type(card) == 'basic';
                        }, 'h').set('goon', get.attitude(target, player) > 0).set('ai', function (card) {
                            return _status.event.goon ? 1 : 0;
                        });
                    }
                    else event.finish();
                    'step 1'
                    if (result.bool) {
                        var card = result.cards[0];
                        target.give(card, player).gaintag.add('miniqinwang');
                        player.addTempSkill('miniqinwang_clear');
                        player.chooseBool('是否令' + get.translation(target) + '摸一张牌？');
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) target.draw();
                },
                ai: {
                    order: 5,
                    result: { player: 1 },
                },
                subSkill: {
                    clear: {
                        charlotte: true,
                        onremove(player) {
                            player.removeGaintag('miniqinwang');
                        },
                    },
                },
            },
            //杨婉
            miniyouyan: {
                group: 'miniyouyan_youyan',
                audio: 'youyan',
                enable: 'phaseUse',
                usable: 1,
                filter(event, player) {
                    return player.countCards('he');
                },
                filterCard: lib.filter.cardDiscardable,
                selectCard: [1, Infinity],
                position: 'he',
                check(card) {
                    if (ui.selected.cards.length) return 0;
                    return 5 - get.value(card);
                },
                delay: 0,
                prompt: '出牌阶段限一次，你可以弃置任意张牌',
                content() { },
                ai: {
                    order: 10,
                    result: { player: 1 },
                },
                subSkill: {
                    youyan: {
                        audio: 'youyan',
                        trigger: { player: 'loseAfter', global: 'loseAsyncAfter' },
                        filter(event, player) {
                            if (event.type != 'discard' || event.getlx === false || player != _status.currentPhase) return false;
                            var evt = event.getl(player);
                            if (!evt || !evt.cards2 || !evt.cards2.length) return false;
                            var list = [];
                            for (var i of evt.cards2) {
                                list.add(get.suit(i, player));
                                if (list.length >= lib.suit.length) return false;
                            }
                            var evt = event.getParent('phaseUse');
                            if (evt?.player == player && !evt.miniyouyaned) return true;
                            var evt = event.getParent('phaseDiscard');
                            if (evt?.player == player && !evt.miniyouyaned) return true;
                            return false;
                        },
                        prompt2: '从牌堆中获得本次弃牌中没有的花色的牌各一张',
                        content() {
                            var evt = trigger.getParent('phaseUse');
                            if (evt?.player == player) evt.miniyouyaned = true;
                            else {
                                var evt = trigger.getParent('phaseDiscard');
                                if (evt) evt.miniyouyaned = true;
                            }
                            var list = [], cards = [];
                            var cards2 = trigger.getl(player).cards2;
                            for (var i of cards2) {
                                list.add(get.suit(i, player));
                            }
                            for (var i of lib.suit) {
                                if (list.includes(i)) continue;
                                var card = get.cardPile2(function (card) {
                                    return get.suit(card, false) == i;
                                })
                                if (card) cards.push(card);
                            }
                            if (cards.length) player.gain(cards, 'gain2');
                        },
                        ai: {
                            effect: {
                                player_use(card, player, target) {
                                    if (typeof card == 'object' && player == _status.currentPhase && player.needsToDiscard() == 1 && card.cards && card.cards.filter(function (i) {
                                        return get.position(i) == 'h';
                                    }).length > 0 && !get.tag(card, 'draw') && !get.tag(card, 'gain') && !get.tag(card, 'discard')) return 'zeroplayertarget';
                                },
                            },
                        },
                    },
                },
            },
            //黄月英
            minijizhi: {
                audio: 'rejizhi',
                audioname: ['lukang'],
                trigger: { player: 'useCard' },
                filter(event, player) {
                    return get.type2(event.card) == 'trick';
                },
                frequent: true,
                content() {
                    'step 0'
                    player.draw();
                    'step 1'
                    var card = result[0];
                    event.card = card;
                    if (['basic', 'trick', 'equip'].includes(get.type2(card))) {
                        if (['basic', 'trick'].includes(get.type2(card))) {
                            player.addTempSkill('minijizhi_' + get.type2(card));
                            player.addMark('minijizhi_' + get.type2(card), 1, false);
                            event.finish();
                        }
                        else player.chooseTarget('集智：是否将' + get.translation(card) + '置入一名其他角色的装备栏？', function (card, player, target) {
                            return target != player && target.canEquip(_status.event.card);
                        }).set('card', card).set('ai', function (target) {
                            var player = _status.event.player;
                            var card = _status.event.card;
                            if ((player.canEquip(_status.event.card) || get.equipValue(_status.event.card, target) < 0) && get.equipValue(card) > 0) return 0;
                            return get.attitude(player, target);
                        });
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target);
                        player.$give(card, target, false);
                        game.delay(0.5);
                        target.equip(card);
                    }
                },
                ai: { noautowuxie: true },
                subSkill: {
                    basic: {
                        mark: true,
                        marktext: '集',
                        intro: { content: '手牌上限+#' },
                        charlotte: true,
                        onremove: true,
                        mod: {
                            maxHandcard(player, num) {
                                return num + player.countMark('minijizhi_basic');
                            },
                        },
                    },
                    trick: {
                        mark: true,
                        marktext: '智',
                        intro: { content: '使用【杀】的额定次数+#' },
                        charlotte: true,
                        onremove: true,
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name == 'sha') return num + player.countMark('minijizhi_trick');
                            },
                        },
                    },
                },
            },
            miniqicai: {
                audio: 'reqicai',
                mod: {
                    targetInRange(card, player, target, now) {
                        var type = get.type(card);
                        if (type == 'trick' || type == 'delay') return true;
                    },
                    canBeDiscarded(card) {
                        if (get.position(card) == 'e' && ['equip1', 'equip2'].includes(get.subtype(card))) return false;
                    },
                },
            },
            //周仓
            minizhongyong: {
                audio: 'zhongyong',
                trigger: { player: 'useCardAfter' },
                filter(event, player) {
                    if (event.card.name != 'sha') return false;
                    if (event.cards.filterInD().length) return true;
                    var shan = [];
                    game.countPlayer2(function (current) {
                        current.getHistory('useCard', function (evt) {
                            if (evt.card.name == 'shan' && evt.getParent(3) == event) shan.addArray(evt.cards);
                        });
                    });
                    return shan.filterInD('d').length;
                },
                direct: true,
                content() {
                    'step 0'
                    event.sha = trigger.cards.slice(0).filterInD();
                    event.shan = [];
                    game.countPlayer2(function (current) {
                        current.getHistory('useCard', function (evt) {
                            if (evt.card.name == 'shan' && evt.getParent(3) == trigger) event.shan.addArray(evt.cards);
                        });
                    });
                    event.shan.filterInD('d');
                    player.chooseTarget(get.prompt2('minizhongyong'), function (card, player, target) {
                        return !_status.event.source.includes(target) && target != player;
                    }).set('ai', function (target) {
                        return get.attitude(_status.event.player, target);
                    }).set('source', trigger.targets);
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minizhongyong', target);
                        if (event.sha.length && event.shan.length) {
                            player.chooseControl().set('choiceList', [
                                '将' + get.translation(event.sha) + '交给' + get.translation(target),
                                '将' + get.translation(event.shan) + '交给' + get.translation(target),
                            ]).set('ai', function () {
                                return _status.event.choice;
                            }).set('choice', function () {
                                if (get.color(event.sha) != 'black') return 0;
                                return 1;
                            }());
                        }
                        else event._result = { index: event.sha.length ? 0 : 1 };
                    }
                    else event.finish();
                    'step 2'
                    var cards = result.index == 0 ? event.sha : event.shan;
                    target.gain(cards, 'gain2');
                    event.cards = cards;
                    'step 3'
                    if (cards.filter(function (card) {
                        return get.color(card) == 'red';
                    }).length) target.chooseToUse('忠勇：是否使用一张【杀】？', { name: 'sha' }).set('filterTarget', function (card, player, target) {
                        return target != _status.event.sourcex && _status.event.sourcex.inRange(target) && lib.filter.targetEnabled.apply(this, arguments);
                    }).set('sourcex', player).set('addCount', false);
                    'step 4'
                    if (cards.filter(function (card) {
                        return get.color(card) == 'black';
                    }).length) {
                        player.draw('nodelay');
                        target.draw();
                    }
                },
            },
            minidaopu: {
                mod: {
                    aiOrder(player, card, num) {
                        if (!player.getEquip('qinglong')) return;
                        if (get.itemtype(card) == 'card' && card.name == 'sha' && get.color(card) == 'red') return num + 0.1;
                    },
                },
                inherit: 'jie',
                filter(event, player) {
                    if (!player.getEquip('qinglong')) return false;
                    return event.card && event.card.name == 'sha' && get.color(event.card) == 'red' && event.notLink();
                },
                group: 'minidaopu_qinglong',
                init(player, skill) {
                    player.addExtraEquip(skill, 'qinglong', true, player => player.hasEmptySlot(1) && lib.card['qinglong']);
                },
                onremove(player, skill) {
                    player.removeExtraEquip(skill);
                },
                subSkill: {
                    qinglong: {
                        mod: {
                            attackRange(player, num) {
                                if (player.hasEmptySlot(1)) return num + 2;
                            },
                        },
                        audio: 'qinglong_skill',
                        trigger: { player: ['shaMiss', 'eventNeutralized'] },
                        filter(event, player) {
                            if (!player.hasEmptySlot(1) || !event.card || event.card.name != 'sha') return false;
                            return event.target.isIn() && player.canUse('sha', event.target, false) && (player.hasSha() || _status.connectMode && player.countCards('h'));
                        },
                        direct: true,
                        locked: true,
                        content() {
                            player.chooseToUse(get.prompt('qinglong', trigger.target), function (card, player, event) {
                                if (get.name(card) != 'sha') return false;
                                return lib.filter.filterCard.apply(this, arguments);
                            }, trigger.target, -1).set('addCount', false).logSkill = event.name;
                        },
                    },
                },
            },
            //吕凯
            minitunan: {
                audio: 'xinfu_tunan',
                inherit: 'xinfu_tunan',
                filterTarget: true,
                selectTarget: [1, 2],
            },
            //孙乾
            miniqianya: {
                audio: 'qianya',
                trigger: { target: 'useCardToTargeted' },
                filter(event, player) {
                    return get.type2(event.card) == 'trick' && player.countCards('h');
                },
                direct: true,
                content() {
                    'step 0'
                    var nh = player.countCards('h');
                    player.chooseCardTarget({
                        filterCard: true,
                        filterTarget: lib.filter.notMe,
                        selectCard: [1, nh],
                        ai1(card) {
                            var player = _status.event.player;
                            var cardname = _status.event.cardname;
                            if (_status.event.du) return -get.value(card, player, 'raw');
                            else if (_status.event.shuimeng) {
                                if (cardname == 'wuzhong') {
                                    if (player.needsToDiscard(2 - ui.selected.cards.length)) {
                                        return 10 - get.value(card, player, 'raw');
                                    }
                                }
                                else if (cardname == 'guohe') {
                                    if (player.needsToDiscard(-1 - ui.selected.cards.length)) {
                                        return 10 - get.value(card, player, 'raw');
                                    }
                                }
                                return 0;
                            }
                            else if (cardname == 'lebu') {
                                if (player.needsToDiscard(1 - ui.selected.cards.length)) {
                                    return 8 - get.value(card, player, 'raw');
                                }
                                else {
                                    if (!ui.selected.cards.length) {
                                        return 6 - get.value(card, player, 'raw');
                                    }
                                    return 0;
                                }
                            }
                            else if (cardname == 'shunshou') {
                                if (_status.event.nh <= 2) return get.value(card, player, 'raw');
                            }
                            else if (cardname == 'huogong') {
                                if (player.hp == 1) return get.value(card, player, 'raw');
                            }
                            if (ui.selected.cards.length) return 0;
                            return 7 - get.value(card, player, 'raw');
                        },
                        ai2(target) {
                            var att = get.attitude(_status.event.player, target);
                            var nh2 = target.countCards('h');
                            var num = Math.sqrt(1 + nh2);
                            var cardname = _status.event.cardname;
                            if (_status.event.du) return 0.5 - att;
                            else if (_status.event.shuimeng) {
                                return att / num;
                            }
                            else if (cardname == 'lebu') {
                                return att / num;
                            }
                            else if (cardname == 'shunshou') {
                                if (_status.event.nh <= 2) return att / num;
                            }
                            else if (cardname == 'huogong') {
                                if (_status.event.player.hp == 1) return att / num;
                            }
                            if (_status.event.nh > nh2 + 1) {
                                return att / num;
                            }
                            return 0;
                        },
                        du: player.hasCard(function (card) {
                            return get.value(card, player, 'raw') < 0;
                        }),
                        shuimeng: trigger.getParent(2).name == 'shuimeng',
                        nh: nh,
                        cardname: trigger.card.name,
                        prompt: get.prompt2('miniqianya')
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('miniqianya', result.targets);
                        player.give(result.cards, result.targets[0]);
                        var card = get.cardPile2(function (card) {
                            return get.type(card) != 'equip';
                        });
                        if (card) player.gain(card, 'gain2');
                    }
                },
            },
            //甘夫人
            minishushen: {
                audio: 'shushen',
                trigger: { global: 'damageBegin4' },
                check(event, player) {
                    return get.damageEffect(event.player, event.source, player, event.nature) * event.num < get.effect(player, { name: 'losehp' }, player, player) + get.effect(player, { name: 'draw' }, player, player) + get.effect(event.player, { name: 'draw' }, player, player) / 2;
                },
                logTarget: 'player',
                prompt2: '失去1点体力并防止此伤害，然后你与其各摸一张牌',
                content() {
                    'step 0'
                    trigger.cancel();
                    player.loseHp();
                    'step 1'
                    if (player.isIn() && trigger.player.isIn()) {
                        var targets = [player, trigger.player];
                        targets.sortBySeat(_status.currentPhase);
                        targets[0].draw('nodelay');
                        targets[1].draw();
                    }
                },
                group: 'minishushen_draw',
                ai: { threaten: 0.8 },
                subSkill: {
                    draw: {
                        trigger: { player: 'recoverAfter' },
                        direct: true,
                        preHidden: true,
                        content() {
                            'step 0'
                            event.num = trigger.num || 1;
                            'step 1'
                            player.chooseTarget(get.prompt2('minishushen'), lib.filter.notMe).set('ai', function (target) {
                                return get.attitude(_status.event.player, target);
                            }).setHiddenSkill('minishushen');
                            'step 2'
                            if (result.bool) {
                                player.logSkill('minishushen', result.targets);
                                result.targets[0].draw();
                                if (event.num > 1) {
                                    event.num--;
                                    event.goto(1);
                                }
                            }
                        },
                        ai: { expose: 0.1 },
                    },
                },
            },
            minihuangsi: {
                audio: 'shenzhi',
                enable: 'chooseToUse',
                mark: true,
                limited: true,
                skillAnimation: true,
                animationColor: 'fire',
                filter(event, player) {
                    if (event.type != 'dying') return false;
                    return event.dying == player;
                },
                content() {
                    'step 0'
                    player.awakenSkill('minihuangsi');
                    if (player.hp < 1) player.recover(1 - player.hp);
                    event.num = player.countCards('h') + 2;
                    player.discard(player.getCards('h'));
                    'step 1'
                    player.chooseTarget('皇思：是否令一名角色摸' + get.cnNumber(num) + '张牌？').set('ai', function (target) {
                        return get.attitude(_status.event.player, target);
                    });
                    'step 2'
                    if (result.bool) {
                        player.line('minishushen', result.targets);
                        result.targets[0].draw(num);
                    }
                },
                ai: {
                    order: 0.5,
                    skillTagFilter(player, tag, target) {
                        if (player != target || player.storage.minihuangsi) return false;
                    },
                    save: true,
                    result: {
                        player(player) {
                            if (player.hp <= 0) return 10;
                            if (player.hp <= 1 && player.countCards('he') <= 1) return 10;
                            return 0;
                        },
                    },
                    threaten(player, target) {
                        if (!target.storage.minihuangsi) return 0.6;
                    },
                },
            },
            //刘永
            minifengxiang: {
                audio: 'fengxiang',
                trigger: { player: 'damageEnd' },
                forced: true,
                content() {
                    'step 0'
                    player.draw();
                    'step 1'
                    var target = game.findPlayer(target => {
                        if (!target.isDamaged()) return false;
                        return !game.hasPlayer(current => {
                            return current != target && current.countCards('h', card => card.hasGaintag('fengxiang_tag')) >= target.countCards('h', card => card.hasGaintag('fengxiang_tag'));
                        });
                    });
                    if (target) {
                        player.line(target);
                        target.recover();
                    }
                },
            },
            //糜竺
            miniziyuan: {
                audio: 'ziyuan',
                enable: 'phaseUse',
                filterCard: true,
                selectCard: [1, Infinity],
                filterTarget: lib.filter.notMe,
                check(card) {
                    return lib.skill.rerende.check(card);
                },
                discard: false,
                lose: false,
                delay: false,
                usable: 1,
                content() {
                    'step 0'
                    player.give(cards, target);
                    'step 1'
                    var num = cards.reduce(function (num, card) {
                        return num + (get.number(card, player) || 0);
                    }, 0);
                    if (num >= 13) target.recover();
                    if (num <= 13) player.draw();
                },
                ai: {
                    order: 7,
                    result: {
                        target(player, target) {
                            return lib.skill.rerende.ai.result.target(player, target);
                        },
                    },
                    effect: {
                        target(card, player, target) {
                            return lib.skill.rerende.ai.effect.target_use(card, player, target);
                        },
                    },
                },
            },
            minijugu: {
                audio: 'jugu',
                mod: {
                    maxHandcard(player, num) {
                        return num + player.maxHp;
                    },
                },
                trigger: { player: 'phaseBegin' },
                filter(event, player) {
                    if (typeof player.maxHp != 'number' || player.maxHp < 1) return false;
                    return player.hasUseTarget(get.autoViewAs({ name: 'wugu' }, []));
                },
                direct: true,
                locked: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minijugu'), '视为对至多' + get.cnNumber(player.maxHp) + '名角色使用【五谷丰登】', [1, player.maxHp], function (card, player, target) {
                        return player.canUse(get.autoViewAs({ name: 'wugu' }, []), target, false);
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        return get.effect(target, get.autoViewAs({ name: 'wugu' }, []), player, player);
                    });
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        player.logSkill('minijugu', targets);
                        player.useCard(get.autoViewAs({ name: 'wugu' }, []), targets, false);
                    }
                },
            },
            //糜夫人
            miniguixiu: {
                audio: 'guixiu',
                trigger: { player: ['phaseJieshuBegin', 'dying'] },
                filter(event, player) {
                    return event.name == 'phaseJieshu' || player.storage.miniguixiu;
                },
                forced: true,
                usable: 1,
                content() {
                    player[player.getHp() % 2 == 0 ? 'recover' : 'draw']();
                },
            },
            minicunsi: {
                derivation: ['miniyongjue', 'miniguixiux'],
                audio: 'cunsi',
                enable: 'phaseUse',
                mark: true,
                limited: true,
                filter(event, player) {
                    return player.hp > 0;
                },
                filterTarget: lib.filter.notMe,
                skillAnimation: true,
                animationColor: 'orange',
                content() {
                    'step 0'
                    player.awakenSkill('minicunsi');
                    player.storage.miniguixiu = true;
                    'step 1'
                    target.addSkills('miniyongjue');
                    'step 2'
                    var num = player.hp;
                    player.loseHp(num);
                    target.draw(num + 1);
                },
                ai: {
                    order: 4,
                    expose: 0.5,
                    result: {
                        target(player, target) {
                            //if(!player.countCards('hs',{name:['tao','jiu']})) return 0;
                            return lib.skill.cunsi.ai.result.target(player, target);
                        },
                    },
                },
            },
            miniyongjue: {
                audio: 'yongjue',
                trigger: { global: 'useCardAfter', player: 'damageBegin3' },
                filter(event, player) {
                    if (!event.card || event.card.name != 'sha') return false;
                    if (event.name == 'damage') return typeof get.number(event.card) == 'number' && ((_status.connectMode && player.countCards('he')) || player.getDiscardableCards(player, 'he').some(card => {
                        if (typeof get.number(card, player) != 'number') return false;
                        return get.number(card, player) >= get.number(event.card);
                    }));
                    if (!event.cards || !event.cards.filterInD().length || event.player == player) return false;
                    var evt = event.getParent('phaseUse');
                    return evt?.player == event.player && event.player.getHistory('useCard', function (evt2) {
                        return evt2.card.name == 'sha' && evt2.getParent('phaseUse') == evt;
                    }).indexOf(event) == 0;
                },
                direct: true,
                frequent: true,
                content() {
                    'step 0'
                    if (trigger.name == 'useCard') player.chooseBool(get.prompt('miniyongjue'), '获得' + get.translation(trigger.cards.filterInD())).set('frequentSkill', 'miniyongjue');
                    else {
                        var num = get.number(trigger.card);
                        player.chooseToDiscard(get.prompt('miniyongjue'), '弃置一张点数大于等于' + num + '的牌，防止此伤害', 'he', function (card, player) {
                            return get.number(card, player) >= _status.event.num;
                        }).set('ai', function (card) {
                            var player = _status.event.player;
                            return player.hp * player.hp - get.value(card);
                        }).set('num', num).logSkill = 'miniyongjue';
                    }
                    'step 1'
                    if (result.bool) {
                        if (trigger.name == 'useCard') {
                            player.logSkill('miniyongjue');
                            player.gain(trigger.cards.filterInD(), 'gain2');
                        }
                        else trigger.cancel();
                    }
                },
            },
            //王悦
            minihuguan: {
                audio: 'huguan',
                audioname: ['wangyue'],
                trigger: { global: 'useCard' },
                filter(event, player) {
                    if (get.color(event.card) != 'red') return false;
                    var evt = event.getParent('phaseUse');
                    if (!evt || evt.player != event.player) return false;
                    return event.player.getHistory('useCard', function (evtx) {
                        return get.color(evtx.card) == 'red' && evtx.getParent('phaseUse') == evt;
                    }).indexOf(event) == 0;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseControl(lib.suit, 'cancel2').set('prompt', get.prompt2('minihuguan', trigger.player)).set('ai', function () {
                        var player = _status.event.player, target = _status.event.getTrigger().player;
                        var list = lib.suit.slice(0);
                        var att = get.attitude(player, trigger.player);
                        if (att == 0) return 'cancel2';
                        list.removeArray(target.getStorage(att > 0 ? 'huguan_add' : 'minihuguan_add'));
                        if (list.length) return list.randomGet();
                        return 'cancel2';
                    });
                    'step 1'
                    if (result.control != 'cancel2') {
                        var target = trigger.player;
                        event.target = target;
                        player.logSkill('huguan', target);
                        game.log(player, '选择了', '#g' + get.translation(result.control), '花色');
                        event.suit = result.control;
                        var str = get.translation(target);
                        var suit = get.translation(event.suit);
                        player.chooseControl().set('choiceList', [
                            '令' + str + '本回合' + suit + '牌不计入手牌上限',
                            '令' + str + '本回合不能弃置' + suit + '牌',
                        ]).set('ai', () => _status.event.att > 0 ? 0 : 1).set('att', get.attitude(player, target));
                    }
                    else event.finish();
                    'step 2'
                    var skill = (result.index == 0 ? '' : 'mini') + 'huguan_add';
                    target.addTempSkill(skill);
                    target.markAuto(skill, [event.suit]);
                },
                subSkill: {
                    add: {
                        charlotte: true,
                        onremove: true,
                        mod: {
                            cardDiscardable(card, player) {
                                if (player.getStorage('minihuguan_add').includes(get.suit(card, player)) && get.position(card) == 'h') return false;
                            }
                        },
                        intro: { content: '本回合不能弃置$花色的手牌' },
                    },
                },
            },
            minimingluan: {
                audio: 'mingluan',
                trigger: { global: 'phaseJieshuBegin' },
                filter(event, player) {
                    return player != event.player && event.player.isIn() && game.getGlobalHistory('changeHp', evt => evt.getParent().name == 'recover').length && event.player.countCards('h');
                },
                prompt(event, player) {
                    return get.translation('minimingluan') + '（摸' + (event.player.countCards('h')) + '弃' + (player.countCards('h') + event.player.countCards('h') - 5) + '）';
                },
                check(event, player) {
                    return player.countCards('h') < 5;
                },
                content() {
                    'step 0'
                    player.draw(trigger.player.countCards('h'));
                    'step 1'
                    if (player.countCards('h') > 5) player.chooseToDiscard('h', player.countCards('h') - 5, true);
                },
            },
            //伊籍
            minijijie: {
                onremove: true,
                intro: { content: '已发动过#次' },
                audio: 'xinfu_jijie',
                inherit: 'xinfu_jijie',
                contentBefore() {
                    player.addMark('minijijie', 1, false);
                },
                group: 'minijijie_log',
                subSkill: {
                    log: {
                        audio: 'xinfu_jijie',
                        trigger: { global: ['gainAfter', 'loseAsyncAfter'] },
                        filter(event, player) {
                            if (player.hasSkill('minijijie_used')) return false;
                            return game.hasPlayer(current => current.isPhaseUsing() && event.getg(current).length > 1);
                        },
                        prompt2: '发动【机捷】',
                        content() {
                            player.addTempSkill('minijijie_used', 'roundStart');
                            player.addMark('minijijie', 1, false);
                            var next = game.createEvent('minijijie');
                            next.player = player;
                            next.setContent(lib.skill.minijijie.content);
                        },
                    },
                    used: { charlotte: true },
                },
            },
            minijiyuan: {
                audio: 'xinfu_jiyuan',
                trigger: { global: ['dying', 'gainAfter', 'loseAsyncAfter'] },
                filter(event, player) {
                    if (event.name == 'dying') return player.hasMark('minijijie');
                    if (event.giver != player) return false;
                    if (event.name == 'gain') {
                        return event.player != player && event.getg(event.player).length > 0;
                    }
                    return game.hasPlayer(function (current) {
                        return current != player && event.getg(current).length > 0;
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    if (trigger.name != 'loseAsync') event.targets = [trigger.player];
                    else event.targets = game.filterPlayer(function (current) {
                        return current != player && trigger.getg(current).length > 0;
                    });
                    'step 1'
                    var target = event.targets.shift();
                    event.target = target;
                    var str2 = get.translation(target);
                    var str = (trigger.name == 'dying' ? '令' + str2 + '摸' + get.cnNumber(player.countMark('minijijie')) + '张牌，然后清空【机捷】的发动次数' : '令' + str2 + '摸一张牌');
                    player.chooseBool(get.prompt('minijiyuan', target)).set('ai', function () {
                        var evt = _status.event;
                        return get.attitude(player, evt.getParent().target) > 0;
                    }).set('prompt2', str);
                    'step 2'
                    if (result.bool) {
                        player.logSkill('minijiyuan', target);
                        target.draw(trigger.name == 'dying' ? player.countMark('minijijie') : 1);
                        if (trigger.name == 'dying') {
                            player.removeMark('minijijie', player.countMark('minijijie'), false);
                            game.log(player, '清空了', '#g【机捷】', '的发动次数');
                        }
                    }
                    if (targets.length > 0 && (trigger.name != 'dying' || player.hasMark('minijijie'))) event.goto(1);
                },
            },
            //SP张飞
            minipaoxiao: {
                mod: {
                    cardUsable(card, player) {
                        if (get.name(card, player) == 'sha') return Infinity;
                    },
                    targetInRange(card, player) {
                        if (get.name(card, player) == 'sha') return true;
                    },
                },
                audio: 'paoxiao',
                audioname: ['xiahouba', 'guanzhang'],
                audioname2: { Mbabysp_zhangfei: 'minipaoxiao_Mbabysp_zhangfei' },
                trigger: { player: 'useCard' },
                filter(event, player) {
                    if (event.card.name != 'sha') return false;
                    return player.getHistory('useCard', evt => evt.card.name == 'sha').indexOf(event) > 0;
                },
                forced: true,
                content() {
                    trigger.baseDamage++;
                    player.addTempSkill('minipaoxiao_ai');
                    if (player.getHistory('useCard', evt => evt.card.name == 'sha').indexOf(trigger) > 1) {
                        trigger.directHit.addArray(game.filterPlayer());
                        player.addTempSkill('minipaoxiao_unequip');
                    }
                },
                subSkill: {
                    ai: {
                        charlotte: true,
                        ai: {
                            directHit_ai: true,
                            unequip_ai: true,
                            skillTagFilter(player, tag, arg) {
                                if (!arg || !arg.card || arg.card.name != 'sha' || !player.hasSkill('minipaoxiao')) return false;
                            },
                        },
                    },
                    unequip: {
                        charlotte: true,
                        ai: {
                            unequip: true,
                            skillTagFilter(player, tag, arg) {
                                if (!arg || !arg.card || arg.card.name != 'sha' || !player.hasSkill('minipaoxiao')) return false;
                            },
                        },
                    },
                    Mbabysp_zhangfei: { audio: 'ext:活动武将/audio/skill:2' },
                },
            },
            minixuhe: {
                audio: 'ext:活动武将/audio/skill:1',
                trigger: { player: ['shaMiss', 'useCard', 'respond'] },
                filter(event, player, name) {
                    return name == 'shaMiss' || event.card.name == 'shan';
                },
                async cost(event, trigger, player) {
                    event.result = { bool: true, targets: [event.triggername == 'shaMiss' ? trigger.target : lib.skill.chongzhen.logTarget(trigger, player)] };
                },
                locked: true,
                content() {
                    player.draw('nodelay');
                    event.targets[0].draw();
                },
            },
            //关羽
            minirewusheng: {
                group: ['minirewusheng_wusheng', 'minirewusheng_effect'],
                audio: 'wusheng',
                audioname: ['re_guanyu', 'jsp_guanyu'],
                audioname2: {
                    guanzhang: "wusheng_guanzhang",
                    guansuo: "wusheng_guansuo",
                },
                trigger: { player: 'phaseBegin' },
                forced: true,
                locked: false,
                content() {
                    var card = get.cardPile(function (card) {
                        return get.color(card) == 'red';
                    });
                    if (card) player.gain(card, 'gain2');
                },
                subSkill: {
                    wusheng: {
                        audio: 'wusheng',
                        audioname: ['re_guanyu', 'jsp_guanyu'],
                        audioname2: {
                            guanzhang: "wusheng_guanzhang",
                            guansuo: "wusheng_guansuo",
                        },
                        enable: ['chooseToRespond', 'chooseToUse'],
                        filterCard(card, player) {
                            return get.color(card) == 'red';
                        },
                        position: 'hes',
                        viewAs: { name: 'sha' },
                        viewAsFilter(player) {
                            if (!player.countCards('hes', { color: 'red' })) return false;
                        },
                        prompt: '将一张红色牌当作【杀】使用或打出',
                        check(card) {
                            var val = get.value(card);
                            if (_status.event.name == 'chooseToRespond') return 1 / Math.max(0.1, val);
                            return 5 - val;
                        },
                        ai: {
                            respondSha: true,
                            skillTagFilter(player) {
                                if (!player.countCards('hes', { color: 'red' })) return false;
                            },
                        },
                    },
                    effect: {
                        mod: {
                            aiOrder(player, card, num) {
                                if (get.itemtype(card) == 'card' && card.name == 'sha' && get.color(card) == 'red') return num + 0.1;
                            },
                        },
                        audio: 'wusheng',
                        audioname: ['re_guanyu', 'jsp_guanyu'],
                        audioname2: {
                            guanzhang: "wusheng_guanzhang",
                            guansuo: "wusheng_guansuo",
                        },
                        inherit: 'jie',
                    },
                },
            },
            minituodao: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: ['useCard', 'respond'] },
                filter(event, player) {
                    return event.card.name == 'shan';
                },
                forced: true,
                content() {
                    player.addSkill('minituodao_mark');
                    player.addMark('minituodao_mark', 1, false);
                    player.when('useCard')
                        .filter((event, player) => event.card.name == 'sha')
                        .then(() => {
                            trigger.baseDamage += player.countMark('minituodao_mark');
                            player.removeSkill('minituodao_mark');
                        });
                },
                subSkill: {
                    mark: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '下一张【杀】的伤害基数+#' },
                    },
                },
            },
            miniguanjue: { audio: 'ext:活动武将/audio/skill:2' },
            //王桃
            miniyaopei: {
                audio: 'yaopei',
                trigger: { global: 'phaseDiscardEnd' },
                filter(event, player) {
                    if (player == event.player || !event.player.isIn() || !event.player.getHistory('lose', function (evt) {
                        return evt.type == 'discard' && evt.getParent('phaseDiscard') == event;
                    }).length) return false;
                    return player.countCards('he');
                },
                direct: true,
                content() {
                    'step 0'
                    var suits = [], str = '该角色本阶段弃置的花色：';
                    trigger.player.getHistory('lose', function (evt) {
                        if (evt.type == 'discard' && evt.getParent('phaseDiscard') == trigger) {
                            for (var i of evt.cards2) suits.add(get.suit(i, evt.hs.includes(i) ? evt.player : false));
                        }
                    });
                    suits.sort((a, b) => lib.suit.indexOf(a) - lib.suit.indexOf(b));
                    event.suits = suits;
                    suits.forEach(suit => str += get.translation(suit));
                    player.chooseCardTarget({
                        prompt: get.prompt('miniyaopei', trigger.player),
                        prompt2: '<span class="text center"><li>操作提示：选择要弃置的牌，若其本阶段未弃置过此花色的牌，再选择执行摸牌选项的角色，另一名角色执行回复体力的选项。<br><li>' + str + '</span>',
                        suits: suits,
                        position: 'he',
                        filterCard(card, player) {
                            return lib.filter.cardDiscardable(card, player, 'miniyaopei');
                        },
                        filterTarget(card, player, target) {
                            if (!ui.selected.cards.length || _status.event.suits.includes(get.suit(ui.selected.cards[0]))) return false;
                            return target == player || target == _status.event.getTrigger().player;
                        },
                        selectTarget() {
                            if (!ui.selected.cards.length || _status.event.suits.includes(get.suit(ui.selected.cards[0]))) return -1;
                            return 1;
                        },
                        filterOk() {
                            if (!ui.selected.cards.length) return false;
                            return _status.event.suits.includes(get.suit(ui.selected.cards[0])) || ui.selected.targets.length;
                        },
                        ai1(card) {
                            var player = _status.event.player, source = _status.event.getTrigger().player;
                            if (_status.event.suits.includes(get.suit(card))) return 8 - get.value(card);
                            if (get.attitude(player, source) > 0 && (get.recoverEffect(player, player, player) > 0 || get.recoverEffect(source, player, player) > 0)) return 12 - get.value(card);
                            return 0;
                        },
                        ai2(target) {
                            var player = _status.event.player, source = _status.event.getTrigger().player;
                            var der = get.recoverEffect(source, player, player) > get.recoverEffect(player, player, player) ? player : source;
                            return target == source ? 10 : 0;
                        }
                    });
                    'step 1'
                    if (result.bool) {
                        var target = trigger.player;
                        player.logSkill('miniyaopei', target);
                        player.discard(result.cards);
                        if (!event.suits.some(suit => get.suit(result.cards[0], player) == suit)) {
                            if (player == result.targets[0]) {
                                if (target.isDamaged() && target.hp < player.hp && (get.mode() != 'identity' || player.identity != 'nei')) player.addExpose(0.15);
                                target.recover();
                                player.draw(2);
                            }
                            else {
                                if ((player.isHealthy() || player.hp > target.hp) && (get.mode() != 'identity' || player.identity != 'nei')) player.addExpose(0.15);
                                target.draw(2);
                                player.recover();
                            }
                        }
                        else {
                            player.draw(2);
                            player.recover();
                        }
                    }
                },
            },
            //龙凤
            miniyoulong: {
                zhuanhuanji: true,
                marktext: '☯',
                mark: true,
                intro: {
                    content(storage, player) {
                        var str = player.storage.miniyou_luanfeng ? '' : '每回合限一次，';
                        return str + (storage ? '你可以弃置一张非基本牌，视为使用一张未以此法使用过的基本牌。' : '你可以废除你的一个装备栏，视为使用一张未以此法使用过的普通锦囊牌。');
                    },
                },
                init(player) {
                    player.storage.miniyoulong = false;
                    if (!player.storage.miniyoulong2) player.storage.miniyoulong2 = [];
                },
                hiddenCard(player, name) {
                    var list = get.inpileVCardList(info => info[0] == 'basic' || info[0] == 'trick');
                    if (!list.some(name2 => name2[2] == name && !player.storage.miniyoulong2.some(cardx => cardx.name == name2[2] && cardx.nature == name2[3]))) return false;
                    if (player.hasSkill('miniyoulong_' + (player.storage.miniyoulong || false))) return false;
                    var type = get.type(name);
                    if (player.storage.miniyoulong) return type == 'basic' && ((_status.connectMode && player.countCards('he')) || player.countCards('he', card => get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player)));
                    return type == 'trick' && player.hasEnabledSlot();
                },
                audio: 'youlong',
                enable: 'chooseToUse',
                filter(event, player) {
                    if (player.hasSkill('miniyoulong_' + (player.storage.miniyoulong || false))) return false;
                    var list = get.inpileVCardList(info => info[0] == 'basic' || info[0] == 'trick'), type = player.storage.miniyoulong ? 'basic' : 'trick';
                    if (type == 'basic' && !player.countCards('he', card => get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player))) return false;
                    if (type == 'trick' && !player.hasEnabledSlot()) return false;
                    return list.some(name => name[0] == type && !player.storage.miniyoulong2.some(cardx => cardx.name == name[2] && cardx.nature == name[3]) && event.filterCard(get.autoViewAs({ name: name[2], nature: name[3] }, 'unsure'), player, event));
                },
                chooseButton: {
                    dialog(event, player) {
                        var dialog = ui.create.dialog('游龙', 'hidden');
                        var list2 = get.inpileVCardList(info => info[0] == 'basic' || info[0] == 'trick'), type = player.storage.miniyoulong ? 'basic' : 'trick';
                        if (type == 'trick') {
                            var equips = [];
                            for (let i = 1; i < 6; i++) {
                                if (!player.hasEnabledSlot(i)) continue;
                                equips.push([i, get.translation('equip' + i)]);
                            }
                            if (equips.length > 0) dialog.add([equips, 'tdnodes']);
                        }
                        var list = list2.filter(name => name[0] == type && !player.storage.miniyoulong2.some(cardx => cardx.name == name[2] && cardx.nature == name[3]) && event.filterCard(get.autoViewAs({ name: name[2], nature: name[3] }, 'unsure'), player, event));
                        list = list.map(card => {
                            card[0] = get.translation(card[0]);
                            return card;
                        });
                        dialog.add([list, 'vcard']);
                        return dialog;
                    },
                    filter(button) {
                        if (ui.selected.buttons.length && typeof button.link == typeof ui.selected.buttons[0].link) return false;
                        return true;
                    },
                    select: () => _status.event.player.storage.miniyoulong ? 1 : 2,
                    check(button) {
                        var player = _status.event.player;
                        if (typeof button.link == 'number') {
                            var card = player.getEquip(button.link);
                            if (card) {
                                var val = get.value(card);
                                if (val > 0) return 0;
                                return 5 - val;
                            }
                            switch (button.link) {
                                case 3: return 4.5; break;
                                case 4: return 4.4; break;
                                case 5: return 4.3; break;
                                case 2: return (3 - player.hp) * 1.5; break;
                                case 1: {
                                    if (game.hasPlayer(function (current) {
                                        return (get.realAttitude || get.attitude)(player, current) < 0 && get.distance(player, current) > 1;
                                    })) return 0;
                                    return 3.2;
                                }
                            }
                        }
                        var name = button.link[2];
                        var evt = _status.event.getParent();
                        if (name == 'shan') return 2;
                        if (evt.type == 'dying') {
                            if (get.attitude(player, evt.dying) < 2) return false;
                            if (name == 'jiu') return 2.1;
                            return 1.9;
                        }
                        if (evt.type == 'phase') return player.getUseValue({ name: name, nature: button.link[3] });
                        return 1;
                    },
                    backup(links, player) {
                        if (!links[1]) links = [6, links[0]];
                        else if (typeof links[1] == 'number') links.reverse();
                        var equip = links[0];
                        var name = links[1][2];
                        var nature = links[1][3];
                        var next = {
                            viewAs: {
                                name: name,
                                nature: nature,
                                isCard: true,
                            },
                            popname: true,
                            precontent() {
                                var skill = 'miniyoulong_' + (player.storage.miniyoulong || false);
                                player.logSkill('miniyoulong');
                                if (skill == 'miniyoulong_false') player.disableEquip(lib.skill.miniyoulong_backup.equip);
                                else {
                                    player.discard(event.result.cards);
                                    event.result.card = { name: event.result.card.name, nature: event.result.card.nature };
                                    event.result.cards = [];
                                }
                                delete event.result.skill;
                                if (!player.storage.miniyou_luanfeng) player.addTempSkill(skill);
                                player.changeZhuanhuanji('miniyoulong');
                                player.storage.miniyoulong2.add({ name: event.result.card.name, nature: event.result.card.nature });
                            },
                        };
                        if (player.storage.miniyoulong) {
                            next.filterCard = (card, player) => get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player);
                            next.ignoreMod = true;
                            next.position = 'he';
                            next.check = (card) => 7 - get.value(card);
                        }
                        else {
                            next.equip = equip;
                            next.filterCard = () => false;
                            next.selectCard = -1;
                        }
                        return next;
                    },
                    prompt(links, player) {
                        if (!links[1]) links = [6, links[0]];
                        else if (typeof links[1] == 'number') links.reverse();
                        var equip = 'equip' + links[0];
                        var name = links[1][2];
                        var nature = links[1][3];
                        if (player.storage.miniyoulong) return '弃置一张非基本牌，视为使用' + (get.translation(nature) || '') + get.translation(name);
                        return '废除自己的' + get.translation(equip) + '栏，视为使用' + (get.translation(nature) || '') + get.translation(name);
                    },
                },
                ai: {
                    respondSha: true,
                    respondShan: true,
                    skillTagFilter(player, tag, arg) {
                        if (arg == 'respond') return false;
                        if (!player.storage.miniyoulong || player.hasSkill('miniyoulong_true')) return false;
                        if (!((_status.connectMode && player.countCards('he')) || player.countCards('he', card => get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player)))) return false;
                        var list = get.inpileVCardList(info => info[0] == 'basic' && !player.storage.miniyoulong2.some(card => card.name == info[2] && card.nature == info[3]));
                        var name = (tag == 'respondSha' ? 'sha' : 'shan');
                        return list.some(name2 => name2[2] == name);
                    },
                    order(item, player) {
                        if (player && _status.event.type == 'phase') {
                            var list = get.inpileVCardList(info => info[0] == 'basic' || info[0] == 'trick');
                            var max = 0, type = player.storage.miniyoulong ? 'basic' : 'trick';
                            list = list.filter(name => name[0] == type && !player.storage.miniyoulong2.some(card => card.name == name[2] && card.nature == name[3]));
                            list = list.map(namex => { return { name: namex[2], nature: namex[3] } });
                            for (var card of list) {
                                if (player.getUseValue(card) > 0) {
                                    var temp = get.order(card);
                                    if (temp > max) max = temp;
                                }
                            }
                            if (max > 0) max += 0.3;
                            return max;
                        }
                        return 1;
                    },
                    result: { player: 1 },
                },
                subSkill: {
                    true: { charlotte: true },
                    false: { charlotte: true },
                },
            },
            miniluanfeng: {
                audio: 'luanfeng',
                trigger: { global: 'dying' },
                filter(event, player) {
                    return event.player.maxHp >= player.maxHp && event.player.hp < 1;
                },
                limited: true,
                skillAnimation: true,
                animationColor: 'soil',
                logTarget: 'player',
                check(event, player) {
                    return lib.skill.xinwanlan.check(event, player);
                },
                content() {
                    'step 0'
                    player.awakenSkill('miniluanfeng');
                    trigger.player.recover(3 - trigger.player.hp);
                    'step 1'
                    var targets = [player, trigger.player];
                    while (targets.length) {
                        var target = targets.shift(), list = [];
                        for (var i = 1; i < 6; i++) {
                            for (var j = 0; j < target.countDisabledSlot(i); j++) {
                                list.push(i);
                            }
                        }
                        if (list.length) target.enableEquip(list);
                    }
                    'step 2'
                    trigger.player.drawTo(6);
                    'step 3'
                    player.storage.miniyoulong2 = [];
                    player.storage.miniyou_luanfeng = true;
                    player.removeSkill('miniyoulong_true');
                    player.removeSkill('miniyoulong_false');
                    game.delayx();
                },
            },
            //关张
            minifuhun: {
                audio: 'fuhun',
                inherit: 'fuhun',
                derivation: ['minirewusheng', 'minipaoxiao'],
                check(card) {
                    if (_status.event.player.hasSkill('minirewusheng') && get.color(card) == 'red') return 0;
                    if (_status.event.name == 'chooseToRespond') {
                        if (card.name == 'sha') return 0;
                        return 6 - get.useful(card);
                    }
                    if (_status.event.player.countCards('hs') < 4) return 6 - get.useful(card);
                    return 7 - get.useful(card);
                },
                ai: {
                    respondSha: true,
                    skillTagFilter(player) {
                        if (player.countCards('hs') < 2) return false;
                    },
                    order(item, player) {
                        if (player.hasSkill('minirewusheng') && player.hasSkill('minipaoxiao')) return 1;
                        if (player.countCards('hs') < 4) return 1;
                        return 4;
                    },
                },
                group: 'minifuhun_effect',
                subSkill: {
                    effect: {
                        audio: 'fuhun',
                        trigger: { source: 'damageSource' },
                        filter(event, player) {
                            if (!event.card || event.card.name != 'sha') return false;
                            if (player.storage.minifuhun) return false;
                            if (player.getHistory('sourceDamage', evt => evt.card && evt.card.name == 'sha').length > 1) return true;
                            return player.isPhaseUsing() && event.getParent().skill == 'minifuhun';
                        },
                        forced: true,
                        content() {
                            var skills = lib.skill.minifuhun.derivation.slice();
                            if (player.getHistory('sourceDamage', evt => evt.card && evt.card.name == 'sha').length > 1) {
                                player.removeSkills(skills);
                                player.addSkills(skills);
                                player.storage.minifuhun = true;
                            }
                            else player.addTempSkills(skills);
                        },
                    },
                },
            },
            //谋刘备
            minisbrende: {
                audio: 'sbrende',
                enable: ['chooseToUse', 'chooseToRespond'],
                maxNum: 10,
                filter(event, player) {
                    if (player.hasSkill('minisbrende_used')) return false;
                    for (var name of lib.inpile) {
                        var card = { name: name, isCard: true };
                        if (get.type(name) == 'basic') {
                            if (player.countMark('minisbrende') < 2) continue;
                            if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return true;
                            if (name == 'sha') {
                                for (var nature of lib.inpile_nature) {
                                    card.nature = nature;
                                    if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return true;
                                }
                            }
                        }
                        if (get.type(name) == 'trick') {
                            if (player.countMark('minisbrende') < 3) continue;
                            if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return true;
                        }
                    }
                    return false;
                },
                group: ['minisbrende_give', 'minisbrende_gain'],
                chooseButton: {
                    dialog(event, player) {
                        var dialog = ui.create.dialog('仁德');
                        if (event.type == 'phase') {
                            dialog._chosenOpt = [];
                            var table = document.createElement('div');
                            table.classList.add('add-setting');
                            table.style.margin = '0';
                            table.style.width = '100%';
                            table.style.position = 'relative';
                            var list = ['视为使用牌', '交给其他角色牌'];
                            for (var i of list) {
                                var td = ui.create.div('.shadowed.reduce_radius.pointerdiv.tdnode');
                                td.innerHTML = '<span>' + i + '</span>';
                                td.link = i;
                                if (i == list[0]) {
                                    td.classList.add('bluebg');
                                    dialog._chosenOpt.add(td);
                                }
                                td.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function () {
                                    if (_status.dragged) return;
                                    if (_status.clicked) return;
                                    if (_status.justdragged) return;
                                    _status.tempNoButton = true;
                                    _status.clicked = true;
                                    setTimeout(function () {
                                        _status.tempNoButton = false;
                                    }, 500);
                                    var link = this.link;
                                    if (link == '交给其他角色牌') game.uncheck();
                                    var current = this.parentNode.querySelector('.bluebg');
                                    if (current) {
                                        current.classList.remove('bluebg');
                                        dialog._chosenOpt.remove(current);
                                    }
                                    dialog._chosenOpt.add(this);
                                    this.classList.add('bluebg');
                                    game.check();
                                });
                                table.appendChild(td);
                                dialog.buttons.add(td);
                            }
                            dialog.content.appendChild(table);
                        }
                        var cards = [];
                        for (var name of lib.inpile) {
                            var card = { name: name, isCard: true };
                            if (get.type(name) == 'basic') {
                                if (player.countMark('minisbrende') < 2) continue;
                                if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) cards.push(['基本', '', name]);
                                if (name == 'sha') {
                                    for (var nature of lib.inpile_nature) {
                                        card.nature = nature;
                                        if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) cards.push(['基本', '', name, nature]);
                                    }
                                }
                            }
                            if (get.type(name) == 'trick') {
                                if (player.countMark('minisbrende') < 3) continue;
                                if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) cards.push(['锦囊', '', name]);
                            }
                        }
                        dialog.add([cards, 'vcard'])
                        return dialog;
                    },
                    check(button, player) {
                        if (typeof button.link == 'string') return -1;
                        if (_status.event.getParent().type != 'phase') return 1;
                        return _status.event.player.getUseValue({ name: button.link[2], nature: button.link[3] });
                    },
                    select() {
                        var opts = _status.event.dialog._chosenOpt;
                        return opts?.length && opts[0].link == '交给其他角色牌' ? 0 : 1;
                    },
                    backup(links, player) {
                        var isUse = links.length == 1;
                        var backup = get.copy(lib.skill['minisbrende_' + (isUse ? 'use' : 'give')]);
                        if (isUse) backup.viewAs = { name: links[0][2], nature: links[0][3], isCard: true };
                        return backup;
                    },
                    prompt(links, player) {
                        var isUse = links.length == 1;
                        return (isUse ? ('移去' + (get.type(links[0][2]) == 'basic' ? '2' : '3') + '枚“仁望”，视为使用或打出' + (get.translation(links[0][3]) || '') + get.translation(links[0][2]))
                            : '###仁德###出牌阶段每名角色限一次。你可以将任意张牌交给一名其他角色，然后你获得等量“仁望”标记（至多为' + lib.skill.minisbrende.maxNum + '）');
                    }
                },
                hiddenCard(player, name) {
                    const list = ['basic', 'trick'], num = list.indexOf(get.type(name));
                    return num != -1 && player.countMark('minisbrende') > 1 + num && !player.hasSkill('minisbrende_used');
                },
                marktext: '仁',
                intro: {
                    name: '仁望',
                    name2: '仁望',
                    content: 'mark',
                },
                ai: {
                    respondSha: true,
                    respondShan: true,
                    save: true,
                    skillTagFilter(player) {
                        return player.countMark('minisbrende') > 1 && !player.hasSkill('minisbrende_used');
                    },
                    order(item, player) {
                        if (_status.event.type == 'phase' && lib.skill.minisbzhangwu.ai.result.player(player) > 0) return 9.1;
                        return 0.5;
                    },
                    result: {
                        player(player) {
                            if (_status.event.dying) {
                                return get.attitude(player, _status.event.dying);
                            }
                            return _status.event.type == 'phase' && player.countMark('minisbrende') <= 2 ? 0 : 1;
                        },
                    },
                },
                subSkill: {
                    backup: {},
                    used: { charlotte: true },
                    given: { onremove: true },
                    use: {
                        audio: 'sbrende',
                        filterCard: () => false,
                        selectCard: -1,
                        popname: true,
                        precontent() {
                            player.logSkill('minisbrende_use');
                            delete event.result.skill;
                            player.removeMark('minisbrende', 2 + ['basic', 'trick'].indexOf(get.type(event.result.card.name)));
                            player.addTempSkill('minisbrende_used');
                        }
                    },
                    give: {
                        audio: 'sbrende',
                        enable: 'phaseUse',
                        filterCard: true,
                        selectCard: [1, Infinity],
                        position: 'he',
                        discard: false,
                        lose: false,
                        delay: false,
                        filter(event, player) {
                            if (player.countMark('minisbrende') < 2 || player.hasSkill('minisbrende_used')) return true;
                            for (var name of lib.inpile) {
                                if (get.type(name) != 'basic') continue;
                                var card = { name: name, isCard: true };
                                if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return false;
                                if (name == 'sha') {
                                    for (var nature of lib.inpile_nature) {
                                        card.nature = nature;
                                        if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return false;
                                    }
                                }
                            }
                            return true;
                        },
                        filterTarget(card, player, target) {
                            if (player.getStorage('minisbrende_given').includes(target)) return false;
                            return player != target;
                        },
                        prompt(event) {
                            return '出牌阶段每名角色限一次。你可以将任意张牌交给一名其他角色，然后你获得等量“仁望”标记（至多为' + lib.skill.minisbrende.maxNum + '）';
                        },
                        check(card) {
                            var player = get.owner(card);
                            if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') return 0;
                            if (ui.selected.cards.length + player.countMark('minisbrende') > lib.skill.minisbrende.maxNum) return 0;
                            if (!ui.selected.cards.length && card.name == 'du') return 20;
                            if (ui.selected.cards.length >= Math.max(2, player.countCards('he') - player.hp)) return 0;
                            if (player.countCards('he') <= 1) {
                                var players = game.filterPlayer();
                                for (var i = 0; i < players.length; i++) {
                                    if (players[i].hasSkill('haoshi') &&
                                        !players[i].isTurnedOver() &&
                                        !players[i].hasJudge('lebu') &&
                                        get.attitude(player, players[i]) >= 3 &&
                                        get.attitude(players[i], player) >= 3) {
                                        return 11 - get.value(card);
                                    }
                                }
                                if (player.countCards('he') > player.hp) return 10 - get.value(card);
                                if (player.countCards('he') > 2) return 6 - get.value(card);
                                return -1;
                            }
                            return 18 - (ui.selected.cards.length + player.countMark('minisbrende')) - get.value(card);
                        },
                        content() {
                            player.addTempSkill('minisbrende_given', 'phaseUseAfter');
                            player.markAuto('minisbrende_given', [target]);
                            player.markAuto('minisbrende_givenx', [target]);
                            player.give(cards, target);
                            var num = Math.min(lib.skill.minisbrende.maxNum - player.countMark('minisbrende'), cards.length);
                            if (num > 0) player.addMark('minisbrende', num);
                        },
                        ai: {
                            order(skill, player) {
                                return player.countMark('minisbrende') < 2 ? 6.8 : 5.8;
                            },
                            result: {
                                target(player, target) {
                                    if (!player.hasFriend() && player.hasSkill('minisbzhangwu') && ui.selected.cards.length &&
                                        get.value(ui.selected.cards[0]) > (lib.skill.minisbzhangwu.filterTarget(null, player, target) ? 3 : 5)) return -0.1;
                                    if (target.hasSkillTag('nogain')) return 0;
                                    if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') {
                                        if (target.hasSkillTag('nodu')) return 0;
                                        return -10;
                                    }
                                    if (target.hasJudge('lebu')) return 0;
                                    var nh = target.countCards('h');
                                    return Math.max(1, 5 - nh);
                                }
                            },
                        },
                    },
                    gain: {
                        audio: 'sbrende',
                        trigger: { player: 'phaseUseBegin' },
                        filter(event, player) {
                            return player.countMark('minisbrende') < lib.skill.minisbrende.maxNum;
                        },
                        forced: true,
                        locked: false,
                        content() {
                            var num = Math.min(lib.skill.minisbrende.maxNum - player.countMark('minisbrende'), 3);
                            if (num > 0) player.addMark('minisbrende', num);
                        }
                    },
                },
            },
            minisbzhangwu: {
                audio: 'sbzhangwu',
                enable: 'phaseUse',
                skillAnimation: 'epic',
                animationColor: 'orange',
                limited: true,
                filter(event, player) {
                    if (game.roundNumber <= 1) return false;
                    if (!game.hasPlayer(current => lib.skill.minisbzhangwu.filterTarget(null, player, current))) return false;
                    return true;
                },
                filterTarget(card, player, target) {
                    if (target == player) return false;
                    return player.getStorage('minisbrende_givenx').includes(target);
                },
                selectTarget: [-1, -2],
                multiline: true,
                content() {
                    'step 0'
                    player.awakenSkill('minisbzhangwu');
                    var num = Math.min(game.roundNumber - 1, 3);
                    var cards = target.getCards('he'), count = cards.length;
                    if (count == 0) event.finish();
                    else if (count <= num) event._result = { bool: true, cards: cards };
                    else target.chooseCard('章武：交给' + get.translation(player) + get.cnNumber(num) + '张牌', true, 'he', num);
                    'step 1'
                    if (result.bool) target.give(result.cards, player);
                },
                contentAfter() {
                    player.recover(3);
                    player.tempBanSkill('minisbrende', null, false);
                },
                ai: {
                    order: 9,
                    combo: 'minisbrende',
                    result: {
                        player(player, target) {
                            var targets = game.filterPlayer(current => lib.skill.minisbzhangwu.filterTarget(null, player, current));
                            if (!targets.length) return 0;
                            var eff = 0;
                            for (var target of targets) {
                                eff += get.effect(target, { name: 'shunshou_copy2' }, player, player);
                            }
                            eff += 15 - 5 * Math.max(0, 3 - player.getDamagedHp());
                            return eff > 15 ? 1 : 0;
                        },
                    }
                }
            },
            minisbjijiang: {
                zhuSkill: true,
                audio: 'sbjijiang',
                trigger: { player: 'phaseUseEnd' },
                filter(event, player) {
                    if (!player.hasZhuSkill('minisbjijiang')) return false;
                    return game.hasPlayer(current => {
                        if (current.group != 'shu' || player == current) return false;
                        return game.hasPlayer(currentx => current.inRange(currentx));
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minisbjijiang'), 2).set('filterTarget', (card, player, target) => {
                        if (!ui.selected.targets.length) return target.group == 'shu' && target != player && game.hasPlayer(currentx => target.inRange(currentx));
                        return ui.selected.targets[0].inRange(target);
                    }).set('targetprompt', ['进行选择', '出杀对象']).set('ai', target => {
                        var player = _status.event.player;
                        if (ui.selected.targets.length) return get.effect(target, { name: 'sha' }, player, ui.selected.targets[0], player);
                        var targets = game.filterPlayer(current => target.inRange(current));
                        if (targets.some(currentx => get.effect(currentx, { name: 'sha' }, target, player) > 0)) return 2 - Math.abs(get.attitude(player, target));
                        return 0;
                    }).set('multitarget', true);
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets;
                        event.targets = targets;
                        player.logSkill('minisbjijiang', targets, false);
                        player.line2(targets);
                        var choiceList = [
                            '视为对' + get.translation(targets[1]) + '使用一张【杀】',
                            '你的下一个出牌阶段开始前，跳过此阶段'
                        ];
                        targets[0].chooseControl().set('choiceList', choiceList).set('ai', () => {
                            return _status.event.choice;
                        }).set('choice', get.effect(targets[1], { name: 'sha' }, targets[0], targets[0]) > get.effect(targets[0], { name: 'lebu' }, targets[0], targets[0]) ? 0 : 1);
                    }
                    else event.finish();
                    'step 2'
                    if (result.index == 0) targets[0].useCard({ name: 'sha', isCard: true }, targets[1], false);
                    else targets[0].addSkill('sbjijiang_skip');
                },
            },
            //谋马超
            minisbtieji: {
                audio: 'sbtieji',
                inherit: 'sbtieji',
                logAudio: () => 1,
                async content(event, trigger, player) {
                    const target = trigger.target;
                    target.addTempSkill('fengyin');
                    trigger.directHit.add(target);
                    const result = await player.mini_chooseToMouYi(target).set('namelist', [
                        '出阵迎战', '拱卫中军', '直取敌营', '扰阵疲敌'
                    ]).set('ai', button => {
                        const source = get.event().getParent().player, target = get.event().getParent().target;
                        if (!target.countCards('he') && button.link[2] == 'db_def2') return 10;
                        if (!target.countCards('he') && get.attitude(target, source) <= 0 && button.link[2] == 'db_atk1') return 10;
                        return 1 + Math.random();
                    }).set('sourceSkill', 'sbtieji').forResult();
                    if (result?.bool) {
                        if (result.player == 'db_def1') player.gainPlayerCard(target, 'he', true);
                        else player.draw(2);
                    }
                },
                group: 'minisbtieji_mouyi',
                subSkill: {
                    mouyi: {
                        audio: 'sbtieji1.mp3',
                        trigger: {
                            player: ['chooseToDuibenAfter', 'mini_chooseToMouYiAfter'],
                            target: ['chooseToDuibenAfter', 'mini_chooseToMouYiAfter'],
                        },
                        filter(event, player) {
                            if (event.name == 'chooseToDuiben' && event.title !== '谋弈') return false;
                            return event.result && (event.player == player) === event.result.bool;
                        },
                        forced: true,
                        locked: false,
                        async content(event, trigger, player) {
                            player.addTempSkill('shenzhu_more');
                            player.addMark('shenzhu_more', 1, false);
                            const result = await player.chooseToDiscard('h', '铁骑：是否弃置一张手牌并获得一张【杀】？').set('ai', card => {
                                if (get.name(card, get.event().player) == 'sha') return 0;
                                return lib.skill.zhiheng.check(card);
                            }).forResult();
                            if (result?.bool) {
                                const card = get.cardPile(card => card.name == 'sha');
                                if (card) player.gain(card, 'gain2');
                            }
                        },
                    },
                },
                init() {
                    if (!_status.miniMouYi) {
                        _status.miniMouYi = true;
                        lib.skill.minisbtieji.initMouYi();
                    }
                },
                initMouYi() {
                    game.broadcastAll(() => {
                        lib.element.player.mini_chooseToMouYi = function (target) {
                            var next = game.createEvent('mini_chooseToMouYi');
                            next.player = this;
                            next.target = target;
                            next.setContent(() => {
                                'step 0'
                                if (!target || !event.namelist) {
                                    event.result = { bool: false };
                                    event.finish();
                                    return;
                                }
                                game.broadcastAll((list, sourceSkill) => {
                                    const list2 = ['db_atk1', 'db_atk2', 'db_def1', 'db_def2'];
                                    for (const name of list2) {
                                        lib.card[name].image = (event.sourceSkill ? 'card/' : 'ext:活动武将/image/card/') + name + '_' + list[list2.indexOf(name)];
                                        lib.translate[name] = list[list2.indexOf(name)];
                                    }
                                }, event.namelist, event.sourceSkill);
                                game.log(player, '向', target, '发起了', '#y谋弈');
                                if (!event.ai) event.ai = () => 1 + Math.random();
                                if (_status.connectMode) {
                                    player.chooseButtonOL([
                                        [player, ['谋弈：请选择一种策略', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true],
                                        [target, ['谋弈：请选择一种策略', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true],
                                    ], () => { }, event.ai).set('processAI', () => {
                                        const buttons = _status.event.dialog.buttons;
                                        return { bool: true, links: [buttons.randomGet().link] };
                                    }).set('switchToAuto', () => _status.event.result = 'ai');
                                }
                                'step 1';
                                if (_status.connectMode) {
                                    event.mes = result[player.playerid].links[0][2];
                                    event.tes = result[target.playerid].links[0][2];
                                    event.goto(4);
                                }
                                else player.chooseButton(['谋弈：请选择一种策略', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true).set('ai', event.ai);
                                'step 2';
                                event.mes = result.links[0][2];
                                target.chooseButton(['谋弈：请选择一种策略', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true).set('ai', event.ai);
                                'step 3';
                                event.tes = result.links[0][2];
                                'step 4';
                                game.broadcast(() => ui.arena.classList.add('thrownhighlight'));
                                ui.arena.classList.add('thrownhighlight');
                                game.addVideo('thrownhighlight1');
                                target.$compare(game.createCard(event.tes, '', ''), player, game.createCard(event.mes, '', ''));
                                game.log(target, '选择的策略为', '#g' + get.translation(event.tes));
                                game.log(player, '选择的策略为', '#g' + get.translation(event.mes));
                                game.delay(0, 1500);
                                'step 5';
                                let mes = event.mes.slice(6), tes = event.tes.slice(6), str;
                                if (mes == tes) {
                                    str = get.translation(player) + '谋弈成功';
                                    player.popup('胜', 'wood');
                                    target.popup('负', 'fire');
                                    game.log(player, '#g胜');
                                    event.result = { bool: true };
                                }
                                else {
                                    str = get.translation(player) + '谋弈失败';
                                    target.popup('胜', 'wood');
                                    player.popup('负', 'fire');
                                    game.log(target, '#g胜');
                                    event.result = { bool: false };
                                }
                                event.result.player = event.mes;
                                event.result.target = event.tes;
                                game.broadcastAll(str => {
                                    const dialog = ui.create.dialog(str);
                                    dialog.classList.add('center');
                                    setTimeout(() => dialog.close(), 1000);
                                }, str);
                                if (event.sourceSkill) game.trySkillAudio(event.sourceSkill + '_' + (event.result.bool ? 'true' + mes : 'false'), player);
                                else game.broadcastAll((name, bool, mes) => {
                                    game.playAudio('..', 'extension', '活动武将/audio/skill', name + (bool ? parseFloat(1 + parseInt(mes)) : '4'));
                                }, event.getParent().name, event.result.bool, mes);
                                game.delay(2);
                                'step 6';
                                game.broadcastAll(() => ui.arena.classList.remove('thrownhighlight'));
                                game.addVideo('thrownhighlight2');
                                if (event.clear !== false) game.broadcastAll(ui.clear);
                            });
                            return next;
                        };
                        if (game && (game.players || game.dead)) {
                            const players = game.players.slice().concat(game.dead);
                            for (const player of players) {
                                if (!player.mini_chooseToMouYi) player.mini_chooseToMouYi = lib.element.player.mini_chooseToMouYi;
                            }
                        }
                    });
                },
            },
            //谋黄忠
            minisbliegong: {
                audio: 'sbliegong',
                inherit: 'sbliegong',
                filter(event, player) {
                    return !event.getParent()._minisbliegong_player && event.targets.length == 1 && event.card.name == 'sha' && player.getStorage('minisbliegong').length > 0;
                },
                prompt2(event, player) {
                    var str = '', storage = player.getStorage('minisbliegong');
                    if (storage.length > 1) str += ('亮出并获得牌堆顶的' + get.cnNumber(storage.length - 1) + '张牌并增加伤害；且');
                    str += ('令' + get.translation(event.target) + '不能使用花色为');
                    for (var i of storage) str += get.translation(i);
                    str += ('的牌响应' + get.translation(event.card));
                    return str;
                },
                check(event, player) {
                    var target = event.target;
                    if (get.attitude(player, target) > 0) return false;
                    if (target.hasSkillTag('filterDamage', null, {
                        player: player,
                        card: event.card,
                    })) return false;
                    var storage = player.getStorage('minisbliegong');
                    if (storage.length >= 4) return true;
                    if (storage.length < 3) return false;
                    if (target.hasShan()) return storage.includes('heart') && storage.includes('diamond');
                    return true;
                },
                async content(event, trigger, player) {
                    var storage = player.getStorage('minisbliegong').slice();
                    var num = storage.length - 1;
                    var evt = trigger.getParent();
                    if (num > 0) {
                        if (typeof evt.baseDamage != 'number') evt.baseDamage = 1;
                        var cards = get.cards(num);
                        await game.cardsGotoOrdering(cards);
                        await player.showCards(cards.slice(), get.translation(player) + '发动了【烈弓】');
                        await player.gain(cards, 'gain2');
                        for (const card of cards) {
                            if (storage.includes(get.suit(card, false))) evt.baseDamage++;
                        }
                    }
                    evt._minisbliegong_player = player;
                    player.when('useCardAfter')
                        .filter(evtxx => evtxx._minisbliegong_player == player)
                        .then(() => player.unmarkSkill('minisbliegong'));
                    var target = trigger.target;
                    target.addTempSkill('minisbliegong_block');
                    if (!target.storage.minisbliegong_block) target.storage.minisbliegong_block = [];
                    target.storage.minisbliegong_block.push([evt.card, storage]);
                    lib.skill.minisbliegong.updateBlocker(target);
                },
                updateBlocker(player) {
                    var list = [], storage = player.storage.minisbliegong_block;
                    if (storage?.length) {
                        for (var i of storage) list.addArray(i[1]);
                    }
                    player.storage.minisbliegong_blocker = list;
                },
                ai: {
                    threaten: 3.5,
                    directHit_ai: true,
                    halfneg: true,
                    skillTagFilter(player, tag, arg) {
                        if (arg?.card && arg.card.name == 'sha') {
                            var storage = player.getStorage('minisbliegong');
                            if (storage.length < 3 || !storage.includes('heart') || !storage.includes('diamond')) return false;
                            var target = arg.target;
                            if (target.hasSkill('bagua_skill') || target.hasSkill('bazhen') || target.hasSkill('rw_bagua_skill')) return false;
                            return true;
                        }
                        return false;
                    },
                },
                intro: {
                    content: '已记录花色：$',
                    markcount(storage) {
                        if (!_status.connectMode && game.HasExtension('十周年UI') && lib.config.extension_十周年UI_playerMarkStyle && lib.config.extension_十周年UI_playerMarkStyle == 'decade') return 0;
                        return storage.length;
                    },
                    onunmark: true,
                },
                group: 'minisbliegong_count',
                subSkill: {
                    block: {
                        mod: {
                            cardEnabled(card, player) {
                                if (!player.storage.minisbliegong_blocker) return;
                                var suit = get.suit(card);
                                if (suit == 'none') return;
                                var evt = _status.event;
                                if (evt.name != 'chooseToUse') evt = evt.getParent('chooseToUse');
                                if (!evt || !evt.respondTo || evt.respondTo[1].name != 'sha') return;
                                if (player.storage.minisbliegong_blocker.includes(suit)) return false;
                            },
                        },
                        trigger: {
                            player: ['damageBefore', 'damageCancelled', 'damageZero'],
                            target: ['shaMiss', 'useCardToExcluded', 'useCardToEnd'],
                            global: ['useCardEnd'],
                        },
                        forced: true,
                        popup: false,
                        firstDo: true,
                        charlotte: true,
                        onremove(player) {
                            delete player.storage.minisbliegong_block;
                            delete player.storage.minisbliegong_blocker;
                        },
                        filter(event, player) {
                            if (!event.card || !player.storage.minisbliegong_block) return false;
                            for (var i of player.storage.minisbliegong_block) {
                                if (i[0] == event.card) return true;
                            }
                            return false;
                        },
                        content() {
                            var storage = player.storage.minisbliegong_block;
                            for (var i = 0; i < storage.length; i++) {
                                if (storage[i][0] == trigger.card) {
                                    storage.splice(i--, 1);
                                }
                            }
                            if (!storage.length) player.removeSkill('minisbliegong_block');
                            else lib.skill.minisbliegong.updateBlocker(target);
                        },
                    },
                    count: {
                        trigger: {
                            player: 'useCard',
                            target: 'useCardToTargeted',
                        },
                        filter(event, player, name) {
                            if (name != 'useCard' && player == event.player) return false;
                            var suit = get.suit(event.card);
                            if (!lib.suit.includes(suit)) return false;
                            if (player.storage.minisbliegong && player.storage.minisbliegong.includes(suit)) return false;
                            return true;
                        },
                        direct: true,
                        content() {
                            player.markAuto('minisbliegong', [get.suit(trigger.card)]);
                            player.storage.minisbliegong.sort((a, b) => lib.suit.indexOf(b) - lib.suit.indexOf(a));
                            if (!_status.connectMode && game.HasExtension('十周年UI') && lib.config.extension_十周年UI_playerMarkStyle && lib.config.extension_十周年UI_playerMarkStyle == 'decade') {
                                game.broadcastAll(function (player, skill) {
                                    if (player.marks[skill]) player.marks[skill].firstChild.innerHTML = player.getStorage(skill).reduce((str, suit) => str += get.translation(suit), '');
                                }, player, 'minisbliegong');
                            }
                        },
                    },
                },
            },
            //谋赵云
            minisblongdan: {
                audio: 'sblongdan',
                enable: ['chooseToUse', 'chooseToRespond'],
                filter(event, player) {
                    if (event.type == 'wuxie' || !player.hasMark('charge')) return false;
                    for (var name of lib.inpile) {
                        if (get.type(name) != 'basic') continue;
                        if (player.hasCard({ type: 'basic' }, 'hs')) {
                            if (event.filterCard(get.autoViewAs({ name: name }, 'unsure'), player, event)) return true;
                            if (name == 'sha') {
                                for (var nature of lib.inpile_nature) {
                                    if (event.filterCard(get.autoViewAs({ name: name, nature: nature }, 'unsure'), player, event)) return true;
                                }
                            }
                        }
                    }
                    return false;
                },
                chargeSkill: 3,
                chooseButton: {
                    dialog(event, player) {
                        var list = [];
                        for (var name of lib.inpile) {
                            if (get.type(name) != 'basic') continue;
                            if (player.hasCard({ type: 'basic' }, 'hs')) {
                                if (event.filterCard(get.autoViewAs({ name: name }, 'unsure'), player, event)) list.push(['基本', '', name]);
                                if (name == 'sha') {
                                    for (var nature of lib.inpile_nature) {
                                        if (event.filterCard(get.autoViewAs({ name: name, nature: nature }, 'unsure'), player, event)) list.push(['基本', '', name, nature]);
                                    }
                                }
                            }
                        }
                        return ui.create.dialog('龙胆', [list, 'vcard'], 'hidden');
                    },
                    check(button) {
                        if (_status.event.getParent().type != 'phase') return 1;
                        var player = _status.event.player, card = { name: button.link[2], nature: button.link[3] };
                        if (card.name == 'jiu' && Math.min(player.countMark('charge'), player.countCards('h', { type: 'basic' })) < 2) return 0;
                        return player.getUseValue(card, null, true);
                    },
                    backup(links, player) {
                        return {
                            viewAs: {
                                name: links[0][2],
                                nature: links[0][3],
                            },
                            filterCard: { type: 'basic' },
                            position: 'he',
                            popname: true,
                            check(card) {
                                return 6 / Math.max(1, get.value(card));
                            },
                            precontent() {
                                player.removeCharge();
                                player.addTempSkill('minisblongdan_draw');
                            },
                        }
                    },
                    prompt(links, player) {
                        var card = {
                            name: links[0][2],
                            nature: links[0][3],
                            isCard: true,
                        };
                        return '将一张基本牌当做' + get.translation(card) + '使用';
                    },
                },
                hiddenCard(player, name) {
                    if (get.type(name) != 'basic' || !player.hasMark('charge')) return false;
                    return player.hasCard({ type: 'basic' }, 'hs');
                },
                ai: {
                    respondSha: true,
                    respondShan: true,
                    skillTagFilter(player, tag) {
                        return lib.skill.minisblongdan.hiddenCard(player, tag == 'respondSha' ? 'sha' : 'shan');
                    },
                    order: 9,
                    result: {
                        player(player) {
                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                            return 1;
                        },
                    },
                },
                group: 'minisblongdan_charge',
                subSkill: {
                    backup: { audio: 'minisblongdan' },
                    draw: {
                        charlotte: true,
                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                        filter(event, player) {
                            return event.skill == 'minisblongdan_backup';
                        },
                        forced: true,
                        popup: false,
                        content() {
                            player.draw();
                        },
                    },
                    charge: {
                        audio: 'minisblongdan',
                        trigger: {
                            global: ['phaseBefore', 'phaseEnd'],
                            player: 'enterGame',
                        },
                        forced: true,
                        filter(event, player, name) {
                            if (!player.countCharge(true)) return false;
                            return (name != 'phaseBefore' || game.phaseNumber == 0);
                        },
                        content() {
                            player.addCharge();
                        },
                    },
                },
            },
            minisbshilve: {
                audio: 'sbjizhu',
                trigger: { player: ['useCard', 'respond'] },
                filter(event, player) {
                    if (event.card.name != 'sha' && event.card.name != 'shan') return false;
                    const target = lib.skill.chongzhen.logTarget(event, player);
                    return target && event.skill && event.skill == 'minisblongdan_backup';
                },
                logTarget(event, player) {
                    return lib.skill.chongzhen.logTarget(event, player);
                },
                async content(event, trigger, player) {
                    const target = lib.skill.chongzhen.logTarget(trigger, player);
                    const result = await player.mini_chooseToMouYi(target).set('namelist', [
                        '暂避锋芒', '趁虚而入', '偃旗息鼓', '胆壮心雄'
                    ]).set('ai', button => {
                        const source = get.event().getParent().player, target = get.event().getParent().target;
                        const att = get.attitude(source, target);
                        if (source.countMark('charge') > 2 && (button.link[2] == 'db_atk2' || button.link[2] == 'db_def1')) return att > 0 ? -10 : 10;
                        return 1 + Math.random();
                    }).forResult();
                    if (result?.bool) {
                        if (result.player == 'db_def1') {
                            const card = get.cardPile(card => get.type(card) != 'basic');
                            if (card) await player.gain(card, 'gain2');
                        }
                        else if (player.countMark('charge') < 3) player.addMark('charge', 1);
                    }
                },
                init() {
                    if (!_status.miniMouYi) {
                        _status.miniMouYi = true;
                        lib.skill.minisbtieji.initMouYi();
                    }
                },
            },
            //张嶷
            minishizhi: {
                audio: 'reshizhi',
                inherit: 'reshizhi',
                mod: {
                    cardname(card, player) {
                        if (card.name == 'shan' && _status.currentPhase === player) return 'sha';
                    },
                },
            },
            //蒋琬费祎
            minishoucheng: {
                audio: 'shoucheng',
                trigger: { global: ['equipAfter', 'addJudgeAfter', 'loseAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'] },
                filter(event, player) {
                    const target = _status.currentPhase;
                    return game.hasPlayer(current => {
                        if (target && current == target) return false;
                        const evt = event.getl(current);
                        return evt?.hs?.length && current.countCards('h') < current.maxHp;
                    });
                },
                async cost(event, trigger, player) {
                    const targetx = _status.currentPhase;
                    const targets = game.filterPlayer(current => {
                        if (targetx && current == targetx || !current.isIn()) return false;
                        const evt = trigger.getl(current);
                        return evt?.hs?.length && current.countCards('h') < current.maxHp;
                    }).sortBySeat(targetx || player);
                    event.result = await player.chooseTarget((card, player, target) => {
                        return get.event().targets.includes(target);
                    }).set('prompt', '是否对' + (targets.length > 1 ? '其中一名角色' : get.translation(targets[0])) + '发动【守成】？')
                        .set('prompt2', '令其摸两张牌').set('targets', targets).set('ai', target => get.attitude(get.event().player, target)).forResult();
                },
                usable: 1,
                async content(event, trigger, player) {
                    const target = event.targets[0];
                    if (get.mode() != 'identity' || player.identity != 'nei') player.addExpose(0.2);
                    await target.draw(2);
                },
            },
            //谋孙尚香
            minisbxiaoji: {
                audio: 'sbxiaoji',
                inherit: 'xiaoji',
                frequent: false,
                forced: true,
                locked: false,
                async content(event, trigger, player) {
                    await player.draw(2);
                    const result = await player.chooseTarget('是否弃置场上的一张牌？', (card, player, target) => {
                        return target.countDiscardableCards(player, 'ej');
                    }).set('ai', target => {
                        var player = _status.event.player;
                        var att = get.attitude(player, target);
                        if (att > 0 && (target.countCards('j') > 0 || target.countCards('e', function (card) {
                            return get.value(card, target) < 0;
                        }))) return 2;
                        if (att < 0 && target.countCards('e') > 0 && !target.hasSkillTag('noe')) return -1;
                        return 0;
                    }).forResult();
                    if (result.bool) {
                        await player.discardPlayerCard(result.targets[0], 'ej', true);
                        player.addExpose(0.2);
                    }
                },
            },
            minisbjieyin: {
                audio: 'sbjieyin1.mp3',
                trigger: { global: 'phaseBefore', player: 'enterGame' },
                filter(event, player) {
                    return game.hasPlayer(target => target != player && (!target.hasMark('minisbjieyin') || !target.hasSkill('minisbjieyin', null, false, false))) && (event.name != 'phase' || game.phaseNumber == 0);
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt('minisbjieyin'), '选择一名其他角色，你与其各获得1枚“姻”标记，然后令其获得【结姻】，最后你将势力变更至与其相同', (card, player, target) => {
                        return target != player && (!target.hasMark('minisbjieyin') || !target.hasSkill('minisbjieyin', null, false, false));
                    }).set('ai', target => {
                        const player = get.event().player;
                        return get.attitude(player, target) + 1145141919810;
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const target = event.targets[0], skill = event.name;
                    if (!player.hasMark(skill)) player.addMark(skill, 1);
                    if (!target.hasMark(skill)) target.addMark(skill, 1);
                    if (!target.hasSkill(skill, null, false, false)) await target.addSkills(skill);
                    if (player.group != target.group) await player.changeGroup(target.group);
                },
                marktext: '姻',
                intro: { content: 'mark' },
                group: ['minisbjieyin_xingshang', 'minisbjieyin_jieyin'],
                subSkill: {
                    xingshang: {
                        audio: 'sbjieyin1',
                        inherit: 'xingshang',
                        filter(event, player) {
                            if (!event.player.hasMark('minisbjieyin')) return false;
                            return event.player.countCards('hej') > 0;
                        },
                        locked: false,
                        logTarget: 'player',
                        content() {
                            event.togain = trigger.player.getCards('hej');
                            player.gain(event.togain, trigger.player, 'giveAuto', 'bySelf');
                        },
                    },
                    jieyin: {
                        audio: 'sbjieyin1',
                        inherit: 'minijieyin',
                        filter(event, player) {
                            return player.countCards('he') && game.hasPlayer(target => target != player && target.hasMark('minisbjieyin'));
                        },
                        filterTarget(card, player, target) {
                            if (!target.hasMark('minisbjieyin') || target == player) return false;
                            const cardx = ui.selected.cards[0];
                            if (!cardx) return false;
                            if (get.position(cardx) == 'e' && !target.canEquip(cardx)) return false;
                            return true;
                        },
                        prompt: '出牌阶段限一次，你可以将一张手牌交给一名有“姻”的其他角色或将一张装备牌置入一名有“姻”的其他角色的对应空置装备栏，然后你回复1点体力并摸一张牌。',
                        async content(event, trigger, player) {
                            const { target, cards } = event;
                            let result;
                            if (get.position(cards[0]) == 'e') result = { index: 1 };
                            else if (get.type(cards[0]) != 'equip' || !target.canEquip(cards[0])) result = { index: 0 };
                            else result = await player.chooseControl().set(`choiceList`, [`将${get.translation(cards[0])}交给${get.translation(target)}`, `将${get.translation(cards[0])}置入${get.translation(target)}的装备区`]).set('ai', () => 1).forResult();
                            if (result.index == 0) {
                                await player.give(cards, target, true);
                            }
                            else {
                                player.$give(cards, target);
                                await game.delay(0.5);
                                await target.equip(cards[0]);
                            }
                            await player.recover();
                            await player.draw();
                        },
                        ai: {
                            order(_, player = get.event().player) {
                                const es = player.getCards('e');
                                for (let i = 0; i < es.length; i++) {
                                    if (player.countCards('h', { subtype: get.subtype(es[i]) })) return 10;
                                }
                                return 2;
                            },
                            result: {
                                target(player, target) {
                                    const goon = player => {
                                        const es = player.getCards('e');
                                        for (let i = 0; i < es.length; i++) {
                                            if (player.countCards('h', { subtype: get.subtype(es[i]) })) return true;
                                        }
                                        return false;
                                    };
                                    if (player.isHealthy()) {
                                        if (!player.needsToDiscard(1) || goon(player)) return 0.1;
                                        return 0;
                                    }
                                    return 1.5;
                                },
                            },
                        },
                    },
                },
            },
            minisbfanxiang: {
                limited: true,
                audio: 'sbjieyin2.mp3',
                enable: 'phaseUse',
                filter(event, player) {
                    return game.hasPlayer(target => lib.skill.minisbfanxiang.filterTarget(null, player, target));
                },
                filterTarget(card, player, target) {
                    return target != player && target.hasMark('minisbjieyin') && target.countGainableCards(player, 'e');
                },
                selectTarget: [-1, -2],
                multiline: true,
                multitarget: true,
                skillAnimation: true,
                animationColor: 'wood',
                async content(event, trigger, player) {
                    const targets = event.targets.sortBySeat();
                    player.awakenSkill('minisbfanxiang');
                    await player.gain(targets.map(target => target.getGainableCards(player, 'e')).flat(), 'give');
                    for (const i of game.filterPlayer().sortBySeat()) {
                        if (i.hasMark('minisbjieyin')) i.removeMark('minisbjieyin', i.countMark('minisbjieyin'));
                        if (i.hasSkill('minisbjieyin', null, false, false)) await i.removeSkills('minisbjieyin');
                    }
                    await player.addSkills('miniwujian');
                    if (player.group != 'wu') await player.changeGroup('wu');
                },
                derivation: 'miniwujian',
                ai: {
                    order: 10,
                    result: {
                        player(player) {
                            const targets = game.filterPlayer(target => lib.skill.minisbfanxiang.filterTarget(null, player, target));
                            return targets.map(target => target.getGainableCards(player, 'e')).flat().length >= Math.max(3, targets.length);
                        },
                    },
                },
            },
            //sp夏侯氏
            minispyanyu: {
                audio: 'sbyanyu',
                trigger: { global: 'phaseUseBegin' },
                filter(event, player) {
                    return player.hasCard(card => _status.connectMode || lib.filter.cardDiscardable(card, player), 'he');
                },
                async cost(event, trigger, player) {
                    const name = event.name.slice(0, -5);
                    const next = player.chooseToDiscard('he', get.prompt(name));
                    if (player == trigger.player) {
                        next.set('goon', (function () {
                            var map = {
                                basic: 0,
                                trick: 0.1,
                            };
                            var hs = trigger.player.getCards("h");
                            var sha = false;
                            var jiu = false;
                            for (var i = 0; i < hs.length; i++) {
                                if (trigger.player.hasValueTarget(hs[i])) {
                                    if (hs[i].name == "sha" && !sha) {
                                        sha = true;
                                        map.basic += 2;
                                    }
                                    if (hs[i].name == "tao") map.basic += 6;
                                    if (hs[i].name == "jiu") {
                                        jiu = true;
                                        map.basic += 2.5;
                                    }
                                    if (get.type(hs[i]) == "trick") map.trick += get.value(hs[i], player, "raw");
                                }
                            }
                            return map;
                        })());
                        next.set("ai", card => {
                            var map = _status.event.goon;
                            var type = get.type(card, "trick");
                            if (!map[type]) return -1;
                            return map[type] - get.value(card);
                        });
                    }
                    else {
                        next.set("ai", function (cardx) {
                            var map = {
                                basic: 0,
                                trick: 0,
                            };
                            var hs = trigger.player.getCards("h");
                            var sha = false;
                            var jiu = false;
                            for (var i = 0; i < hs.length; i++) {
                                if (hs[i] != cardx && trigger.player.hasValueTarget(hs[i])) {
                                    if (hs[i].name == "sha" && !sha) {
                                        sha = true;
                                        map.basic += 2;
                                    }
                                    if (hs[i].name == "tao") map.basic += 6;
                                    if (hs[i].name == "jiu") {
                                        jiu = true;
                                        map.basic += 3;
                                    }
                                    if (get.type(hs[i]) == "trick") map.trick += player.getUseValue(hs[i]);
                                }
                            }
                            var type = get.type(cardx, "trick");
                            if (!map[type]) return -get.value(cardx);
                            return map[type] - get.value(cardx);
                        })
                    }
                    next.logSkill = name;
                    event.result = await next.forResult();
                },
                popup: false,
                async content(event, trigger, player) {
                    player.addTempSkill(event.name + '_effect');
                    player.markAuto(event.name, [get.type2(event.cards[0])]);
                },
                subSkill: {
                    effect: {
                        init(player, skill) {
                            player.storage[skill] = 0;
                        },
                        onremove(player, skill) {
                            delete player.storage.minispyanyu;
                            delete player.storage.minispyanyu_effect;
                        },
                        trigger: {
                            global: ['loseAfter', 'cardsDiscardAfter', 'loseAsyncAfter', 'equipAfter'],
                        },
                        filter(event, player) {
                            if (player.storage.minispyanyu_effect >= 2) return false;
                            const evt = event.getParent('phaseUse');
                            if (!evt || evt.name != 'phaseUse') return false;
                            const type = player.getStorage('minispyanyu'),
                                cards = event.getd();
                            return cards.some(card => type.includes(get.type2(card)) && get.position(card, true) == 'd');
                        },
                        direct: true,
                        async content(event, trigger, player) {
                            const type = player.getStorage('minispyanyu');
                            let cards = trigger.getd().filter(card => type.includes(get.type2(card)) && get.position(card, true) == 'd');
                            while (cards.length && player.storage.minispyanyu_effect < 2) {
                                const { links } = await player.chooseCardButton(cards, '【燕语】：是否将其中的一张牌交给一名角色？').set('ai', card => {
                                    if (card.name == 'du') return 10;
                                    return get.value(card);
                                }).forResult();
                                if (!links || !links.length) return;
                                player.storage.minispyanyu_effect++;
                                if (!event.logged) {
                                    await player.logSkill(event.name);
                                    player.addExpose(0.25);
                                    event.logged = true;
                                }
                                player.addExpose(0.25);
                                const togain = links[0];
                                cards.remove(togain);
                                const { targets } = await player.chooseTarget(true, '请选择要获得' + get.translation(togain) + '的角色')
                                    .set('ai', function (target) {
                                        var att = get.attitude(_status.event.player, target);
                                        var card = _status.event.card;
                                        var val = get.value(card);
                                        if (player.storage.minispyanyu_effect < 2 && target == _status.currentPhase && target.hasValueTarget(card, null, true)) att = att * 5;
                                        else if (target == player && !player.hasJudge('lebu') && get.type(card) == 'trick') att = att * 3;
                                        if (target.hasSkillTag('nogain')) att /= 10;
                                        return att * val;
                                    })
                                    .set('card', togain).forResult();
                                if (!targets || !targets.length) return;
                                const target = targets[0];
                                player.line(target, 'green');
                                await target.gain(togain, 'gain2');
                            }
                        },
                    }
                }
            },
            //胡金定
            miniwuyuan: {
                audio: 'dcwuyuan',
                inherit: 'dcwuyuan',
                async content(event, trigger, player) {
                    const cards = event.cards, target = event.targets[0];
                    await player.give(cards, target, 'give');
                    await player.recover();
                    let num = 1;
                    if (get.natureList(cards[0]).length) num++;
                    await player.draw('nodelay');
                    await target.draw(num);
                    if (get.color(cards[0]) == 'red') await target.recover();
                    if (get.color(cards[0]) == 'black') {
                        if (!target.countMark(event.name + '_buff')) {
                            target.when({ player: 'phaseBegin' }).then(() => {
                                let num = player.countMark('miniwuyuan_buff');
                                player.removeSkill('miniwuyuan_buff');
                                player.addTempSkill('miniwuyuan_sha');
                                player.addMark('miniwuyuan_sha', num, false);
                            });
                        }
                        target.addSkill(event.name + '_buff');
                        target.addMark(event.name + '_buff', 1, false);
                    }
                },
                subSkill: {
                    buff: {
                        charlotte: true,
                        onremove: true,
                        intro: {
                            content: '下回合使用【杀】的次数上限+#',
                        },
                    },
                    sha: {
                        charlotte: true,
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name == 'sha') return num + player.countMark('miniwuyuan_sha');
                            },
                        },
                        onremove: true,
                        intro: {
                            content: '本回合使用【杀】的次数上限+#',
                        },
                    }
                }
            },
            //邓芝
            miniweimeng: {
                audio: 'weimeng',
                inherit: 'weimeng',
                async content(event, trigger, player) {
                    const target = event.targets[0];
                    let num = player.getHp();
                    if (player.getAllHistory('useSkill', evt => evt.skill == event.name)?.at(-2)?.[event.name + '_mark']) num++;
                    const result = await player.gainPlayerCard(target, 'h', true, [1, num]).forResult();
                    if (result?.bool && target.isIn()) {
                        const hs = player.getCards('he');
                        if (!hs.length) return;
                        const num1 = result.cards.reduce((sum, card) => sum + get.number(card, player), 0);
                        const { cards } = await player.chooseToGive(target, true, Math.min(hs.length, result.cards.length), 'he').forResult();
                        const num2 = cards.reduce((sum, card) => sum + get.number(card, player), 0);
                        if (num2 > num1) await player.draw();
                        else if (num2 < num1) {
                            if (target.countDiscardableCards(player, 'hej')) await player.discardPlayerCard(target, true, 'hej');
                        }
                        else {
                            const history = player.getAllHistory('useSkill', evt => evt.skill == event.name);
                            history[history.length - 1][event.name + '_mark'] = true;
                        }
                    }
                },
            },
            //马神
            minifuman: {
                audio: 'refuman',
                inherit: 'refuman',
                filterTarget(card, player, target) {
                    if (target == player) return false;
                    var stat = player.getStat('skill').minifuman_targets;
                    return !stat || !stat.includes(target);
                },
                filter(event, player) {
                    return player.countCards('he') > 0 && game.hasPlayer(current => lib.skill.minifuman.filterTarget(null, player, current));
                },
                position: 'he',
                check(card) {
                    return get.cardPile2(card => card.name == 'sha') ? 6 - get.value(card) : 0;
                },
                async content(event, trigger, player) {
                    const { target } = event, card = get.cardPile2(card => card.name == 'sha');
                    if (card) {
                        const next = target.gain(card, 'gain2')
                        next.gaintag.add(event.name);
                        await next;
                        player.addSkill(event.name + '_draw');
                    }
                    const stat = player.getStat('skill');
                    if (!stat.minifuman_targets) stat.minifuman_targets = [];
                    stat.minifuman_targets.push(target);
                },
                subSkill: {
                    draw: {
                        trigger: {
                            global: ['loseAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter', 'useCardAfter'],
                        },
                        getIndex(event, player) {
                            if (event.name == 'useCard') {
                                if (event.player.hasHistory('lose', evt => {
                                    if (evt.getParent() != event) return false;
                                    return Object.values(evt.gaintag_map).flat().includes('minifuman');
                                }) && event.player.hasHistory('sourceDamage', evt => evt.card == event.card)) return [event.player];
                            }
                            else return game.filterPlayer(current => {
                                if (current == player) return false;
                                const evt = event.getl(current);
                                if (!evt || !evt.hs || !evt.hs.length) return false;
                                if (event.name == 'lose') {
                                    return Object.values(event.gaintag_map).flat().includes('minifuman');
                                }
                                return current.hasHistory('lose', evt => {
                                    if (event != evt.getParent()) return false;
                                    return Object.values(evt.gaintag_map).flat().includes('minifuman');
                                });
                            }).sortBySeat();
                        },
                        charlotte: true,
                        forced: true,
                        logTarget(event, player, name, target) {
                            return target;
                        },
                        async content(event, trigger, player) {
                            if (trigger.name == 'useCard') await player.draw();
                            else await game.asyncDraw([event.targets[0], player]);
                        },
                    }
                }
            },
            //关羽
            //加个忠义，彩蛋不删
            miniweilin: {
                audio: 'olsbweilin',
                enable: 'chooseToUse',
                filter(event, player) {
                    return get.inpileVCardList(info => {
                        const name = info[2];
                        if (name != 'sha' && name != 'jiu') return false;
                        return get.type(name) == 'basic';
                    }).concat([['锦囊', '', 'mini_zhong'], ['锦囊', '', 'mini_yi']]).some(card => {
                        return player.hasCard(cardx => event.filterCard({ name: card[2], nature: card[3], cards: [cardx] }, player, event), 'hes');
                    });
                },
                usable: 1,
                chooseButton: {
                    dialog(event, player) {
                        const list = get.inpileVCardList(info => {
                            const name = info[2];
                            if (name != 'sha' && name != 'jiu') return false;
                            return get.type(name) == 'basic';
                        }).concat([['锦囊', '', 'mini_zhong'], ['锦囊', '', 'mini_yi']]).filter(card => {
                            return player.hasCard(cardx => event.filterCard({ name: card[2], nature: card[3], cards: [cardx] }, player, event), 'hes');
                        });
                        return ui.create.dialog('威临', [list, 'vcard']);
                    },
                    filter(button, player) {
                        return _status.event.getParent().filterCard({ name: button.link[2], nature: button.link[3] }, player, _status.event.getParent());
                    },
                    check(button) {
                        if (_status.event.getParent().type != 'phase') return 1;
                        const player = get.event().player, value = player.getUseValue({ name: button.link[2], nature: button.link[3] });
                        if (button.link[2] == 'sha' && !player.getHistory('useCard', evt => get.type(evt.card) == 'basic').length) {
                            if (value > 0) return value + 20;
                        }
                        return value;
                    },
                    backup(links, player) {
                        return {
                            audio: 'olsbweilin',
                            filterCard: true,
                            popname: true,
                            check(card) {
                                const name = lib.skill.miniweilin_backup.viewAs.name, color = get.color(card);
                                const phase = (_status.event.getParent().type == 'phase');
                                if (phase && name == 'sha' && color == 'red') return 10 - get.value(card);
                                if (name == 'tao') return 7 + [-2, 0, 2][['black', 'red', 'none'].indexOf(color)] - get.value(card);
                                return 6 - get.value(card);
                            },
                            position: 'hse',
                            viewAs: { name: links[0][2], nature: links[0][3] },
                            precontent() {
                                player.addTempSkill('miniweilin_wusheng');
                            },
                            ai: {
                                directHit_ai: true,
                                skillTagFilter(player, tag, arg) {
                                    if (get.event().skill != 'miniweilin_backup') return false;
                                    return arg?.card?.name == 'sha' && get.color(arg.card) == 'red';
                                },
                            },
                        }
                    },
                    prompt(links, player) {
                        return '###威临###将一张牌当作' + (get.translation(links[0][3]) || '') + '【' + get.translation(links[0][2]) + '】使用';
                    },
                },
                hiddenCard(player, name) {
                    return ['sha', 'jiu', 'mini_zhong', 'mini_yi'].includes(name) && !player.getStat('skill').miniweilin && player.countCards('hes');
                },
                ai: {
                    fireAttack: true,
                    respondSha: true,
                    skillTagFilter(player, tag, arg) {
                        if (arg == 'respond') return false;
                        if (player.getStat('skill').miniweilin || !player.countCards('hes')) return false;
                    },
                    order(item, player) {
                        if (player && _status.event.type == 'phase' && player.hasValueTarget({ name: 'sha' }, true, true)) {
                            let max = 0, names = get.inpileVCardList(info => {
                                const name = info[2];
                                if (name != 'sha' && name != 'jiu') return false;
                                return get.type(name) == 'basic';
                            }).concat([['锦囊', '', 'mini_zhong'], ['锦囊', '', 'mini_yi']]);
                            names = names.map(namex => { return { name: namex[2], nature: namex[3] } });
                            names.forEach(card => {
                                if (player.getUseValue(card) > 0) {
                                    let temp = get.order(card);
                                    if (card.name == 'jiu') {
                                        let cards = player.getCards('hs', cardx => get.value(cardx) < 8);
                                        cards.sort((a, b) => get.value(a) - get.value(b));
                                        if (!cards.some(cardx => get.name(cardx) == 'sha' && !cards.slice(0, 2).includes(cardx))) temp = 0;
                                    }
                                    if (temp > max) max = temp;
                                }
                            });
                            if (max > 0) max += 15;
                            return max;
                        }
                        return 0.5;
                    },
                    result: {
                        player(player) {
                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                            return 1;
                        },
                    },
                },
                derivation: ['mini_zhong', 'mini_yi', 'shuiyanqijuny'],
                group: 'miniweilin_gain',
                global: 'miniweilin_zhong',
                subfrequent: ['gain'],
                subSkill: {
                    wusheng: {
                        charlotte: true,
                        trigger: { global: 'useCardToBegin' },
                        filter(event, player) {
                            if (!event.target) return false;
                            return event.skill === 'miniweilin_backup';
                        },
                        forced: true,
                        popup: false,
                        content() {
                            const { target } = trigger;
                            target.addTempSkill('olsbweilin_wusheng');
                            target.markAuto('olsbweilin_wusheng', [get.color(trigger.card)]);
                        },
                    },
                    zhong: {
                        sourceSkill: false,
                        trigger: { global: 'damageBegin4' },
                        filter(event, player) {
                            if (event.player === player) return false;
                            return player.hasUsableCard('mini_zhong');
                        },
                        direct: true,
                        content() {
                            event.mini_zhong = trigger;
                            player.chooseToUse((card, player) => {
                                if (get.name(card) != 'mini_zhong') return false;
                                return lib.filter.cardEnabled(card, player, 'forceEnable');
                            }, '是否使用【忠】，将即将对' + get.translation(trigger.player) + '造成的伤害转移给自己？');
                        },
                    },
                    backup: {},
                    gain: {
                        audio: 'olsbweilin',
                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                        filter(event, player) {
                            return (game.getAllGlobalHistory('everything', evt => {
                                return ['useCard', 'respond'].includes(evt.name) && evt.player == player;
                            }).indexOf(event) + 1) % 7 == 0;
                        },
                        frequent: true,
                        prompt2: '获得一张【水淹七军】',
                        content() {
                            if (!_status.miniweilin_syqj || _status.miniweilin_syqj.length > 0) {
                                if (!lib.inpile.includes('shuiyanqijuny')) lib.inpile.add('shuiyanqijuny');
                                if (!_status.miniweilin_syqj) _status.miniweilin_syqj = lib.suit.slice(0);
                                player.gain(game.createCard2('shuiyanqijuny', _status.miniweilin_syqj.randomRemove(), 7), 'gain2');
                            }
                            else {
                                const card = get.cardPile('shuiyanqijuny');
                                if (card) player.gain(card, 'gain2');
                            }
                        },
                    },
                },
            },
            miniduoshou: {
                init(player) {
                    if (player.getHistory('useCard', evt => get.color(evt.card) == 'red').length) player.addTempSkill('miniduoshou_used');
                },
                mod: {
                    targetInRange(card, player, target) {
                        if (get.color(card) == 'red' && !player.hasSkill('miniduoshou_used')) return true;
                    },
                },
                audio: 'olsbduoshou',
                trigger: {
                    player: ['useCard', 'useCardToPlayered'],
                    source: 'damageSource',
                },
                filter(event, player, name) {
                    if (event.name == 'damage') return player.getHistory('sourceDamage').indexOf(event) == 0 && event.player.isIn() && event.player.countGainableCards(player, event.player != player ? 'he' : 'e');
                    if (name == 'useCardToPlayered') {
                        if (event.card.name !== 'sha') return false;
                        return player.getHistory('useCard', evt => evt.card.name == 'sha').indexOf(event.getParent()) == 0;
                    }
                    if (get.color(event.card) == 'red' && !player.hasSkill('miniduoshou_used')) return true;
                    return get.type(event.card) == 'basic' && player.getHistory('useCard', evt => get.type(evt.card) == 'basic').indexOf(event) == 0;
                },
                forced: true,
                async content(event, trigger, player) {
                    if (trigger.name == 'damage') player.gainPlayerCard(trigger.player, trigger.player != player ? 'he' : 'e', true);
                    else if (event.triggername == 'useCardToPlayered') {
                        player.line(trigger.target);
                        player.draw(2);
                    }
                    else {
                        if (get.color(trigger.card) == 'red' && !player.hasSkill('miniduoshou_used')) {
                            game.log(trigger.card, '无距离限制');
                            player.addTempSkill('miniduoshou_used');
                        }
                        if (get.type(trigger.card) == 'basic' && player.getHistory('useCard', evt => get.type(evt.card) == 'basic').indexOf(trigger) == 0) {
                            game.log(trigger.card, '不计入次数上限');
                            if (trigger.addCount !== false) {
                                trigger.addCount = false;
                                const stat = player.stat[player.stat.length - 1].card;
                                if (typeof stat[trigger.card.name] === 'number') stat[trigger.card.name]--;
                            }
                        }
                    }
                },
                subSkill: { used: { charlotte: true } },
            },
            //宗预
            minichengshang: {
                audio: 'chengshang',
                trigger: {
                    player: 'useCardAfter',
                },
                filter(event, player) {
                    if (!lib.suit.includes(get.suit(event.card, false)) || typeof get.number(event.card) != 'number') return false;
                    return player.isPhaseUsing();
                },
                usable: 1,
                async content(event, trigger, player) {
                    const suit = get.suit(trigger.card);
                    const number = get.number(trigger.card);
                    const cards = [];
                    for (var i = 0; i < ui.cardPile.childElementCount; i++) {
                        const card = ui.cardPile.childNodes[i];
                        if (card.suit == suit && card.number == number) cards.push(card);
                    }
                    if (cards.length) {
                        const next = player.gain(cards, 'gain2');
                        next.gaintag.add(event.name + '_effect');
                        await next;
                        player.addTempSkill(event.name + '_effect');
                    }
                    else delete player.storage.counttrigger[event.name];
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove(player) {
                            player.removeGaintag('minichengshang_effect');
                        },
                        mod: {
                            ignoredHandcard(card, player) {
                                if (card.hasGaintag('minichengshang_effect')) return true;
                            },
                            cardDiscardable(card, player, name) {
                                if (name == 'phaseDiscard' && card.hasGaintag('minichengshang_effect')) return false;
                            },
                        },
                    }
                }
            },
            //谋黄月英
            miniliuma: {
                init(player) {
                    if (!_status.miniliuma) _status.miniliuma = [];
                    player.markSkill('miniliuma');
                },
                updateLiuma() {
                    for (const i of game.players) {
                        if (i.hasSkill('miniliuma')) i.markSkill('miniliuma');
                    }
                },
                hiddenCard(player, name) {
                    return _status.miniliuma?.some(card => card.name == name);
                },
                enable: ['chooseToUse', 'chooseToRespond'],
                filter(event, player) {
                    return _status.miniliuma?.some(card => event.filterCard(card, player, event));
                },
                chooseButton: {
                    dialog(event, player) {
                        return ui.create.dialog('流马', _status.miniliuma, 'hidden');
                    },
                    filter(button, player) {
                        var evt = _status.event.getParent();
                        if (evt?.filterCard) return evt.filterCard(button.link, player, evt);
                        return true;
                    },
                    check(button) {
                        if (get.event().getParent().type != 'phase') return 1;
                        if (button.link.name == 'du') return 0;
                        const player = get.player();
                        if (player.getUseValue(button.link) > 0) return get.order(button.link);
                        return -1;
                    },
                    backup(links, player) {
                        return {
                            audio: 'miniliuma',
                            filterCard: () => false,
                            selectCard: -1,
                            viewAs: links[0],
                            onuse(result, player) {
                                if (_status.miniliuma?.includes(result.cards[0])) {
                                    _status.miniliuma.remove(result.cards[0]);
                                    lib.skill.miniliuma.updateLiuma();
                                }
                            },
                            onrespond() {
                                return this.onuse.apply(this, arguments);
                            },
                            precontent() {
                                const card = lib.skill.miniliuma_backup.viewAs;
                                event.result.cards = [card];
                                event.result.card.cards = [card];
                            },
                        }
                    },
                    prompt(links) {
                        return '请选择' + get.translation(links) + '的目标';
                    },
                },
                ai: {
                    save: true,
                    respondSha: true,
                    respondShan: true,
                    skillTagFilter(player, tag) {
                        return _status.miniliuma?.some(card => {
                            switch (tag) {
                                case 'respondSha': if (card.name == 'sha') return true; break;
                                case 'respondShan': if (card.name == 'shan') return true; break;
                                case 'save': {
                                    if (card.name == 'tao' || card.name == 'spell_zhiliaoshui') return true;
                                    if (player == _status.event.dying) {
                                        if (card.name == 'jiu' || card.name == 'tianxianjiu') return true;
                                    }
                                    break;
                                }
                            }
                        });
                    },
                    order(item, player) {
                        if (_status.event.type != 'phase') return 4;
                        if (!player || !_status.miniliuma?.some(card => player.getUseValue(card) > 0)) return 0;
                        let cards = _status.miniliuma.filter(card => player.getUseValue(card) > 0);
                        cards.sort((a, b) => get.order(b, player) - get.order(a, player));
                        if (get.order(cards[0], player) <= 0) return 0;
                        return get.order(cards[0], player) + 0.1;
                    },
                    result: {
                        player(player) {
                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                            return 1;
                        },
                    },
                },
                intro: {
                    markcount: () => _status.miniliuma?.length,
                    mark(dialog) {
                        if (_status.miniliuma?.length) dialog.addAuto(_status.miniliuma);
                        else return '“流马”区暂无卡牌';
                    },
                },
                group: ['miniliuma_put', 'miniliuma_give'],
                subSkill: {
                    backup: {},
                    put: {
                        trigger: { player: 'phaseUseEnd' },
                        filter(event, player) {
                            if (!player.countCards('h') || !player.getHp()) return false;
                            return _status.miniliuma.length < 5;
                        },
                        async cost(event, trigger, player) {
                            const num = Math.min(player.getHp(), 5 - _status.miniliuma.length);
                            event.result = await player.chooseCard(get.prompt('miniliuma'), [1, num], '将至多' + get.cnNumber(num) + '张牌置入“流马”区').set('ai', card => {
                                return get.value(card) * get.useful(card);
                            }).forResult();
                        },
                        async content(event, trigger, player) {
                            _status.miniliuma.addArray(event.cards);
                            lib.skill.miniliuma.updateLiuma();
                            player.$give(event.cards, player, false);
                            await player.lose(event.cards, ui.special, 'visible');
                            game.log(player, '将', event.cards, '置入了“流马”区');
                        },
                    },
                    give: {
                        trigger: { global: 'roundStart' },
                        filter(event, player) {
                            if (player.storage.miniliuma_give) return false;
                            return !game.hasPlayer(target => target !== player && target.hasSkill('miniliuma', null, false, false));
                        },
                        async cost(event, trigger, player) {
                            event.result = await player.chooseTarget(get.prompt('miniliuma'), '令一名其他角色获得【流马】（其不能发动此效果）', lib.filter.notMe).set('ai', target => {
                                return get.attitude(get.player(), target);
                            }).forResult();
                        },
                        async content(event, trigger, player) {
                            const target = event.targets[0];
                            target.storage.miniliuma_give = true;
                            await target.addSkills('miniliuma');
                        },
                    },
                },
            },
            minisbjizhi: {
                audio: 'sbjizhi',
                trigger: { player: 'useCard' },
                filter(event, player) {
                    return get.type2(event.card) == 'trick' && event.card.isCard;
                },
                forced: true,
                preHidden: true,
                async content(event, trigger, player) {
                    player.draw();
                },
                ai: { noautowuxie: true },
                mod: {
                    targetInRange(card) {
                        if (get.type2(card) === 'trick') return true;
                    },
                },
            },
            minisbqicai: {
                audio: 'sbqicai',
                mark: true,
                marktext: '☯',
                zhuanhuanji: true,
                intro: {
                    content(storage) {
                        if (!storage) return '每回合限两次，当你使用普通锦囊牌时，你可以为此牌增加或减少一个目标';
                        return '每回合限两次，出牌阶段，你可以弃置一张基本牌，然后从牌堆中获得一张锦囊牌';
                    },
                },
                trigger: { player: 'useCard2' },
                filter(event, player) {
                    if (player.storage.minisbqicai || get.type(event.card) !== 'trick') return false;
                    if (event.targets?.length > 0) return true;
                    const info = get.info(event.card);
                    if (info.allowMultiple == false) return false;
                    if (event.targets && !info.multitarget) {
                        if (game.hasPlayer(current => {
                            return !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current);
                        })) return true;
                    }
                    return false;
                },
                usable: 2,
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt('minisbqicai'), (card, player, target) => {
                        const trigger = get.event().getTrigger();
                        if (trigger.targets?.includes(target)) return true;
                        return lib.filter.targetEnabled2(trigger.card, player, target) && lib.filter.targetInRange(trigger.card, player, target);
                    }).set('prompt2', '为' + get.translation(trigger.card) + '增加或减少一个目标').set('ai', target => {
                        const player = get.player(), trigger = get.event().getTrigger();
                        return get.effect(target, trigger.card, player, player) * (trigger.targets?.includes(target) ? -1 : 1);
                    }).forResult();
                    if (event.result.bool && !event.isMine() && !event.isOnline()) await game.delayx();
                },
                async content(event, trigger, player) {
                    player.changeZhuanhuanji('minisbqicai');
                    if (trigger.targets.includes(event.targets[0])) trigger.targets.removeArray(event.targets);
                    else trigger.targets.addArray(event.targets);
                },
                group: ['minisbqicai_gain', 'minisbqicai_change'],
                subSkill: {
                    gain: {
                        audio: 'sbqicai',
                        inherit: 'wechatjifeng',
                        filter(event, player) {
                            return player.storage.minisbqicai;
                        },
                        usable: 2,
                        filterCard: { type: 'basic' },
                        prompt: '弃置一张基本牌，然后从牌堆中获得一张锦囊牌',
                        contentBefore() {
                            player.changeZhuanhuanji('minisbqicai');
                        },
                    },
                    change: {
                        audio: 'sbqicai',
                        trigger: {
                            global: 'phaseBefore',
                            player: 'enterGame',
                        },
                        filter(event, player) {
                            return event.name != 'phase' || game.phaseNumber == 0;
                        },
                        prompt2(event, player) {
                            return "切换【奇才】为状态" + (player.storage.minisbqicai ? '阳' : '阴');
                        },
                        check: () => Math.random() > 0.5,
                        content() {
                            player.changeZhuanhuanji('minisbqicai');
                        },
                    },
                },
            },
            //谋姜维
            miniranji: {
                audio: 'olsbranji',
                trigger: { player: 'phaseJieshuBegin' },
                prompt2(event, player) {
                    var str = '获得技能';
                    var num = lib.skill.olsbranji.getNum(player);
                    if (num >= player.getHp()) str += '【困奋】';
                    if (num == player.getHp()) str += '和';
                    if (num <= player.getHp()) str += '【诈降】';
                    str += '，然后';
                    var num1 = (player.countCards('h') - player.getHandcardLimit());
                    if (num1 || player.isDamaged()) {
                        if (num1) str += (num1 < 0 ? '摸' + get.cnNumber(-num1) + '张牌' : '弃置' + get.cnNumber(num1) + '张牌');
                        if (num1 && player.isDamaged()) str += '并';
                        if (player.isDamaged()) str += ('回复' + player.getDamagedHp() + '点体力');
                        str += '，最后';
                    }
                    str += '你不能回复体力直到你杀死角色。';
                    return str;
                },
                check(event, player) {
                    var num = lib.skill.olsbranji.getNum(player);
                    if (num == player.getHp()) return true;
                    return player.getHandcardLimit() - player.countCards('h') >= 3 || player.getDamagedHp() >= 2;
                },
                limited: true,
                skillAnimation: true,
                animationColor: 'fire',
                async content(event, trigger, player) {
                    player.awakenSkill('miniranji');
                    var num = lib.skill.olsbranji.getNum(player);
                    const skills = [];
                    if (num >= player.getHp()) skills.push('minikunfen');
                    if (num <= player.getHp()) skills.push('minisbzhaxiang');
                    player.addSkills(skills);
                    if (player.countCards('h') != player.getHandcardLimit() || player.isDamaged()) {
                        var num1 = player.countCards('h') - player.getHandcardLimit();
                        if (num1 !== 0) {
                            if (num1 < 0) await player.drawTo(player.getHandcardLimit());
                            else await player.chooseToDiscard(num1, 'h', true);
                        }
                        if (player.isDamaged()) await player.recover(player.maxHp - player.hp);
                    }
                    player.addSkill('miniranji_norecover');
                    player.when({ source: 'dieAfter' }).then(() => player.removeSkill('miniranji_norecover'));
                },
                derivation: ['minikunfen', 'minisbzhaxiang'],
                subSkill: {
                    norecover: {
                        charlotte: true,
                        mark: true,
                        intro: { content: '不能回复体力' },
                        trigger: { player: 'recoverBefore' },
                        forced: true,
                        firstDo: true,
                        content() {
                            trigger.cancel();
                        },
                        ai: {
                            effect: {
                                target(card, player, target) {
                                    if (get.tag(card, 'recover')) return 'zeroplayertarget';
                                },
                            },
                        },
                    },
                },
            },
            //雷铜
            minikuiji: {
                audio: 'kuiji',
                enable: "phaseUse",
                filter(event, player) {
                    if (player.hasJudge('bingliang')) return false;
                    return player.countCards('hes', card => {
                        return get.color(card) == 'black' && get.type(card) == 'basic';
                    }) > 0;
                },
                position: 'hes',
                discard: false,
                lose: false,
                delay: false,
                prepare(cards, player) {
                    player.$give(cards, player, false);
                },
                filterCard(card, player, event) {
                    return get.color(card) == 'black' && get.type(card) == 'basic' && player.canAddJudge({ name: 'bingliang', cards: [card] });
                },
                selectTarget: -1,
                filterTarget(card, player, target) {
                    return player == target;
                },
                check(card) {
                    return 9 - get.value(card);
                },
                usable: 1,
                content() {
                    'step 0'
                    player.addJudge({ name: 'bingliang' }, cards);
                    player.draw(2);
                    'step 1'
                    var next = player.chooseTarget().set('ai', target => {
                        let player = _status.event.player;
                        if (target.hasSkillTag('filterDamage', null, {
                            player: player
                        }, true)) return get.damageEffect(target, player, player);
                        return 2 * get.damageEffect(target, player, player);
                    });
                    next.set('prompt', '选择一名除你外体力值最大的角色，对其造成2点伤害');
                    next.set('filterTarget', function (card, player, target) {
                        return player != target && !game.hasPlayer(current => {
                            return current != player && current.hp > target.hp;
                        });
                    });
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target);
                        target.damage(2);
                    }
                },
                ai: {
                    result: {
                        target(player, target) {
                            let es;
                            if (['identity', 'guozhan'].includes(get.mode())) es = game.hasPlayer(i => {
                                return i != player && !game.hasPlayer(j => {
                                    return player !== j && j.hp > i.hp;
                                }) && get.attitude(player, i) < 0;
                            });
                            else es = game.hasPlayer(i => {
                                return i.isEnemyOf(player) && !game.hasPlayer(j => {
                                    return j.hp > i.hp && j.isEnemyOf(player);
                                }) && get.attitude(player, i) < 0;
                            });
                            if (es) return 2;
                            return -1.5;
                        },
                    },
                    order: 12,
                },
                group: 'minikuiji_dying',
                subSkill: {
                    dying: {
                        trigger: { global: 'dying' },
                        filter(event, player) {
                            if (!game.hasPlayer(target => target.isDamaged())) return false;
                            let evt = event.getParent(2);
                            return evt && evt.name == 'minikuiji';
                        },
                        locked: true,
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseTarget('溃击：是否选择一名角色，令其回复1点体力？', (card, player, target) => {
                                return target.isDamaged();
                            }, true).set('ai', target => {
                                return get.recoverEffect(target, player, _status.event.player);
                            });
                            'step 1'
                            if (result.bool) {
                                let target = result.targets[0];
                                player.logSkill('minikuiji', target);
                                target.recover();
                            }
                        },
                    },
                },
            },
            //吴兰
            minicuorui: {
                audio: 'wlcuorui',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return game.hasPlayer(current => {
                        return get.distance(player, current) <= 1 && current.countDiscardableCards(player, 'hej') > 0;
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(function (card, player, target) {
                        return get.distance(player, target) <= 1 && target.countDiscardableCards(player, 'hej') > 0;
                    }, get.prompt2('minicuorui')).set('ai', function (target) {
                        if (game.hasPlayer(current => {
                            return current != target && get.attitude(_status.event.player, current) < 0;
                        })) return get.effect(target, { name: 'guohe' }, player, player) + 10;
                        return 0;
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minicuorui', target);
                        player.discardPlayerCard(target, 'hej', true);
                        event.goto(7);
                    }
                    else event.finish();
                    'step 2'
                    if (!result.cards || !result.cards.length) {
                        event.finish();
                        return;
                    }
                    var color = get.color(result.cards[0], result.cards[0].original == 'j' ? false : target);
                    event.color = color;
                    var list = [];
                    if (game.hasPlayer(function (current) {
                        return (get.mode() == 'versus' ? current.isEnemyOf(player) : current != player && current != target) && current.countCards('h');
                    })) list.push('弃置手牌');
                    if (game.hasPlayer(function (current) {
                        return (get.mode() == 'versus' ? current.isEnemyOf(player) : current != player && current != target) && current.countCards('e', { color: color });
                    })) list.push('弃置装备');
                    if (!list.length) {
                        event.finish();
                        return;
                    }
                    if (list.length == 1) event._result = { control: list[0] };
                    else player.chooseControl(list).set('prompt', '挫锐：展示对手的至多两张手牌，或弃置对手装备区内至多两张' + get.translation(color) + '牌').set('ai', function () {
                        var player = _status.event.player;
                        var color = _status.event.getParent().color;
                        if (game.countPlayer(function (current) {
                            if (!current.isEnemyOf(player)) return false;
                            return current.countCards('e', function (card) {
                                return get.color(card) == color && get.value(card) > 0;
                            });
                        }) > 1) return 1;
                        return 0;
                    });
                    'step 3'
                    if (result.control == '弃置装备') event.goto(5);
                    else {
                        var dialog = ['请选择要弃置的牌'];
                        var list = game.filterPlayer(function (current) {
                            return current.isEnemyOf(player) && current.countCards('h');
                        }).sortBySeat();
                        for (var i of list) {
                            dialog.push('<div class="text center">' + get.translation(i) + '</div>');
                            if (player.hasSkillTag('viewHandcard', null, i, true)) dialog.push(i.getCards('h'));
                            else dialog.push([i.getCards('h'), 'blank']);
                        }
                        player.chooseButton([1, 2], true).set('createDialog', dialog).set('ai', function (button) {
                            var color = (get.color(button.link) == _status.event.getParent().color);
                            return color ? Math.random() : 0.35;
                        });
                    }
                    'step 4'
                    player.showCards(result.links);
                    var map = {};
                    var map2 = {};
                    for (var i of result.links) {
                        var id = get.owner(i).playerid;
                        if (!map[id]) map[id] = [];
                        map[id].push(i);
                        if (get.color(i) != event.color) continue;
                        if (!map2[id]) map2[id] = [];
                        map2[id].push(i);
                    }
                    for (var i in map) {
                        var source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                        if (map2[i]) player.gain(map2[i], source, 'bySelf', 'give');
                        player.line(source);
                        game.log(player, '展示了', source, '的', map[i]);
                    }
                    event.next.sort(function (a, b) {
                        return lib.sort.seat(a.source || a.player, b.source || b.player);
                    });
                    event.finish();
                    'step 5'
                    var dialog = ['请选择要弃置的牌'];
                    var list = game.filterPlayer(function (current) {
                        return current.isEnemyOf(player) && current.countCards('e', function (card) {
                            return get.color(card) == event.color;
                        });
                    }).sortBySeat();
                    for (var i of list) {
                        dialog.push('<div class="text center">' + get.translation(i) + '</div>');
                        dialog.push(i.getCards('e', function (card) {
                            return get.color(card) == event.color;
                        }));
                    }
                    player.chooseButton([1, 2], true).set('createDialog', dialog).set('ai', function (button) {
                        var owner = get.owner(button.link);
                        return get.value(button.link, owner)
                    });
                    'step 6'
                    var map = {};
                    for (var i of result.links) {
                        if (get.color(i) != event.color) continue;
                        var id = get.owner(i).playerid;
                        if (!map[id]) map[id] = [];
                        map[id].push(i);
                    }
                    for (var i in map) {
                        (_status.connectMode ? lib.playerOL : game.playerMap)[i].discard(map[i], 'notBySelf').discarder = player;
                    }
                    event.next.sort(function (a, b) {
                        return lib.sort.seat(a.player, b.player);
                    });
                    event.finish();
                    'step 7'
                    if (!result.cards || !result.cards.length) {
                        event.finish();
                        return;
                    }
                    if (game.hasPlayer(current => {
                        return current.countCards('he') > 0 && current != player && current != target;
                    })) {
                        var color = get.color(result.cards[0], result.cards[0].original == 'j' ? false : target);
                        event.color = color;
                        var next = player.chooseTarget(true, '挫锐：选择另一名其他角色', '弃置该角色装备区里至多两张' + get.translation(event.color) + '牌；或弃置该角色的至多两张手牌，然后获得其中的' + get.translation(event.color) + '牌');
                        next.set('filterTarget', (card, player, target) => {
                            return target.countCards('he') > 0 && target != player && target != _status.event.getParent().target;
                        });
                        next.set('ai', target => {
                            return -get.attitude(_status.event.player, target) * target.countCards('he') + 0.1;
                        });
                    }
                    else event.finish();
                    'step 8'
                    if (result.bool) {
                        var targetx = result.targets[0];
                        event.targetx = targetx;
                        player.line(targetx);
                        player.choosePlayerCard(targetx, 'he', true, [1, 2]).set('prompt', '弃置至多两张手牌，或弃置至多两张' + get.translation(event.color) + '装备').set('filterButton', button => {
                            if (ui.selected.buttons.length) {
                                var linkx = ui.selected.buttons[0].link;
                                if (get.position(button.link) != get.position(linkx)) return false;
                            }
                            if (get.position(button.link) == 'e') return get.color(button.link, _status.event.target) == _status.event.getParent().color;
                            return true;
                        }).set('target', targetx);
                    }
                    else event.finish();
                    'step 9'
                    if (result.bool) {
                        var cards = event.cards = result.links;
                        event.targetx.discard(cards, 'notBySelf').discarder = player;
                        if (get.position(cards[0]) == 'e') event.finish();
                    }
                    else event.finish();
                    'step 10'
                    var cards2 = cards.filter(card => {
                        return get.color(card) == event.color;
                    }).filterInD('d');
                    if (cards2.length) player.gain(cards2, 'gain2');
                },
            },
            //二赵
            miniqingren: {
                audio: 'dcqingren',
                trigger: { global: 'phaseJieshuBegin' },
                frequent: true,
                filter(event, player) {
                    return get.info('miniqingren').getNum(player);
                },
                getNum(player) {
                    const filter = evt => get.type(evt.card) == 'basic' && !get.is.virtualCard(evt.card);
                    return player.getHistory('useCard', filter).length + player.getHistory('respond', filter).length;
                },
                content() {
                    player.draw(get.info(event.name).getNum(player));
                },
            },
            //甘夫人糜夫人
            minixunbie: {
                audio: 'dcxunbie',
                inherit: 'dcxunbie',
                characters() {
                    const characters = ['Mbaby_ganfuren', 'Mbaby_mifuren'];
                    game.countPlayer(current => {
                        if (get.nameList(current).includes('Mbaby_ganfuren')) characters.remove('Mbaby_ganfuren');
                        if (get.nameList(current).includes('Mbaby_mifuren')) characters.remove('Mbaby_mifuren');
                    });
                    return characters;
                },
                filter(event, player) {
                    if (player.hp > 0) return false;
                    const characters = get.info('minixunbie').characters();
                    return characters.length && [player.name1, player.name2].some(name => get.character(name, 3).includes('minixunbie'));
                },
                derivation: ['minishushen', 'minihuangsi', 'miniguixiu', 'minicunsi', 'miniyongjue'],
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    const characters = get.info(event.name).characters();
                    const { control: character } = characters.length == 1 ? characters[0] : await player.chooseControl(characters).set('dialog', ['选择要替换成的武将', [characters, 'character']]).set('ai', () => [0, 1].randomGet()).forResult();
                    if (!_status.characterlist) lib.skill.pingjian.initList();
                    await player.reinitCharacter(get.character(player.name2, 3).includes(event.name) ? player.name2 : player.name1, character);
                    await player.recoverTo(1);
                    player.addTempSkill('dcxunbie_muteki');
                },
            },
            // 黄皓
            miniqinqing: {
                audio: 'dcqinqing',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    const zhu = game.findPlayer(current => get.info('jsrgzhenglve').isFirst(current));
                    if (!zhu?.isIn()) return false;
                    return game.hasPlayer(current => current != player && current.inRange(zhu) && current.countDiscardableCards(player, 'he'));
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), (card, player, target) => {
                        const zhu = game.findPlayer(current => get.info('jsrgzhenglve').isFirst(current));
                        return target != player && target.inRange(zhu) && target.countDiscardableCards(player, 'he');
                    }, [1, Infinity]).set('ai', target => {
                        const player = get.player();
                        return get.effect(target, { name: 'guohe_copy' }, player, player);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    let num = 0;
                    for (const target of event.targets.sortBySeat()) {
                        if (!target.countDiscardableCards(player, 'he')) continue;
                        await player.discardPlayerCard(target, 'he', true);
                        num++;
                    }
                    if (num) await player.draw(num);
                },
            },
            minicunwei: {
                audio: 'dccunwei',
                inherit: 'dccunwei',
                async content(event, trigger, player) {
                    await player.draw();
                    if (player.countCards('he') && trigger.targets.length !== 1) await player.chooseToDiscard('he', true, '存畏：请弃置一张牌');
                },
            },
            // 向朗
            miniqianzheng: {
                audio: 'dcqianzheng',
                inherit: 'dcqianzheng',
                trigger: {
                    player: 'useCard',
                    target: 'useCardToTargeted',
                },
                filter(event, player, name) {
                    if (player.countCards('he') < 2) return false;
                    if (name == 'useCard') return event.card.name == 'sha';
                    return event.player != player && (get.type(event.card) == 'trick' || event.card.name == 'sha');
                },
                async cost(event, trigger, player) {
                    let str = '重铸两张牌';
                    if (trigger.cards.length) str += `，若重铸的牌中没有${get.translation(get.type2(trigger.card))}牌，你于${get.translation(trigger.cards)}进入弃牌堆后获得之`;
                    str += '。'
                    event.result = await player.chooseCard(get.prompt(event.skill), str, 2, 'he', lib.filter.cardRecastable).set("ai", card => {
                        let val = get.value(card);
                        if (get.type2(card) == get.event().type) val += 0.5;
                        return 6 - val;
                    }).setHiddenSkill("dcqianzhen").set("type", get.type2(trigger.card)).forResult();
                },
                async content(event, trigger, player) {
                    if (event.cards.every(card => get.type2(card) != get.type2(trigger.card))) {
                        trigger.getParent()[event.name] = true;
                        player.addTempSkill(event.name + '_gain');
                    }
                    await player.recast(event.cards);
                },
                subSkill: {
                    gain: {
                        trigger: { global: 'cardsDiscardAfter' },
                        filter(event, player) {
                            const evt = event.getParent();
                            if (evt.name != 'orderingDiscard') return false;
                            return evt.relatedEvent.miniqianzheng && evt.relatedEvent.cards.filterInD('d').length;
                        },
                        charlotte: true,
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const evt = trigger.getParent().relatedEvent;
                            if (evt.cards.someInD('d')) await player.gain(evt.cards.filterInD('d'), 'gain2');
                        },
                    },
                },
            },
            // 关樾
            minifenhui: {
                audio: 'dcfenhui',
                inherit: 'dcfenhui',
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    const target = event.target;
                    const count = player.getAllHistory('useCard', evt => evt.targets?.includes(target)).length;
                    target.addMark('dcfenhui_mark', Math.min(5, count));
                    await player.draw(Math.min(5, count));
                    player.addSkill(event.name + '_effect');
                    player.markAuto(event.name + '_effect', [target]);
                },
                subSkill: {
                    effect: {
                        audio: 'dcfenhui',
                        trigger: { global: ['damageBegin1', 'die'] },
                        filter(event, player) {
                            if (!player.getStorage('minifenhui_effect').includes(event.player)) return false;
                            return event.name == 'die' || event.player.hasMark('dcfenhui_mark');
                        },
                        logTarget: 'player',
                        forced: true,
                        charlotte: true,
                        onremove: true,
                        async content(event, trigger, player) {
                            if (trigger.name === 'damage') {
                                trigger.player.removeMark('dcfenhui_mark', 1);
                                trigger.num++;
                            } else {
                                await player.loseMaxHp();
                                player.storage.dcshouzhi_modified = true;
                                await player.addSkills('dcxingmen');
                            }
                        },
                    },
                },
            },
            //糜芳傅士仁
            minifengshi: {
                audio: 'fengshi',
                trigger: {
                    player: 'useCardToPlayered',
                    target: 'useCardToTargeted'
                },
                filter(event, player, name) {
                    if (name == 'useCardToPlayered') {
                        if (!event.isFirstTarget) return false;
                        return event.targets.some(target => {
                            return player.countCards('h') > target.countCards('h') && target.countCards('he') > 0 && player.hasCard(card => {
                                return lib.filter.cardDiscardable(card, player, 'minifengshi');
                            }, 'he');
                        });
                    }
                    if (event.player == player) return false;
                    return event.player.countCards('h') > player.countCards('h') && event.player.countDiscardableCards(player, 'he');
                },
                async cost(event, trigger, player) {
                    if (event.triggername == 'useCardToPlayered') {
                        event.result = await player.chooseTarget(get.prompt(event.skill), `弃置你与一名目标角色的各一张牌，然后令${get.translation(trigger.card)}对其造成的伤害+1`, (card, player, target) => {
                            const { targets } = get.event().getTrigger();
                            if (!targets.includes(target)) return false;
                            return player.countCards('h') > target.countCards('h') && target.countCards('he') > 0 && player.hasCard(card => {
                                return lib.filter.cardDiscardable(card, player, 'minifengshi');
                            }, 'he');
                        }).set('ai', target => {
                            let trigger = get.event().getTrigger(), player = trigger.player;
                            if (get.attitude(player, target) > 0) return 0;
                            let eff = get.effect(player, { name: 'guohe_copy2' }, player, get.player()) + get.effect(target, { name: 'guohe_copy2' }, player, get.player());
                            if (get.tag(trigger.card, 'damage')) eff += get.effect(target, trigger.card, trigger.player, get.player());
                            return eff;
                        }).forResult();
                    }
                    else {
                        const target = trigger.player;
                        event.result = await player.chooseBool(get.prompt(event.skill), `弃置${get.translation(target)}的一张牌，然后令${get.translation(trigger.card)}的伤害+1`).set('choice', (() => {
                            if (get.attitude(player, target) > 0) return 0;
                            let eff = get.effect(target, { name: 'guohe_copy2' }, player, player)
                            if (get.tag(trigger.card, 'damage')) eff += get.effect(target, trigger.card, player, player);
                            return eff > 0;
                        })()).forResult();
                        event.result.targets = [target];
                    }
                },
                async content(event, trigger, player) {
                    const [target] = event.targets;
                    if (event.triggername == 'useCardToPlayered') await player.chooseToDiscard('he', true);
                    await player.discardPlayerCard(target, 'he', true);
                    if (get.tag(trigger.card, 'damage')) {
                        const id = event.triggername == 'useCardToPlayered' ? target.playerid : player.playerid;
                        const map = trigger.getParent().customArgs;
                        map[id] ??= {};
                        if (typeof map[id].extraDamage != 'number') map[id].extraDamage = 0;
                        map[id].extraDamage++;
                    }
                },
            },
            //吴班
            miniyouzhan: {
                audio: 'dcyouzhan',
                trigger: { global: ['loseAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'] },
                getIndex(event, player) {
                    return game.filterPlayer(target => {
                        return target !== player && (event.getl(target)?.cards2 ?? []).length > 0;
                    }).sortBySeat().map(target => {
                        return Array.from({ length: event.getl(target).cards2.length }).map(() => target);
                    }).flat();
                },
                filter(event, player, name, target) {
                    return _status.currentPhase === player && target.isIn();
                },
                forced: true,
                logTarget(event, player, name, target) {
                    return target;
                },
                async content(event, trigger, player) {
                    player.addTempSkill('miniyouzhan_limit');
                    const next = player.draw();
                    next.gaintag.add('miniyouzhan');
                    await next;
                    const target = event.targets[0];
                    target.addTempSkill('miniyouzhan_effect');
                    target.addMark('miniyouzhan_effect', 1, false);
                    target.addTempSkill('miniyouzhan_draw');
                },
                ai: {
                    damageBonus: true,
                    skillTagFilter(player, tag, arg) {
                        if (get.itemtype(arg?.target) !== 'player' || !arg.target.hasSkill('miniyouzhan_effect')) return false;
                    },
                },
                subSkill: {
                    effect: {
                        audio: 'dcyouzhan',
                        trigger: { player: 'damageBegin3' },
                        filter(event, player) {
                            return player.hasMark('miniyouzhan_effect');
                        },
                        forced: true,
                        charlotte: true,
                        onremove: true,
                        content() {
                            trigger.num += player.countMark('miniyouzhan_effect');
                            player.removeSkill('miniyouzhan_effect');
                        },
                        intro: { content: '本回合下一次受到的伤害+#' },
                        ai: {
                            effect: {
                                target(card, player, target) {
                                    if (get.tag(card, 'damage')) return 1 + 0.5 * target.countMark('miniyouzhan_effect');
                                },
                            },
                        },
                    },
                    draw: {
                        charlotte: true,
                        trigger: { global: 'phaseJieshuBegin' },
                        filter(event, player) {
                            return !player.getHistory('damage').length;
                        },
                        forced: true,
                        content() {
                            player.draw();
                        },
                    },
                    limit: {
                        charlotte: true,
                        onremove(player) {
                            player.removeGaintag('miniyouzhan');
                        },
                        mod: {
                            ignoredHandcard(card, player) {
                                if (card.hasGaintag('miniyouzhan')) return true;
                            },
                            cardDiscardable(card, player, name) {
                                if (name === 'phaseDiscard' && card.hasGaintag('miniyouzhan')) return false;
                            },
                        },
                    },
                },
            },
            //吴
            //孙权
            minizhiheng: {
                audio: 'zhiheng',
                trigger: { player: 'phaseUseEnd' },
                filter(event, player) {
                    return player.countCards('h');
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseToDiscard('h', get.prompt2('minizhiheng'), [1, Infinity]).set('ai', lib.skill.zhiheng.check).set('complexCard', true).logSkill = 'minizhiheng';
                    'step 1'
                    if (result.bool) player.drawTo(4);
                },
            },
            minirezhiheng: {
                audio: 'rezhiheng',
                enable: 'phaseUse',
                filter(event, player) {
                    var count = (player.getStat('skill').minirezhiheng || 0);
                    return count < event.minirezhiheng_num && player.countDiscardableCards(player, 'he');
                },
                onChooseToUse(event) {
                    if (event.type == 'phase' && !game.online && !event.minirezhiheng_num) {
                        var evtx = event.getParent('phaseUse');
                        var num = 1, player = event.player;
                        var history = player.getHistory('gain', evt => evt.getParent('phaseUse') == evtx && evt.getParent(3).skill == 'minirezhiheng');
                        if (history[0] && !history[0].cards.some(card => get.type(card) == 'delay')) num++;
                        if (history[1] && !history[1].cards.some(card => get.type(card) != 'basic')) num++;
                        event.set('minirezhiheng_num', num);
                    }
                },
                filterCard: lib.filter.cardDiscardable,
                selectCard: [1, Infinity],
                check(card) {
                    var player = _status.event.player;
                    if (get.position(card) == 'h' && !player.countCards('h', 'du') && (player.hp > 2 || !player.countCards('h', function (card) {
                        return get.value(card) >= 8;
                    }))) return 1;
                    return 6 - get.value(card);
                },
                position: 'he',
                discard: false,
                lose: false,
                delay: false,
                content() {
                    'step 0'
                    var num = 1, hs = player.getCards('h');
                    if (!hs.length || hs.some(i => !cards.includes(i))) num = 0;
                    event.num = num;
                    player.discard(cards);
                    'step 1'
                    player.draw(num + cards.length);
                },
                ai: {
                    order: 1,
                    result: { player: 1 },
                },
            },
            minijiuyuan: {
                audio: 'jiuyuan',
                trigger: { global: 'taoBefore' },
                filter(event, player) {
                    if (event.player === player || !player.hasZhuSkill('minijiuyuan', event.player)) return false;
                    return event.player.group == 'wu' && event.target === event.player && player.isDamaged();
                },
                direct: true,
                zhuSkill: true,
                content() {
                    'step 0'
                    trigger.player.chooseBool('是否对' + get.translation(player) + '发动【救援】？', '改为令其回复1点体力，然后你摸一张牌').set('ai', function () {
                        var evt = _status.event;
                        return get.attitude(evt.player, evt.getParent().player) > 0 && evt.getParent().player.hp <= evt.player.hp && !evt.player.isDying();
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minirejiuyuan');
                        trigger.player.line(player, 'green');
                        trigger.cancel();
                        player.recover();
                        trigger.player.draw();
                    }
                },
                group: 'minijiuyuan_tao',
                subSkill: {
                    tao: {
                        audio: 'jiuyuan',
                        trigger: { target: 'taoBegin' },
                        filter(event, player) {
                            if (event.player === player || !player.hasZhuSkill('minijiuyuan', event.player)) return false;
                            return player.isDying() && event.player.group == 'wu';
                        },
                        forced: true,
                        locked: false,
                        content() {
                            trigger.baseDamage++;
                        },
                    },
                },
            },
            minirejiuyuan: {
                audio: 'rejiuyuan',
                trigger: { global: 'recoverBefore' },
                filter(event, player) {
                    if (event.player === player || !player.hasZhuSkill('minirejiuyuan', event.player)) return false;
                    return event.player.group == 'wu' && player.isDamaged();
                },
                direct: true,
                zhuSkill: true,
                content() {
                    'step 0'
                    trigger.player.chooseBool('是否对' + get.translation(player) + '发动【救援】？', '改为令其回复1点体力，然后你摸一张牌').set('ai', function () {
                        var evt = _status.event;
                        return get.attitude(evt.player, evt.getParent().player) > 0 && evt.getParent().player.hp <= evt.player.hp && !evt.player.isDying();
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minirejiuyuan');
                        trigger.player.line(player, 'green');
                        trigger.cancel();
                        player.recover();
                        trigger.player.draw();
                    }
                },
                group: 'minirejiuyuan_tao',
                subSkill: {
                    tao: {
                        audio: 'rejiuyuan',
                        trigger: { target: 'taoBegin' },
                        filter(event, player) {
                            if (event.player === player || !player.hasZhuSkill('minirejiuyuan', event.player)) return false;
                            return player.isDying() && event.player.group == 'wu';
                        },
                        forced: true,
                        locked: false,
                        content() {
                            trigger.baseDamage++;
                        },
                    },
                },
            },
            //甘宁
            miniqixi: {
                audio: 'qixi',
                audioname: ['re_ganning', 'heqi'],
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return game.hasPlayer(target => target !== player && target.countCards('hej'));
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), (card, player, target) => {
                        return target !== player && target.countCards('hej');
                    }).set('ai', target => {
                        const player = get.player();
                        return get.effect(target, { name: 'guohe' }, player, player);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    await player.discardPlayerCard(event.targets[0], 'hej', true);
                },
            },
            minireqixi: {
                inherit: 'miniqixi',
                filter(event, player) {
                    return game.hasPlayer(target => target.countCards('hej'));
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt(event.skill), (card, player, target) => {
                        return target.countCards('hej');
                    }, '弃置一名角色区域内的一张牌').set('ai', target => {
                        const player = get.player();
                        return get.effect(target, { name: 'guohe' }, player, player);
                    }).forResult();
                },
                group: 'minireqixi_qixi',
                subSkill: {
                    qixi: {
                        inherit: 'qixi',
                    },
                },
            },
            minifenwei: {
                audio: 'fenwei',
                audioname: ['heqi'],
                skillAnimation: true,
                animationColor: 'wood',
                mark: true,
                limited: true,
                trigger: { global: 'useCardToPlayered' },
                filter(event, player) {
                    if (event.getParent().triggeredTargets3.length > 1) return false;
                    if (get.type(event.card) != 'trick') return false;
                    if (get.info(event.card).multitarget) return false;
                    if (event.targets.length < 2) return false;
                    return true;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minifenwei'), '令' + get.translation(trigger.card) + '对任意名角色无效', [1, trigger.targets.length], function (card, player, target) {
                        return _status.event.targets.includes(target);
                    }).set('ai', function (target) {
                        var trigger = _status.event.getTrigger();
                        return -get.effect(target, trigger.card, trigger.player, _status.event.player);
                    }).set('targets', trigger.targets);
                    'step 1'
                    if (result.bool) {
                        player.addSkill('minifenwei_huifu');
                        player.logSkill('minifenwei', result.targets);
                        player.awakenSkill('minifenwei');
                        trigger.getParent().excluded.addArray(result.targets);
                    }
                    else event.finish();
                    'step 2'
                    player.draw();
                },
                ai: { expose: 0.2 },
                subSkill: {
                    huifu: {
                        charlotte: true,
                        trigger: {
                            player: 'loseAfter',
                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                        },
                        filter(event, player) {
                            if (player.countCards('h')) return false;
                            if (!player.awakenedSkills.includes('minifenwei')) return false;
                            var evt = event.getl(player);
                            return evt?.player == player && evt?.hs?.length > 0;
                        },
                        direct: true,
                        firstDo: true,
                        content() {
                            player.removeSkill('minifenwei_huifu');
                            player.restoreSkill('minifenwei');
                            game.log(player, '复原了技能', '#g【奋威】');
                        },
                    },
                },
            },
            //大乔
            miniguose: {
                audio: ['wanrong1.mp3', 'wanrong2.mp3'],
                audioname2: { Mbabysp_daqiao: 'miniguose_Mbabysp_daqiao' },
                trigger: {
                    player: 'loseAfter',
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                },
                filter(event, player) {
                    if (event.name == 'gain' && event.player == player) return false;
                    return event.getl?.(player)?.cards2?.some(card => get.suit(card, player) === 'diamond');
                },
                forced: true,
                locked: true,
                content() {
                    player.draw();
                },
                subSkill: {
                    Mbabysp_daqiao: { audio: 'ext:活动武将/audio/skill:2' },
                },
            },
            miniwanrong: {
                audio: 'reguose',
                inherit: 'reguose',
                content() {
                    if (target.hasJudge('lebu')) {
                        player.discard(cards);
                        target.discard(target.getJudge('lebu'));
                    }
                    else player.useCard({ name: 'lebu' }, target, cards).audio = false;
                },
            },
            //黄盖
            minikurou: {
                audio: 'kurou',
                trigger: { player: 'phaseZhunbeiBegin' },
                check(event, player) {
                    return get.effect(player, 'kurou', player, player) > 0;
                },
                content() {
                    player.draw(2);
                },
            },
            minizhaxiang: {
                mod: {
                    targetInRange(card, player, target, now) {
                        if (card.name == 'sha' && get.color(card) == 'red') return true;
                    },
                    cardUsable(card, player, num) {
                        if (card.name == 'sha') return num + 1;
                    }
                },
                audio: 'zhaxiang',
                trigger: { player: 'useCard' },
                forced: true,
                filter(event, player) {
                    return event.card && event.card.name == 'sha' && get.color(event.card) == 'red';
                },
                content() {
                    trigger.directHit.addArray(game.players);
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        return arg.card.name == 'sha' && get.color(arg.card) == 'red';
                    },
                },
            },
            minifanjian: {
                audio: 'fanjian',
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minifanjian'), lib.filter.notMe).ai = function (target) {
                        return get.damageEffect(target, player, player);
                    };
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('minifanjian', target);
                        target.draw();
                        target.damage();
                    }
                },
            },
            minireyingzi: {
                audio: 'reyingzi',
                audioname: ['sunce', 're_sunyi'],
                audioname2: { gexuan: 'reyingzi_gexuan' },
                trigger: { player: 'phaseDrawBegin2' },
                filter(event, player) {
                    return !event.numFixed && lib.skill.sbyingzi.getNum(player) > 0;
                },
                forced: true,
                content() {
                    trigger.num += lib.skill.sbyingzi.getNum(player);
                },
                ai: { threaten: 2 },
                mod: {
                    maxHandcard(player, num) {
                        return num + lib.skill.sbyingzi.getNum(player);
                    },
                },
            },
            minirefanjian: {
                audio: 'refanjian',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h');
                },
                usable: 1,
                chooseButton: {
                    dialog(event, player) {
                        return ui.create.dialog(
                            '###反间###<div class="text center">' + lib.translate.minirefanjian_info + '</div>',
                            [lib.suit.slice().reverse().map(i => ['', '', 'lukai_' + i]), 'vcard'], 'hidden');
                    },
                    filter(button, player) {
                        return player.hasCard(card => get.suit(card, player) == button.link[2].slice(6), 'h');
                    },
                    check: () => 1 + Math.random(),
                    backup(links, player) {
                        return {
                            audio: 'sbfanjian',
                            suit: links.map(i => i[2].slice(6))[0],
                            filterTarget: lib.filter.notMe,
                            async content(event, trigger, player) {
                                const playerSuit = lib.skill.minirefanjian_backup.suit, target = event.target;
                                player.popup(playerSuit);
                                game.log(player, '选择了', '#g' + get.translation(playerSuit));
                                const str = [get.translation(player), get.translation(playerSuit)];
                                const { control: targetSuit } = await target.chooseControl(lib.suit.slice().reverse()).set('prompt', '反间：请选择一个花色').set('ai', () => {
                                    const player = get.event().player, target = get.event().getParent().player, suit = get.event().suit;
                                    let players = game.filterPlayer(current => get.damageEffect(current, target, target) > 0);
                                    if (!players.length || (players.length == 1 && players.includes(player))) return suit;
                                    const drawEffect = get.effect(player, { name: 'draw' }, player, player);
                                    players.sort((a, b) => get.damageEffect(b, target, target) - get.damageEffect(a, target, target) - (b == player ? drawEffect : 0) + (a == player ? drawEffect : 0));
                                    return players[0] != player ? suit : lib.suit.filter(i => i != suit).randomGet();
                                }).set('suit', playerSuit).set('prompt2', '若你选择的花色为' + str[1] + '，你摸一张牌并受到' + str + '对你造成1点伤害，否则' + str[0] + '对一名角色造成1点伤害').forResult();
                                player.$compare(game.createCard('lukai_' + playerSuit, '', ''), target, game.createCard('lukai_' + targetSuit, '', ''));
                                await game.delay(0, 1500);
                                target.popup(targetSuit);
                                game.log(target, '选择了', '#g' + get.translation(targetSuit));
                                await game.delay(2);
                                if (playerSuit == targetSuit) {
                                    player.line(target);
                                    await target.draw();
                                    await target.damage();
                                }
                                else {
                                    const { targets: aim } = await player.chooseTarget('反间：对一名角色造成1点伤害', true).set('ai', target => {
                                        return get.damageEffect(target, get.event().player, get.event().player);
                                    }).forResult();
                                    if (aim) {
                                        player.line(aim[0]);
                                        await aim[0].damage();
                                    }
                                }
                            },
                            ai: {
                                result: {
                                    target(player, target) {
                                        return get.damageEffect(target, player, player) * Math.sign(Math.sign(get.attitude(player, target)) - 0.5);
                                    },
                                },
                            },
                        }
                    },
                    prompt(links, player) {
                        const suit = get.translation(links.map(i => i[2].slice(6))[0]);
                        return '###反间###令一名其他角色选择一个花色，若其选择的为' + suit + '，你令其摸一张牌并对其造成1点伤害，否则你对一名角色造成1点伤害';
                    },
                },
                ai: {
                    order: 10,
                    result: {
                        player(player) {
                            return game.countPlayer(target => get.damageEffect(target, player, player) > 0);
                        },
                    },
                },
                subSkill: { backup: {} },
            },
            miniqianxun: {
                audio: 'qianxun',
                trigger: { target: 'useCardToTarget' },
                filter(event, player) {
                    return event.targets.length === 1 && get.type2(event.card) === 'trick';
                },
                forced: true,
                content() {
                    'step 0'
                    player.draw();
                    player.chooseCardTarget({
                        prompt: '谦逊：是否将一张手牌交给一名其他角色？',
                        filterCard: true,
                        filterTarget: lib.filter.notMe,
                        ai1(card) {
                            if (card.name == 'du') return 10;
                            var player = _status.event.player;
                            if (!game.hasPlayer(function (current) {
                                return get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                            })) return 0;
                            return 1 / Math.max(0.1, get.value(card));
                        },
                        ai2(target) {
                            var player = _status.event.player, att = get.attitude(player, target);
                            if (ui.selected.cards[0].name == 'du') return -att;
                            if (target.hasSkillTag('nogain')) att /= 6;
                            return att;
                        },
                    });
                    'step 1'
                    if (result.bool) {
                        player.line(result.targets[0]);
                        result.targets[0].gain(result.cards, player, 'giveAuto');
                    }
                },
            },
            minireqianxun: {
                audio: 'reqianxun',
                trigger: { target: 'useCardToBegin', player: 'judgeBefore' },
                filter(event, player) {
                    if (!player.countCards('h') || !player.getHp()) return false;
                    if (event.name == 'judge') return event.getParent().name == 'phaseJudge';
                    if (event.card && get.type(event.card) == 'trick') return true;
                },
                direct: true,
                async content(event, trigger, player) {
                    var num = Math.min(player.countCards('h'), player.getHp());
                    var result = await player.chooseCard(get.prompt('minireqianxun'), '将至多' + get.cnNumber(num) + '张手牌置于武将牌上', [1, num]).set('ai', card => 1 / (get.value(card) || 0.5)).forResult();
                    if (result.bool) {
                        var cards = result.cards;
                        player.logSkill('minireqianxun');
                        player.addSkill('minireqianxun2');
                        player.addToExpansion(cards, 'giveAuto', player).gaintag.add('minireqianxun2');
                    }
                },
                ai: {
                    effect(card, player, target) {
                        if (!target.hasFriend()) return;
                        var type = get.type(card);
                        var nh = Math.min(target.countCards(), game.countPlayer(i => get.attitude(target, i) > 0));
                        if (type == 'trick') {
                            if (!get.tag(card, 'multitarget') || get.info(card).singleCard) {
                                if (get.tag(card, 'damage')) return [1.5, nh - 1];
                                return [1, nh];
                            }
                        }
                        else if (type == 'delay') return [0.5, 0.5];
                    },
                },
            },
            minireqianxun2: {
                charlotte: true,
                audio: 'reqianxun',
                trigger: { global: 'phaseEnd' },
                forced: true,
                content() {
                    var cards = player.getExpansions('minireqianxun2');
                    if (cards.length) player.gain(cards, 'draw');
                    player.removeSkill('minireqianxun2');
                },
                intro: {
                    mark(dialog, storage, player) {
                        var cards = player.getExpansions('minireqianxun2');
                        if (player.isUnderControl(true)) dialog.addAuto(cards);
                        else return '共有' + get.cnNumber(cards.length) + '张牌';
                    },
                    markcount: 'expansion',
                },
            },
            minilianying: {
                audio: 'relianying',
                trigger: {
                    player: 'loseAfter',
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                },
                filter(event, player) {
                    if (player.countCards('h')) return false;
                    var evt = event.getl(player);
                    return evt?.hs?.length;
                },
                frequent: true,
                content() {
                    'step 0'
                    player.draw(2);
                    player.chooseCardTarget({
                        prompt: '连营：是否将一张手牌交给一名其他角色？',
                        filterCard: true,
                        filterTarget: lib.filter.notMe,
                        ai1(card) {
                            if (card.name == 'du') return 10;
                            var player = _status.event.player;
                            if (!game.hasPlayer(function (current) {
                                return get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                            })) return 0;
                            return 1 / Math.max(0.1, get.value(card));
                        },
                        ai2(target) {
                            var player = _status.event.player, att = get.attitude(player, target);
                            if (ui.selected.cards[0].name == 'du') return -att;
                            if (target.hasSkillTag('nogain')) att /= 6;
                            return att;
                        },
                    });
                    'step 1'
                    if (result.bool) {
                        player.line(result.targets[0]);
                        result.targets[0].gain(result.cards, player, 'giveAuto');
                    }
                },
                ai: {
                    threaten: 0.8,
                    effect: {
                        target(card) {
                            if (card.name == 'guohe' || card.name == 'liuxinghuoyu') return 0.5;
                        },
                    },
                    noh: true,
                },
            },
            minitianyi: {
                audio: 'tianyi',
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseControl('选项一', '选项二', 'cancel2').set('choiceList', [
                        '本回合使用【杀】的次数上限+1，且使用【杀】造成伤害后回复1点体力',
                        '摸一张牌，本回合使用【杀】无距离限制且无视防具'
                    ]).set('ai', () => {
                        if ((player.countCards('h', card => {
                            return get.name(card, player) == 'sha' && player.hasUseTarget(card);
                        }) - player.getCardUsable('sha')) > 1) return 0;
                        return 1;
                    }).set('prompt', get.prompt('minitianyi'));
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('minitianyi');
                        if (result.index == 1) player.draw();
                        player.addTempSkill('minitianyi_' + result.index);
                    }
                },
                subSkill: {
                    '0': {
                        charlotte: true,
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name == 'sha') return num + 1;
                            },
                        },
                        trigger: { source: 'damageSource' },
                        filter(event, player) {
                            return player.isDamaged() && event.card && event.card.name == 'sha';
                        },
                        direct: true,
                        content() {
                            player.recover();
                        },
                        mark: true,
                        intro: { content: '使用【杀】的次数上限+1，且使用【杀】造成伤害后回复1点体力' },
                    },
                    '1': {
                        charlotte: true,
                        mod: {
                            targetInRange(card, player, target, now) {
                                if (card.name == 'sha') return true;
                            },
                        },
                        ai: {
                            unequip: true,
                            unequip_ai: true,
                            skillTagFilter(player, tag, arg) {
                                return arg?.name == 'sha';
                            },
                        },
                        mark: true,
                        intro: { content: '使用【杀】无距离限制且无视防具' },
                    },
                },
            },
            miniretianyi: {
                audio: 'tianyi',
                audioname: ['re_taishici'],
                trigger: { player: ['phaseUseBegin', 'useCardToPlayer'] },
                filter(event, player) {
                    return event.name == 'phaseUse' || (event.card.name == 'sha' && player.canCompare(event.target));
                },
                async cost(event, trigger, player) {
                    if (trigger.name == 'phaseUse') {
                        const result = await player.chooseButton([
                            get.prompt(event.name.slice(0, -5)),
                            [
                                [
                                    ['add', '本回合使用【杀】的次数上限+1'],
                                    ['recover', `本回合使用【杀】造成伤害后回复1点体力`],
                                    ['draw', `摸一张牌`],
                                    ['range', `本回合使用【杀】无距离限制且无视目标角色的防具`],
                                ],
                                'textbutton',
                            ],
                        ]).set('ai', button => {
                            const { link } = button, player = get.player();
                            if (link == 'add' && (player.countCards('h', card => {
                                return get.name(card, player) == 'sha' && player.hasUseTarget(card);
                            }) - player.getCardUsable('sha')) > 1) return 2;
                            if (link == 'recover' && player.isHealthy()) return 0;
                            if (link == 'range' && game.hasPlayer(current => player.canUse({ name: 'sha' }, current, true) && get.effect(current, { name: 'sha' }, player, player) > 0)) return 0;
                            return 1;
                        }).set('selectButton', 2).forResult();
                        event.result = {
                            bool: result?.bool,
                            cost_data: result?.links,
                        }
                    }
                    else {
                        const { target, card } = trigger;
                        const result = await player.chooseBool(get.prompt(event.name.slice(0, -5), target), `你可以与其拼点，若你赢，你可以为${get.translation(card)}额外指定一个目标`).set('choice', get.attitude(player, target) <= 0).forResult();
                        event.result = {
                            bool: result?.bool,
                            targets: [target],
                        }
                    }
                },
                async content(event, trigger, player) {
                    const { cost_data: choices } = event, { target, card } = trigger;
                    if (trigger.name == 'phaseUse') {
                        if (choices.includes('add')) {
                            game.log(player, '选择了', '#y选项一');
                            player.addTempSkill(event.name + '_add');
                            player.addMark(event.name + '_add', 1, false);
                        }
                        if (choices.includes('recover')) {
                            game.log(player, '选择了', '#y选项二');
                            player.addTempSkill(event.name + '_recover');
                        }
                        if (choices.includes('draw')) {
                            game.log(player, '选择了', '#y选项三');
                            await player.draw();
                        }
                        if (choices.includes('range')) {
                            game.log(player, '选择了', '#y选项四');
                            player.addTempSkill(event.name + '_range');
                        }
                    }
                    else {
                        const { bool } = await player.chooseToCompare(target).forResult();
                        if (!bool || !game.hasPlayer(current => !trigger.targets.includes(current) && lib.filter.targetEnabled2(card, player, current))) return;
                        const result = await player.chooseTarget(get.prompt(event.name), '为' + get.translation(card) + '增加一个目标', (card, player, target) => {
                            const evt = _status.event.getTrigger();
                            return !evt.targets.includes(target) && lib.filter.targetEnabled2(evt.card, player, target);
                        }).set('ai', target => {
                            const evt = _status.event.getTrigger();
                            return get.effect(target, evt.card, evt.player, evt.player);
                        }).forResult();
                        if (!result?.targets?.length) return;
                        if (player != game.me && !player.isOnline()) await game.delayx();
                        trigger.targets.push(result.targets[0]);
                        game.log(result.targets[0], '成为了', card, '的额外目标');
                    }
                },
                subSkill: {
                    add: {
                        charlotte: true,
                        onremove: true,
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name == 'sha') return num + player.countMark('miniretianyi_add');
                            },
                        },
                        intro: { content: '使用【杀】的次数上限+#' },
                    },
                    recover: {
                        charlotte: true,
                        trigger: { source: 'damageSource' },
                        filter(event, player) {
                            return player.isDamaged() && event.card?.name == 'sha';
                        },
                        forced: true,
                        popup: false,
                        content() {
                            player.recover();
                        },
                        mark: true,
                        intro: { content: '使用【杀】造成伤害后回复1点体力' },
                    },
                    range: {
                        charlotte: true,
                        mod: {
                            targetInRange(card, player, target) {
                                if (card.name == 'sha') return true;
                            },
                        },
                        mark: true,
                        intro: { content: '使用【杀】无距离限制且无视防具' },
                        ai: {
                            unequip: true,
                            skillTagFilter(player, tag, arg) {
                                if (!arg || !arg.card || arg.card.name != 'sha') return false;
                            },
                        },
                    },
                },
            },
            minihanzhan: {
                audio: 'hanzhan',
                inherit: 'hanzhan',
                group: 'minihanzhan_gain',
                subSkill: {
                    gain: {
                        audio: 'hanzhan',
                        getCards(event) {
                            const cards = [];
                            for (const i of event.lose_list) {
                                if (Array.isArray(i[1])) {
                                    for (const j of i[1]) {
                                        if (get.name(j, i[0]) == 'sha' && get.position(j, true) == 'o') cards.push(j)
                                    }
                                } else {
                                    const j = i[1];
                                    if (get.name(j, i[0]) == 'sha' && get.position(j, true) == 'o') cards.push(j)
                                }
                            }
                            return cards;
                        },
                        trigger: { global: 'chooseToCompareAfter' },
                        filter(event, player) {
                            if (event.preserve) return false;
                            if (player != event.player && player != event.target && (!event.targets || !event.targets.includes(player))) return false;
                            return get.info('minihanzhan_gain').getCards(event).length;
                        },
                        frequent: true,
                        prompt2(event, player) {
                            const cards = get.info('minihanzhan_gain').getCards(event);
                            return '获得' + get.translation(cards);
                        },
                        async content(event, trigger, player) {
                            await player.gain(get.info(event.name).getCards(trigger), 'gain2');
                        },
                    }
                }
            },
            //鲁肃
            minihaoshi: {
                audio: 'haoshi',
                trigger: { player: 'phaseDrawBegin2' },
                filter(event, player) {
                    return !event.numFixed;
                },
                preHidden: true,
                check(event, player) {
                    if (player.countCards('h') <= 1) return true;
                    return game.hasPlayer(function (current) {
                        return current != player && current.isMinHandcard() && get.attitude(player, current) > 0;
                    });
                },
                content() {
                    trigger.num += 2;
                    player.addSkill('minihaoshi2');
                },
                ai: {
                    noh: true,
                    skillTagFilter(player, tag) {
                        if (tag == 'noh') {
                            if (player.countCards('h') != 2) return false;
                        }
                    },
                },
            },
            minihaoshi2: {
                trigger: { player: 'phaseDrawEnd' },
                forced: true,
                popup: false,
                audio: false,
                content() {
                    'step 0'
                    player.removeSkill('minihaoshi2');
                    if (player.countCards('h') <= 5) {
                        event.finish();
                        return;
                    }
                    else player.chooseCardTarget({
                        selectCard: Math.floor(player.countCards('h') / 2),
                        filterTarget(card, player, target) {
                            return target.isMinHandcard();
                        },
                        selectTarget: [0, 1],
                        prompt: '好施：将一半的手牌交给场上手牌数最少的一名角色或弃置一半的手牌',
                        forced: true,
                        ai2(target) {
                            return get.attitude(_status.event.player, target);
                        }
                    });
                    'step 1'
                    if (result.targets && result.targets[0]) result.targets[0].gain(result.cards, player, 'giveAuto');
                    else player.discard(result.cards);
                },
            },
            miniolhaoshi: {
                audio: 'olhaoshi',
                inherit: 'olhaoshi',
                forced: true,
                locked: false,
                async content(event, trigger, player) {
                    trigger.num += 2;
                },
                group: 'miniolhaoshi_give',
                subSkill: {
                    give: {
                        audio: 'olhaoshi',
                        trigger: { player: 'phaseDrawEnd' },
                        filter(event, player) {
                            return player.countCards("h") > 5;
                        },
                        async cost(event, trigger, player) {
                            const num = Math.floor(player.countCards("h") / 2);
                            event.result = await player.chooseCardTarget({
                                prompt: '好施：是否将' + get.cnNumber(num) + '张手牌交给一名其他角色？',
                                filterCard: true,
                                selectCard: num,
                                position: 'h',
                                filterTarget: lib.filter.notMe,
                                ai1(card) {
                                    const player = get.player();
                                    if (game.hasPlayer(target => {
                                        if (target === player) return false;
                                        return get.attitude(player, target) > 0 && get.attitude(target, player) > 0;
                                    })) {
                                        if (!player.hasValueTarget(card) || (card.name == "sha" && player.countCards("h", cardx => {
                                            return cardx.name == "sha" && !ui.selected.cards.includes(cardx);
                                        }) > player.getCardUsable("sha"))) return 2;
                                        return Math.max(2, get.value(card) / 4);
                                    }
                                    return 1 / Math.max(1, get.value(card));
                                },
                                ai2(target) {
                                    const player = get.player();
                                    return get.attitude(player, target);
                                },
                            }).forResult();
                        },
                        async content(event, trigger, player) {
                            const target = event.targets[0], cards = event.cards;
                            player.line(target, 'green');
                            await player.give(cards, target);
                            player.markAuto('olhaoshi_help', [target]);
                            player.addTempSkill('olhaoshi_help', { player: 'phaseBeginStart' });
                        },
                    }
                }
            },
            minidimeng: {
                audio: 'oldimeng',
                inherit: 'oldimeng',
                filter(event, player) {
                    if (player.hasMark('minidimeng')) return false;
                    return game.hasPlayer(current => lib.skill.minidimeng.filterTarget(null, player, current));
                },
                filterTarget(card, player, target) {
                    if (!ui.selected.targets.length) {
                        return game.hasPlayer(current => {
                            if (current == target) return false;
                            return target.countCards('h') + current.countCards('h') > 0;
                        });
                    }
                    return ui.selected.targets[0].countCards('h') + target.countCards('h') > 0;
                },
                async content(event, trigger, player) {
                    const targets = event.targets;
                    targets[0].swapHandcards(targets[1]);
                    const num = Math.abs(targets[0].countCards('h') - targets[1].countCards('h'));
                    if (num > 0) player.addMark(event.name, num);
                },
                marktext: '盟',
                intro: {
                    name2: '盟',
                    content: 'mark',
                },
                group: 'minidimeng_discard',
                subSkill: {
                    discard: {
                        trigger: { player: ['phaseDrawEnd', 'phaseEnd'] },
                        filter(event, player) {
                            if (!player.hasMark('minidimeng')) return false;
                            return player.hasCard(card => _status.connectMode || lib.filter.cardDiscardable(card, player), 'he');
                        },
                        async cost(event, trigger, player) {
                            event.result = await player.chooseToDiscard('he', get.prompt('minidimeng'), '弃置任意张牌并移除等量的“盟”标记', [1, player.countMark('minidimeng')]).set('ai', card => {
                                const player = get.player();
                                if (player.countCards('h') < 3) return 0;
                                if (['haoshi', 'olhaoshi'].some(skill => player.hasSkill(skill)) && !game.hasPlayer(current => current != player && get.attitude(player, current) > 0 && current.isMinHandcard())) return 0;
                                return 6 - get.value(card);
                            }).set('logSkill', 'minidimeng').forResult();
                        },
                        popup: false,
                        async content(event, trigger, player) {
                            player.removeMark('minidimeng', event.cards.length);
                        },
                    }
                }
            },
            // 吴国太
            miniganlu: {
                moveCheck(player, target) {
                    if (target == player) return false;
                    return player.countCards('e', card => {
                        return target.countCards('e', cardx => get.subtype(card) == get.subtype(cardx) && player.canEquip(cardx, true) && target.canEquip(card, true));
                    });
                },
                audio: 'ganlu',
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    var list = [];
                    if (player.canMoveCard(null, true)) list.push('移动牌');
                    if (game.hasPlayer(current1 => {
                        return game.hasPlayer(current2 => lib.skill.miniganlu.moveCheck(current1, current2));
                    })) list.push('交换牌');
                    list.push('摸牌');
                    list.push('cancel2');
                    player.chooseControl(list).set('choiceList', [
                        '移动场上的一张装备牌',
                        '交换场上装备区中两张副类别相同的装备牌的位置',
                        '摸一张牌',
                    ]).set('prompt', '请选择你要执行的选项').set('ai', function () {
                        var player = _status.event.player;
                        if (player.canMoveCard(true, true)) return '移动牌';
                        return '摸牌';
                    });
                    'step 1'
                    if (result.control != 'cancel2') {
                        switch (result.control) {
                            case '摸牌':
                                player.logSkill('miniganlu');
                                player.draw();
                                event.finish();
                                break;
                            case '移动牌':
                                player.logSkill('miniganlu');
                                player.moveCard().nojudge = true;
                                event.finish();
                                break;
                            case '交换牌':
                                player.chooseCardTarget({
                                    prompt: '甘露：请选择两名角色，交换他们装备区的一张副类别相同的一张牌',
                                    filterCard: false,
                                    selectCard: -1,
                                    filterTarget(card, player, target) {
                                        if (!ui.selected.targets.length) return game.hasPlayer(current => lib.skill.miniganlu.moveCheck(target, current));
                                        return lib.skill.miniganlu.moveCheck(ui.selected.targets[0], target);
                                    },
                                    selectTarget: 2,
                                    complexSelect: true,
                                    complexTarget: true,
                                    forced: true,
                                });
                                break;
                        }
                    }
                    else event.finish();
                    'step 2'
                    var targets = result.targets;
                    event.targets = targets;
                    player.logSkill('miniganlu', targets);
                    player.chooseButton([
                        '###甘露###<div class="text center">请选择' + get.translation(targets[0]) + '和' + get.translation(targets[1]) + '交换的装备牌</div>',
                        '<div class="text center">' + get.translation(targets[0]) + '</div>',
                        targets[0].getCards('e'),
                        '<div class="text center">' + get.translation(targets[1]) + '</div>',
                        targets[1].getCards('e')
                    ], 2, true).set('filterButton', button => {
                        var targets = _status.event.targets;
                        if (!ui.selected.buttons.length) {
                            if (targets[0].getCards('e', card => {
                                return targets[1].countCards('e', cardx => get.subtype(card) == get.subtype(cardx) && targets[0].canEquip(cardx, true) && targets[1].canEquip(card, true));
                            }).includes(button.link)) return true;
                            if (targets[1].getCards('e', card => {
                                return targets[0].countCards('e', cardx => get.subtype(card) == get.subtype(cardx) && targets[1].canEquip(cardx, true) && targets[0].canEquip(card, true));
                            }).includes(button.link)) return true;
                            return false;
                        }
                        var card = ui.selected.buttons[0].link;
                        var owner = get.owner(card);
                        var target = targets.find(target => target != owner);
                        return target.getCards('e', cardx => get.subtype(card) == get.subtype(cardx) && owner.canEquip(cardx, true) && target.canEquip(card, true)).includes(button.link);
                    }).set('targets', targets);
                    'step 3'
                    if (result.bool) {
                        if (get.owner(result.links[0]) != targets[0]) result.links.reverse();
                        game.log(player, '令', targets[0], '和', targets[1], '交换了', result.links[0], '和', result.links[1]);
                        event.links = result.links;
                        game.loseAsync({
                            player: targets[0],
                            target: targets[1],
                            cards1: event.links[0],
                            cards2: event.links[1],
                        }).setContent('swapHandcardsx');
                    }
                    else event.finish();
                    'step 4'
                    if (get.position(event.links[1], true) == 'o') targets[0].equip(event.links[1]);
                    if (get.position(event.links[0], true) == 'o') targets[1].equip(event.links[0]);
                },
            },
            minibuyi: {
                audio: 'buyi',
                trigger: { global: 'dying' },
                usable: 3,
                filter(event, player) {
                    return event.player.hp <= 0 && event.player.countCards('h');
                },
                direct: true,
                content() {
                    'step 0'
                    var check;
                    if (trigger.player.isUnderControl(true, player)) {
                        check = player.hasCard(function (card) {
                            return get.type(card) == 'basic';
                        });
                    }
                    else check = (get.attitude(player, trigger.player) > 0);
                    player.choosePlayerCard(trigger.player, get.prompt('minibuyi', trigger.player), 'h').set('ai', function (button) {
                        if (!_status.event.check) return 0;
                        if (_status.event.target.isUnderControl(true, _status.event.player)) {
                            if (get.type(button.link) == 'basic') {
                                return 10 - get.value(button.link);
                            }
                            return 0;
                        }
                        else return Math.random();
                    }).set('check', check).set('filterButton', function (button) {
                        if (_status.event.player == _status.event.target) {
                            return lib.filter.cardDiscardable(button.link, _status.event.player);
                        }
                        return true;
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minibuyi', trigger.player);
                        event.card = result.links[0];
                        player.showCards([event.card], get.translation(player) + '展示的手牌');
                    }
                    else {
                        player.storage.counttrigger.minibuyi--;
                        event.finish();
                    }
                    'step 2'
                    if (get.type(event.card) == 'basic') {
                        trigger.player.discard(event.card);
                        trigger.player.recover();
                    }
                },
            },
            minireganlu: {
                audio: 'olganlu',
                trigger: { player: 'phaseUseBegin' },
                locked: true,
                async cost(event, trigger, player) {
                    const list = ['摸牌'];
                    if (game.hasPlayer(current => game.hasPlayer(currentx => currentx != current && (current.countCards('e') + currentx.countCards('e')) > 0))) list.push('交换牌');
                    const result = await player.chooseControl(list).set('choiceList', [
                        '摸两张牌，然后移动场上的一张装备牌或交换场上装备区中两张副类别相同的装备牌的位置',
                        '交换两名角色装备区的牌，然后弃置一张牌',
                    ]).set('prompt', '请选择你要执行的选项').set('ai', () => {
                        const player = get.player();
                        const controls = get.event().controls.slice();
                        if (controls.includes('交换牌') && game.hasPlayer(current => game.hasPlayer(currentx => {
                            if (currentx == current) return false;
                            const att1 = get.attitude(player, current), att2 = get.attitude(player, currentx);
                            if (att1 * att2 > 0) return false;
                            let delta = get.value(current.getCards('e'), currentx) - get.value(currentx.getCards('e'), currentx);
                            return Math.abs(delta) > 4 && Math.abs(current.countCards('e') - currentx.countCards('e')) > 1;
                        }))) return '交换牌';
                        return '摸牌';
                    }).forResult();
                    event.result = {
                        bool: true,
                        cost_data: result?.control,
                    }
                },
                async content(event, trigger, player) {
                    const { cost_data: control } = event;
                    if (control == '摸牌') {
                        await player.draw(2);
                        const list = [];
                        if (player.canMoveCard(null, true)) list.push('移动牌');
                        if (game.hasPlayer(current1 => {
                            return game.hasPlayer(current2 => lib.skill.miniganlu.moveCheck(current1, current2));
                        })) list.push('交换牌');
                        if (!list.length) return;
                        list.push('cancel2');
                        const result = await player.chooseControl(list).set('choiceList', [
                            '移动场上的一张装备牌',
                            '交换场上装备区中两张副类别相同的装备牌的位置',
                        ]).set('prompt', '请选择你要执行的选项').set('ai', () => {
                            const player = get.player();
                            if (player.canMoveCard(true, true)) return '移动牌';
                            return '交换牌';
                        }).forResult();
                        switch (result?.control) {
                            case '移动牌': {
                                await player.moveCard().set('nojudge', true);
                                break;
                            }
                            case '交换牌': {
                                let result;
                                result = await player.chooseTarget('甘露：请选择两名角色，交换他们装备区的一张副类别相同的一张牌', (card, player, target) => {
                                    if (!ui.selected.targets.length) return game.hasPlayer(current => lib.skill.miniganlu.moveCheck(target, current));
                                    return lib.skill.miniganlu.moveCheck(ui.selected.targets[0], target);
                                }, 2).forResult();
                                if (result?.bool && result?.targets?.length) {
                                    const { targets } = result;
                                    result = await player.chooseButton([
                                        '###甘露###<div class="text center">请选择' + get.translation(targets[0]) + '和' + get.translation(targets[1]) + '交换的装备牌</div>',
                                        '<div class="text center">' + get.translation(targets[0]) + '</div>',
                                        targets[0].getCards('e'),
                                        '<div class="text center">' + get.translation(targets[1]) + '</div>',
                                        targets[1].getCards('e')
                                    ], 2, true).set('filterButton', button => {
                                        var targets = _status.event.targets;
                                        if (!ui.selected.buttons.length) {
                                            if (targets[0].getCards('e', card => {
                                                return targets[1].countCards('e', cardx => get.subtype(card) == get.subtype(cardx) && targets[0].canEquip(cardx, true) && targets[1].canEquip(card, true));
                                            }).includes(button.link)) return true;
                                            if (targets[1].getCards('e', card => {
                                                return targets[0].countCards('e', cardx => get.subtype(card) == get.subtype(cardx) && targets[1].canEquip(cardx, true) && targets[0].canEquip(card, true));
                                            }).includes(button.link)) return true;
                                            return false;
                                        }
                                        var card = ui.selected.buttons[0].link;
                                        var owner = get.owner(card);
                                        var target = targets.find(target => target != owner);
                                        return target.getCards('e', cardx => get.subtype(card) == get.subtype(cardx) && owner.canEquip(cardx, true) && target.canEquip(card, true)).includes(button.link);
                                    }).set('targets', targets).forResult();
                                    if (result?.bool && result?.links?.length == 2) {
                                        if (get.owner(result.links[0]) != targets[0]) result.links.reverse();
                                        game.log(player, '令', targets[0], '和', targets[1], '交换了', result.links[0], '和', result.links[1]);
                                        event.links = result.links;
                                        await game.loseAsync({
                                            player: targets[0],
                                            target: targets[1],
                                            cards1: event.links[0],
                                            cards2: event.links[1],
                                        }).setContent('swapHandcardsx');
                                        if (get.position(event.links[1], true) == 'o') await targets[0].equip(event.links[1]);
                                        if (get.position(event.links[0], true) == 'o') await targets[1].equip(event.links[0]);
                                    }
                                }
                                break;
                            }
                        }
                    }
                    else if (game.hasPlayer(current => game.hasPlayer(currentx => currentx != current && (current.countCards('e') + currentx.countCards('e')) > 0))) {
                        const result = await player.chooseTarget('甘露：请选择两名角色，交换他们装备区的牌', true, 2, (card, player, target) => {
                            if (target.isMin()) return false;
                            if (ui.selected.targets.length == 0) return true;
                            if (ui.selected.targets[0].countCards('e') == 0 && target.countCards('e') == 0) return false;
                            return true;
                        }).set('ai', target => {
                            const player = get.player();
                            return get.effect(target, 'xinganlu', player, player);
                        }).set('multitarget', true).forResult();
                        if (result?.bool && result?.targets?.length) {
                            const [target1, target2] = result.targets;
                            await target1.swapEquip(target2);
                            if (player.countDiscardableCards(player, 'he')) await player.chooseToDiscard('he', true);
                        }
                    }
                },
            },
            minirebuyi: {
                audio: 'olbuyi',
                trigger: { global: 'dying' },
                usable: 3,
                filter(event, player) {
                    return event.player.hp <= 0;
                },
                async cost(event, trigger, player) {
                    const { player: target } = trigger;
                    const bool = target.countCards('h');
                    let next;
                    if (!bool) {
                        next = player.chooseBool(get.prompt(event.skill, target), '令其摸一张牌并展示之');
                        next.set('choice', get.attitude(player, target) > 0);
                    }
                    else {
                        next = player.choosePlayerCard(target, get.prompt(event.skill, target), 'h', 'visible', [1, Infinity]);
                        next.set('ai', button => {
                            const { player, target } = get.event();
                            const { link } = button;
                            const att = get.attitude(player, target);
                            if (att <= 0) {
                                if (get.type(link) != 'basic') return 1;
                                return 0;
                            };
                            if (get.type(link) == 'basic' && ui.selected.buttons.length < target.getDamagedHp()) return 10 - get.value(link);
                            return 0;
                        });
                        next.set('filterButton', button => {
                            const { player, target } = get.event();
                            if (player == target) return lib.filter.cardDiscardable(button.link, player);
                            return true;
                        })
                    }
                    event.result = await next.forResult();
                },
                logTarget: 'player',
                async content(event, trigger, player) {
                    const { player: target } = trigger;
                    let { cards } = event;
                    if (get.itemtype(cards) != 'cards') {
                        cards = await target.draw().forResult();
                        if (get.itemtype(cards) != 'cards') return;
                    }
                    await player.showCards(cards, `${get.translation(player)}对${player === target ? '自己' : get.translation(target)}发动了【补益】`);
                    await target.discard(cards).set('discarder', player);
                    const num = cards.filter(card => get.type(card) == 'basic').length;
                    if (num) await target.recover(num);
                },
            },
            minipojun: {
                audio: 'decadepojun',
                trigger: { player: 'useCardToPlayered' },
                direct: true,
                filter(event, player) {
                    return event.card.name == 'sha' && event.target.getHp() > 0 && event.target.countCards('he');
                },
                content() {
                    'step 0'
                    const num = Math.min(trigger.target.getHp(), trigger.target.countCards('he'));
                    var next = player.choosePlayerCard(trigger.target, 'he', [1, num], get.prompt(event.name, trigger.target));
                    next.set('ai', function (button) {
                        if (!_status.event.goon) return 0;
                        var val = get.value(button.link);
                        if (_status.event.target.getEquips(2).some(i => i == button.link)) return 2 * (val + 3);
                        return val;
                    });
                    next.set('goon', get.attitude(player, trigger.target) <= 0);
                    next.set('forceAuto', true);
                    'step 1'
                    if (result.bool) {
                        event.cards = result.cards;
                        var target = trigger.target;
                        player.logSkill(event.name, trigger.target);
                        target.addSkill('minipojun2');
                        target.addToExpansion(result.cards, 'giveAuto', target).gaintag.add('minipojun2');
                    }
                    else event.finish();
                    'step 2'
                    var discard = false, draw = false;
                    for (var i of cards) {
                        var type = get.type2(i);
                        if (type == 'equip') discard = true;
                        if (i.name == 'shan') draw = true;
                    }
                    if (discard) {
                        event.equip = true;
                        player.chooseButton(['选择一张装备牌置入弃牌堆', cards.filter(function (card) {
                            return get.type(card) == 'equip';
                        })], true).set('ai', function (button) {
                            return get.value(button.link, _status.event.getTrigger().target);
                        });
                    }
                    if (draw) event.draw = true;
                    'step 3'
                    if (event.equip && result.links && result.links.length) trigger.target.loseToDiscardpile(result.links);
                    if (event.draw) player.draw();
                },
                ai: {
                    unequip_ai: true,
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (get.attitude(player, arg.target) > 0) return false;
                        if (tag == 'directHit_ai') return arg.target.hp >= Math.max(1, arg.target.countCards('h') - 1);
                        if (arg?.name == 'sha' && arg.target.getEquips(2).length) return true;
                        return false;
                    }
                },
            },
            minipojun2: {
                trigger: { global: 'phaseEnd' },
                forced: true,
                popup: false,
                charlotte: true,
                filter(event, player) {
                    return player.getExpansions('minipojun2').length > 0;
                },
                content() {
                    'step 0'
                    var cards = player.getExpansions('minipojun2');
                    player.gain(cards, 'draw');
                    game.log(player, '收回了' + get.cnNumber(cards.length) + '张〖破军〗牌');
                    'step 1'
                    player.removeSkill('minipojun2');
                },
                intro: {
                    markcount: 'expansion',
                    mark(dialog, storage, player) {
                        var cards = player.getExpansions('minipojun2');
                        if (player.isUnderControl(true)) dialog.addAuto(cards);
                        else return '共有' + get.cnNumber(cards.length) + '张牌';
                    },
                },
            },
            minirepojun: {
                inherit: 'minipojun',
                audio: 'repojun',
                filter(event, player) {
                    return event.card.name == 'sha' && event.target.countCards('he');
                },
                group: 'repojun3',
            },
            minidcpojun: {
                audio: 'decadepojun',
                trigger: {
                    player: 'useCardToPlayered',
                    target: 'useCardToTargeted',
                },
                filter(event, player) {
                    if (event.player == event.target || event.card.name != 'sha') return false;
                    return player.maxHp > 0 && get.info('minidcpojun').logTarget(event, player).countCards('he') > 0;
                },
                async cost(event, trigger, player) {
                    const target = get.info('minidcpojun').logTarget(trigger, player);
                    const next = player.choosePlayerCard(target, 'he', [1, Math.min(player.maxHp, target.countCards('he'))], get.prompt(event.name.slice(0, -5), target));
                    next.set('ai', button => {
                        if (!_status.event.goon) return 0;
                        const val = get.value(button.link);
                        if (button.link == _status.event.target.getEquip(2)) return 2 * (val + 3);
                        return val;
                    });
                    next.set('goon', get.attitude(player, target) <= 0);
                    next.set('forceAuto', true);
                    event.result = await next.forResult();
                },
                logTarget(event, player) {
                    return event.player == player ? event.target : event.player;
                },
                async content(event, trigger, player) {
                    const target = get.info(event.name).logTarget(trigger, player);
                    target.addSkill(event.name + '_gain');
                    const next = target.addToExpansion("giveAuto", event.cards, target)
                    next.gaintag.add(event.name + '_gain');
                    await next;
                },
                ai: {
                    unequip_ai: true,
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        const target = get.info('minidcpojun').logTarget(arg, player);
                        if (get.attitude(player, target) > 0) return false;
                        if (tag == 'directHit_ai') return player == arg.player && player.maxHp >= Math.max(1, arg.target.countCards('h') - 1);
                        return arg?.card?.name == 'sha' && arg.target?.getEquip(2);
                    },
                },
                subSkill: {
                    gain: {
                        charlotte: true,
                        trigger: { global: 'phaseEnd' },
                        filter(event, player) {
                            return player.getExpansions('minidcpojun_gain').length > 0;
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const cards = player.getExpansions(event.name);
                            await player.gain(cards, 'draw');
                            game.log(player, '收回了' + get.cnNumber(cards.length) + '张“破军”牌');
                            player.removeSkill(event.name);
                        },
                        intro: {
                            markcount: 'expansion',
                            mark(dialog, storage, player) {
                                var cards = player.getExpansions('minidcpojun_gain');
                                if (player.isUnderControl(true)) dialog.addAuto(cards);
                                else return '共有' + get.cnNumber(cards.length) + '张牌';
                            },
                        },
                    }
                }
            },
            miniyicheng: {
                audio: ['yicheng1.mp3', 'yicheng2.mp3'],
                trigger: {
                    global: ['loseAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                },
                forced: true,
                getIndex(event, player) {
                    return game.filterPlayer(current => {
                        const evt = event.getl(current);
                        const num = current.getCards('x').map(card => get.type2(card)).toUniqued().length;
                        return (evt?.xs?.length || (event.name == 'addToExpansion' && event.player == current)) && num > 0 && num <= 3;
                    }).sortBySeat();
                },
                logTarget(event, player, triggername, target) {
                    return target;
                },
                async content(event, trigger, player) {
                    const target = event.targets[0], num = target.getCards('x').map(card => get.type2(card)).toUniqued().length;
                    if (num == 1) {
                        if (!target.hasSkill('fengyin')) target.addTempSkill('fengyin');
                        target.addTempSkill(event.name + '_ban');
                    }
                    else if (num == 2) {
                        target.addTempSkill(event.name + '_damage');
                    }
                    else {
                        await player.draw(3);
                    }
                },
                subSkill: {
                    ban: {
                        mod: {
                            cardEnabled2(card) {
                                if (get.position(card) == 'h') return false;
                            },
                        },
                        mark: true,
                        intro: {
                            content: '本回合非锁定技失效且不能使用或打出手牌',
                        },
                    },
                    damage: {
                        trigger: {
                            player: 'damageBegin3',
                        },
                        charlotte: true,
                        onremove: true,
                        forced: true,
                        popup: false,
                        content() {
                            trigger.num++;
                        },
                        mark: true,
                        intro: {
                            content: '本回合受到伤害的伤害+1',
                        },
                    }
                }
            },
            //吕蒙
            minikeji: {
                audio: 'keji',
                audioname: ['re_lvmeng'],
                audioname2: { Mbaby_sb_lvmeng: 'sbkeji' },
                trigger: { player: 'phaseDiscardBefore' },
                filter(event, player) {
                    if (player.hasSkill('minisbduojing_keji')) return true;
                    const history = player.getHistory('useCard').concat(player.getHistory('respond'));
                    return !history.some(evt => evt.card.name == 'sha' && evt.isPhaseUsing());
                },
                frequent: true,
                content() {
                    trigger.cancel();
                    player.draw();
                },
            },
            miniqinxue: {
                skillAnimation: true,
                animationColor: 'wood',
                audio: 'qinxue',
                juexingji: true,
                derivation: 'minigongxin',
                trigger: { player: 'phaseJieshuBegin' },
                forced: true,
                filter(event, player) {
                    return player.countCards('h') >= player.hp * 3;
                },
                content() {
                    'step 0'
                    var num = player.maxHp - player.hp;
                    player.awakenSkill('miniqinxue');
                    if (num > 0) player.loseMaxHp(num);
                    player.changeSkills(['minigongxin'], ['minikeji']);
                },
            },
            //谋吕蒙
            minisbduojing: {
                audio: 'sbduojing',
                enable: 'phaseUse',
                usable: 2,
                filterTarget: lib.filter.notMe,
                async content(event, trigger, player) {
                    const target = event.target;
                    const result = await player.mini_chooseToMouYi(target).set('namelist', [
                        '半渡而击', '扰袭敌营', '休养生息', '白衣渡江'
                    ]).set('ai', button => {
                        const source = get.event().getParent().player, target = get.event().getParent().target;
                        if (get.effect(target, { name: 'sha', storage: { minisbduojing: true } }, source, source) < 0 && (button.link[2] == 'db_atk2' || button.link[2] == 'db_def1')) return 10;
                        if (get.effect(target, { name: 'shunshou_copy2' }, source, source) < 0 && (button.link[2] == 'db_atk1' || button.link[2] == 'db_def2')) return 10;
                        return 1 + Math.random();
                    }).forResult();
                    if (result?.bool) {
                        if (result.player == 'db_def1') {
                            await player.gainPlayerCard(target, 'he', true);
                            await player.recover();
                            const num = player.getDamagedHp();
                            if (num > 0) {
                                await player.draw(num);
                                await player.chooseToDiscard(num, 'he', true);
                            }
                        }
                        else {
                            const card = new lib.element.VCard({ name: 'sha', storage: { minisbduojing: true } });
                            if (player.canUse(card, target, false)) await player.useCard(card, target, false);
                            player.addTempSkill('shenzhu_more');
                            player.addMark('shenzhu_more', 1, false);
                            player.addTempSkill('minisbduojing_keji');
                        }
                    }
                },
                init() {
                    if (!_status.miniMouYi) {
                        _status.miniMouYi = true;
                        lib.skill.minisbtieji.initMouYi();
                    }
                },
                ai: {
                    order(item, player) {
                        return get.order({ name: 'sha' }, player) - 0.01;
                    },
                    unequip: true,
                    unequip_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (!arg || !arg.card || !arg.card.storage || !arg.card.storage.minisbduojing) return false;
                    },
                    result: { target: -1 },
                },
                subSkill: {
                    keji: {
                        charlotte: true,
                        mark: true,
                        intro: { content: '本回合无视【克己】发动条件' },
                    },
                },
            },
            //小乔
            minitianxiang: {
                audio: 'tianxiang',
                audioname: ['ol_xiaoqiao'],
                trigger: { player: 'damageBegin3' },
                filter(event, player) {
                    return player.hasCard(card => {
                        if (_status.connectMode) return true;
                        return get.suit(card) === 'heart' && lib.filter.cardDiscardable(card, player)
                    }, 'h');
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseCardTarget({
                        prompt: get.prompt2(event.skill),
                        filterCard(card, player) {
                            return get.suit(card) == 'heart' && lib.filter.cardDiscardable(card, player);
                        },
                        filterTarget: lib.filter.notMe,
                        ai1(card) {
                            return 10 - get.value(card);
                        },
                        ai2(target) {
                            const player = get.player(), trigger = get.event().getTrigger(), att = get.attitude(player, target);
                            const da = player.hp === 1 ? 10 : 0, eff = get.damageEffect(target, trigger.source, target);
                            if (att === 0) return 0.1 + da;
                            if (eff >= 0 && att > 0) return att + da;
                            return -att + da;
                        },
                    }).forResult();
                },
                async content(event, trigger, player) {
                    trigger.cancel();
                    const target = event.targets[0];
                    await player.discard(event.cards);
                    player.addTempSkill(`${skill}_effect`);
                    let args = [trigger.num, trigger.nature, trigger.cards, trigger.card];
                    args.push(trigger.source?.isIn() ? trigger.source : 'nosource');
                    const next = target.damage.apply(target, args.slice());
                    next[`${skill}_effect`] = [player];
                    await next;
                },
                ai: {
                    maixie_defend: true,
                    effect: {
                        target(card, player, target) {
                            if (player.hasSkillTag('jueqing', false, target)) return;
                            if (get.tag(card, 'damage') && target.countCards('h') > 1) return 0.7;
                        },
                    },
                    threaten(player, target) {
                        if (!target.countCards('h')) return 2;
                    },
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        trigger: { global: ['damageAfter', 'damageCancelled', 'damageZero'] },
                        filter(event, player) {
                            return event.minitianxiang_effect?.includes(player) && event.player.isIn();
                        },
                        forced: true,
                        popup: false,
                        content() {
                            trigger.player.draw();
                        },
                    },
                },
            },
            miniretianxiang: {
                inherit: 'minitianxiang',
                async cost(event, trigger, player) {
                    event.result = await player.chooseCardTarget({
                        prompt: get.prompt2(event.skill),
                        filterCard(card, player) {
                            return get.suit(card) == 'heart' && lib.filter.cardDiscardable(card, player);
                        },
                        filterTarget: lib.filter.notMe,
                        ai1(card) {
                            return 10 - get.value(card);
                        },
                        ai2(target) {
                            const player = get.player(), trigger = get.event().getTrigger(), att = get.attitude(player, target);
                            const da = player.hp === 1 ? 10 : 0, eff = get.damageEffect(target, trigger.source, target);
                            if (att === 0) return 0.1 + da;
                            if (eff >= 0 && att > 0) return att + da;
                            if (att > 0 && target.hp > 1) {
                                if (target.getDamagedHp() >= 3) return att * 1.1 + da;
                                if (target.getDamagedHp() >= 2) return att * 0.9 + da;
                            }
                            return -att + da;
                        },
                    }).forResult();
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        trigger: { global: ['damageAfter', 'damageCancelled', 'damageZero'] },
                        filter(event, player) {
                            return event.miniretianxiang_effect?.includes(player) && event.player.isIn();
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const target = trigger.player;
                            let result;
                            if (target.isHealthy()) result = { index: 0 };
                            else {
                                result = await player.chooseControl().set('choiceList', [
                                    '令' + get.translation(target) + '摸一张牌',
                                    '令' + get.translation(target) + '摸' + get.cnNumber(Math.min(5, target.getDamagedHp())) + '张牌',
                                ]).set('ai', () => {
                                    const player = get.player(), target = get.event().getTrigger().player;
                                    return get.attitude(player, target) > 0 ? 1 : 0;
                                }).forResult();
                            }
                            await target.draw(result.index === 0 ? 1 : Math.min(5, target.getDamagedHp()));
                        },
                    },
                },
            },
            minijiang: {
                audio: 'jiang',
                inherit: 'jiang',
                filter(event, player) {
                    return event.card.name == 'sha' || event.card.name == 'juedou';
                },
                ai: {
                    effect: {
                        target(card, player, target) {
                            if (card.name == 'sha' || card.name == 'juedou') return [1, 0.6];
                        },
                        player(card, player, target) {
                            if (card.name == 'sha' || card.name == 'juedou') return [1, 1];
                        },
                    },
                },
            },
            miniolhunzi: {
                audio: 'olhunzi',
                audioname: ['re_sunyi'],
                trigger: {
                    global: 'phaseBefore',
                    player: ['miniolhunzi_awaken', 'enterGame'],
                },
                filter(event, player, name) {
                    if (name === 'miniolhunzi_awaken') return _status.gameDrawed;
                    return player.hp === 1 && (event.name !== 'phase' || game.phaseNumber === 0);
                },
                juexingji: true,
                forced: true,
                skillAnimation: true,
                animationColor: 'wood',
                async content(event, trigger, player) {
                    player.awakenSkill('miniolhunzi');
                    await player.loseMaxHp();
                    await player.addSkills(lib.skill[event.name].derivation);
                },
                derivation: ['minireyingzi', 'minireyinghun'],
                init(player, skill) {
                    if (typeof player._miniolhunzi_hp !== 'number') {
                        game.broadcastAll(player => {
                            player._miniolhunzi_hp = player.hp;
                            Object.defineProperties(player, {
                                hp: {
                                    configurable: true,
                                    get() {
                                        return this._miniolhunzi_hp;
                                    },
                                    set(num) {
                                        game.broadcastAll((player, num) => {
                                            player._miniolhunzi_hp = num;
                                        }, this, num);
                                        if (this._miniolhunzi_hp === 1) {
                                            const event = _status.event;
                                            const next = event.trigger('miniolhunzi_awaken');
                                            next.player = this;
                                        }
                                    },
                                },
                            });
                        }, player);
                    }
                },
            },
            minihunzi: {
                audio: 'olhunzi',
                audioname: ['re_sunyi'],
                audioname2: { Mbaby_sunce: 'hunzi' },
                derivation: ['reyingzi', 'minireyinghun'],
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return player.hp == 1;
                },
                juexingji: true,
                forced: true,
                skillAnimation: true,
                animationColor: 'wood',
                content() {
                    'step 0'
                    player.awakenSkill('minihunzi');
                    player.loseMaxHp();
                    'step 1'
                    player.addSkills(lib.skill[event.name].derivation);
                },
                ai: {
                    threaten(player, target) {
                        if (target.hp == 1) return 2;
                        return 0.5;
                    },
                    maixie: true,
                    effect: {
                        target(card, player, target) {
                            if (!target.hasFriend()) return;
                            if (get.tag(card, 'damage') == 1 && target.hp == 2 && !target.isTurnedOver() && _status.currentPhase != target && get.distance(_status.currentPhase, target, 'absolute') <= 3) return [0.5, 1];
                        },
                    },
                },
            },
            minizhiba: {
                audio: 'zhiba',
                zhuSkill: true,
                global: 'minizhiba_global',
                subSkill: {
                    global: {
                        forceaudio: true,
                        audio: 'zhiba',
                        enable: 'phaseUse',
                        filter(event, player) {
                            if (player.group !== 'wu' || !player.hasCard({ name: ['juedou'] }, 'h')) return false;
                            return game.hasPlayer(target => lib.skill.minizhiba_global.filterTarget(null, player, target));
                        },
                        filterCard: { name: ['juedou'] },
                        filterTarget(card, player, target) {
                            if (player.getStorage('minizhiba_used').includes(target)) return false;
                            return target !== player && target.hasZhuSkill('minizhiba', player);
                        },
                        prompt() {
                            var player = _status.event.player;
                            var list = game.filterPlayer(target => lib.skill.minizhiba_global.filterTarget(null, player, target));
                            var str = '将一张【决斗】交给' + get.translation(list);
                            if (list.length > 1) str += '中的一人';
                            return str;
                        },
                        discard: false,
                        lose: false,
                        delay: false,
                        content() {
                            player.addTempSkill('minizhiba_used', 'phaseUseAfter');
                            player.markAuto('minizhiba_used', [target]);
                            target.gain(cards, player, 'give');
                        },
                        ai: {
                            expose: 0.3,
                            order: 10,
                            result: { target: 1 },
                        },
                    },
                    used: {
                        charlotte: true,
                        onremove: true,
                    },
                },
            },
            miniolzhiba: {
                audio: 'olzhiba',
                zhuSkill: true,
                global: 'miniolzhiba_global',
                subSkill: {
                    global: {
                        forceaudio: true,
                        audio: 'olzhiba',
                        enable: 'phaseUse',
                        filter(event, player) {
                            if (player.group !== 'wu' || !player.hasCard({ name: ['sha', 'juedou'] }, 'h')) return false;
                            return game.hasPlayer(target => lib.skill.miniolzhiba_global.filterTarget(null, player, target));
                        },
                        filterCard: { name: ['sha', 'juedou'] },
                        filterTarget(card, player, target) {
                            if (player.getStorage('miniolzhiba_used').includes(target)) return false;
                            return target !== player && target.hasZhuSkill('miniolzhiba', player);
                        },
                        prompt() {
                            var player = _status.event.player;
                            var list = game.filterPlayer(target => lib.skill.miniolzhiba_global.filterTarget(null, player, target));
                            var str = '将一张【杀】或【决斗】交给' + get.translation(list);
                            if (list.length > 1) str += '中的一人';
                            return str;
                        },
                        discard: false,
                        lose: false,
                        delay: false,
                        content() {
                            player.addTempSkill('miniolzhiba_used', 'phaseUseAfter');
                            player.markAuto('miniolzhiba_used', [target]);
                            target.gain(cards, player, 'give');
                        },
                        ai: {
                            expose: 0.3,
                            order: 10,
                            result: { target: 1 },
                        },
                    },
                    used: {
                        charlotte: true,
                        onremove: true,
                    },
                },
            },
            minibuqu: {
                audio: 'gzbuqu',
                trigger: { player: 'chooseToUseBefore' },
                filter(event, player) {
                    return event.type == 'dying' && player.isDying() && event.dying == player && player.countMark('minibuqu') < 4;
                },
                forced: true,
                preHidden: true,
                content() {
                    player.addMark('minibuqu', 1);
                    if (player.hp <= 0) player.recover(1 - player.hp);
                },
                marktext: '创',
                intro: { name: '不屈', name2: '创', content: 'mark' },
                mod: {
                    maxHandcard(player, num) {
                        return num + player.countMark('minibuqu');
                    },
                },
                ai: {
                    save: true,
                    mingzhi: true,
                    skillTagFilter(player, tag, target) {
                        if (player != target || player.countMark('minibuqu') > 3) return false;
                    },
                },
            },
            minirebuqu: {
                audio: 'buqu',
                trigger: { player: ['damageBegin2', 'loseHpBegin'] },
                filter(event, player) {
                    return player.countMark('minirebuqu') < 4;
                },
                forced: true,
                preHidden: true,
                content() {
                    trigger.cancel();
                    player.addMark('minirebuqu', 1);
                },
                marktext: '创',
                intro: { name: '不屈', name2: '创', content: 'mark' },
                mod: {
                    maxHandcard(player, num) {
                        return num + player.countMark('minirebuqu');
                    },
                },
            },
            miniqingchuang: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                filter(event, player) {
                    if (!player.hasMark('minirebuqu')) return false;
                    return player.countCards('h', card => lib.skill.miniqingchuang.filterCard(card, player));
                },
                filterCard(card, player) {
                    return get.name(card, player) == 'tao' || get.name(card, player) == 'jiu';
                },
                check(card) {
                    var player = _status.event.player;
                    return 2 - ['tao', 'jiu'].indexOf(get.name(card, player));
                },
                usable: 1,
                delay: 0,
                content() {
                    player.removeMark('minirebuqu', 1);
                    player.draw();
                },
                ai: {
                    order: 7,
                    result: { player: 1 },
                },
            },
            //孙尚香
            minijieyin: {
                audio: 'jieyin',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he');
                },
                filterCard: true,
                usable: 1,
                position: 'he',
                check(card) {
                    var player = _status.event.player;
                    if (get.position(card) == 'e') {
                        var subtype = get.subtype(card);
                        if (!game.hasPlayer(function (current) {
                            return current != player && current.hp != player.hp && get.attitude(player, current) > 0 && !current.countCards('e', { subtype: subtype });
                        })) return 0;
                        if (player.countCards('h', { subtype: subtype })) return 20 - get.value(card);
                        return 10 - get.value(card);
                    }
                    else {
                        if (player.countCards('e')) return 0;
                        if (player.countCards('h', { type: 'equip' })) return 0;
                        return 8 - get.value(card);
                    }
                },
                filterTarget(cardx, player, target) {
                    const card = ui.selected.cards[0];
                    if (!card || target === player) return false;
                    if (get.position(card) === 'h') return true;
                    return get.type(card) === 'equip' && target.canEquip(card);
                },
                discard: false,
                delay: 0,
                lose: false,
                async content(event, trigger, player) {
                    const { target, cards } = event, [card] = cards;
                    const hs = get.position(card) === 'h', canEquip = get.type(card) === 'equip' && target.canEquip(card);
                    let result;
                    if (!hs) result = { index: 1 };
                    else if (!canEquip) result = { index: 0 };
                    else result = await player.chooseControl().set('choiceList', [
                        `将${get.translation(card)}交给${get.translation(target)}`,
                        `将${get.translation(card)}置入${get.translation(target)}的装备区`,
                    ]).set('ai', () => 1).forResult();
                    if (result.index === 1) {
                        player.$give(cards, target);
                        await target.equip(cards[0]);
                    }
                    else await player.give(cards, target, true);
                    await player.recover();
                },
                ai: {
                    order() {
                        var player = _status.event.player;
                        var es = player.getCards('e');
                        for (var i = 0; i < es.length; i++) {
                            if (player.countCards('h', { subtype: get.subtype(es[i]) })) return 10;
                        }
                        return 2;
                    },
                    result: {
                        target(player, target) {
                            var goon = function () {
                                var es = player.getCards('e');
                                for (var i = 0; i < es.length; i++) {
                                    if (player.countCards('h', { subtype: get.subtype(es[i]) })) return true;
                                }
                                return false;
                            }
                            if (player.hp > target.hp + (player.isHealthy() ? 0 : 1)) {
                                if (target.isHealthy()) {
                                    if (!player.needsToDiscard(1) || goon()) return 0.1;
                                    return 0;
                                }
                                return 1;
                            }
                            if (player.isHealthy()) {
                                if (!player.needsToDiscard(1) || goon()) return 0.1;
                                return 0;
                            }
                            return 1.5;
                        },
                    },
                },
            },
            minijieyi: {
                audio: 'rejieyin',
                inherit: 'minijieyin',
                async content(event, trigger, player) {
                    const { target, cards } = event, [card] = cards;
                    const hs = get.position(card) === 'h', canEquip = get.type(card) === 'equip' && target.canEquip(card);
                    let result;
                    if (!hs) result = { index: 1 };
                    else if (!canEquip) result = { index: 0 };
                    else result = await player.chooseControl().set('choiceList', [
                        `将${get.translation(card)}交给${get.translation(target)}`,
                        `将${get.translation(card)}置入${get.translation(target)}的装备区`,
                    ]).set('ai', () => 1).forResult();
                    if (result.index === 1) {
                        player.$give(cards, target);
                        await target.equip(cards[0]);
                    }
                    else await player.give(cards, target, true);
                    await player.recover();
                    await player.draw();
                    if (target.getHp() >= player.getHp() || target.isDamaged()) {
                        result = await player.chooseBool(`是否令${get.translation(target)}${target.getHp() >= player.getHp() ? '摸一张牌' : '回复1点体力'}`).set('choice', get.attitude(player, target) > 0).forResult();
                        if (result?.bool) await target[target.getHp() >= player.getHp() ? 'draw' : 'recover']();
                    }
                },
            },
            minimeibu: {
                audio: 'meibu',
                trigger: { global: 'phaseUseBegin' },
                filter(event, player) {
                    return event.player != player && event.player.isIn() && player.countCards('he');
                },
                direct: true,
                derivation: 'rezhixi',
                content() {
                    'step 0'
                    player.chooseToDiscard(get.prompt2('minimeibu', trigger.player), 'he').set('ai', function (card) {
                        if (_status.event.check) return 6 - get.value(card);
                        return 0;
                    }).set('check', lib.skill.new_meibu.checkx(trigger, player)).set('logSkill', ['minimeibu', trigger.player]);
                    'step 1'
                    if (result.bool) {
                        var target = trigger.player;
                        player.line(target, 'green');
                        player.addTempSkill('minimeibu_gain');
                        target.addTempSkill('rezhixi', 'phaseUseAfter');
                    }
                },
                ai: { expose: 0.2 },
                subSkill: {
                    gain: {
                        trigger: { global: 'loseAfter' },
                        forced: true,
                        charlotte: true,
                        popup: false,
                        onremove: true,
                        filter(event, player) {
                            return event.getParent(3).name == 'rezhixi' && get.position(event.cards[0]) == 'd';
                        },
                        content() {
                            player.gain(trigger.cards[0], 'gain2');
                        },
                    },
                },
            },
            miniyinbing: {
                group: 'miniyinbing_discard',
                audio: 'yinbing',
                trigger: { player: 'phaseDiscardBefore' },
                direct: true,
                filter(event, player) {
                    return player.countCards('he', { type: 'basic' }) < player.countCards('he');
                },
                content() {
                    'step 0'
                    player.chooseCard([1, player.countCards('he') - player.countCards('he', { type: 'basic' })], 'he', get.prompt('miniyinbing'), function (card) {
                        return get.type(card) != 'basic';
                    }).set('ai', function (card) {
                        return 6 - get.value(card);
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('miniyinbing');
                        player.addToExpansion(result.cards, player, 'give').gaintag.add('miniyinbing');
                    }
                },
                marktext: '兵',
                onremove(player, skill) {
                    var cards = player.getExpansions(skill);
                    if (cards.length) player.loseToDiscardpile(cards);
                },
                intro: {
                    content: 'expansion',
                    markcount: 'expansion',
                },
                ai: {
                    effect: {
                        target(card, player, target, current) {
                            if (card.name == 'sha' && current < 0) return 1.2;
                        },
                    },
                    threaten(player, target) {
                        if (target.getExpansions('miniyinbing').length) return 2;
                        return 1;
                    }
                },
                subSkill: {
                    discard: {
                        audio: 'yinbing',
                        trigger: { player: 'damageEnd' },
                        forced: true,
                        filter(event, player) {
                            return event.card && player.getExpansions('miniyinbing').length > 0 && event.card.name == 'sha';
                        },
                        content() {
                            'step 0'
                            player.chooseCardButton('移去一张引兵牌', player.getExpansions('miniyinbing'), true);
                            'step 1'
                            if (result.bool) {
                                player.loseToDiscardpile(result.links);
                                player.draw();
                            }
                        },
                    },
                },
            },
            minijuedi: {
                audio: 'juedi',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return player.getExpansions('miniyinbing').length > 0;
                },
                forced: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2(event.name), function (card, player, target) {
                        return player.hp >= target.hp;
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        var att = get.attitude(player, target);
                        if (att < 2) return att - 10;
                        var num = att / 10;
                        if (target == player) {
                            num += player.maxHp - player.countCards('h') + 0.5;
                        }
                        else {
                            num += _status.event.n2 * 2;
                            if (target.isDamaged()) {
                                if (target.hp == 1) {
                                    num += 3;
                                }
                                else if (target.hp == 2) {
                                    num += 2;
                                }
                                else {
                                    num += 0.5;
                                }
                            }
                        }
                        if (target.hasJudge('lebu')) {
                            num /= 2;
                        }
                        return num;
                    }, true).set('n2', player.getExpansions('miniyinbing').length);
                    'step 1'
                    if (result.bool) {
                        player.line(result.targets[0], 'green');
                        var cards = player.getExpansions('miniyinbing');
                        if (result.targets[0] == player) {
                            player.loseToDiscardpile(cards);
                            var num = player.maxHp - player.countCards('h') + (event.name == 'minijuedi' ? 1 : 0);
                            if (num > 0) player.draw(num);
                        }
                        else {
                            var target = result.targets[0];
                            target.recover();
                            target.gain(cards, player, 'give');
                            target.draw(cards.length);
                        }
                    }
                },
            },
            minihongyuan: {
                audio: 'hongyuan',
                trigger: { player: 'phaseDrawBegin2' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minihongyuan'), '令至多两名角色各摸一张牌', [1, 2]).set('ai', function (target) {
                        return Math.sqrt(5 - Math.min(4, target.countCards('h'))) * get.attitude(_status.event.player, target);
                    });
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        player.logSkill('minihongyuan', targets);
                        if (targets.length == 1) {
                            targets[0].draw();
                            event.finish();
                        }
                        else game.asyncDraw(targets);
                    }
                    else event.finish();
                    'step 2'
                    game.delayx();
                },
            },
            minizenhui: {
                audio: 'chanhui',
                usable: 1,
                trigger: { player: 'useCardToPlayer' },
                filter(event, player) {
                    if (_status.currentPhase != player) return false;
                    if (event.targets.length > 1) return false;
                    var card = event.card;
                    if (card.name == 'sha' || get.type(card) == 'trick') return true;
                    return false;
                },
                check(event, player) {
                    return get.attitude(player, event.target) < 0;
                },
                logTarget: 'target',
                content() {
                    'step 0'
                    trigger.target.chooseCard('he', '谮毁：交给' + get.translation(player) + '一张牌，或失去1点体力').set('ai', function (card) {
                        return 7 - get.value(card);
                    });
                    'step 1'
                    if (result.bool) player.gain(result.cards, trigger.target, 'giveAuto');
                    else trigger.target.loseHp();
                },
            },
            minijiaojin: {
                audio: 'jiaojin',
                trigger: { target: 'useCardToTargeted' },
                filter(event, player) {
                    return (event.card.name == 'sha' || get.type(event.card) == 'trick') && event.player != player;
                },
                direct: true,
                content() {
                    'step 0'
                    var next = player.chooseToDiscard('h', '骄矜：是否弃置一张手牌令' + get.translation(trigger.card) + '对你无效？');
                    next.set('ai', function (card) {
                        if (_status.event.goon2) {
                            return 3 + _status.event.val - get.value(card);
                        }
                        return 0;
                    });
                    next.set('val', get.value(trigger.cards.filterInD()));
                    next.set('goon2', get.effect(player, trigger.card, trigger.player, player) < 0)
                    next.logSkill = ['minijiaojin', trigger.player];
                    'step 1'
                    if (result.bool) trigger.excluded.push(player);
                },
            },
            minilihuo: {
                group: ['minilihuo_target', 'minilihuo_draw'],
                trigger: { player: 'useCard1' },
                filter(event, player) {
                    if (event.card.name == 'sha' && !event.card.nature) return true;
                    return false;
                },
                audio: 'lihuo',
                check(event, player) {
                    return player.hp > 2;
                },
                content() {
                    game.setNature(trigger.card, 'fire');
                    var next = game.createEvent('minilihuo_clear');
                    next.player = player;
                    next.card = trigger.card;
                    event.next.remove(next);
                    next.forceDie = true;
                    trigger.after.push(next);
                    next.setContent(function () {
                        var num = 0;
                        player.getHistory('sourceDamage', function (evt) {
                            if (evt.card == card) num += evt.num;
                        });
                        if (num > 1) player.loseHp();
                        delete card.nature;
                    });
                },
                subSkill: {
                    target: {
                        trigger: { player: 'useCard2' },
                        filter(event, player) {
                            if (event.card.name != 'sha' || get.nature(event.card) != 'fire') return false;
                            return game.hasPlayer(function (current) {
                                return !event.targets.includes(current) && player.canUse(event.card, current);
                            });
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseTarget(get.prompt('minilihuo'), '为' + get.translation(trigger.card) + '增加一个目标', function (card, player, target) {
                                return !_status.event.sourcex.includes(target) && player.canUse(_status.event.card, target);
                            }).set('sourcex', trigger.targets).set('card', trigger.card).set('ai', function (target) {
                                var player = _status.event.player;
                                return get.effect(target, _status.event.card, player, player);
                            });
                            'step 1'
                            if (result.bool) {
                                if (!event.isMine() && !_status.connectMode) game.delayx();
                                event.target = result.targets[0];
                            }
                            else event.finish();
                            'step 2'
                            player.logSkill('minilihuo', event.target);
                            trigger.targets.push(event.target);
                        },
                    },
                    draw: {
                        audio: 'lihuo',
                        trigger: { source: 'damageSource' },
                        filter(event, player) {
                            return event.card && event.card.name == 'sha' && get.nature(event.card) == 'fire';
                        },
                        forced: true,
                        locked: false,
                        usable: 1,
                        content() {
                            player.draw();
                        },
                    },
                },
            },
            minichunlao: {
                audio: 'chunlao',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return player.countCards('h') > 0 && (_status.connectMode || player.countCards('h', 'sha') > 0) && !player.getExpansions('minichunlao').length;
                },
                intro: {
                    content: 'expansion',
                    markcount: 'expansion',
                },
                onremove(player, skill) {
                    var cards = player.getExpansions(skill);
                    if (cards.length) player.loseToDiscardpile(cards);
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseCard([1, Math.max(1, player.countCards('h', 'sha'))], get.prompt('minichunlao'), '将任意张【杀】置于武将牌上作为“醇”', { name: 'sha' }).set('ai', function () {
                        return 1;
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minichunlao');
                        player.addToExpansion('gain2', result.cards).gaintag.add('minichunlao');
                    }
                },
                group: 'minichunlao2'
            },
            minichunlao2: {
                enable: 'chooseToUse',
                filter(event, player) {
                    return event.type == 'dying' && event.dying && event.dying.hp <= 0 && player.getExpansions('minichunlao').length > 0;
                },
                filterTarget(card, player, target) {
                    return target == _status.event.dying;
                },
                direct: true,
                delay: false,
                selectTarget: -1,
                content() {
                    'step 0'
                    player.chooseCardButton(get.translation('minichunlao'), player.getExpansions('minichunlao'), true);
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minichunlao');
                        event.type = 'dying';
                        player.loseToDiscardpile(result.links);
                        target.useCard({ name: 'jiu', isCard: true }, target);
                        var nature = get.color(result.links[0]);
                        if (nature == 'red') player.recover();
                        if (nature == 'black') player.draw(2);
                    }
                },
                ai: {
                    order: 6,
                    skillTagFilter(player) {
                        return player.getExpansions('minichunlao').length > 0;
                    },
                    save: true,
                    result: { target: 1 },
                },
            },
            minianxu: {
                audio: 'anxu',
                trigger: { player: ['phaseUseBegin', 'phaseUseEnd'] },
                direct: true,
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current != player && current.isMaxHandcard() && current.countCards('h');
                    });
                },
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minianxu'), function (card, player, target) {
                        return target.isMaxHandcard() && target.countCards('h') && player != target;
                    }, function (target) {
                        var att = get.attitude(_status.event.player, target);
                        if (target.hasSkill('tuntian')) return att / 10;
                        return -att;
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minianxu', target);
                        player.gainPlayerCard(target, 'h', true);
                    }
                    else event.finish();
                    'step 2'
                    if (get.suit(result.cards[0]) == 'spade') {
                        player.line(target);
                        target.draw();
                    }
                },
            },
            minixingwu: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h');
                },
                filterCard: true,
                filterTarget: lib.filter.notMe,
                check(card) {
                    return 8 - get.value(card);
                },
                usable: 1,
                contentBefore() {
                    _status.event.player = player;
                    _status.event.trigger('useXingWu');
                },
                content() {
                    'step 0'
                    player.turnOver();
                    if (target.countCards('e')) player.discardPlayerCard(target, 'e', true);
                    'step 1'
                    var num = 2;
                    if (target.sex == 'female') num = 1;
                    target.damage(num, 'nocard');
                },
                ai: {
                    damage: 2,
                    order: 9,
                    result: {
                        target(player, target) {
                            if (get.attitude(player, target) > 0) return 0;
                            return get.damageEffect(target, player);
                        },
                    },
                },
            },
            miniluoyan: {
                audio: 'ext:活动武将/audio/skill:1',
                derivation: ['miniretianxiang', 'olhongyan'],
                trigger: { player: 'minixingwuAfter' },
                forced: true,
                content() {
                    const skills = lib.skill.miniluoyan.derivation.slice();
                    player.changeSkills(skills, []).set('$handle', (player, skills) => {
                        player.addTempSkill(skills, { player: 'phaseUseBegin' });
                        for (const skill of skills) {
                            player.popup(skill);
                            game.log(player, '获得了技能', '【' + get.translation(skill) + '】');
                        }
                    });
                },
            },
            minihuimou: {
                audio: 'ext:活动武将/audio/skill:1',
                trigger: { player: ['useCard', 'respond', 'loseAfter'], global: 'loseAsyncAfter' },
                filter(event, player) {
                    if (!game.hasPlayer(function (current) {
                        return current.isTurnedOver();
                    })) return false;
                    if (event.name.indexOf('lose') != 0) return player != _status.currentPhase && get.suit(event.card, player) == 'heart';
                    if (event.type != 'discard' || event.getlx === false || get.translation(event.getParent(2).name) != '天香') return false;
                    return event.getl(player).cards2.filter(function (card) {
                        return get.suit(card, player) == 'heart';
                    }).length;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minihuimou'), '令一名背面朝上的角色翻至正面', function (card, player, target) {
                        return target.isTurnedOver();
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        return get.attitude(player, target);
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('minihuimou', target);
                        if (target.isTurnedOver()) target.turnOver();
                    }
                },
            },
            minianguo: {
                audio: 'anguo',
                inherit: 'xinanguo',
                filterTarget: true,
            },
            // 孙坚
            miniyinghun: {
                audio: 'yinghun',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return game.hasPlayer(current => current != player);
                },
                preHidden: true,
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), lib.filter.notMe).set('ai', target => {
                        const player = get.player(), att = get.attitude(player, target);
                        if (player.getDamagedHp() > 1) return -att;
                        return att;
                    }).setHiddenSkill(event.skill).forResult();
                },
                async content(event, trigger, player) {
                    const [target] = event.targets;
                    await target.draw();
                    const num = player.getDamagedHp();
                    if (num > 0) await target.chooseToDiscard(num, true, 'he', 'allowChooseAll');
                },
            },
            minireyinghun: {
                audio: 'yinghun',
                audioname: ['ol_sunjian', 'sunce'],
                audioname2: { Mbaby_re_sunyi: 'gzyinghun_re_sunyi1.mp3' },
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return game.hasPlayer(current => current != player);
                },
                preHidden: true,
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), lib.filter.notMe).set('ai', target => {
                        const player = get.player(), att = get.attitude(player, target);
                        if (att > 0) return 10 + att;
                        if (player.getDamagedHp() > 1) return -att;
                        return att;
                    }).setHiddenSkill(event.skill).forResult();
                },
                async content(event, trigger, player) {
                    const [target] = event.targets;
                    const num = player.getDamagedHp();
                    if (num == 0) await target.draw();
                    else {
                        const result = await player.chooseControl([`摸${get.cnNumber(num)}张牌`, `摸一弃${get.cnNumber(num, true)}`]).set('prompt', `请选择一项令${get.translation(target)}执行`).set('ai', () => {
                            const { player, target } = get.event();
                            const num = (get.attitude(player, target) > 0 ? 0 : 1);
                            return (player.isHealthy() ? 1 - num : num);
                        }).set('target', target).forResult();
                        if (result?.index === 0 && num > 0) await target.draw(num);
                        if (result?.index === 1) {
                            await target.draw();
                            if (num > 0) await target.chooseToDiscard(num, true, 'he', 'allowChooseAll');
                        }
                    }
                },
            },
            miniwulie: {
                audio: 'wulie',
                trigger: { player: 'phaseBegin' },
                mark: true,
                limited: true,
                filter(event, player) {
                    return player.hp > 0;
                },
                direct: true,
                skillAnimation: true,
                animationColor: 'wood',
                content() {
                    'step 0'
                    var map = {}, list = [];
                    for (var i = 1; i <= player.hp; i++) {
                        var cn = get.cnNumber(i, true);
                        map[cn] = i;
                        list.push(cn);
                    }
                    list.push('cancel2');
                    event.map = map;
                    player.chooseControl(list).set('prompt', get.prompt2('miniwulie')).set('ai', function () {
                        var player = _status.event.player;
                        if (player.hasUnknown() || !_status.event.controls.includes(get.cnNumber(_status.event.goon, true))) return 'cancel2';
                        return get.cnNumber(_status.event.goon, true);
                    }).set('goon', player.hp - 1 + Math.sign(player.countCards('hs', { name: ['tao', 'jiu'] })));
                    'step 1'
                    if (result.control != 'cancel2') {
                        var num = event.map[result.control] || 1;
                        player.logSkill('miniwulie');
                        player.awakenSkill('miniwulie');
                        player.loseHp(num);
                        player.addSkill('miniwulie2');
                        player.addMark('miniwulie2', num);
                        player.chooseTarget([1, num], '是否令至多' + get.cnNumber(num) + '名其他角色各获得1枚「烈」标记？', lib.filter.notMe).set('ai', function (target) {
                            var player = _status.event.player;
                            return get.attitude(player, target);
                        });
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        player.line(targets);
                        for (var i of targets) {
                            i.addSkill('miniwulie2');
                            i.addMark('miniwulie2', 1);
                        }
                    }
                },
            },
            miniwulie2: {
                marktext: '烈',
                intro: { name2: '烈', content: 'mark' },
                trigger: { player: 'damageBegin3' },
                nopop: true,
                content() {
                    trigger.cancel();
                    player.removeMark('miniwulie2', 1);
                    if (!player.storage.miniwulie2) player.removeSkill('miniwulie2');
                },
            },
            minikuizhu: {
                audio: 'nzry_kuizhu',
                trigger: { player: 'phaseDiscardEnd' },
                filter(event, player) {
                    var cards = [];
                    player.getHistory('lose', function (evt) {
                        if (evt.type == 'discard' && evt.getParent('phaseDiscard') == event) cards.addArray(evt.cards2);
                    });
                    return cards.length;
                },
                direct: true,
                content() {
                    'step 0'
                    var cards = [];
                    player.getHistory('lose', function (evt) {
                        if (evt.type == 'discard' && evt.getParent('phaseDiscard') == trigger) cards.addArray(evt.cards2);
                    });
                    event.num = cards.length;
                    event.str1 = '令至多' + event.num + '名角色摸一张牌';
                    event.str2 = '对任意名体力值之和不大于' + event.num + '的角色造成一点伤害';
                    player.chooseControl('cancel2').set('ai', function () {
                        if (game.countPlayer(function (current) { return get.attitude(player, current) < 0 && current.hp <= event.num }) > 0) return 1;
                        return 0;
                    }).set('choiceList', [event.str1, event.str2]).set('prompt', get.prompt2('minikuizhu'));
                    'step 1'
                    if (result.control == 'cancel2') event.finish();
                    event.control = [event.str1, event.str2][result.index];
                    'step 2'
                    var num = event.num, str = event.control;
                    player.chooseTarget('请选择〖溃诛〗的目标', str, [0, Infinity], function (card, player, target) {
                        var num = _status.event.num;
                        switch (event.control) {
                            case event.str1:
                                return ui.selected.targets.length < num;
                                break;
                            case event.str2:
                                if (!ui.selected.targets.length) return target.hp <= num;
                                var summer = 0;
                                for (var i of ui.selected.targets) summer += i.hp;
                                return summer + target.hp <= num;
                                break;
                        }
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        switch (event.control) {
                            case event.str1:
                                return get.attitude(player, target);
                                break;
                            case event.str2:
                                return get.damageEffect(target, player, player);
                                break;
                        }
                    }).set('num', num).set('complexSelect', true).set('complexTarget', true);
                    'step 3'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        player.logSkill('minikuizhu', targets);
                        if (event.control == event.str1) game.asyncDraw(targets);
                        else for (var target of targets) target.damage();
                    }
                },
            },
            minichezheng: {
                audio: 'nzry_zhizheng',
                mod: {
                    playerEnabled(card, player, target) {
                        if (target != player && card.name == 'sha' && player.isPhaseUsing() && !target.inRange(player)) return false;
                    },
                },
                trigger: { player: 'phaseUseEnd' },
                forced: true,
                content() {
                    var num = game.countPlayer(function (current) {
                        if (current == player) return false;
                        return !current.inRange(player);
                    });
                    player.draw(Math.max(2, num));
                },
            },
            minilijun: {
                audio: 'nzry_lijun1',
                trigger: { global: 'useCardAfter' },
                filter(event, player) {
                    if (event.card.name != 'sha' || event.player.group != 'wu') return false;
                    if (!event.player.isPhaseUsing() || event.player == player) return false;
                    if (player.hasSkill('minilijun_used')) return false;
                    return true;
                },
                zhuSkill: true,
                forced: true,
                locked: false,
                content() {
                    'step 0'
                    player.addTempSkill('minilijun_used', 'phaseUseAfter');
                    player.draw();
                    player.chooseBool().set('prompt', '立军：是否令' + get.translation(trigger.player) + '摸一张牌？').set('choice', get.attitude(player, trigger.player) > 0);
                    'step 1'
                    if (result.bool) {
                        player.line(trigger.player);
                        trigger.player.draw();
                    }
                },
                subSkill: { used: { charlotte: true } },
            },
            miniguzheng: {
                audio: 'guzheng',
                trigger: { global: 'phaseDiscardAfter' },
                filter(event, player) {
                    if (event.player != player && event.player.isIn()) {
                        return event.player.getHistory('lose', function (evt) {
                            return evt.type == 'discard' && evt.getParent('phaseDiscard') == event && evt.hs.filterInD('d').length > 0;
                        }).length > 0;
                    }
                    return false;
                },
                checkx(event, player, cards, cards2) {
                    if (cards.length > 2 || get.attitude(player, event.player) > 0) return true;
                    for (var i = 0; i < cards2.length; i++) {
                        if (get.value(cards2[i], event.player, 'raw') < 0) return true;
                    }
                    return false;
                },
                direct: true,
                preHidden: true,
                content() {
                    'step 0'
                    var cards = [];
                    var cards2 = [];
                    game.getGlobalHistory('cardMove', function (evt) {
                        if (evt.name == 'cardsDiscard' && evt.getParent('phaseDiscard') == trigger) cards.addArray(evt.cards.filterInD('d'));
                    });
                    game.countPlayer2(function (current) {
                        current.getHistory('lose', function (evt) {
                            if (evt.type != 'discard' || evt.getParent('phaseDiscard') != trigger) return;
                            cards.addArray(evt.cards.filterInD('d'));
                            if (current == trigger.player) cards2.addArray(evt.hs.filterInD('d'));
                        })
                    });
                    event.cards = cards;
                    var check = lib.skill.miniguzheng.checkx(trigger, player, cards, cards2);
                    player.chooseCardButton(cards, '固政：选择令' + get.translation(trigger.player) + '收回的牌').set('ai', function (button) {
                        if (_status.event.check) {
                            return 20 - get.value(button.link, _status.event.getTrigger().player);
                        }
                        return 0;
                    }).set('check', check).set('cards', cards2).set('filterButton', function (button) {
                        return _status.event.cards.includes(button.link);
                    }).setHiddenSkill(event.name);
                    'step 1'
                    if (result.bool) {
                        game.delay(0.5);
                        player.logSkill('miniguzheng', trigger.player);
                        trigger.player.gain(result.links[0]);
                        trigger.player.$gain2(result.links[0]);
                        game.log(trigger.player, '收回了', result.links[0]);
                        event.cards.remove(result.links[0]);
                        if (event.cards.length) {
                            player.gain(event.cards);
                            player.$gain2(event.cards);
                            game.log(player, '收回了', event.cards);
                        }
                        else player.draw();
                        game.delay();
                    }
                },
                ai: { expose: 0.2 },
            },
            miniliangyin: {
                group: 'miniliangyin_discard',
                audio: 'liangyin',
                trigger: { global: ['loseAfter', 'addToExpansionAfter', 'cardsGotoSpecialAfter', 'loseAsyncAfter'] },
                filter(event, player, name) {
                    if (event.name == 'lose' || event.name == 'loseAsync') return event.getlx !== false && event.toStorage == true;
                    if (event.name == 'cardGotoSpecial') return !event.notrigger;
                    return true;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('miniliangyin'), '令一名角色摸一张牌').set('ai', function (target) {
                        var player = _status.event.player;
                        return get.attitude(player, target);
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('miniliangyin', result.targets);
                        result.targets[0].draw();
                    }
                },
                subSkill: {
                    discard: {
                        trigger: { global: ['gainAfter', 'loseAfter'] },
                        filter(event, player) {
                            return event.fromStorage == true || game.hasPlayer2(function (current) {
                                var evt = event.getl(current);
                                return evt?.xs?.length > 0;
                            });
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseTarget(get.prompt('miniliangyin'), '令一名角色弃置一张牌').set('ai', function (target) {
                                var player = _status.event.player;
                                return get.effect(target, { name: 'guohe_copy2' }, player, player);
                            });
                            'step 1'
                            if (result.bool) {
                                player.logSkill('miniliangyin', result.targets);
                                result.targets[0].chooseToDiscard('he', 1, true);
                            }
                        },
                    },
                },
            },
            miniaocai: {
                audio: 'aocai',
                enable: ['chooseToUse', 'chooseToRespond'],
                hiddenCard(player, name) {
                    if (player != _status.currentPhase && get.type(name) == 'basic' && lib.inpile.includes(name)) return true;
                },
                filter(event, player) {
                    if (event.responded || player == _status.currentPhase || event.miniaocai) return false;
                    for (var i of lib.inpile) {
                        if (get.type(i) == 'basic' && event.filterCard(get.autoViewAs({ name: i }, 'unsure'), player, event)) return true;
                    }
                    return false;
                },
                delay: false,
                content() {
                    'step 0'
                    var evt = event.getParent(2), aozhan = player.hasSkill('aozhan');
                    evt.set('miniaocai', true);
                    var cards = get.cards(player.countCards('h') == 0 ? 4 : 3);
                    for (var i = cards.length - 1; i >= 0; i--) {
                        ui.cardPile.insertBefore(cards[i].fix(), ui.cardPile.firstChild);
                    }
                    player.chooseButton(['傲才：选择要' + (evt.name == 'chooseToUse' ? '使用' : '打出') + '的牌', cards]).set('filterButton', function (button) {
                        return _status.event.cards.includes(button.link);
                    }).set('cards', cards.filter(function (card) {
                        if (aozhan && card.name == 'tao') return false;
                        return evt.filterCard(card, evt.player, evt);
                    })).set('ai', function (button) {
                        var evt = _status.event.getParent(3);
                        if (evt?.ai) {
                            var tmp = _status.event;
                            _status.event = evt;
                            var result = (evt.ai || event.ai1)(button.link, _status.event.player, evt);
                            _status.event = tmp;
                            return result;
                        }
                        return 1;
                    });
                    'step 1'
                    var evt = event.getParent(2);
                    if (result.bool && result.links && result.links.length) {
                        var name = result.links[0].name;
                        if (evt.name == 'chooseToUse') {
                            game.broadcastAll(function (result, name) {
                                lib.skill.aocai_backup.viewAs = { name: name, cards: [result], isCard: true };
                                lib.skill.aocai_backup.prompt = '请选择' + get.translation(result) + '的目标';
                            }, result.links[0], name);
                            evt.set('_backupevent', 'aocai_backup');
                            evt.backup('aocai_backup');
                        }
                        else {
                            delete evt.result.skill;
                            delete evt.result.used;
                            evt.result.card = get.autoViewAs(result.links[0]);
                            evt.result.cards = [result.links[0]];
                            evt.redo();
                            return;
                        }
                    }
                    evt.goto(0);
                },
                ai: {
                    effect: {
                        target(card, player, target, effect) {
                            if (get.tag(card, 'respondShan')) return 0.7;
                            if (get.tag(card, 'respondSha')) return 0.7;
                        },
                    },
                    order: 11,
                    respondShan: true,
                    respondSha: true,
                    result: {
                        player(player) {
                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                            return 1;
                        },
                    },
                },
            },
            miniduwu: {
                audio: 'duwu',
                enable: 'phaseUse',
                filter(event, player) {
                    return !player.hasSkill('miniduwu2') && game.hasPlayer(function (current) {
                        return current.hp > 0 && current.hp <= player.countCards('he') && player.inRange(current);
                    });
                },
                filterCard() {
                    return !ui.selected.targets.length;
                },
                position: 'he',
                selectCard: [1, Infinity],
                complexSelect: true,
                complexCard: true,
                filterTarget(card, player, target) {
                    return target != player && target.hp > 0 && player.inRange(target) && ui.selected.cards.length == target.hp;
                },
                check(card) {
                    var player = _status.event.player;
                    if (game.hasPlayer(function (current) {
                        return current != player && current.hp > 0 && player.inRange(current) && ui.selected.cards.length == current.hp && get.damageEffect(current, player, player) > 0;
                    })) return 0;
                    switch (ui.selected.cards.length) {
                        case 0: return 8 - get.value(card);
                        case 1: return 6 - get.value(card);
                        case 2: return 3 - get.value(card);
                        default: return 0;
                    }
                },
                content() {
                    player.addTempSkill('miniduwu3');
                    target.damage('nocard');
                },
                ai: {
                    expose: 0.3,
                    damage: true,
                    order: 2,
                    result: {
                        target(player, target) {
                            return get.damageEffect(target, player);
                        },
                    },
                },
            },
            miniduwu2: { charlotte: true },
            miniduwu3: {
                trigger: { global: 'dyingAfter' },
                charlotte: true,
                filter(event, player) {
                    return event.player.isIn() && event.reason && event.reason.getParent().name == 'miniduwu';
                },
                forced: true,
                popup: false,
                content() {
                    player.draw();
                    player.addTempSkill('miniduwu2');
                },
            },
            miniwengua: {
                global: 'miniwengua2',
                audio: 'wengua',
            },
            miniwengua2: {
                audio: 'wengua',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he') && game.hasPlayer(function (current) {
                        return current.hasSkill('miniwengua') && !current.hasSkill('miniwengua3');
                    });
                },
                prompt: () => lib.translate.miniwengua_info,
                filterTarget(card, player, target) {
                    return target.hasSkill('miniwengua') && !target.hasSkill('miniwengua3');
                },
                selectTarget() {
                    if (game.countPlayer(function (current) {
                        return current.hasSkill('miniwengua') && !current.hasSkill('miniwengua3');
                    }) == 1) return -1;
                    return 1;
                },
                filterCard: true,
                selectCard: [0, 1],
                check(card) {
                    var list = game.filterPlayer(function (current) {
                        return current.hasSkill('miniwengua') && !current.hasSkill('miniwengua3');
                    });
                    list.sort(function (a, b) {
                        var p = _status.event.player;
                        return get.attitude(p, b) - get.attitude(p, a);
                    });
                    if (get.type2(card) == 'trick' && (list[0].isDamaged() || list[0].maxHp < 5)) return 10;
                    if (card.name == 'sha') return 5;
                    return 8 - get.value(card);
                },
                filterOk() {
                    return ui.selected.targets.length && ui.selected.cards.length;
                },
                direct: true,
                delay: false,
                discard: false,
                lose: false,
                position: 'he',
                content() {
                    'step 0'
                    target.logSkill('miniwengua', player);
                    target.addTempSkill('miniwengua3', 'phaseUseAfter');
                    if (target != player) player.give(cards, target);
                    player.showCards(cards, get.translation(player) + '发动了【问卦】');
                    'step 1'
                    var card = cards[0];
                    if (get.type2(card) == 'trick') {
                        if (target.maxHp < 5) target.gainMaxHp();
                        target.recover();
                    }
                    'step 2'
                    var choiceList = [
                        '将' + get.translation(cards[0]) + '置于牌堆顶',
                        '将' + get.translation(cards[0]) + '置于牌堆底'
                    ];
                    if (target != player) choiceList.push('将' + get.translation(cards[0]) + '留给自己');
                    if (target.getCards('he').includes(cards[0])) {
                        target.chooseControl().set('choiceList', choiceList).set('ai', () => target != player && get.attitude(target, player) < 0 ? 2 : 1);
                    }
                    else event.finish();
                    'step 3'
                    event.index = result.index;
                    if (event.index == 0 || event.index == 1) {
                        var next = event.target.lose(cards[0], ui.cardPile);
                        if (event.index == 0) next.insert_card = true;
                        target.$throw(cards, 1000);
                    }
                    else event.finish();
                    'step 4'
                    game.delayx();
                    'step 5'
                    if (event.index == 1) {
                        game.log(target, '将', cards, '置于', '#y牌堆底');
                        if (player == target) player.draw('nodelay');
                        else game.asyncDraw([player, target], null, null);
                    }
                    else {
                        game.log(target, '将', cards, '置于', '#g牌堆顶');
                        if (player == target) player.draw('nodelay', 'bottom');
                        else game.asyncDraw([player, target], null, null, true);
                    }
                },
                ai: {
                    order: 9,
                    result: { target: 1 },
                },
            },
            miniwengua3: { charlotte: true },
            minifuzhu: {
                audio: 'fuzhu',
                inherit: 'fuzhu',
                filter(event, player) {
                    return event.player != player && ui.cardPile.childElementCount <= player.maxHp * 10;
                },
                onWash() {
                    _status.event.getParent('minifuzhu').washed = false;
                    return 'remove';
                },
                content() {
                    'step 0'
                    event.washed = false;
                    lib.onwash.push(lib.skill.minifuzhu.onWash);
                    event.total = game.countPlayer2();
                    'step 1'
                    event.total--;
                    var card = get.cardPile2(function (card) {
                        return card.name == 'sha' && player.canUse(card, trigger.player, false);
                    });
                    if (card) {
                        card.remove();
                        game.updateRoundNumber();
                        player.useCard(card, trigger.player, false);
                    }
                    'step 2'
                    if (event.total > 0 && !event.washed && ui.cardPile.childElementCount <= player.maxHp * 10 && trigger.player.isIn()) event.goto(1);
                    else lib.onwash.remove(lib.skill.minifuzhu.onWash);
                    'step 3'
                    var cards = get.cards(ui.cardPile.childElementCount + 1);
                    for (var i = 0; i < cards.length; i++) {
                        ui.cardPile.insertBefore(cards[i], ui.cardPile.childNodes[get.rand(ui.cardPile.childElementCount)]);
                    }
                    game.updateRoundNumber();
                },
            },
            minihongde: {
                group: 'minihongde_hongde',
                audio: 'hongde',
                trigger: {
                    player: 'loseAfter',
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                },
                frequent: true,
                filter(event, player) {
                    if (event.name == 'gain' && event.player == player) return false;
                    var evt = event.getl(player);
                    return evt?.cards2?.length > 0;
                },
                usable: 2,
                frequent: true,
                content() {
                    player.draw();
                },
                subSkill: {
                    hongde: {
                        trigger: { player: 'gainAfter' },
                        filter(event, player) {
                            return event.cards?.length > 1;
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseTarget(get.prompt('minihongde'), '令一名其他角色摸一张牌', lib.filter.notMe).set('ai', function (target) {
                                var player = _status.event.player;
                                return get.attitude(player, target);
                            });
                            'step 1'
                            if (result.bool) {
                                var target = result.targets[0]
                                player.logSkill('minihongde', target);
                                target.draw();
                            }
                        },
                    },
                },
            },
            minidingpan: {
                audio: 'dingpan',
                inherit: 'dingpan',
                filter(event, player) {
                    return (player.getStat().skill.minidingpan || 0) < game.countGroup();
                },
            },
            minijueyan: {
                derivation: 'minijizhi',
                audio: 'drlt_jueyan',
                enable: 'phaseUse',
                filter(event, player) {
                    return Array.from({ length: 4 }).map((_, i) => i + 1).some(i => player.hasEnabledSlot(i));
                },
                usable: 1,
                content() {
                    'step 0'
                    var list = [];
                    for (var i = 1; i <= 4; i++) {
                        if (player.hasEnabledSlot(i)) list.push('equip' + i);
                    }
                    if (list.includes('equip3') && list.includes('equip4')) list.push('equip3_4');
                    list.remove('equip3');
                    list.remove('equip4');
                    player.chooseControl(list).set('ai', function () {
                        var player = _status.event.player;
                        if (list.includes('equip2')) return 'equip2';
                        if (list.includes('equip1') && (player.countCards('h', function (card) {
                            return get.name(card, player) == 'sha' && player.hasUseTarget(card);
                        }) - player.getCardUsable('sha')) > 1) return 'equip1';
                        if (list.includes('equip3_4') && player.countCards('h', function (card) {
                            return get.type2(card, player) == 'trick' && player.hasUseTarget(card, false);
                        }) > 1) return 'equip3_4';
                    }).set('prompt', '决堰：请选择你要废除的装备栏');
                    'step 1'
                    if (result.control == 'equip3_4') {
                        player.disableEquip(3, 4);
                        player.recover();
                        player.addTempSkills('minijizhi');
                    }
                    else player.disableEquip(result.control);
                    if (result.control == 'equip2') player.draw(3);
                    player.addTempSkill(['drlt_jueyan1', 'drlt_jueyan3', 'drlt_jueyan2'][['equip1', 'equip2', 'equip3_4'].indexOf(result.control)]);
                },
                ai: {
                    order: 13,
                    result: {
                        player(player) {
                            if (!player.isDisabled('equip2')) return 1;
                            if (!player.isDisabled('equip1') && (player.countCards('h', function (card) {
                                return get.name(card, player) == 'sha' && player.hasValueTarget(card);
                            }) - player.getCardUsable('sha')) > 1) return 1;
                            if ((player.hasEnabledSlot(3) && player.hasEnabledSlot(4)) && player.countCards('h', function (card) {
                                return get.type2(card, player) == 'trick' && player.hasUseTarget(card, false);
                            }) > 1) return 1;
                            return -1;
                        },
                    },
                },
            },
            minihuairou: {
                audio: 'drlt_huairou',
                enable: 'phaseUse',
                filter(event, player) {
                    var list = [], bool = false;
                    for (var i = 1; i <= 5; i++) {
                        if (!player.hasEnabledSlot(i)) list.push('equip' + i);
                    }
                    for (var name of lib.inpile) {
                        if (get.type(name) != 'basic' && get.type2(name) != 'trick') continue;
                        var storage = player.getStorage('minihuairou_used');
                        if (!storage.includes(name)) {
                            bool = true;
                            break;
                        }
                    }
                    return bool && player.countCards('he', function (card) {
                        return list.includes(get.subtype(card));
                    });
                },
                filterCard(card, player) {
                    var list = [];
                    for (var i = 1; i <= 5; i++) {
                        if (!player.hasEnabledSlot(i)) list.push('equip' + i);
                    }
                    return get.type(card) == 'equip' && list.includes(get.subtype(card));
                },
                check(card) {
                    var player = _status.event.player;
                    if (player.isDisabled(get.subtype(card))) return 5;
                    return 6 - get.value(card);
                },
                position: 'he',
                discard: false,
                visible: true,
                loseTo: 'discardPile',
                delay: 0.5,
                prepare(cards, player) {
                    player.addTempSkill('minihuairou_used');
                    player.$throw(cards, 1000);
                    game.log(player, '将', cards, '置入了弃牌堆');
                },
                content() {
                    'step 0'
                    var list = [];
                    for (var name of lib.inpile) {
                        if (get.type(name) != 'basic' && get.type2(name) != 'trick') continue;
                        var storage = player.getStorage('minihuairou_used');
                        if (!storage.includes(name)) {
                            list.push([get.translation(get.type2({ name: name })), '', name]);
                            if (name == 'sha') {
                                for (var nature of lib.inpile_nature) list.push(['基本', '', name, nature]);
                            }
                        }
                    }
                    player.chooseButton(['怀柔：选择获得一种基本牌或锦囊牌', [list, 'vcard']], true);
                    'step 1'
                    player.markAuto('minihuairou_used', [result.links[0][2]]);
                    var card = get.cardPile(function (card) {
                        return card.name == result.links[0][2] && (get.nature(card) == result.links[0][3] || !result.links[0][3]);
                    });
                    if (card) player.gain(card, 'gain2');
                    else {
                        player.popup('杯具');
                        game.log('但是牌堆中已经没有', '#y' + get.translation(result.links[0][2]), '了！')
                    }
                },
                ai: {
                    order: 10,
                    result: { player: 1 },
                },
                subSkill: { used: { charlotte: true, onremove: true } },
            },
            miniyanxiao: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he', { suit: 'diamond' }) && game.hasPlayer(function (target) {
                        return target.canAddJudge({ name: 'miniyanxiao_card' });
                    });
                },
                filterTarget(card, player, target) {
                    return target.canAddJudge({ name: 'miniyanxiao_card' });
                },
                filterCard: { suit: 'diamond' },
                check(card) {
                    return 7 - get.value(card);
                },
                position: 'he',
                discard: false,
                lose: false,
                delay: false,
                prepare: 'give',
                content() {
                    'step 0'
                    game.addGlobalSkill('miniyanxiao_global');
                    target.addJudge({ name: 'miniyanxiao_card' }, cards);
                    'step 1'
                    game.delayx();
                },
                ai: {
                    order: 8,
                    result: {
                        target(player, target) {
                            if (target.countCards('j', function (card) {
                                return get.effect(target, {
                                    name: card.viewAs || card.name,
                                    cards: [card],
                                }, target, target) < 0;
                            })) return 3;
                            return 1;
                        },
                    },
                },
                subSkill: {
                    global: {
                        audio: 'yanxiao',
                        forceaudio: true,
                        trigger: { player: 'phaseJudgeBegin' },
                        filter(event, player) {
                            return player.countCards('j') && player.hasJudge('miniyanxiao_card');
                        },
                        forced: true,
                        content() {
                            'step 0'
                            player.gain(player.getCards('j'), 'gain2');
                            player.judge();
                            'step 1'
                            if (result.color == 'red') player.draw();
                            else player.addTempSkill('miniyanxiao_sha');
                        },
                        ai: {
                            effect: {
                                target(card, player, target) {
                                    if (get.type(card) == 'delay' && target.hasJudge('miniyanxiao_card')) return [0, 0, 0, 0.1];
                                },
                            },
                        },
                    },
                    sha: {
                        charlotte: true,
                        mark: true,
                        marktext: '+1',
                        intro: { content: '出【杀】次数+1' },
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name == 'sha') return num + 1;
                            },
                        },
                    },
                },
            },
            minianxian: {
                audio: 'ext:活动武将/audio/skill:1',
                group: 'minianxian_target',
                trigger: { player: 'useCardToPlayer' },
                filter(event, player) {
                    return event.card.name == 'sha' && event.target.countCards('h') && !event.card.minianxian;
                },
                check(event, player) {
                    return get.attitude(player, event.target) <= 0;
                },
                prompt2(event, player) {
                    return '令' + get.translation(event.target) + '弃置一张手牌';
                },
                logTarget: 'target',
                content() {
                    trigger.target.chooseToDiscard('h', true);
                },
                subSkill: {
                    target: {
                        trigger: { target: 'useCardToTarget' },
                        filter(event, player) {
                            return event.card.name == 'sha' && player.countCards('h');
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseToDiscard(get.prompt('minianxian'), '弃置一张手牌令' + get.translation(trigger.card) + '对你无效，然后' + get.translation(trigger.player) + '摸一张牌' + (player.canUse({ name: 'sha', isCard: true }, trigger.player, false) ? '，若你弃置了方片花色的牌，则你视为对' + get.translation(trigger.player) + '使用一张不触发〖安娴〗的【杀】' : '')).set('ai', function (card) {
                                var player = _status.event.player;
                                var trigger = _status.event.getTrigger();
                                if (get.suit(card) == 'diamond' && player.canUse({ name: 'sha', isCard: true }, trigger.player, false)) return get.attitude(player, trigger.player) > 0 ? 0 : 9 - get.value(card);
                                return 6 - get.value(card);
                            }).logSkill = ['minianxian', trigger.player];
                            'step 1'
                            if (result.bool) {
                                trigger.player.draw();
                                trigger.getParent().excluded.push(player);
                                if (get.suit(result.cards[0], player) == 'diamond') {
                                    var card = { name: 'sha', isCard: true };
                                    if (player.canUse(card, trigger.player, false)) player.useCard(card, trigger.player).card.minianxian = true;
                                }
                            }
                        },
                    },
                },
            },
            minicanshi: {
                audio: 'canshi',
                trigger: { player: 'phaseDrawBegin2' },
                check(event, player) {
                    if (player.skipList.includes('phaseUse') || !player.countCards('h', function (card) {
                        return get.type2(card) == 'trick' && player.hasUseTarget(card);
                    })) return true;
                    var num = game.countPlayer(function (current) {
                        if (player.hasSkill('guiming') && current.group == 'wu') return true;
                        return current.isDamaged();
                    });
                    return num > 1;
                },
                prompt(event, player) {
                    var num = game.countPlayer(function (current) {
                        if (player.hasSkill('guiming') && current.group == 'wu' && current != player) return true;
                        return current.isDamaged();
                    });
                    return get.prompt('minicanshi') + '（可多摸' + get.cnNumber(num) + '张牌，且本回合使用【杀】须弃置一张牌）';
                },
                filter(event, player) {
                    return !event.numFixed && game.hasPlayer(function (current) {
                        if (player.hasSkill('guiming') && current.group == 'wu' && current != player) return true;
                        return current.isDamaged();
                    });
                },
                content() {
                    var num = game.countPlayer(function (current) {
                        if (player.hasSkill('guiming') && current.group == 'wu' && current != player) return true;
                        return current.isDamaged();
                    });
                    if (num > 0) trigger.num += num;
                    player.addTempSkill('minicanshi2');
                },
            },
            minicanshi2: {
                trigger: { player: 'useCard' },
                filter(event, player) {
                    if (!player.countCards('he')) return false;
                    return event.card.name == 'sha';
                },
                forced: true,
                autodelay: true,
                content() {
                    player.chooseToDiscard(true, 'he');
                },
            },
            minichouhai: {
                audio: 'chouhai',
                trigger: { player: 'damageBegin3' },
                filter(event, player) {
                    return event.card && event.card.name == 'sha' && !player.countCards('he');
                },
                forced: true,
                content() {
                    trigger.num++;
                },
                ai: {
                    effect: {
                        target(card, player, target, current) {
                            if (card.name == 'sha' && !target.countCards('he')) return [1, -2];
                        },
                    },
                },
            },
            miniguolun: {
                audio: 'xinfu_guolun',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h');
                },
                filterTarget(card, player, target) {
                    return target != player && target.countCards('h');
                },
                usable: 1,
                content() {
                    'step 0'
                    player.choosePlayerCard(target, true, 'h');
                    'step 1'
                    event.cardt = result.cards[0];
                    target.showCards(event.cardt);
                    player.chooseCard('he').set('ai', function (card) {
                        var event = _status.event.getParent(), player = event.player;
                        var numt = get.number(event.cardt);
                        var att = get.attitude(player, target);
                        var value = get.value(event.cardt);
                        var num = get.number(card);
                        if (num < numt || att > 2) return value + 6 - get.value(card);
                        else if (num == numt) return value - get.value(card);
                        return -1;
                    });
                    'step 2'
                    if (!result.bool) event.finish();
                    else {
                        player.showCards(result.cards);
                        event.cardp = result.cards[0];
                    }
                    'step 3'
                    player.swapHandcards(target, [event.cardp], [event.cardt]);
                    'step 4'
                    var nump = get.number(event.cardp, player);
                    var numt = get.number(event.cardt, target);
                    if (nump < numt) {
                        player.draw(2);
                    }
                    else if (nump > numt) {
                        target.draw();
                        player.recover();
                    }
                },
                ai: {
                    order: 8,
                    result: {
                        player(player, target) {
                            if (get.attitude(player, target) > 0) return 1.5;
                            return 0.5;
                        },
                    },
                },
            },
            minisongsang: {
                audio: 'xinfu_songsang',
                inherit: 'gongao',
            },
            minizhente: {
                audio: 'zhente',
                inherit: 'zhente',
                filter(event, player) {
                    var color = get.color(event.card);
                    if (player == event.player || event.player.isDead() || color == 'none') return false;
                    var type = get.type(event.card);
                    return type == 'basic' || type == 'trick';
                },
                usable: Infinity,
            },
            minizhiwei: {
                audio: 'zhiwei',
                trigger: { global: 'phaseBefore', player: ['enterGame', 'phaseZhunbeiBegin'] },
                filter(event, player, name) {
                    if (game.countPlayer() < 2) return false;
                    return (name != 'phaseBefore' || game.phaseNumber == 0) && !player.hasSkill('minizhiwei2');
                },
                forced: true,
                content() {
                    'step 0'
                    player.chooseTarget('请选择【至微】的目标', '选择一名其他角色。该角色造成伤害后，你摸一张牌，该角色受到伤害后，你可以交给其一张牌。你弃牌阶段弃置的牌可以交给该角色。', true, lib.filter.notMe).set('ai', function (target) {
                        var att = get.attitude(_status.event.player, target);
                        if (att > 0) return 1 + att;
                        return Math.random();
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line('minizhiwei', target);
                        player.storage.minizhiwei2 = target;
                        player.addSkill('minizhiwei2');
                    }
                },
            },
            minizhiwei2: {
                group: ['minizhiwei2_draw', 'minizhiwei2_discard', 'minizhiwei2_gain', 'minizhiwei2_clear'],
                charlotte: true,
                onremove: true,
                mark: 'character',
                intro: { content: '$造成伤害后你摸一张牌；$受到伤害后你可以交给其一张牌；你于弃牌阶段弃置牌后可以交给$' },
                subSkill: {
                    draw: {
                        audio: 'zhiwei',
                        trigger: { global: 'damageSource' },
                        filter(event, player) {
                            return event.source == player.storage.minizhiwei2;
                        },
                        forced: true,
                        logTarget: 'source',
                        content() {
                            player.draw();
                        },
                    },
                    discard: {
                        trigger: { global: 'damageEnd' },
                        filter(event, player) {
                            return event.player == player.storage.minizhiwei2 && player.countCards('h');
                        },
                        direct: true,
                        content() {
                            'step 0'
                            var target = player.storage.minizhiwei2;
                            event.target = target;
                            player.chooseCard('h', '至微：是否将一张手牌交给' + get.translation(target) + '？').set('ai', function (card) {
                                if (_status.event.goon) return 5 - get.value(card);
                                return -get.value(card);
                            }).set('goon', get.attitude(player, target) > 0);
                            'step 1'
                            if (result.bool) {
                                player.logSkill('minizhiwei', target);
                                target.gain(result.cards, player, 'giveAuto');
                            }
                        },
                    },
                    gain: {
                        audio: 'zhiwei',
                        trigger: { player: 'loseAfter', global: 'loseAsyncAfter' },
                        filter(event, player) {
                            if (event.type != 'discard' || event.getlx === false || event.getParent('phaseDiscard').player != player || !player.storage.minizhiwei2 || !player.storage.minizhiwei2.isIn()) return false;
                            var evt = event.getl(player);
                            return evt?.cards2.someInD('d');
                        },
                        logTarget(event, player) {
                            return player.storage.minizhiwei2;
                        },
                        check(event, player) {
                            return get.attitude(player, player.storage.minizhiwei2) > 0;
                        },
                        prompt: (event, player) => '是否对' + get.translation(player.storage.minizhiwei2) + '发动【至微】？',
                        prompt2: (event, player) => '将' + get.translation(event.getl(player).cards2.filterInD('d')) + '交给' + get.translation(player.storage.minizhiwei2),
                        content() {
                            if (trigger.delay === false) game.delay();
                            player.storage.minizhiwei2.gain(trigger.getl(player).cards2.filterInD('d'), 'gain2');
                        },
                    },
                    clear: {
                        audio: 'zhiwei',
                        trigger: { global: 'die' },
                        filter(event, player) {
                            return event.player == player.storage.minizhiwei2;
                        },
                        forced: true,
                        content() {
                            player.removeSkill('minizhiwei2');
                        },
                    },
                },
            },
            //朱桓
            minifenli: {
                audio: 'fenli',
                trigger: { player: ['phaseJudgeBefore', 'phaseUseBefore', 'phaseDiscardBefore'] },
                filter(event, player) {
                    switch (event.name) {
                        case 'phaseJudge': return player.isMaxHandcard(); break;
                        case 'phaseUse': return player.isMaxHp(); break;
                        case 'phaseDiscard': return player.isMaxEquip(); break;
                    }
                    return false;
                },
                check(event, player) {
                    switch (event.name) {
                        case 'phaseJudge': {
                            if (player.hasJudge('lebu') || player.hasJudge('bingliang')) return true;
                            if (player.getHistory('skipped').length > 0) return false;
                            return game.hasPlayer(function (current) {
                                return get.attitude(player, current) < 0 && current.hp == 1 && get.damageEffect(current, player, player) > 0;
                            });
                            break;
                        }
                        case 'phaseUse': {
                            if (!player.needsToDiscard() || (player.countCards('e') && player.isMaxEquip())) return true;
                            if (player.getHistory('skipped').length > 0) return false;
                            return game.hasPlayer(function (current) {
                                return get.attitude(player, current) < 0 && current.hp == 1 && get.damageEffect(current, player, player) > 0;
                            });
                            break;
                        }
                        case 'phaseDiscard': {
                            return true;
                            break;
                        }
                    }
                    return false;
                },
                prompt(event, player) {
                    return get.prompt('minifenli') + '（可跳过' + get.translation(event.name) + (event.name == 'phaseJudge' ? '和摸牌阶段' : '') + '）';
                },
                content() {
                    trigger.cancel();
                    game.log(player, '跳过了', '#y' + get.translation(trigger.name));
                    if (trigger.name == 'phaseJudge') {
                        player.skip('phaseDraw');
                        game.log(player, '跳过了', '#y摸牌阶段');
                    }
                },
            },
            minipingkou: {
                audio: 'pingkou',
                trigger: { player: 'phaseEnd' },
                filter(event, player) {
                    return player.getHistory('skipped').length;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget([1, player.getHistory('skipped').length], get.prompt2('minipingkou'), lib.filter.notMe).set('ai', function (target) {
                        var player = _status.event.player;
                        return get.damageEffect(target, player, player) * (target.countCards('e') ? 2 : 1);
                    });
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        event.targets = targets;
                        player.logSkill('minipingkou', targets);
                        for (var i of targets) i.damage();
                        if (targets.length == player.getHistory('skipped').length || !game.hasPlayer(function (current) {
                            return current.countGainableCards(player, 'e') && targets.includes(current);
                        })) event.finish();
                    }
                    else event.finish();
                    'step 2'
                    player.chooseTarget('请选择一名目标角色，获得其装备区中的一张牌', true, function (card, player, target) {
                        return target.countGainableCards(player, 'e') && _status.event.targets.includes(target);
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        return 1 + Math.random() - get.attitude(player, target);
                    }).set('targets', targets);
                    'step 3'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target);
                        player.gainPlayerCard(target, 'e', true);
                    }
                },
                ai: {
                    combo: 'minifenli',
                    effect: {
                        target(card) {
                            if (card.name == 'lebu' || card.name == 'bingliang') return 0.5;
                        },
                    },
                },
            },
            //严畯
            miniguanchao: {
                audio: 'xinfu_guanchao',
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    var list = ['递增', '递减', '取消'];
                    player.chooseControl(list).set('prompt', get.prompt2('miniguanchao')).set('ai', function () {
                        return [0, 1].randomGet();
                    }).set('choiceList', [
                        '使用【杀】的次数上限+1，使用牌严格递增摸一张牌',
                        '计算与其他角色之间的距离-1，使用牌严格递减摸一张牌'
                    ]);
                    'step 1'
                    switch (result.control) {
                        case '递增': {
                            player.logSkill('miniguanchao');
                            player.addTempSkill('miniguanchao_dizeng');
                            break;
                        }
                        case '递减': {
                            player.logSkill('miniguanchao');
                            player.addTempSkill('miniguanchao_dijian');
                            break;
                        }
                        case '取消': {
                            break;
                        }
                    }
                },
                subSkill: {
                    dizeng: {
                        mark: true,
                        marktext: '增',
                        intro: { content: '使用【杀】的次数上限+1，使用牌严格递增摸一张牌' },
                        trigger: { player: 'useCard' },
                        audio: 'xinfu_guanchao',
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name == 'sha') return num + 1;
                            },
                            aiOrder(player, card, num) {
                                if (typeof card.number != 'number') return;
                                var history = player.getHistory('useCard');
                                if (history.length == 0) return num + 10 * (14 - card.number);
                                var num = get.number(history[0].card);
                                if (!num) return;
                                for (var i = 1; i < history.length; i++) {
                                    var num2 = get.number(history[i].card);
                                    if (!num2 || num2 <= num) return;
                                    num = num2;
                                }
                                if (card.number > num) return num + 10 * (14 - card.number);
                            },
                        },
                        filter(event, player) {
                            var history = player.getHistory('useCard');
                            if (history.length < 2) return false;
                            var num = get.number(history[0].card);
                            if (!num) return false;
                            for (var i = 1; i < history.length; i++) {
                                var num2 = get.number(history[i].card);
                                if (!num2 || num2 <= num) return false;
                                num = num2;
                            }
                            return true;
                        },
                        forced: true,
                        content() {
                            player.draw();
                        },
                    },
                    dijian: {
                        mark: true,
                        marktext: '减',
                        intro: { content: '计算与其他角色之间的距离-1，使用牌严格递减摸一张牌' },
                        trigger: { player: 'useCard' },
                        audio: 'xinfu_guanchao',
                        mod: {
                            globalFrom(from, to, distance) {
                                return distance - 1;
                            },
                            aiOrder(player, card, num) {
                                if (typeof card.number != 'number') return;
                                var history = player.getHistory('useCard');
                                if (history.length == 0) return num + 10 * card.number;
                                var num = get.number(history[0].card);
                                if (!num) return;
                                for (var i = 1; i < history.length; i++) {
                                    var num2 = get.number(history[i].card);
                                    if (!num2 || num2 >= num) return;
                                    num = num2;
                                }
                                if (card.number < num) return num + 10 * card.number;
                            },
                        },
                        filter(event, player) {
                            var history = player.getHistory('useCard');
                            if (history.length < 2) return false;
                            var num = get.number(history[0].card);
                            if (!num) return false;
                            for (var i = 1; i < history.length; i++) {
                                var num2 = get.number(history[i].card);
                                if (!num2 || num2 >= num) return false;
                                num = num2;
                            }
                            return true;
                        },
                        forced: true,
                        content() {
                            player.draw();
                        },
                    },
                },
            },
            minixunxian: {
                audio: 'xinfu_xunxian',
                trigger: { global: 'cardsDiscardAfter' },
                filter(event, player) {
                    if (!event.cards.filterInD('d').length) return false;
                    var evt = event.getParent();
                    if (evt.name != 'orderingDiscard') return false;
                    var evtx = (evt.relatedEvent || evt.getParent());
                    if (evtx.player != player) return false;
                    return player.hasHistory('lose', function (evtxx) {
                        return evtx == (evtxx.relatedEvent || evtxx.getParent()) && evtxx.cards2.length;
                    });
                },
                usable: 1,
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minixunxian'), '令一名其他角色获得' + get.translation(trigger.cards.filterInD('d')), lib.filter.notMe).set('ai', function (target) {
                        var player = _status.event.player;
                        var att = get.attitude(player, target);
                        if (att < 3) return 0;
                        if (target.hasJudge('lebu')) att /= 5;
                        if (target.hasSha() && _status.event.sha) att /= 5;
                        if (_status.event.wuxie && target.needsToDiscard(1)) att /= 5;
                        return att / (1 + get.distance(player, target, 'absolute'));
                    }).set('sha', trigger.cards.filterInD('d').filter(function (card) {
                        return card.name == 'sha';
                    }).length).set('wuxie', trigger.cards.filterInD('d').filter(function (card) {
                        return card.name == 'wuxie';
                    }).length);
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('minixunxian', target);
                        target.gain(trigger.cards.filterInD('d'), 'gain2');
                    }
                    else player.storage.counttrigger.minixunxian--;
                },
                ai: { expose: 0.25 },
            },
            //孙翊
            minisyxiongyi: {
                derivation: ['minihunzi', 'reyingzi', 'minireyinghun'],
                audio: 'syxiongyi',
                skillAnimation: true,
                animationColor: 'wood',
                limited: true,
                enable: 'chooseToUse',
                filter(event, player) {
                    if (event.type != 'dying') return false;
                    if (player != event.dying) return false;
                    return true;
                },
                async content(event, trigger, player) {
                    player.awakenSkill('minisyxiongyi');
                    if (!_status.characterlist) lib.skill.pingjian.initList();
                    if (_status.characterlist.includes('Mbaby_xushi')) {
                        if (player.name2 && get.character(player.name2)[3].includes('minisyxiongyi')) {
                            await player.reinitCharacter(player.name2, 'Mbaby_xushi');
                        }
                        else await player.reinitCharacter(player.name1, 'Mbaby_xushi');
                        if (player.hp < 3) await player.recover(3 - player.hp);
                    }
                    else {
                        await player.addSkills('minihunzi');
                        if (player.hp < 1) await player.recover(1 - player.hp);
                    }
                },
                ai: {
                    order: 1,
                    save: true,
                    skillTagFilter(player, arg, target) {
                        return player == target;
                    },
                    result: { player: 10 },
                },
            },
            //璇天帝
            minishezang: {
                audio: 'shezang',
                inherit: 'shezang',
                round: 0,
                usable: 1,
            },
            //托尼
            miniyoudi: {
                audio: 'xinfu_youdi',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return player.countCards('h');
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('miniyoudi'), function (card, player, target) {
                        return player != target;
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        if (player.countCards('h', 'sha') > player.countCards('h') / 3 && player.countCards('h', { color: 'red' }) > player.countCards('h') / 2) return 0;
                        if (target.countCards('he') == 0) return 0.1;
                        return -get.attitude(_status.event.player, target);
                    });
                    'step 1'
                    if (result.bool) {
                        game.delay();
                        player.logSkill('miniyoudi', result.targets);
                        event.target = result.targets[0];
                        event.target.discardPlayerCard(player, 'h', true);
                    }
                    else event.finish();
                    'step 2'
                    if (result.links[0].name != 'sha' && event.target.countCards('he')) {
                        player.gainPlayerCard('he', event.target, true);
                        player.draw();
                    }
                    if (get.color(result.links[0]) != 'black' && player.maxHp < 5) player.gainMaxHp();
                },
                ai: { expose: 0.25 },
            },
            //朱自清の父亲
            minizhenglun: {
                audio: 'nzry_zhenglun',
                trigger: { player: 'phaseDrawBegin2' },
                filter(event, player) {
                    if (event.numFixed) return false;
                    return !player.hasMark('nzry_huaiju');
                },
                content() {
                    trigger.num--;
                    player.addMark('nzry_huaiju', 1);
                },
                ai: { combo: 'nzry_huaiju' },
            },
            //孙登
            minikuangbi: {
                audio: 'rekuangbi',
                enable: 'phaseUse',
                filterTarget(card, player, target) {
                    return target != player && target.countCards('he') > 0;
                },
                usable: 1,
                content() {
                    'step 0'
                    target.chooseCard('he', [1, 3], '匡弼：将至多三张牌置于' + get.translation(player) + '的武将牌上', true, 'allowChooseAll').set('ai', function (card) {
                        if (get.attitude(_status.event.player, _status.event.getParent().player) > 0) {
                            return 7 - get.value(card);
                        }
                        return -get.value(card);
                    });
                    'step 1'
                    if (result.bool) {
                        event.num = result.cards.length;
                        player.addToExpansion(result.cards, target, 'give').gaintag.add('minikuangbi');
                        player.chooseBool('匡弼：是否令' + get.translation(target) + '摸' + get.cnNumber(event.num) + '张牌？').set('choice', get.attitude(player, target) > 0);
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        player.line(target);
                        target.draw(num);
                    }
                },
                intro: {
                    content: 'expansion',
                    markcount: 'expansion',
                },
                onremove(player, skill) {
                    player.removeGaintag(skill);
                    var cards = player.getExpansions(skill);
                    if (cards.length) player.loseToDiscardpile(cards);
                },
                ai: {
                    order: 7,
                    result: {
                        player: 1,
                        target(player, target) {
                            if (get.attitude(player, target) > 0) {
                                return Math.sqrt(target.countCards('he'));
                            }
                            return 0;
                        },
                    },
                },
                group: ['minikuangbi_gain', 'minikuangbi_effect'],
                subSkill: {
                    gain: {
                        audio: 'rekuangbi',
                        trigger: { player: 'phaseBegin' },
                        filter(event, player) {
                            return player.getExpansions('minikuangbi').length;
                        },
                        forced: true,
                        locked: false,
                        content() {
                            player.gain(player.getExpansions('minikuangbi'), 'gain2').gaintag.add('minikuangbi');
                        },
                    },
                    effect: {
                        audio: 'rekuangbi',
                        trigger: {
                            player: 'loseAfter',
                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                        },
                        filter(event, player) {
                            var evt = event.getl(player);
                            if (!evt || !evt.hs || !evt.hs.length) return false;
                            if (player.countCards('h', function (card) {
                                return card.hasGaintag('minikuangbi');
                            })) return false;
                            if (event.name == 'lose') {
                                for (var i in event.gaintag_map) {
                                    if (event.gaintag_map[i].includes('minikuangbi')) return true;
                                }
                                return false;
                            }
                            return player.hasHistory('lose', function (evt) {
                                if (event != evt.getParent()) return false;
                                for (var i in evt.gaintag_map) {
                                    if (evt.gaintag_map[i].includes('minikuangbi')) return true;
                                }
                                return false;
                            });
                        },
                        forced: true,
                        locked: false,
                        content() {
                            player.draw();
                            player.recover();
                        },
                    },
                },
            },
            //潘濬
            miniguanwei: {
                audio: 'xinfu_guanwei',
                trigger: { global: 'phaseUseEnd' },
                filter(event, player) {
                    var map = {};
                    event.player.getHistory('useCard', function (evt) {
                        if (evt.getParent('phaseUse') == event) {
                            var suit = get.suit(evt.card, event.player);
                            if (!map[suit]) map[suit] = 1;
                            else map[suit]++;
                        }
                    });
                    for (var i in map) {
                        if (map[i] > 1) return true;
                    }
                    return false;
                },
                direct: true,
                usable: 1,
                content() {
                    'step 0'
                    player.chooseToDiscard(get.prompt('miniguanwei', trigger.player), '弃置一张牌，令其摸两张牌并进行一个额外的出牌阶段', 'he').set('ai', function (card) {
                        if (get.attitude(_status.event.player, _status.currentPhase) <= 0) return 0;
                        return 9 - get.value(card);
                    }).set('logSkill', 'miniguanwei');
                    'step 1'
                    if (result.bool) {
                        if (trigger.player != player) player.addExpose(0.5);
                        player.line(trigger.player, 'green');
                        trigger.player.draw(2);
                    }
                    else event.finish();
                    'step 2'
                    var next = trigger.player.phaseUse();
                    event.next.remove(next);
                    trigger.getParent('phase').next.push(next);
                },
            },
            minigongqing: {
                audio: 'xinfu_gongqing',
                trigger: { player: 'damageBegin4' },
                filter(event, player, name) {
                    if (!event.source) return false;
                    var num = event.source.getAttackRange();
                    if (num < 3) return event.num > 1;
                    return true;
                },
                preHidden: true,
                forced: true,
                content() {
                    var range = trigger.source.getAttackRange();
                    if (range < 3 && trigger.num > 1) trigger.num = 1;
                    if (range >= 3) player.draw();
                },
                ai: {
                    filterDamage: true,
                    skillTagFilter(player, tag, arg) {
                        if (arg?.player) {
                            if (arg.player.hasSkillTag('jueqing', false, player)) return false;
                            if (arg.player.getAttackRange() < 3) return true;
                        }
                        return false;
                    }
                },
            },
            //丁奉
            miniduanbing: {
                audio: 'duanbing',
                group: 'miniduanbing_sha',
                preHidden: ['miniduanbing_sha'],
                inherit: 'reduanbing',
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('miniduanbing'), '为' + get.translation(trigger.card) + '增加一个目标', function (card, player, target) {
                        return !_status.event.sourcex.includes(target) && get.distance(player, target) <= 1 && player.canUse(_status.event.card, target);
                    }).set('sourcex', trigger.targets).set('ai', function (target) {
                        var player = _status.event.player;
                        return get.effect(target, _status.event.card, player, player);
                    }).set('card', trigger.card).setHiddenSkill(event.name);
                    'step 1'
                    if (result.bool) {
                        if (!event.isMine() && !event.isOnline()) game.delayx();
                        event.targets = result.targets;
                    }
                    else event.finish();
                    'step 2'
                    player.logSkill('miniduanbing', targets);
                    trigger.targets.addArray(targets);
                },
                subSkill: {
                    sha: {
                        audio: 'duanbing',
                        audioname: ['heqi'],
                        trigger: { player: 'useCardToPlayered' },
                        forced: true,
                        filter(event, player) {
                            if (player.getHistory('useCard', evt => evt.card.name == 'sha').indexOf(event.getParent()) != 0) return false;
                            return event.card.name == 'sha' && !event.getParent().directHit.includes(event.target) && get.distance(player, event.target) <= 1;
                        },
                        logTarget: 'target',
                        content() {
                            var id = trigger.target.playerid;
                            var map = trigger.getParent().customArgs;
                            if (!map[id]) map[id] = {};
                            if (typeof map[id].shanRequired == 'number') map[id].shanRequired++;
                            else map[id].shanRequired = 2;
                        },
                        ai: {
                            directHit_ai: true,
                            skillTagFilter(player, tag, arg) {
                                if (arg.card.name != 'sha' || arg.target.countCards('h', 'shan') > 1 || player.getHistory('useCard', evt => evt.card.name == 'sha').length || get.distance(player, arg.target) > 1) return false;
                            },
                        },
                    },
                },
            },
            minifenxun: {
                group: 'minifenxun_draw',
                audio: 'fenxun',
                inherit: 'refenxun',
                content() {
                    player.addTempSkill('minifenxun2');
                    player.markAuto('minifenxun2', targets);
                },
                subSkill: {
                    draw: {
                        audio: 'fenxun',
                        trigger: { player: 'phaseEnd' },
                        filter(event, player) {
                            return game.hasPlayer(current => get.distance(player, current) <= 1 && current.getHistory('damage').length);
                        },
                        forced: true,
                        locked: false,
                        content() {
                            player.draw(game.filterPlayer(current => get.distance(player, current) <= 1 && current.getHistory('damage').length).reduce((sum, target) => {
                                return sum + target.getHistory('damage').reduce((num, evt) => num + evt.num, 0);
                            }, 0));
                        },
                    },
                },
            },
            minifenxun2: {
                charlotte: true,
                onremove: true,
                mod: {
                    globalFrom(from, to) {
                        if (from.getStorage('minifenxun2').includes(to)) return -Infinity;
                    },
                },
            },
            //薛综
            minifunan: {
                audio: 'funan',
                trigger: { global: ['useCard', 'respond'] },
                filter(event, player) {
                    if (!event.respondTo) return false;
                    if (event.player == player) return false;
                    if (player != event.respondTo[0]) return false;
                    return event.cards.filterInD('od').length;
                },
                logTarget: 'player',
                content() {
                    player.gain(trigger.cards.filterInD('od'), 'gain2');
                },
            },
            minijiexun: {
                audio: 'jiexun',
                trigger: { player: 'phaseJieshuBegin' },
                direct: true,
                content() {
                    'step 0'
                    var suits = {};
                    game.countPlayer(current => {
                        for (var card of current.getCards('ej')) {
                            if (typeof suits[get.suit(card)] != 'number') suits[get.suit(card)] = 0;
                            suits[get.suit(card)]++;
                        }
                    });
                    var choices = lib.suit.slice();
                    choices.push('cancel2');
                    var str = lib.suit.map(suit => {
                        return get.translation(suit) + '：' + get.cnNumber(suits[suit] || 0) + '张'
                    }).join('；');
                    player.chooseControl(choices).set('prompt', get.prompt('minijiexun') + '（已发动过' + get.cnNumber(player.countMark('minijiexun')) + '次）').set('ai', function () {
                        var player = _status.event.player;
                        var map = {};
                        game.countPlayer(current => {
                            for (var card of current.getCards('ej')) {
                                if (typeof map[get.suit(card)] != 'number') map[get.suit(card)] = 0;
                                map[get.suit(card)]++;
                            }
                        });
                        for (var suit in map) map[suit] = Math.abs(map[suit]);
                        var bool = game.hasPlayer(current => get.attitude(player, current) > 0);
                        var list = lib.suit.slice().sort((a, b) => (bool ? 1 : -1) * ((map[b] || 0) - (map[a] || 0)));
                        if (bool && map[list[0]] > 0 || !bool || player.hasMark('minijiexun')) return list[0];
                        return 'cancel2';
                    }).set('prompt2', get.skillInfoTranslation('minijiexun', player) + '<br>' + str);
                    'step 1'
                    if (result.control != 'cancel2') {
                        var suit = result.control;
                        event.suit = suit;
                        var num1 = game.countPlayer(function (current) {
                            return current.countCards('ej', { suit: suit });
                        });
                        var num2 = player.countMark('minijiexun');
                        event.num1 = num1;
                        event.num2 = num2;
                        var str = '令一名角色摸' + get.cnNumber(num1) + '张牌';
                        if (num2) str += '，然后弃置' + get.cnNumber(num2) + '张牌';
                        player.chooseTarget('请选择【诫训】的目标', str).set('ai', function (target) {
                            var player = _status.event.player, att = get.attitude(player, target);
                            return _status.event.eff * Math.sign(att) + att / 114514;
                        }).set('eff', num1 >= num2 && num1 > 0 ? 1 : -1);
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minijiexun', target);
                        if (player.hasMark('minijiexun') || event.num1) player.addExpose(0.2);
                        player.popup(event.suit);
                        game.log(player, '选择了', '#y' + get.translation(event.suit));
                        player.addMark('minijiexun', 1, false);
                        if (event.num1) target.draw(event.num1);
                    }
                    else event.finish();
                    'step 3'
                    if (event.num2) target.chooseToDiscard(event.num2, true, 'he');
                    else event.finish();
                    'step 4'
                    if (result.bool && result.autochoose && result.cards.length == result.rawcards.length) {
                        player.removeMark('minijiexun', player.countMark('minijiexun'), false);
                        game.log(player, '清空了', '#g【诫训】', '的发动次数');
                    }
                },
                onremove: true,
                intro: { content: '已发动#次' },
            },
            minisbkurou: {
                audio: 'sbkurou',
                enable: 'phaseUse',
                usable: 1,
                content() {
                    player.loseHp();
                    player.addTempSkill('minisbkurou_effect', { player: 'phaseBegin' });
                    player.gainMaxHp();
                    player.addMark('minisbkurou_effect', 1, false);
                },
                ai: {
                    order: 8,
                    result: {
                        player(player) {
                            return get.effect(player, { name: 'losehp' }, player, player);
                        },
                    },
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove(player) {
                            player.loseMaxHp(player.countMark('minisbkurou_effect'));
                            delete player.storage.minisbkurou_effect;
                        },
                        intro: { content: '手牌上限和体力上限+#' },
                        mod: {
                            maxHandcard(player, num) {
                                return num + player.countMark('minisbkurou_effect');
                            },
                        },
                        trigger: { player: 'recoverEnd' },
                        filter(event, player) {
                            return player.isPhaseUsing() && player.getStat('skill').minisbkurou;
                        },
                        forced: true,
                        content() {
                            delete player.getStat('skill').minisbkurou;
                            player.popup('苦肉');
                            game.log(player, '重置了技能', '#g【苦肉】');
                        },
                    },
                },
            },
            minisbzhaxiang: {
                audio: 'sbzhaxiang',
                audioname2: { Mbaby_ol_sb_jiangwei: 'zhaxiang_ol_sb_jiangwei' },
                trigger: { player: 'loseHpEnd' },
                forced: true,
                content() {
                    player.draw(3 * trigger.num);
                },
                ai: {
                    maihp: true,
                    effect(card, player, target) {
                        if (get.tag(card, 'damage')) {
                            if (player.hasSkillTag('jueqing', false, target)) return [1, 1];
                            return 1.2;
                        }
                        if (get.tag(card, 'loseHp')) {
                            if (target.hp <= 1) return;
                            var using = target.isPhaseUsing();
                            if (target.hp <= 2) return [1, player.countCards('h') <= 1 && using ? 3 : 0];
                            if (using && target.countCards('h', { name: 'sha', color: 'red' })) return [1, 3];
                            return [1, (target.countCards('h') <= target.hp || using && game.hasPlayer(function (current) {
                                return current != player && get.attitude(player, current) < 0 && player.inRange(current);
                            })) ? 3 : 2]
                        }
                    },
                },
                group: ['minisbzhaxiang_draw', 'minisbzhaxiang_effect'],
                subSkill: {
                    draw: {
                        audio: 'sbzhaxiang',
                        trigger: { player: 'phaseEnd' },
                        filter(event, player) {
                            return player.isDamaged();
                        },
                        forced: true,
                        content() {
                            player.draw(Math.ceil(player.getDamagedHp() / 2));
                        },
                    },
                    effect: {
                        audio: 'sbzhaxiang',
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            if (event.card.name != 'sha') return false;
                            return player.countMark('minisbzhaxiang_count') < Math.ceil(player.getDamagedHp() / 2);
                        },
                        forced: true,
                        content() {
                            player.addTempSkill('minisbzhaxiang_count');
                            player.addMark('minisbzhaxiang_count', 1, false);
                            trigger.directHit.addArray(game.filterPlayer());
                            trigger.addCount = false;
                            if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                        },
                        ai: {
                            directHit_ai: true,
                            skillTagFilter(player, tag, arg) {
                                return arg.card && arg.card.name == 'sha' && player.countMark('minisbzhaxiang_count') < Math.ceil(player.getDamagedHp() / 2);
                            },
                        },
                        mod: {
                            targetInRange(card, player) {
                                if (card.name == 'sha' && player.countMark('minisbzhaxiang_count') < Math.ceil(player.getDamagedHp() / 2)) return true;
                            },
                            //cardUsable:function(card,player){
                            //if(card.name=='sha'&&player.countMark('minisbzhaxiang_count')<Math.ceil(player.getDamagedHp()/2)) return Infinity;
                            //},
                        },
                    },
                    count: {
                        charlotte: true,
                        onremove: true,
                    },
                },
            },
            //张奋
            miniwanglu: {
                derivation: 'miniwanglu_faq',
                audio: 'dcwanglu',
                trigger: { player: 'phaseZhunbeiBegin' },
                forced: true,
                content() {
                    if (!player.hasEquipableSlot(5) || player.getEquip('minidagongche')) {
                        var next = player.phaseUse();
                        event.next.remove(next);
                        trigger.getParent().next.push(next);
                    }
                    else {
                        var card = game.createCard('minidagongche', 'spade', 9);
                        player.$gain2(card);
                        game.delayx();
                        player.equip(card);
                    }
                },
                broadcast(player) {
                    var card = player.getEquip('minidagongche');
                    if (card) game.broadcast(function (card, storage) {
                        card.storage = storage;
                    }, card, card.storage);
                },
                ai: {
                    effect: {
                        target(card, player, target) {
                            if (target == player && get.type(card) == 'equip' && get.subtype(card) == 'equip1') return 'zerotarget';
                        },
                    },
                },
            },
            minixianzhu: {
                derivation: 'minixianzhu_faq',
                audio: 'dcxianzhu',
                trigger: { source: 'damageSource' },
                filter(event, player) {
                    if (!event.card || event.card.name != 'sha') return false;
                    var card = player.getEquip('minidagongche');
                    if (!card) return false;
                    var num = 0;
                    for (var i = 1; i <= 3; i++) {
                        var key = '大攻车选项' + get.cnNumber(i, true);
                        if (card.storage[key]) num += card.storage[key];
                    }
                    return num < 5;
                },
                direct: true,
                content() {
                    'step 0'
                    var choiceList = [
                        '令【杀】无距离限制且无视防具',
                        '令【杀】的可选目标数+1',
                        '令【杀】造成伤害后的弃牌数+1',
                    ];
                    var list = [];
                    var card = player.getEquip('minidagongche');
                    for (var i = 1; i <= 3; i++) {
                        var key = '大攻车选项' + get.cnNumber(i, true);
                        var num = card.storage[key];
                        if (i == 1) {
                            if (!num) list.push('选项一');
                            else choiceList[0] = ('<span style="opacity:0.5; ">' + choiceList[0] + '（已强化）</span>');
                        }
                        else {
                            list.push('选项' + get.cnNumber(i, true));
                            if (num) choiceList[i - 1] += ('（已强化' + num + '次）');
                        }
                    }
                    player.chooseControl(list, 'cancel2').set('prompt', '是否发动【陷筑】强化【大攻车】？').set('choiceList', choiceList).set('ai', function () {
                        var player = _status.event.player, controls = _status.event.controls.slice(0);
                        var getval = function (choice) {
                            var card = player.getEquip('minidagongche');
                            if (choice == '选项一') {
                                card.storage.大攻车选项一 = 1;
                                var goon = false;
                                if (game.hasPlayer(function (current) {
                                    var eff1 = 0, eff2 = 0;
                                    var cardx = { name: 'sha', isCard: true };
                                    if (player.canUse(cardx, current)) eff1 = get.effect(current, cardx, player, player);
                                    cardx.storage = { minidagongche: true };
                                    if (player.canUse(cardx, current)) eff2 = get.effect(current, cardx, player, player);
                                    return (eff2 > eff1);
                                })) goon = true;
                                delete card.storage.大攻车选项一;
                                if (goon) return 5;
                                return 0;
                            }
                            else if (choice == '选项二') {
                                var num = 1;
                                if (card.storage.大攻车选项二) num += card.storage.大攻车选项二;
                                var cardx = { name: 'sha', isCard: true };
                                if (game.countPlayer(function (current) {
                                    return player.canUse(cardx, current) && get.effect(current, cardx, player, player) > 0;
                                }) > num) return 2;
                            }
                            else if (choice == '选项三') return 1;
                            return 0;
                        };
                        var eff = 0, current = 'cancel2';
                        for (var i of controls) {
                            var effx = getval(i);
                            if (effx > eff) {
                                eff = effx;
                                current = i;
                            }
                        }
                        return current;
                    });
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('minixianzhu');
                        var card = player.getEquip('minidagongche'), key = '大攻车' + result.control;
                        if (!card.storage[key]) card.storage[key] = 0;
                        card.storage[key]++;
                        lib.skill.miniwanglu.broadcast(player);
                    }
                },
                group: 'minixianzhu_sha',
                subSkill: {
                    sha: {
                        audio: 'dcxianzhu',
                        enable: 'phaseUse',
                        filter(event, player) {
                            return /*player.getCardUsable('sha')>0&&*/game.hasPlayer(target => player.canUse({ name: 'sha' }, target, false)) && player.countCards('h', card => lib.skill.minixianzhu.subSkill.sha.filterCard(card, player));
                        },
                        filterCard(card, player) {
                            return get.type(card) == 'equip' && get.subtype(card) == 'equip1';
                        },
                        filterTarget(card, player, target) {
                            return player.canUse({ name: 'sha', isCard: true }, target, false);
                        },
                        usable: 1,
                        check: (card) => 1 / (get.value(card) || 0.5),
                        prompt: '弃置一张手牌中的武器牌，视为对一名其他角色使用一张无视距离且不计入次数的【杀】',
                        content() {
                            player.useCard({ name: 'sha', isCard: true }, target, false);
                        },
                    },
                },
            },
            minichaixie: {
                audio: 'dcchaixie',
                trigger: {
                    player: ['loseAfter'],
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                },
                forced: true,
                filter(event, player) {
                    var evt = event.getl(player);
                    if (!evt || !evt.es || !evt.es.length) return false;
                    for (var card of evt.es) {
                        if (card.name == 'minidagongche') {
                            for (var i = 1; i <= 3; i++) {
                                if (card.storage['大攻车选项' + get.cnNumber(i, true)]) return true;
                            }
                        }
                    }
                    return false;
                },
                content() {
                    var num = 0;
                    var evt = trigger.getl(player);
                    for (var card of evt.es) {
                        if (card.name == 'minidagongche') {
                            for (var i = 1; i <= 3; i++) {
                                var key = '大攻车选项' + get.cnNumber(i, true);
                                if (card.storage[key]) num += card.storage[key];
                            }
                        }
                    }
                    player.draw(num);
                },
            },
            minidagongche_skill: {
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                filter(event, player) {
                    var cardx = {
                        name: 'sha',
                        isCard: true,
                        storage: { minidagongche: true },
                    };
                    return player.hasUseTarget(cardx);
                },
                equipSkill: true,
                content() {
                    var card = {
                        name: 'sha',
                        isCard: true,
                        storage: { minidagongche: true },
                    };
                    lib.skill.miniwanglu.broadcast(player);
                    player.chooseUseTarget(card, '大攻车：是否视为使用【杀】？', false).logSkill = 'minidagongche_skill';
                },
                mod: {
                    targetInRange(card, player, target) {
                        if (card.storage && card.storage.minidagongche) {
                            var cardx = player.getEquip('minidagongche');
                            if (cardx?.storage?.大攻车选项一) return true;
                        }
                    },
                    selectTarget(card, player, range) {
                        if (card.storage && card.storage.minidagongche && range[1] != -1) {
                            var cardx = player.getEquip('minidagongche');
                            if (cardx?.storage?.大攻车选项二) range[1] += cardx.storage.大攻车选项二;
                        }
                    },
                    canBeDiscarded(card) {
                        if (card.name == 'minidagongche' && get.position(card) == 'e') {
                            for (var i = 1; i <= 3; i++) {
                                if (card.storage['大攻车选项' + get.cnNumber(i, true)]) return;
                            }
                            return false;
                        }
                    },
                },
                ai: {
                    unequip: true,
                    skillTagFilter(player, tag, arg) {
                        if (!arg || !arg.card || !arg.card.storage || !arg.card.storage.minidagongche) return false;
                        var card = player.getEquip('minidagongche');
                        if (!card || !card.storage.大攻车选项一) return false;
                    },
                },
                group: 'minidagongche_skill_discard',
                subSkill: {
                    discard: {
                        trigger: { source: 'damageSource' },
                        equipSkill: true,
                        forced: true,
                        filter(event, player) {
                            if (!event.card || !event.card.storage || !event.card.storage.minidagongche) return false;
                            if (event.getParent().type != 'card') return false;
                            return event.player.hasCard(function (card) {
                                return lib.filter.canBeDiscarded(card, event.player, player);
                            }, 'he');
                        },
                        logTarget: 'player',
                        content() {
                            var num = 1;
                            var cardx = player.getEquip('minidagongche');
                            if (cardx?.storage?.大攻车选项三) num += cardx.storage.大攻车选项三;
                            player.discardPlayerCard(trigger.player, true, num, 'he');
                        },
                    },
                },
            },
            miniyanzhu: {
                audio: 'yanzhu',
                enable: 'phaseUse',
                filterTarget: lib.filter.notMe,
                usable: 1,
                content() {
                    'step 0'
                    if (!target.countCards('e') || player.storage.miniyanzhu) event._result = { index: 0 };
                    else target.chooseControl().set('prompt', get.translation(player) + '发动了【宴诛】，请选择一项').set('choiceList', [
                        '弃置一张牌，并令下次受到的伤害+1直到下回合开始',
                        '将装备区内的所有牌交给' + get.translation(player) + '并令其发动【宴诛】无法选择此项',
                    ]).set('ai', function () {
                        if (_status.event.player.countCards('e') >= 3) return 0;
                        return 1;
                    });
                    'step 1'
                    if (result.index == 1) {
                        target.give(target.getCards('e'), player);
                        player.storage.miniyanzhu = true;
                    }
                    else {
                        if (target.countCards('he') > 0) target.chooseToDiscard('he', true);
                        target.addTempSkill('reyanzhu2', { player: 'phaseBegin' });
                        target.addMark('reyanzhu2', 1, false);
                    }
                },
                ai: {
                    order: 6,
                    result: {
                        target(player, target) {
                            if (player.storage.miniyanzhu) return -1;
                            var ne = target.countCards('e');
                            if (!ne) return -2;
                            if (ne >= 2) return -ne;
                            return 0;
                        },
                    },
                },
            },
            minixingxue: {
                audio: 'xingxue',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return player.maxHp > 0;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget([1, player.maxHp], get.prompt2('minixingxue')).set('ai', function (target) {
                        var att = get.attitude(_status.event.player, target);
                        if (target.countCards('he')) return att;
                        return att / 10;
                    });
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        event.targets = result.targets;
                        player.logSkill('minixingxue', targets);
                        event.targets2 = event.targets.slice(0);
                    }
                    else event.finish();
                    'step 2'
                    if (event.targets.length) {
                        var target = event.targets.shift();
                        target.draw();
                        event.current = target;
                    }
                    else event.finish();
                    'step 3'
                    if (event.current && event.current.countCards('he')) {
                        if (event.targets2.length == 1) event.current.chooseCard('选择一张牌置于牌堆顶', 'he', true);
                        else event.current.chooseCardTarget({
                            prompt: '将一张牌置于牌堆顶，或交给其他目标角色',
                            filterCard: true,
                            position: 'he',
                            filterTarget(card, player, target) {
                                return target != player && _status.event.getParent().targets2.includes(target);
                            },
                            forced: true,
                            selectTarget: [0, 1],
                            ai1: (card) => 6 - get.value(card),
                            ai2: (target) => get.attitude(_status.event.player, target),
                        });
                    }
                    else event.goto(2);
                    'step 4'
                    if (result?.cards?.length) {
                        if (!result?.targets?.length) {
                            event.current.lose(result.cards, ui.cardPile, 'insert');
                            event.current.$throw(result.cards.length, 1000);
                        }
                        else event.current.give(result.cards, result.targets[0]);
                    }
                    'step 5'
                    event.goto(2);
                },
            },
            minizhaofu: {
                zhuSkill: true,
                audio: 'zhaofu',
                enable: 'phaseUse',
                filterTarget: lib.filter.notMe,
                selectTarget: [1, 2],
                usable: 1,
                content() {
                    target.addTempSkill('minizhaofu_effect', 'roundStart');
                },
                ai: {
                    order: 9,
                    result: {
                        target(player, target) {
                            var targets = game.filterPlayer(function (current) {
                                return current.group == 'wu' && get.attitude(player, current) > 0;
                            });
                            if (targets.length) {
                                for (var targetx of targets) {
                                    if (!targetx.inRange(target)) return -1;
                                }
                                return -0.5;
                            }
                            return 0;
                        },
                    },
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        mark: true,
                        intro: { content: '已视为在所有吴势力角色的攻击范围内' },
                        mod: {
                            inRangeOf(from, to) {
                                if (from.group == 'wu') return true;
                            },
                        },
                    },
                },
            },
            //孙茹
            minixiecui: {
                audio: 'xiecui',
                trigger: { global: 'damageBegin1' },
                filter(event, player) {
                    var source = event.source;
                    if (!source || source != _status.currentPhase || event.getParent().type != 'card') return false;
                    return !source.hasHistory('sourceDamage', function (evt) {
                        return evt.getParent().type == 'card';
                    });
                },
                logTarget: 'source',
                prompt2(event, player) {
                    var source = event.source;
                    var str = ('令' + get.translation(event.player) + '即将受到的');
                    str += ('' + event.num + '点');
                    if (event.hasNature('linked')) {
                        str += (get.translation(event.nature) + '属性');
                    }
                    str += '伤害+1';
                    if (source.countCards('h') > source.getHp()) {
                        var cards = event.cards.filterInD();
                        if (cards.length) {
                            str += ('；然后' + get.translation(event.source) + '获得' + get.translation(cards) + '，且本回合的手牌上限+1');
                        }
                    }
                    return str;
                },
                check(event, player) {
                    var source = event.source;
                    var att = get.attitude(player, event.player);
                    if (att < 0) {
                        if (source.countCards('h') <= source.getHp() || !event.cards.filterInD().length) return true;
                        return get.attitude(player, source) > 0;
                    }
                    return false;
                },
                content() {
                    trigger.num++;
                    var source = trigger.source;
                    if (source.countCards('h') > source.getHp()) {
                        var cards = trigger.cards.filterInD();
                        if (cards.length > 0) {
                            source.gain(cards, 'gain2');
                            source.addMark('xiecui_effect', 1, false);
                            source.addTempSkill('xiecui_effect');
                        }
                    }
                },
                ai: { threaten: 2 },
            },
            //虞翻
            minizongxuan: {
                audio: 'zongxuan',
                trigger: {
                    player: 'loseAfter',
                    global: 'loseAsyncAfter',
                },
                filter(event, player) {
                    if (event.type != 'discard') return false;
                    var evt = event.getl(player);
                    if (!evt || !evt.cards2) return false;
                    for (var i = 0; i < evt.cards2.length; i++) {
                        if (get.position(evt.cards2[i]) == 'd') {
                            return true;
                        }
                    }
                    return false;
                },
                check(trigger, player) {
                    if (trigger.getParent(3).name == 'phaseDiscard') return true;
                    if (!game.hasPlayer(function (current) {
                        return current != player && get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                    })) return false;
                    var cards = trigger.getl(player).cards2;
                    for (var i = 0; i < cards.length; i++) {
                        if (get.position(cards[i], true) == 'd' && get.type2(cards[i], false) == 'trick') {
                            return true;
                        }
                    }
                    return false;
                },
                content() {
                    'step 0'
                    var cards = [], cards2 = trigger.getl(player).cards2;
                    for (var i = 0; i < cards2.length; i++) {
                        if (get.position(cards2[i], true) == 'd') {
                            cards.push(cards2[i]);
                        }
                    }
                    var next = player.chooseToMove('纵玄：将任意张牌置于牌堆顶', true);
                    next.set('list', [
                        ['本次弃置的牌（请将要给出的牌也留在这里）', cards],
                        ['牌堆顶'],
                    ]);
                    next.set('filterOk', function (moved) {
                        if (moved[0].length == 1) return true;
                        return moved[1].length > 0;
                    });
                    next.set('processAI', function (list) {
                        var cards = list[0][1].slice(0), player = _status.event.player;
                        var result = [[], []];
                        if (game.hasPlayer(function (current) {
                            return current != player && get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                        })) {
                            var max_val = 0;
                            var max_card = false;
                            for (var i of cards) {
                                var val = get.value(i, 'raw');
                                if (val > max_val) {
                                    max_card = i;
                                    max_val = val;
                                }
                            }
                            if (max_card) {
                                result[0].push(max_card);
                                cards.remove(max_card);
                            }
                        }
                        if (cards.length) {
                            var max_val = 0;
                            var max_card = false;
                            var equip = game.hasPlayer(function (current) {
                                return current.isDamaged() && get.recoverEffect(current, player, player) > 0;
                            })
                            for (var i of cards) {
                                var val = get.value(i);
                                var type = get.type2(i, false);
                                if (type == 'basic') val += 3;
                                if (type == 'equip' && equip) val += 9;
                                if (max_val == 0 || val > max_val) {
                                    max_card = i;
                                    max_val = val;
                                }
                            }
                            if (max_card) {
                                result[1].push(max_card);
                                cards.remove(max_card);
                            }
                            result[0].addArray(cards);
                        }
                        return result;
                    })
                    'step 1'
                    if (result.bool) {
                        var cards = result.moved[1].slice(0);
                        event.cards = cards;
                        var list = result.moved[0].slice(0);
                        if (list.length && game.hasPlayer((current) => (current != player))) {
                            var next = player.chooseButton([(cards.length ? '是否' : '') + '将其中一张牌交给一名其他角色，然后你摸一张牌' + (cards.length ? '？' : ''), list]).set('ai', function (button) {
                                if (_status.event.goon) return Math.max(0.1, get.value(button.link, 'raw'));
                                return 0;
                            }).set('goon', game.hasPlayer(function (current) {
                                return current != player && get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                            }));
                            if (!result.moved[1].length) next.set('forced', true);
                        }
                        else event.goto(4);
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        var card = result.links[0];
                        event.card = card;
                        player.chooseTarget('令一名其他角色获得' + get.translation(card), lib.filter.notMe, true).set('ai', function (target) {
                            var card = _status.event.card, player = _status.event.player;
                            var eff = Math.max(0.1, get.value(card, target)) * get.attitude(player, target);
                            if (target.hasSkill('nogain')) eff /= 10;
                            return eff;
                        }).set('card', card);
                    }
                    else event.goto(4);
                    'step 3'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target, 'green');
                        target.gain(card, 'gain2');
                        player.draw();
                    }
                    'step 4'
                    if (cards.length) {
                        game.log(player, '将', cards, '置于了牌堆顶');
                        while (cards.length) ui.cardPile.insertBefore(cards.pop().fix(), ui.cardPile.firstChild);
                    }
                },
            },
            minizhiyan: {
                audio: 'zhiyan',
                audioname2: { gexuan: 'zhiyan_gexuan' },
                trigger: { player: 'phaseJieshuBegin' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('zhiyan'), '令一名角色摸一张牌并展示之。若为非装备牌则你摸一张牌；若为装备牌则其使用此牌并回复1点体力').set('ai', function (target) {
                        return get.attitude(_status.event.player, target) * (target.isDamaged() ? 2 : 1);
                    });
                    'step 1'
                    if (result.bool) {
                        event.target = result.targets[0];
                        player.logSkill('minizhiyan', result.targets);
                        event.bool = false;
                        event.target.draw('visible');
                    }
                    else {
                        event.finish();
                    }
                    'step 2'
                    var card = result[0];
                    if (get.type(card) == 'equip') {
                        if (target.getCards('h').includes(card) && target.hasUseTarget(card)) {
                            event.target.chooseUseTarget(card, true, 'nopopup');
                            game.delay();
                        }
                    }
                    else {
                        player.draw();
                        event.finish();
                    }
                    'step 3'
                    target.recover();
                },
                ai: {
                    expose: 0.2,
                    threaten: 1.2
                },
            },
            //全琮
            miniyaoming: {
                audio: 'yaoming',
                trigger: {
                    player: ['damageEnd', 'phaseEnd'],
                    source: 'damageSource',
                },
                filter(event, player) {
                    const storage = player.storage.miniyaoming_kanon || { '摸牌': 0, '弃牌': 0, '制衡': 0 };
                    if (event.name == 'phase' && player.getHistory('useSkill', evt => evt.skill == 'miniyaoming').length) return false;
                    return game.hasPlayer(target => {
                        return ['摸牌', '弃牌', '制衡'].some(control => {
                            if (storage[control] > 1) return false;
                            if (control == '弃牌' && (target == player || !target.countCards('h'))) return false;
                            return true;
                        });
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    player.addTempSkill('miniyaoming_kanon');
                    var func = function () {
                        game.countPlayer(target => {
                            var list = ['摸牌', '弃牌', '制衡'].filter(control => {
                                var num = player.storage.miniyaoming_kanon[control];
                                if (num > 1) return false;
                                if (control == '弃牌' && (target == player || !target.countCards('h'))) return false;
                                return true;
                            }), str = '';
                            for (var i of list) str += (i + '<br>');
                            str = str.slice(0, -4);
                            target.prompt(str);
                        });
                    };
                    if (event.player == game.me) func();
                    else if (event.isOnline()) player.send(func);
                    player.chooseTarget(get.prompt2('miniyaoming'), (card, player, target) => {
                        var storage = player.storage.miniyaoming_kanon;
                        if (storage['摸牌'] < 2 || storage['制衡'] < 2) return true;
                        return storage['弃牌'] < 2 && target != player && target.countCards('h');
                    }).set('ai', target => {
                        var player = _status.event.player;
                        var storage = player.storage.miniyaoming_kanon;
                        if (get.attitude(player, target) > 0 && storage['摸牌'] < 2) return get.effect(target, { name: 'draw' }, player, player);
                        if (get.attitude(player, target) < 0 && storage['弃牌'] < 2 && target != player && target.countCards('h')) return get.effect(target, { name: 'guohe_copy2' }, player, player);
                        if (get.attitude(player, target) > 0 && storage['制衡'] < 2) return get.effect(target, { name: 'kaihua' }, player, player);
                        return 0;
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('miniyaoming', target);
                        var controls = ['摸牌', '弃牌', '制衡'].filter(control => {
                            var num = player.storage.miniyaoming_kanon[control];
                            if (num > 1) return false;
                            if (control == '弃牌' && (target == player || !target.countCards('h'))) return false;
                            return true;
                        });
                        if (controls.length == 1) event._result = { control: controls[0] };
                        else {
                            var str = get.translation(target);
                            var choiceList = [
                                '令' + str + '摸一张牌',
                                '弃置' + str + '一张手牌',
                                '令' + str + '摸两张牌，然后其弃置两张牌',
                            ];
                            var list = ['摸牌', '弃牌', '制衡'];
                            for (var i = 0; i < 3; i++) {
                                if (!controls.includes(list[i])) {
                                    choiceList[i] = '<span style="opacity:0.5">' + choiceList[i] + '</span>';
                                }
                            }
                            player.chooseControl(controls).set('choiceList', choiceList).set('ai', () => {
                                var player = _status.event.player;
                                var target = _status.event.target;
                                var controls = _status.event.controls.slice();
                                var map = {
                                    '摸牌': get.effect(target, { name: 'draw' }, player, player),
                                    '弃牌': get.effect(target, { name: 'guohe_copy2' }, player, player),
                                    '制衡': get.effect(target, { name: 'kaihua' }, player, player),
                                };
                                controls.sort((a, b) => map[b] - map[a]);
                                return controls[0];
                            }).set('target', target);
                        }
                    }
                    else event.finish();
                    'step 2'
                    player.storage.miniyaoming_kanon[result.control]++;
                    switch (result.control) {
                        case '摸牌':
                            target.draw();
                            break;
                        case '弃牌':
                            player.discardPlayerCard(target, 'h', true);
                            break;
                        case '制衡':
                            target.draw(2);
                            break;
                    }
                    if (result.control != '制衡') event.finish();
                    'step 3'
                    target.chooseToDiscard(2, 'he', true);
                },
                subSkill: {
                    kanon: {
                        charlotte: true,
                        onremove: true,
                        init(player) {
                            if (!player.storage.miniyaoming_kanon) player.storage.miniyaoming_kanon = { '摸牌': 0, '弃牌': 0, '制衡': 0 };
                        },
                    },
                },
            },
            //顾雍
            minishenxing: {
                audio: 'reshenxing',
                enable: 'phaseUse',
                usable: 20,
                async content(event, trigger, player) {
                    const num = Math.min(2, player.getStat('skill').minishenxing - 1);
                    await player.draw();
                    if (num) {
                        await player.chooseToDiscard('he', num, true);
                        if (!player.countDiscardableCards(player, 'he')) player.tempBanSkill('minishenxing', 'phaseUseAfter', false);
                    }
                },
                ai: {
                    order(item, player) {
                        const num = player.getStat('skill').minishenxing || 0;
                        if (!num) return 10;
                        if (num == 1) return 1;
                        return 0;
                    },
                    result: { player: 1 },
                },
            },
            miniligong: {
                audio: 'dcligong',
                inherit: 'dcligong',
                filter(event, player) {
                    var list = lib.skill.dchuishu.getList(player);
                    return list.some(i => i >= 5);
                },
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    await player.gainMaxHp();
                    await player.recover();
                    await player.removeSkills('dcyishu');
                    if (!_status.characterlist) game.initCharacterList();
                    const EditList = ((!_status.connectMode && game.getExtensionConfig('活动武将', 'PingJianName')) ? game.getExtensionConfig('活动武将', 'PingJianName') : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                    let list = EditList.filter(name => _status.characterlist.includes(name) && (get.character(name, 1) == 'wu' || (get.is.double(name, true) || []).includes('wu')) && ['female', 'double'].includes(get.character(name, 0)));
                    for (const current of game.players.concat(game.dead)) {
                        list.removeArray(get.nameList(current));
                    }
                    list = list.filter(name => {
                        return (lib.character[name][3] || []).some(skill => {
                            const info = get.info(skill);
                            return info && !info.charlotte;
                        });
                    }).randomGets(4);
                    const map = {};
                    for (const name of list) {
                        let skills = (lib.character[name][3] || []).filter(skill => {
                            const info = get.info(skill);
                            return info && !info.charlotte;
                        });
                        if (skills.length) map[name] = skills;
                    }
                    if (!Object.keys(map).length) return;
                    const result = await player.chooseButton([
                        `###离宫###<div class="text center">请选择获得至多两个技能，或点击“取消”摸三张牌</div>`,
                        [dialog => {
                            dialog.css({ top: get.is.phoneLayout() ? '20%' : '25%' });
                            const { characterMap: map } = get.event();
                            for (const name of Object.keys(map)) {
                                const table = document.createElement('div');
                                table.classList.add('add-setting');
                                table.style.margin = '0';
                                table.style.width = '100%';
                                table.style.position = 'relative';
                                table.style.display = 'flex';
                                table.style.justifyContent = 'flex-start';
                                table.style.alignItems = 'center';
                                const tdc = ui.create.button(name, 'character', table, true);
                                for (const item in tdc.node) {
                                    if (item == 'name') {
                                        tdc.node.name.style.writingMode = 'horizontal-tb';
                                    } else {
                                        tdc.node[item].hide();
                                    }
                                }
                                tdc.style.height = '40px';
                                lib.setIntro(tdc);
                                const skills = map[name];
                                for (let i = 0; i < skills.length; i++) {
                                    const td = ui.create.button([skills[i], get.translation(skills[i])], 'tdnodes', table);
                                    td.setNodeIntro(get.translation(skills[i]), get.skillInfoTranslation(skills[i], get.player()));
                                    dialog.buttons.add(td);
                                }
                                dialog.content.appendChild(table);
                            }
                        }, 'handle'],
                    ], [1, 2]).set('characterMap', map).set('ai', button => {
                        const { link } = button;
                        const info = get.info(link);
                        if (info?.ai?.neg) return 0;
                        return get.skillRank(link, 'inout');
                    }).forResult();
                    if (result?.links?.length) await player.changeSkills(result.links, ['dchuishu']);
                    else await player.draw(3);
                },
                derivation: 'Mbaby_characterlist_faq',
            },
            //蒋钦
            minijianyi: {
                audio: 'spjianyi',
                trigger: { global: 'phaseEnd' },
                filter(event, player) {
                    return player != event.player && game.getGlobalHistory('cardMove', evt => {
                        if (evt.name != 'lose' || evt.type != 'discard') return false;
                        return evt.cards.some(i => ['equip1', 'equip2'].includes(get.subtype(i, false)) && get.position(i, true) == 'd');
                    }).length > 0;
                },
                forced: true,
                async content(event, trigger, player) {
                    const cards = game.getGlobalHistory('cardMove', evt => {
                        if (evt.name != 'lose' || evt.type != 'discard') return false;
                        return evt.cards.some(i => ['equip1', 'equip2'].includes(get.subtype(i, false)) && get.position(i, true) == 'd');
                    }).reduce((list, evt) => {
                        return list.add(...evt.cards.filter(i => ['equip1', 'equip2'].includes(get.subtype(i, false)) && get.position(i, true) == 'd'));
                    }, []);
                    const result = await player.chooseButton(['俭衣：选择获得其中一张牌', cards], true).set('ai', button => {
                        return get.value(button.link, get.event().player);
                    }).forResult();
                    if (result.bool) await player.gain(result.links, 'gain2');
                },
            },
            minishangyi: {
                inherit: 'twshangyi',
                content() {
                    'step 0'
                    target.viewHandcards(player);
                    var chooseButton;
                    if (player.countCards('h')) chooseButton = player.chooseButton([1, 2], ['###尚义###<div class="text center">选择' + get.translation(target) + '的一张手牌获得之，或选择你与其的各一张牌以交换</div>', '<div class="text center">' + get.translation(target) + '的手牌</div>', target.getCards('h'), '<div class="text center">你的手牌</div>', player.getCards('h')], true);
                    else chooseButton = player.chooseButton(['###尚义###<div class="text center">弃置' + get.translation(target) + '的一张手牌</div>', '<div class="text center">' + get.translation(target) + '的手牌</div>', target.getCards('h')], true);
                    chooseButton.set('target', target);
                    chooseButton.set('ai', button => {
                        var player = _status.event.player, owner = get.owner(button.link), color = get.color(button.link, owner), value = get.value(button.link, owner);
                        if (player.countCards('h')) {
                            if (!ui.selected.buttons.length) {
                                if (player.countCards('h', card => {
                                    return get.color(card, player) == 'red' && get.value(card) < 6;
                                }) && color == 'red' && value > 7) return value * 3;
                                return value;
                            }
                            else {
                                if (get.value(ui.selected.buttons[0].link) < 4) return 0;
                                return 4 + (get.color(ui.selected.buttons[0].link, get.owner(ui.selected.buttons[0].link)) == 'red' ? 3 : 1) - value;
                            }
                        }
                        else {
                            if (color == 'black') return value * 1.5;
                            return value;
                        }
                    });
                    chooseButton.set('filterButton', button => {
                        if (get.itemtype(button.link) != 'card') return false;
                        if (!ui.selected.buttons.length && get.owner(button.link) != _status.event.target) return false;
                        if (ui.selected.buttons.length && get.owner(ui.selected.buttons[0].link) == get.owner(button.link)) return false;
                        return true;
                    });
                    'step 1'
                    if (result.bool) {
                        if (result.links.length == 1) {
                            player.gain(result.links, target, 'give');
                            if (get.color(result.links[0], target) != 'black') event.finish();
                        }
                        else {
                            var links = result.links.slice();
                            if (get.owner(links[0]) != player) links.reverse();
                            var card1 = links[0], card2 = links[1];
                            player.swapHandcards(target, [card1], [card2]);
                            if (get.color(card1, player) != 'red' || get.color(card2, target) != 'red') event.finish();
                        }
                    }
                    else event.finish();
                    'step 2'
                    player.draw();
                },
            },
            //吕岱
            miniqinguo: {
                inherit: 'xinfu_qinguo',
                async content(event, trigger, player) {
                    const result = await player.chooseUseTarget({ name: 'sha' }, get.prompt('xinfu_qinguo'), '视为使用一张【杀】，若此【杀】造成伤害，则你摸一张牌', false).set('logSkill', 'miniqinguo').forResult();
                    if (result.bool && game.hasPlayer2(target => {
                        return target.getHistory('damage', evt => evt.getParent(4) == event).length;
                    })) await player.draw();
                },
                group: 'miniqinguo_recover',
                subSkill: {
                    recover: {
                        audio: 'qinguo_use',
                        trigger: {
                            player: 'loseAfter',
                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                        },
                        filter(event, player) {
                            if (player.isHealthy() || player.countCards('e') < player.hp) return false;
                            var evt = event.getl(player);
                            if (event.name == 'equip' && event.player == player) return !evt || evt.cards.length != 1;
                            return evt?.es?.length;
                        },
                        frequent: true,
                        prompt: '是否发动【勤国】回复1点体力？',
                        content() {
                            player.recover();
                        },
                    },
                },
            },
            //新贺齐
            miniqizhou: {
                audio: 'qizhou',
                trigger: {
                    player: 'loseAfter',
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter', 'phaseBefore'],
                },
                filter(event, player) {
                    if (event.name != 'phase' && (event.name != 'equip' || event.player != player)) {
                        var evt = event.getl(player);
                        if (!evt || !evt.es || !evt.es.length) return false;
                    }
                    var num = player.countMark('miniqizhou');
                    return lib.skill.miniqizhou.getSuitNum(player) != num;
                },
                forced: true,
                popup: false,
                content() {
                    lib.skill.miniqizhou.init(player);
                },
                getSuitNum(player) {
                    var suits = [], es = player.getCards('e');
                    for (var i of es) suits.add(get.suit(i, player));
                    return Math.min(4, suits.length);
                },
                init(player) {
                    player.removeAdditionalSkill('miniqizhou');
                    var num = lib.skill.miniqizhou.getSuitNum(player);
                    player.storage.miniqizhou = num;
                    if (num > 0) player.addAdditionalSkill('miniqizhou', lib.skill.miniqizhou.derivation.slice(0, num));
                },
                onremove: true,
                derivation: ['reyingzi', 'minireqixi', 'decadexuanfeng', 'miniduanbing'],
            },
            minishanxi: {
                audio: 'shanxi',
                enable: 'phaseUse',
                filter(event, player) {
                    return game.hasPlayer((current) => lib.skill.minishanxi.filterTarget(null, player, current));
                },
                filterTarget(card, player, target) {
                    return target != player && player.countCards('h') + target.countCards('h') > 0 && !player.inRangeOf(target);
                },
                usable: 1,
                content() {
                    'step 0'
                    var cards1 = player.getCards('h'), cards2 = target.getCards('h');
                    var num = Array.from({ length: 5 }).map((_, i) => i + 1).reduce((sum, i) => sum + target.countEmptySlot(i), 1);
                    var dialog = ['闪袭：选择展示至多' + get.cnNumber(num) + '张牌'];
                    if (cards1.length > 0) {
                        dialog.push('<div class="text center">你的手牌</div>');
                        dialog.push(cards1);
                    }
                    if (cards2.length > 0) {
                        dialog.push('<div class="text center">' + get.translation(target) + '的手牌</div>');
                        if (player.hasSkillTag('viewHandcard', null, target, true)) dialog.push(cards2);
                        else dialog.push([cards2.randomSort(), 'blank']);
                    }
                    player.chooseButton(dialog, [1, num], true).set('ai', function (button) {
                        var player = _status.event.player, target = _status.event.getParent().target;
                        var card = button.link, cards = ui.selected.buttons.map(button => button.link);
                        var hs = player.getCards('h'), discard = false;
                        for (var i of cards) {
                            if (hs.includes(i)) {
                                discard = true;
                                break;
                            }
                        }
                        if (hs.includes(card)) {
                            if (discard || get.name(card) != 'shan') return 0;
                            if (target.hasCard(card => get.value(card, target) > 5, 'e')) return 2;
                            return 0;
                        }
                        if (discard && !target.hasCard(function (cardx) {
                            return cardx != card && !cards.includes(cardx) && get.value(cardx, target) > 0;
                        }, 'he')) return 0;
                        return 1 + Math.random();
                    });
                    'step 1'
                    if (result.bool) {
                        event.cards = result.links;
                        var list1 = [], list2 = [];
                        var hs = player.getCards('h');
                        for (var card of result.links) {
                            if (hs.includes(card)) {
                                list1.push(card);
                            }
                            else {
                                list2.push(card);
                            }
                        }
                        event.list1 = list1;
                        event.list2 = list2;
                        event.videoId = lib.status.videoId++;
                        game.broadcastAll(function (player, target, list1, list2, id) {
                            var dialog = ui.create.dialog(player + '对' + target + '发动了【闪袭】');
                            dialog.videoId = id;
                            if (list1.length > 0) {
                                dialog.add('<div class="text center">' + player + '展示的牌</div>');
                                dialog.add(list1);
                            }
                            if (list2.length > 0) {
                                dialog.add('<div class="text center">' + target + '被展示的牌</div>');
                                dialog.add(list2);
                            }
                        }, get.translation(player), get.translation(target), list1, list2, event.videoId)
                        game.delay(4);
                    }
                    else event.finish();
                    'step 2'
                    game.broadcastAll('closeDialog', event.videoId);
                    var list1 = event.list1.filter((card) => get.name(card, player) == 'shan');
                    var list2 = event.list2.filter((card) => get.name(card, target) == 'shan');
                    if (list1.length && list2.length) {
                        game.loseAsync({
                            lose_list: [
                                [player, list1],
                                [target, list2]
                            ],
                            discarder: player,
                        }).setContent('discardMultiple');
                    }
                    else if (list2.length) {
                        target.discard(list2);
                    }
                    else if (list1.length) player.discard(list1);
                    else event.finish();
                    'step 3'
                    if (target.hasCard(function (card) {
                        return !cards.includes(card) && lib.filter.canBeGained(card, player, target);
                    }, 'he')) player.gainPlayerCard(target, true, 'he').set('filterButton', function (button) {
                        return !_status.event.cards.includes(button.link);
                    }).set('cards', cards);
                },
                ai: {
                    order: 14,
                    result: {
                        target(player, target) {
                            return -target.countCards('h');
                        },
                    },
                },
            },
            //孙寒华
            minihuiling: {
                audio: 'dchuiling',
                inherit: 'dchuiling',
                trigger: {
                    player: ['useCard', 'loseAfter'],
                    global: 'loseAsyncAfter',
                },
                filter(event, player) {
                    if (!ui.discardPile.childElementCount) return false;
                    if (event.name == 'useCard') return true;
                    return event.type == 'discard' && event.getl(player).cards2.length > 0;
                },
                content() {
                    'step 0';
                    var mark = false;
                    var red = 0,
                        black = 0;
                    for (var i = 0; i < ui.discardPile.childElementCount; i++) {
                        var color = get.color(ui.discardPile.childNodes[i]);
                        if (color == 'red') red++;
                        if (color == 'black') black++;
                    }
                    if (red == black) event.finish();
                    else if (red > black) {
                        player.logSkill(event.name);
                        player.recover();
                        event.finish();
                        if (get.color(trigger.card) == 'black') mark = true;
                        event.logged = true;
                    } else {
                        if (!event.isMine() && !event.isOnline()) game.delayx();
                        player
                            .chooseTarget(get.prompt(event.name), '弃置一名角色区域内的一张牌', (card, player, target) => {
                                return target.countDiscardableCards(player, 'hej') > 0;
                            })
                            .set('ai', target => {
                                return get.effect(target, { name: 'guohe_copy2' }, _status.event.player);
                            });
                        if (get.color(trigger.card) == 'red') mark = true;
                    }
                    if (mark) {
                        if (!event.logged) player.logSkill(event.name);
                        player.addMark(event.name, 1);
                        event.logged = true;
                    }
                    'step 1';
                    if (result.bool) {
                        var target = result.targets[0];
                        if (!event.logged) player.logSkill(event.name, target);
                        else player.line(target);
                        player.discardPlayerCard(target, 'hej', true);
                    }
                },
            },
            minichongxu: {
                audio: 'dcchongxu',
                inherit: 'dcchongxu',
                prompt() {
                    return '限定技。你可以失去〖汇灵〗，增加' + Math.min(game.countPlayer(), _status.event.player.countMark('minihuiling')) + '点体力上限，然后获得〖踏寂〗和〖清荒〗。';
                },
                filter(event, player) {
                    return player.countMark('minihuiling') >= 4;
                },
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    const num = player.countMark('minihuiling');
                    await player.removeSkills('minihuiling');
                    await player.gainMaxHp(Math.min(game.countPlayer(), num));
                    await player.addSkills(['dctaji', 'dcqinghuang']);
                },
                ai: {
                    combo: 'minihuiling',
                    order(itemp, player) {
                        if (
                            player.hasCard(card => {
                                return get.type(card) != 'equip' && player.getUseValue(card) > 1;
                            }, 'h')
                        )
                            return 12;
                        return 0.1;
                    },
                    result: {
                        player(player) {
                            var count = player.countMark('minihuiling');
                            if (count >= game.countPlayer() - 1) return 1;
                            return count >= 6 || player.hp <= 2 ? 1 : 0;
                        },
                    },
                },
            },
            //张温
            minisongshu: {
                audio: 'songshu',
                inherit: 'songshu',
                usable: 1,
                filter(event, player) {
                    return game.hasPlayer(current => get.info('songshu').filterTarget(null, player, current));
                },
                async content(event, trigger, player) {
                    const { target } = event;
                    const { bool } = await player.chooseToCompare(target).set('small', get.attitude(player, target) > 0).forResult();
                    if (!bool) {
                        const { bool: draw } = await player.chooseBool(`是否与${get.translation(target)}各摸两张牌`).forResult();
                        if (draw) await game.asyncDraw([player, target], 2);
                    }
                    else {
                        delete player.getStat().skill.minisongshu;
                        game.log(player, '重置了', '#g【颂蜀】');
                    }
                },
            },
            minisibian: {
                audio: 'sibian',
                inherit: 'sibian',
                async content(event, trigger, player) {
                    trigger.changeToZero();
                    const cards = get.cards(4);
                    await game.cardsGotoOrdering(cards);
                    await player.showCards(event.cards);
                    cards.sort(function (a, b) {
                        return b.number - a.number;
                    });
                    const gains = [];
                    const mx = [cards[0].number, cards[3].number];
                    for (var i = 0; i < cards.length; i++) {
                        if (mx.includes(cards[i].number)) gains.addArray(cards.splice(i--, 1));
                    }
                    await player.gain(gains, 'gain2');
                    if (!cards.length || !game.hasPlayer(current => current.isMinHandcard() || current.isMaxHandcard())) return;
                    const { targets } = await player.chooseTarget('是否令一名手牌数最少或最多的角色获得' + get.translation(cards), (card, player, target) => {
                        return target.isMinHandcard() || target.isMaxHandcard();
                    }).set('ai', target => {
                        return get.attitude(_status.event.player, target);
                    }).forResult();
                    if (!targets || !targets.length) return;
                    player.line(targets[0]);
                    player.addExpose(0.2);
                    await targets[0].gain(cards, 'gain2');
                },
            },
            // 卫诸
            minifuhai: {
                inherit: 'jsrgfuhai',
                async content(event, trigger, player) {
                    const targets = event.targets.sortBySeat();
                    const next = player.chooseCardOL(targets, '请展示一张手牌', true).set('ai', card => {
                        return -get.value(card);
                    }).set('aiCard', target => {
                        const hs = target.getCards('h');
                        return { bool: true, cards: [hs.randomGet()] };
                    });
                    next._args.remove('glow_result');
                    const result = await next.forResult();
                    const cards = [];
                    const videoId = lib.status.videoId++;
                    for (let i = 0; i < targets.length; i++) {
                        cards.push(result[i].cards[0]);
                        game.log(targets[i], '展示了', result[i].cards[0]);
                    }
                    game.broadcastAll((targets, cards, id, player) => {
                        var dialog = ui.create.dialog(get.translation(player) + '发动了【浮海】', cards);
                        dialog.videoId = id;
                        const getName = target => {
                            if (target._tempTranslate) return target._tempTranslate;
                            var name = target.name;
                            if (lib.translate[name + '_ab']) return lib.translate[name + '_ab'];
                            return get.translation(name);
                        };
                        for (let i = 0; i < targets.length; i++) {
                            dialog.buttons[i].querySelector('.info').innerHTML = getName(targets[i]) + '|' + get.strNumber(cards[i].number);
                        }
                    }, targets, cards, videoId, player);
                    await game.delay(4);
                    game.broadcastAll('closeDialog', videoId);
                    let clock = -1, anticlock = -1;
                    for (let j = 0; j < 2; j++) {
                        let increase = -Infinity, decrease = Infinity, count = 0;
                        for (let i = 0; i < targets.length; i++) {
                            const number = get.number(cards[i], false);
                            let flag = false;
                            if (number > increase) {
                                increase = number;
                                flag = true;
                            } else increase = Infinity;
                            if (number < decrease) {
                                decrease = number;
                                flag = true;
                            } else decrease = -Infinity;
                            if (flag) count++;
                            else break;
                        }
                        targets.reverse();
                        cards.reverse();
                        if (j == 0) anticlock = Math.max(2, count);
                        else clock = Math.max(2, count);
                    }
                    const result2 = await player.chooseControl(`↖顺时针(${clock})`, `逆时针(${anticlock})↗`).set('prompt', '请选择一个方向，摸对应数量的牌').set('ai', () => get.event().choice).set('choice', clock > anticlock ? 0 : 1).forResult();
                    await player.draw(result2?.index == 0 ? clock : anticlock);
                },
            },
            // 潘马
            miniduodao: {
                audio: 'reduodao',
                inherit: 'reduodao',
                async cost(event, trigger, player) {
                    const { player: target, card } = trigger, goon = get.color(card) === 'red';
                    let prompt = '弃置一张牌，然后', cards = target.getEquips(1).filter(card => {
                        return lib.filter.canBeGained(card, player, target);
                    });
                    if (goon) {
                        if (target.countGainableCards(player, 'hej')) prompt += '获得' + get.translation(target) + '区域内的一张牌';
                        else prompt += '无事发生';
                    }
                    else {
                        if (cards.length) prompt += '获得' + get.translation(target) + '装备区中的' + get.translation(cards);
                        else prompt += '无事发生';
                    }
                    event.result = await player.chooseToDiscard('he', get.prompt(event.name.slice(0, -5), target), prompt).set('ai', card => {
                        const { player, target, goon, eff } = get.event();
                        if (goon) {
                            let att = get.attitude(player, target);
                            if (att < 0) att = -Math.sqrt(-att);
                            else att = Math.sqrt(att);
                            if (att * lib.card.shunshou.ai.result.target(player, target) > 0) return 6.5 - get.value(card);
                            return 0;
                        }
                        if (typeof eff === 'number') return eff - get.value(card);
                        return 0;
                    }).set('eff', function () {
                        let es = trigger.player.getEquips(1).filter(card => {
                            return lib.filter.canBeGained(card, player, trigger.player);
                        });
                        if (!es.length) return false;
                        if (get.attitude(player, trigger.player) > 0) return -2 * es.reduce((acc, card) => {
                            return acc + get.value(card, trigger.player);
                        }, 0);
                        return 2 * es.reduce((acc, card) => {
                            return acc + get.value(card, player);
                        }, 0);
                    }()).set('target', target).set('goon', goon).forResult();
                },
                async content(event, trigger, player) {
                    const { player: target, card } = trigger;
                    if (get.color(card) == 'red') {
                        if (target.countGainableCards(player, 'hej')) await player.gainPlayerCard(target, 'hej', true);
                    }
                    else {
                        const cards = target.getEquips(1).filter(card => {
                            return lib.filter.canBeGained(card, player, target);
                        });
                        if (cards.length) await player.gain(cards, target, 'give', 'bySelf');
                    }
                },
            },
            minianjian: {
                audio: 'reanjian',
                inherit: 'xinanjian',
                async content(event, trigger, player) {
                    const { card, target } = trigger, str1 = get.translation(card), str2 = get.translation(target);
                    if (!card.storage) card.storage = {};
                    card.storage[event.name] = true;
                    target.when({ player: 'dyingBegin' }).filter(evt => evt.getParent(3) == trigger.getParent()).then(() => {
                        player.addTempSkill('minianjian_ban', { global: ['dyingEnd', 'phaseEnd'] });
                    })
                    const result = await player.chooseControl().set('prompt', '暗箭：请选择一项').set('choiceList', [`令${str2}不能响应${str1}`, `令${str1}对${str2}的伤害值基数+1`]).set('ai', () => {
                        const target = get.event().getTrigger().target;
                        const player = get.event().player;
                        let num = target.mayHaveShan(player, 'use', target.getCards('h', i => {
                            return i.hasGaintag('sha_notshan');
                        })) ? 0 : 1;
                        if (get.attitude(player, target) > 0) num = 1 - num;
                        return num;
                    }).forResult();
                    if (result?.index == 0) {
                        game.log(player, '令', card, '不能被', target, '响应');
                        trigger.directHit.push(target);
                    } else {
                        game.log(player, '令', card, '对', target, '的伤害+1');
                        const id = target.playerid;
                        const map = trigger.customArgs;
                        if (!map[id]) map[id] = {};
                        if (!map[id].extraDamage) map[id].extraDamage = 0;
                        map[id].extraDamage++;
                    }
                },
                ai: {
                    unequip: true,
                    unequip_ai: true,
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (tag == 'unequip' && (!arg || !arg.card || !arg.card.storage || !arg.card.storage.minianjian)) return false;
                        if (tag == 'unequip_ai' && (!arg || arg.name != 'sha')) return false;
                        if (tag == 'directHit_ai' && (!arg || !arg.card || !arg.target || arg.card.name != 'sha' || arg.target.inRange(player) || get.attitude(player, arg.target) > 0)) return false;
                    },
                },
                subSkill: {
                    ban: {
                        charlotte: true,
                        mod: {
                            cardSavable(card) {
                                if (card.name == 'tao') return false;
                            },
                        },
                    }
                }
            },
            // 阚泽
            minikuanshi: {
                audio: 'rekuanshi',
                trigger: { player: 'phaseJieshuBegin' },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.name.slice(0, -5))).set('animate', false).set('ai', target => {
                        let att = get.attitude(get.player(), target);
                        if (target.hp < 3) att /= 1.5;
                        return att;
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const target = event.targets[0];
                    const history = target.getAllHistory('damage');
                    if (history.length) history[history.length - 1][event.name + '_mark'] = true;
                    player.addTempSkill(event.name + '_effect', { player: 'phaseBegin' });
                    player.markAuto(event.name + '_effect', [target]);
                    await game.delayx();
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '当$于每两次受到伤害后，其回复1点体力' },
                        trigger: { global: 'damageEnd' },
                        filter(event, player) {
                            const { player: target } = event;
                            if (!player.getStorage('minikuanshi_effect').includes(target) || target.isHealthy()) return false;
                            let history = target.getAllHistory('damage', null, event), num = 0;
                            for (let i = history.length - 1; i >= 0; i--) {
                                const evt = history[i];
                                if (evt['minikuanshi_mark']) break;
                                num++;
                            }
                            return num % 2 == 0;
                        },
                        forced: true,
                        logTarget: 'player',
                        content() {
                            trigger.player.recover();
                        },
                    },
                },
            },
            //谋甘宁
            minisbqixi: {
                audio: 'sbqixi',
                enable: 'phaseUse',
                usable: 1,
                filter(event, player) {
                    return game.hasPlayer(current => player != current);
                },
                chooseButton: {
                    dialog(event, player) {
                        return ui.create.dialog('###奇袭###' + get.translation('minisbqixi_info'));
                    },
                    chooseControl(event, player) {
                        return lib.suit.slice().concat(['cancel2']);
                    },
                    check(event, player) {
                        return get.event().controls.remove('cancel2').randomGet();
                    },
                    backup(result, player) {
                        return {
                            audio: 'minisbqixi',
                            suit: result.control,
                            filterTarget: lib.filter.notMe,
                            filterCard: () => false,
                            selectCard: -1,
                            async content(event, trigger, player) {
                                const { suit } = get.info('minisbqixi_backup');
                                const { target } = event;
                                let num = 1, list = lib.suit.slice();
                                while (true) {
                                    const result = list.length == 1 ? { control: list[0] } : await target.chooseControl(list).set('prompt', `奇袭：猜测${get.translation(player)}声明的花色`).set('ai', () => {
                                        const controls = get.event().controls;
                                        if (controls.includes('diamond') && Math.random() < 0.3) return 'diamond';
                                        return controls.randomGet();
                                    }).forResult();
                                    if (result?.control) {
                                        const { control } = result;
                                        target.chat(`我猜是${get.translation(control)}！`);
                                        game.log(target, '猜测为', '#y' + control);
                                        if (!event.isMine() && !event.isOnline()) await game.delayx();
                                        if (suit !== control) {
                                            player.chat('猜错了！');
                                            game.log(target, '猜测', '#y错误');
                                            num++;
                                            list.remove(control);
                                        }
                                        else {
                                            player.chat(num == 1 ? '这么准？' : '猜对了！');
                                            game.log(target, '猜测', '#g正确');
                                            break;
                                        }
                                    }
                                    else break;
                                }
                                if (target.countDiscardableCards(player, 'hej')) {
                                    player.line(target);
                                    await player.discardPlayerCard(target, num, true, 'hej');
                                }
                            },
                            ai: {
                                result: {
                                    target(player, target) {
                                        return get.effect(target, { name: 'guohe' }, player, target) * (5 - get.attitude(player, target) / 2);
                                    },
                                }
                            }
                        }
                    },
                    prompt: () => '请选择【奇袭】的目标',
                },
                ai: {
                    order: 10,
                    result: { player: 1 },
                },
                subSkill: { backup: {} },
            },
            minisbfenwei: {
                audio: 'sbfenwei',
                inherit: 'sbfenwei',
                usable: 1,
                prompt: '将至多三张牌称为“威”分别置于等量名角色的武将牌上，然后你摸等量牌',
                content() {
                    'step 0'
                    for (var i = 0; i < cards.length; i++) {
                        targets[i].addToExpansion(cards[i], player, 'give').gaintag.add(event.name);
                    }
                    'step 1'
                    player.draw(cards.length);
                },
                limited: false,
                skillAnimation: false,
                animationColor: false,
                marktext: '威',
                intro: {
                    name: '威',
                    markcount: 'expansion',
                    content: 'expansion',
                },
                group: 'minisbfenwei_effect',
                subSkill: {
                    effect: {
                        audio: 'sbfenwei',
                        trigger: { global: 'useCardToTarget' },
                        filter(event, player) {
                            return event.target.getExpansions('minisbfenwei').length > 0 && get.type2(event.card) === 'trick';
                        },
                        forced: true,
                        logTarget: 'target',
                        async content(event, trigger, player) {
                            const target = trigger.target, str = get.translation(target), cards = target.getExpansions('minisbfenwei');
                            const result = await player.chooseControl().set('choiceList', [
                                '令' + str + '获得' + get.translation(cards),
                                '移去' + str + '的“威”，令' + get.translation(trigger.card) + '对其无效',
                                '移去' + str + '的“威”，令其不可响应' + get.translation(trigger.card),
                                '移去' + str + '的“威”，你摸一张牌',
                            ]).set('prompt', '奋威：请选择一项').set('ai', () => {
                                const player = get.player(), trigger = get.event().getTrigger(), target = trigger.target;
                                const map = {
                                    0: target.getExpansions('minisbfenwei').reduce((sum, card) => {
                                        return sum + get.value(card, target) * Math.sign(get.attitude(player, target));
                                    }, 0),
                                    1: -get.effect(target, trigger.card, trigger.player, player),
                                    2: (() => {
                                        let num = 1.3;
                                        if (trigger.card.name == 'sha' && (() => {
                                            if (target.mayHaveShan(player, 'use', current.getCards('h', i => {
                                                return i.hasGaintag('sha_notshan');
                                            })) && get.attitude(player, target) <= 0) {
                                                if (target.hasSkillTag('useShan')) num = 1.9;
                                                return true;
                                            }
                                            return false;
                                        })()) return num + Math.random();
                                        return 0.5 + Math.random();
                                    })(),
                                    3: get.effect(player, { name: 'draw' }, player, player),
                                };
                                return Array.from({ length: 4 }).map((_, i) => i).sort((a, b) => map[b] - map[a])[0];
                            }).forResult();
                            if (result.index === 0) {
                                await target.gain(cards, target, 'give');
                            }
                            else {
                                await target.loseToDiscardpile(cards);
                                switch (result.index) {
                                    case 1:
                                        trigger.targets.remove(target);
                                        trigger.getParent().triggeredTargets2.remove(target);
                                        trigger.untrigger();
                                        game.log(trigger.card, '对', target, '无效');
                                        break;
                                    case 2:
                                        trigger.getParent().directHit.add(target);
                                        game.log(target, '不能响应', trigger.card);
                                        break;
                                    case 3:
                                        await player.draw();
                                        break;
                                }
                            }
                        },
                    },
                },
            },
            //陈武董袭
            miniduanxie: {
                audio: 'duanxie',
                inherit: 'duanxie',
                selectTarget() {
                    return [1, game.hasPlayer(current => current.isLinked()) ? 1 : 2];
                },
            },
            minifenming: {
                audio: 'fenming',
                inherit: 'fenming',
                filter(event, player) {
                    return get.info('minifenming').logTarget(event, player).length;
                },
                logTarget(event, player) {
                    return game.filterPlayer(current => current.isLinked() && current.countDiscardableCards(player, "he")).sortBySeat();
                },
                async content(event, trigger, player) {
                    let num = 0;
                    for (const target of event.targets) {
                        if (!target.countDiscardableCards(player, "he")) continue;
                        const { bool } = await player.discardPlayerCard(target, 'he', true).forResult();
                        if (bool) num++;
                    }
                    if (num > 0) await player.draw(num);
                },
            },
            // 许贡
            minibiaozhao: {
                audio: 'biaozhao',
                trigger: { global: 'roundStart' },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), 2).set('ai', target => {
                        const player = get.player();
                        const att = get.attitude(player, target);
                        if (!ui.selected.targets.length) return att * (Math.sqrt(target.countCards('hs')) + 0.1);
                        return -att / Math.sqrt(target.countCards('hs') + 0.1);
                    }).set('targetprompt', ['用牌无限制', '打你变疼']).forResult();
                },
                async content(event, trigger, player) {
                    const { targets } = event;
                    const [target1, target2] = targets;
                    const effect = event.name + '_syujin';
                    player.addTempSkill(effect, { player: 'die', global: 'roundStart' });
                    player.storage[effect] ??= [];
                    player.storage[effect].push(targets);
                    target1.addSkill(event.name + '_A');
                    target1.markAuto(event.name + '_A', [target2]);
                    target2.addSkill(event.name + '_B');
                    target2.addMark(event.name + '_B' + player.playerid, 1, false);
                    target2.markAuto(event.name + '_B', [player]);
                },
                subSkill: {
                    syujin: {
                        charlotte: true,
                        onremove(player, skill) {
                            const list = player.storage.minibiaozhao_syujin;
                            for (const targets of list) {
                                targets[0].unmarkAuto('minibiaozhao_A', [targets[1]]);
                                targets[1].unmarkAuto('minibiaozhao_B', [player]);
                                delete targets[1].storage['minibiaozhao_B' + player.playerid];
                                if (!targets[0].getStorage('minibiaozhao_A')) targets[0].removeSkill('minibiaozhao_A');
                                if (!targets[1].getStorage('minibiaozhao_B')) targets[1].removeSkill('minibiaozhao_B');
                            }
                            delete player.storage.minibiaozhao_syujin;
                        },
                    },
                    A: {
                        charlotte: true,
                        onremove: true,
                        mark: true,
                        marktext: '表',
                        intro: { content: '对$使用牌无次数和距离限制' },
                        mod: {
                            targetInRange(card, player, target) {
                                if (player.getStorage('minibiaozhao_A').includes(target)) return true;
                            },
                            cardUsableTarget(card, player, target) {
                                if (player.getStorage('minibiaozhao_A').includes(target)) return true;
                            },
                        },
                    },
                    B: {
                        charlotte: true,
                        onremove(player, skill) {
                            for (var i in player.storage) {
                                if (i.indexOf('minibiaozhao_B') == 0) delete player.storage[i];
                            }
                        },
                        trigger: { source: 'damageBegin1' },
                        filter(event, player) {
                            return event.card && player.getStorage('minibiaozhao_B').includes(event.player);
                        },
                        forced: true,
                        async content(event, trigger, player) {
                            trigger.num += player.countMark(event.name + trigger.player.playerid) || 1;
                        },
                        mark: true,
                        marktext: '召',
                        intro: {
                            content(storage, player) {
                                let str = '';
                                for (const target of storage) {
                                    str += '对' + get.translation(target) + '使用牌造成的伤害+' + player.countMark('minibiaozhao_B' + target.playerid);
                                }
                                return str;
                            },
                        },
                    },
                }
            },
            miniyechou: {
                audio: 'yecchou',
                trigger: { player: 'die' },
                forceDie: true,
                skillAnimation: true,
                animationColor: 'wood',
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), lib.filter.notMe).set('forceDie', true).set('ai', target => {
                        const player = get.player();
                        let att = get.attitude(player, target);
                        if (att > 0) return 0;
                        att = Math.sqrt(0.01 - att);
                        return att * (get.distance(_status.currentPhase, target, 'absolute') || game.players.length);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const { targets: [target] } = event;
                    player.line(target, 'green');
                    target.addTempSkill(event.name + '_buff', { player: 'phaseBegin' });
                    target.addSkill(event.name + '_effect');
                    target.addMark(event.name + '_effect', 1, false);

                },
                subSkill: {
                    buff: {
                        charlotte: true,
                        trigger: { global: 'phaseEnd' },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            await player.loseHp();
                        },
                        mark: true,
                        marktext: '仇',
                        intro: { content: '每个回合结束时失去1点体力直到回合开始' },
                    },
                    effect: {
                        charlotte: true,
                        onremove: true,
                        trigger: { player: 'damageBegin3' },
                        filter(event, player) {
                            return event.num >= player.getHp();
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            trigger.num *= 2 * player.countMark(event.name);
                        },
                        mark: true,
                        marktext: '仇',
                        intro: { content: '当你受到伤害值不小于体力值的伤害时，此伤害翻&倍' },
                        ai: {
                            effect: {
                                target(card, player, target) {
                                    if (get.tag(card, 'damage')) {
                                        if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                        if (target.hp == 1) return 2;
                                    }
                                },
                            },
                        },
                    }
                }
            },
            // 朱佩兰
            minicilv: {
                audio: 'dccilv',
                inherit: 'dccilv',
                filter(event, player) {
                    return get.type(event.card) == 'trick';
                },
                async content(event, trigger, player) {
                    const num = Math.max(1, 3 - player.getStorage(event.name).length);
                    await player.draw(num);
                    if (player.countCards('h') > player.maxHp && player.getStorage(event.name).length < 3) {
                        let result, list = ['无效', '防伤', '获得'].filter(i => !player.getStorage(event.name).includes(i));
                        if (list.length == 1) result = { control: list[0] };
                        else result = await player.chooseControl(list).set('prompt', '辞虑：选择执行并移去一项').set('ai', () => {
                            const player = get.event().player, trigger = get.event().getTrigger(), card = trigger.card;
                            let controls = get.event().controls.slice();
                            if (controls.includes('防伤')) {
                                if (get.tag(card, 'damage')) return '防伤';
                                else controls.remove('防伤');
                            }
                            if (get.effect(player, trigger.card, trigger.player, player) < 0 && controls.includes('无效')) return '无效';
                            return controls[controls.length - 1];
                        }).forResult();
                        if (!result?.control) return;
                        const choice = result.control;
                        player.popup(choice);
                        game.log(player, '选择了', '#y' + choice);
                        switch (choice) {
                            case '无效':
                                trigger.getParent().excluded.add(player);
                                game.log(trigger.card, '对', player, '无效');
                                break;
                            case '防伤':
                                player.addTempSkill(event.name + '_effect');
                                player.markAuto(event.name + '_effect', [trigger.card]);
                                break;
                            case '获得':
                                player.when({ global: 'useCardAfter' }).filter(evt => evt == trigger.getParent()).then(() => {
                                    const cards = (trigger.cards || []).filterInD();
                                    if (cards.length) player.gain(cards, 'gain2');
                                });
                                break;
                        }
                        player.markAuto(event.name, [choice]);
                    }
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        trigger: { player: 'damageBegin4' },
                        filter(event, player) {
                            const evt = event.getParent(2);
                            return evt?.name === 'useCard' && player.getStorage('minicilv_effect').includes(evt.card);
                        },
                        forced: true,
                        async content(event, trigger, player) {
                            trigger.cancel();
                        },
                        ai: {
                            effect: {
                                target(card, player, target) {
                                    if (player.getStorage('minicilv_effect').includes(card)) return 'zeroplayertarget';
                                },
                            },
                        },
                    },
                },
            },
            minitongye: {
                audio: 'sbtongye',
                trigger: {
                    global: ['phaseBefore', 'washCard'],
                    player: ['enterGame', 'changeSkillsAfter'],
                },
                filter(event, player) {
                    const skill = 'minitongye', skills = player.additionalSkills?.[skill] ?? [];
                    if (event.name === 'cardsGotoPile') return skills.length > 0;
                    if (event.name === 'changeSkills' && !event.addSkill.includes(skill)) return false;
                    if (!get.info(skill).derivation.some(skill2 => !skills.includes(skill2))) return false;
                    return event.name !== 'phase' || game.phaseNumber === 0;
                },
                forced: true,
                async content(event, trigger, player) {
                    const goon = (trigger.name === 'cardsGotoPile'), skill = event.name, skills = get.info(skill).derivation;
                    await player[goon ? 'removeAdditionalSkills' : 'addAdditionalSkills'](...(goon ? [skill] : [skill, skills]));
                },
                derivation: ['sbyingzi', 'miniguzheng'],
                onremove(player, skill) {
                    player.removeAdditionalSkills(skill);
                },
            },
            // 谢灵毓
            miniyuandi: {
                init: () => { game.addGlobalSkill('miniyuandi_ai') },
                onremove: () => {
                    if (!game.hasPlayer(i => i.hasSkill('miniyuandi', null, null, false), true)) game.removeGlobalSkill('miniyuandi_ai');
                },
                audio: 'dcyuandi',
                trigger: { global: 'useCard' },
                filter(event, player) {
                    const evt = event.getParent('phaseUse');
                    if (!evt || evt.player != event.player) return false;
                    if (event.player == player || !event.targets || event.targets.length > 1 || event.targets[0] != event.player) return false;
                    return event.player.getHistory('useCard', evtx => evtx.getParent('phaseUse') == evt && evtx.targets?.length == 1 && evtx.targets[0] == event.player).indexOf(event) == 0;
                },
                async cost(event, trigger, player) {
                    const { player: target } = trigger;
                    const name = get.translation(target);
                    const choices = ['选项二'];
                    const choiceList = [`弃置${name}一张手牌`, `你与${name}各摸一张牌`];
                    if (target.countDiscardableCards(player, 'h')) choices.unshift('选项一');
                    else choiceList[0] = '<span style="opacity:0.5">' + choiceList[0] + '</span>';
                    const next = player.chooseControl(choices, 'cancel2');
                    next.set('choiceList', choiceList)
                    next.set('prompt', get.prompt(event.skill, target))
                    next.set('ai', () => {
                        return get.event().choice;
                    });
                    next.set('choice', (() => {
                        if (get.attitude(player, target) < 0) {
                            if (choices.includes('选项一')) return '选项一';
                            return 'cancel2';
                        }
                        return '选项二';
                    })());
                    const result = await next.forResult();
                    event.result = {
                        bool: result?.control != 'cancel2',
                        cost_data: result?.control,
                    }
                },
                logTarget: 'player',
                async content(event, trigger, player) {
                    const { targets: [target], cost_data } = event;
                    if (cost_data == '选项一') {
                        await player.discardPlayerCard(target, 'h', true);
                        if (get.mode() !== 'identity' || player.identity !== 'nei') player.addExpose(0.15);
                    } else await game.asyncDraw([target, player]);
                },
                subSkill: {
                    ai: {
                        mod: {
                            aiOrder(player, card, num) {
                                const info = get.info(card);
                                if (!info?.toself) return;
                                const evt = get.event().getParent('phaseUse');
                                if (!evt || evt.player != player) return;
                                if (player.hasHistory('useCard', evtx => evtx.getParent('phaseUse') == evt && evtx.targets?.length == 1 && evtx.targets[0] == player)) return;
                                if (game.hasPlayer(current => {
                                    return current.hasSkill('miniyuandi') && get.attitude(player, current) >= 0;
                                })) return num + 10;
                                return num / 3;
                            },
                        },
                        trigger: { player: 'dieAfter' },
                        filter(event, player) {
                            return !game.hasPlayer(current => current.hasSkill('miniyuandi', null, null, false), true);
                        },
                        silent: true,
                        forceDie: true,
                        async content(event, trigger, player) {
                            game.removeGlobalSkill(event.name);
                        },
                    }
                }
            },
            // 吕范
            minidiaodu: {
                audio: 'diaodu',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return game.hasPlayer(target => get.distance(player, target) <= 1 && target.countGainableCards(player, 'e'));
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), (card, player, target) => {
                        return get.distance(player, target) <= 1 && target.countGainableCards(player, 'e');
                    }).set('ai', target => {
                        const player = get.player();
                        return get.effect(target, { name: 'shunshou_copy', position: 'e' }, player, player);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const { targets: [sourceTarget] } = event;
                    if (!sourceTarget.countGainableCards(player, 'e')) return;
                    let result = await player.gainPlayerCard(sourceTarget, 'e', true).forResult();
                    if (!result?.bool || !result?.cards?.length) return;
                    const [card] = result.cards;
                    if (!game.hasPlayer(target => target != sourceTarget) || get.owner(card) != player) return;
                    result = await player.chooseTarget(`调度：将${get.translation(card)}交给另一名角色`, (card, player, target) => {
                        return target != get.event().sourceTarget;
                    }, true).set('ai', target => {
                        const player = get.player();
                        return get.attitude(player, target);
                    }).set('sourceTarget', sourceTarget).forResult();
                    if (!result?.targets?.length) return;
                    const [target] = result.targets;
                    player.line(target, 'green');
                    if (target != player) await player.give([card], target);
                    if (get.owner(card) == target) {
                        result = await target.chooseUseTarget(card).forResult();
                        if (result?.bool) await player.draw();
                        else await target.draw();
                    }
                },
            },
            minidiancai: {
                getNum(event, player) {
                    return player.getHistory('lose', evt => {
                        return evt.cards2?.length && evt.getParent('phaseUse') == event;
                    }).reduce((sum, evt) => sum + evt.cards2.length, 0)
                },
                audio: 'diancai',
                trigger: { global: 'phaseUseEnd' },
                filter(event, player) {
                    const num = get.info('minidiancai').getNum(event, player);
                    return num >= Math.min(5, player.getHp());
                },
                frequent: true,
                async content(event, trigger, player) {
                    await player.drawTo(player.maxHp);
                    if (get.info('minidiaodu')?.filter?.(null, player)) await game.createTrigger(event.triggername, 'minidiaodu', player, trigger).goto(1);
                },
            },
            //葛玄
            minilianhua: {
                audio: 'gxlianhua',
                trigger: {
                    player: 'phaseZhunbeiBegin',
                    global: 'damageEnd',
                },
                filter(event, player) {
                    if (event.name === 'phaseZhunbei') return true;
                    return event.player !== player && event.player.isIn() && _status.currentPhase !== player;
                },
                forced: true,
                async content(event, trigger, player) {
                    const skill = event.name;
                    if (trigger.name === 'phaseZhunbei') {
                        let cards = [], skills = [], { red, black } = player.storage[skill];
                        player.storage[skill] = { red: 0, black: 0 };
                        player.unmarkSkill(skill);
                        if (red + black < 4) {
                            cards.add('tao');
                            skills.add('minireyingzi');
                        }
                        if (red > black) {
                            cards.add('wuzhong');
                            skills.add('minireguanxing');
                        } else if (red < black) {
                            cards.add('shunshou');
                            skills.add('minizhiyan');
                        } else {
                            cards.addArray(['sha', 'juedou']);
                            skills.add('minigongxin');
                        }
                        await player.addTempSkills(skills);
                        cards = cards.map(name => get.cardPile(name)).filter(i => i !== undefined);
                        if (cards.length) await player.gain(cards, 'gain2');
                    }
                    else {
                        player.storage[skill][player.getFriends().includes(trigger.player) ? 'red' : 'black']++;
                        player.markSkill(skill);
                    }
                },
                intro: {
                    markcount: storage => Object.keys(storage).reduce((sum, i) => sum + storage[i], 0),
                    content: (storage, player, skill) => `共有${lib.skill[skill].intro.markcount(storage)}个标记`,
                },
                init(player, skill) {
                    player.storage[skill] ??= { red: 0, black: 0 };
                },
                derivation: ['minireyingzi', 'minireguanxing', 'minizhiyan', 'minigongxin'],
            },
            // 孙桓
            mininiji: {
                audio: 'dcniji',
                inherit: 'dcniji',
                filter(event, player) {
                    return ['basic', 'trick'].includes(get.type(event.card));
                },
                async content(event, trigger, player) {
                    const next = player.draw();
                    const evt = trigger.getParent('mininiji_discard');
                    if (!evt || evt.player != player) {
                        next.gaintag = [event.name];
                    }
                    await next;
                    player.addTempSkill(event.name + '_clear');
                },
                group: 'mininiji_discard',
                subSkill: {
                    clear: {
                        charlotte: true,
                        onremove(player) {
                            player.removeGaintag('mininiji');
                        },
                    },
                    discard: {
                        audio: 'dcniji',
                        trigger: { global: 'phaseJieshuBegin' },
                        filter(event, player) {
                            return player.countCards('hs');
                        },
                        forced: true,
                        locked: false,
                        async content(event, trigger, player) {
                            const result = await player.chooseToUse({
                                filterCard(card) {
                                    if (get.itemtype(card) != 'card' || (get.position(card) != 'h' && get.position(card) != 's')) {
                                        return false;
                                    }
                                    return lib.filter.filterCard.apply(this, arguments);
                                },
                                prompt: '是否使用一张手牌，然后弃置所有“逆击”牌？',
                                addCount: false,
                            }).forResult();
                            if (result?.bool) await game.delayex();
                            const cards = player.getCards('h', card => card.hasGaintag('mininiji') && lib.filter.cardDiscardable(card, player, 'mininiji'));
                            if (cards.length) await player.discard(cards);
                        },
                    }
                }
            },
            //群
            miniqieting: {
                audio: 'qieting',
                trigger: { global: 'phaseJieshuBegin' },
                filter(event, player) {
                    return event.player.countCards('h') > player.countCards('h');
                },
                forced: true,
                content() {
                    player.draw();
                },
            },
            minireqieting: {
                audio: 'reqieting',
                trigger: { global: 'phaseEnd' },
                filter(event, player) {
                    if (event.player == player) return false;
                    return event.player.countCards('h') > player.countCards('h') || !event.player.getHistory('sourceDamage', function (evt) {
                        return evt.player != event.player;
                    }).length;
                },
                direct: true,
                content() {
                    'step 0'
                    event.logged = false;
                    if (trigger.player.countCards('h') <= player.countCards('h')) event.goto(2);
                    'step 1'
                    player.logSkill('minireqieting', trigger.player);
                    player.draw();
                    if (trigger.player.getHistory('sourceDamage', function (evt) {
                        return evt.player != trigger.player;
                    }).length) event.finish();
                    else event.logged = true;
                    'step 2'
                    var list = ['摸一张牌'], target = trigger.player, str = get.translation(target);
                    event.target = target;
                    event.addIndex = 0;
                    if (target.countCards('h') > 0) list.push('观看' + str + '的两张手牌并获得其中一张');
                    else event.addIndex++;
                    if (target.countCards('e', function (card) {
                        return player.canEquip(card);
                    }) > 0) list.push('将' + str + '装备区内的一张牌移动至自己的装备区');
                    player.chooseControl('cancel2').set('choiceList', list).set('prompt', get.prompt('minireqieting', target)).set('ai', function () {
                        var evt = _status.event.getParent();
                        if (get.attitude(evt.player, evt.target) > 0) return 0;
                        var val = evt.target.hasSkillTag('noe') ? 6 : 0;
                        if (evt.target.countCards('e', function (card) {
                            return evt.player.canEquip(card) && get.value(card, evt.target) > val && get.effect(evt.player, card, evt.player, evt.player) > 0;
                        }) > 0) return 2 - evt.addIndex;
                        if (evt.target.countCards('h') > 0) return 1;
                        return 0;
                    });
                    'step 3'
                    if (result.control != 'cancel2') {
                        if (!event.logged) player.logSkill('minireqieting', target);
                        else player.line(target);
                        if (result.index == 0) {
                            player.draw();
                            event.finish();
                        }
                        else if (result.index + event.addIndex == 1) {
                            player.choosePlayerCard(target, 'h', 2, true);
                            player.addExpose(0.2);
                            event.goto(5);
                        }
                        else {
                            player.addExpose(0.1);
                            player.choosePlayerCard(target, 'e', true).set('filterButton', function (button) {
                                return _status.event.player.canEquip(button.link);
                            }).set('ai', function (button) {
                                var player = _status.event.player;
                                return get.effect(player, button.link, player, player);
                            });
                        }
                    }
                    else event.finish();
                    'step 4'
                    if (result.bool) {
                        var card = result.cards[0];
                        target.$give(card, player, false);
                        game.delay(0.5);
                        player.equip(card);
                    }
                    event.finish();
                    'step 5'
                    if (result.bool) player.chooseButton(['选择获得一张牌', result.cards], true);
                    else event.finish();
                    'step 6'
                    if (result.bool) {
                        var card = result.links[0];
                        if (lib.filter.canBeGained(card, player, target)) player.gain(card, target, 'giveAuto', 'bySelf');
                        else game.log('但', card, '不能被', player, '获得！');
                    }
                },
            },
            minixianzhou: {
                audio: 'xianzhou',
                enable: 'phaseUse',
                limited: true,
                skillAnimation: true,
                animationColor: 'gray',
                filter(event, player) {
                    return player.countCards('h');
                },
                filterCard: true,
                position: 'h',
                selectCard: -1,
                filterTarget: lib.filter.notMe,
                discard: false,
                lose: false,
                delay: false,
                content() {
                    'step 0'
                    player.awakenSkill('minixianzhou');
                    target.gain(cards, player, 'give');
                    'step 1'
                    var list = game.filterPlayer(function (current) {
                        return target.inRange(current);
                    });
                    if (list.length) {
                        var max = Math.min(list.length, cards.length);
                        target.chooseTarget(true, [1, max], '对至多' + get.cnNumber(max) + '名范围内的角色各造成1点伤害', function (card, player, target) {
                            return _status.event.list.includes(target);
                        }).set('list', list).set('ai', function (target) {
                            var player = _status.event.player;
                            return get.damageEffect(target, player, player);
                        });
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        target.line(targets, 'green');
                        for (var i of targets) i.damage('nocard', target);
                    }
                },
                ai: {
                    order: 1,
                    result: {
                        target: 1,
                        player(player) {
                            var bool = true, players = game.filterPlayer();
                            for (var i = 0; i < players.length; i++) {
                                if (players[i] != player && get.attitude(player, players[i]) > 2 && get.attitude(players[i], player) > 2) bool = false; break;
                            }
                            if (bool) return -10;
                            if (game.phaseNumber < game.players.length) return -10;
                            if (player.countCards('h') + player.hp > player.maxHp) return 1;
                            return -10;
                        },
                    },
                },
            },
            minirexianzhou: {
                limited: true,
                audio: 'rexianzhou',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he') > 0;
                },
                filterCard: true,
                position: 'he',
                selectCard: [1, Infinity],
                check(card) {
                    var player = _status.event.player;
                    if (ui.selected.cards.length >= player.hp) return 0;
                    return 7 - get.value(card);
                },
                filterTarget: lib.filter.notMe,
                discard: false,
                lose: false,
                delay: false,
                skillAnimation: true,
                animationColor: 'gray',
                content() {
                    'step 0'
                    player.awakenSkill('minirexianzhou');
                    player.give(cards, target);
                    player.recover(cards.length)
                    'step 1'
                    var list = game.filterPlayer(function (current) {
                        return target.inRange(current);
                    });
                    if (list.length) {
                        var max = Math.min(list.length, cards.length);
                        player.chooseTarget(true, [1, max], '对至多' + get.cnNumber(max) + '名范围内的角色各造成1点伤害', function (card, player, target) {
                            return _status.event.list.includes(target);
                        }).set('list', list).set('ai', function (target) {
                            var player = _status.event.player;
                            return get.damageEffect(target, player, player);
                        });
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        player.line(targets, 'green');
                        for (var i of targets) i.damage('nocard');
                    }
                },
                ai: {
                    order: 1,
                    result: {
                        target: 1,
                        player(player) {
                            var bool = true, players = game.filterPlayer();
                            for (var i = 0; i < players.length; i++) {
                                if (players[i] != player && get.attitude(player, players[i]) > 2 && get.attitude(players[i], player) > 2) {
                                    bool = false; break;
                                }
                            }
                            if (bool) return -10;
                            if (player.hp == 1) return 1;
                            return -10;
                        }
                    },
                },
            },
            minipianyi: {
                audio: ['pianyi1.mp3', 'pianyi2.mp3'],
                trigger: { player: 'phaseJieshuBegin' },
                frequent: true,
                content() {
                    player.draw(player.isTurnedOver() ? 3 : 1);
                },
            },
            //庞德
            minijianchu: {
                audio: 'mengjin',
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    return event.card.name == 'sha' && event.target.countDiscardableCards(player, 'he') > 0;
                },
                async cost(event, trigger, player) {
                    let target = trigger.target, list = [event.skill, target];
                    event.result = await player.discardPlayerCard(target, get.prompt(...list)).set('logSkill', list).forResult();
                },
                popup: false,
                async content(event, trigger, player) {
                    const cards = trigger.getParent().cards;
                    if (cards?.someInD('od')) {
                        const target = trigger.target;
                        await target.gain(cards.filterInD('od'), 'gain2');
                    }
                },
                ai: {
                    unequip_ai: true,
                    skillTagFilter(player, tag, arg) {
                        return arg?.card && arg.target && arg.card.name == 'sha' && arg.target.getEquips(2).length === 1;
                    },
                },
            },
            minirejianchu: {
                audio: 'jianchu',
                audioname: ['re_pangde'],
                inherit: 'minijianchu',
                async cost(event, trigger, player) {
                    let target = trigger.target, list = [event.skill, target];
                    const result = event.result = await player.discardPlayerCard(target, get.prompt(...list)).set('ai', button => {
                        const { player, target } = get.event(), att = get.attitude(player, target), val = get.value(button.link);
                        if (att > 0) return -val;
                        else if (att === 0) return 0;
                        else {
                            if (get.position(button.link) === 'e' && get.subtype(button.link) == 'equip2') return val * 2;
                            return val;
                        }
                    }).set('logSkill', list).forResult();
                },
                async content(event, trigger, player) {
                    const card = event.cards[0], target = trigger.target;
                    if (card) {
                        if (get.type(card, null, target) !== 'basic') {
                            await player.draw();
                            trigger.getParent().directHit.add(target);
                            game.log(target, '不可响应', trigger.card);
                        }
                        else {
                            trigger.addCount = false;
                            if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                            game.log(trigger.card, '不计入次数');
                        }
                    }
                },
                ai: {
                    unequip_ai: true,
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (tag == 'directHit_ai') return arg.card.name == 'sha' && arg.target.countCards('e', function (card) {
                            return get.value(card) > 1;
                        }) > 0;
                        if (arg?.name == 'sha' && arg.target.getEquips(2).length) return true;
                        return false;
                    }
                },
            },
            minichenglve: {
                enable: 'phaseUse',
                usable: 1,
                audio: 'nzry_chenglve',
                content() {
                    'step 0'
                    player.draw();
                    player.chooseToDiscard('h', true);
                    'step 1'
                    if (result.bool) {
                        player.addTempSkill('minichenglve_use');
                        player.markAuto('minichenglve_use', [get.suit(result.cards[0], player)]);
                        player.storage.minichenglve_use.sort(function (a, b) {
                            return lib.suit.indexOf(b) - lib.suit.indexOf(a);
                        });
                        if (game.HasExtension('十周年UI')) {
                            game.broadcastAll(function (player) {
                                var str = '成略';
                                for (var suit of player.getStorage('minichenglve_use')) str += get.translation(suit);
                                if (player.marks.minichenglve_use) player.marks.minichenglve_use.firstChild.innerHTML = str;
                            }, player);
                        }
                    }
                },
                ai: {
                    order: 10,
                    result: { player: 1 },
                },
                subSkill: {
                    use: {
                        charlotte: true,
                        onremove: true,
                        intro: {
                            markcount: () => undefined,
                            content: '使用$花色的牌无距离和次数限制',
                        },
                        mod: {
                            cardUsable(card, player) {
                                const suit = get.suit(card);
                                if (suit == 'unsure' || player.getStorage('minichenglve_use').includes(suit)) return Infinity;
                            },
                            targetInRange(card, player) {
                                const suit = get.suit(card);
                                if (suit == 'unsure' || player.getStorage('minichenglve_use').includes(suit)) return true;
                            },
                        },
                    },
                },
            },
            minijijun: {
                audio: 'xinfu_jijun',
                trigger: { global: 'useCardToPlayer' },
                filter(event, player) {
                    var bool1 = (event.targets.length == 1 && (event.card.name == 'sha' || get.type2(event.card) == 'trick'));
                    var bool2 = (event.card.name == 'sha');
                    if (event.player == player && bool1) return true;
                    if (event.target == player && bool2) return true;
                    return false;
                },
                forced: true,
                content() {
                    player.judge(function (card) {
                        return get.color(card) == 'black' ? 1.5 : -1.5;
                    }).set('callback', function () {
                        if (event.judgeResult.color == 'black' && get.position(card, true) == 'o') player.addToExpansion('gain2', [card]).gaintag.add('minijijun');
                    });
                },
                marktext: '兵',
                //避免重复换了一个字眼
                intro: {
                    content: 'expansion',
                    markcount: 'expansion',
                },
                onremove(player, skill) {
                    var cards = player.getExpansions(skill);
                    if (cards.length) player.loseToDiscardpile(cards);
                },
            },
            minifangtong: {
                audio: 'xinfu_fangtong',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return player.getExpansions('minijijun').length;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseButton([1, 3], [get.prompt2('minifangtong'), player.getExpansions('minijijun')]).set('ai', function (button) {
                        var player = _status.event.player;
                        if (player.getExpansions('minijijun').length >= 3 && game.hasPlayer(function (current) {
                            return get.damageEffect(current, player, player, 'thunder') > 0;
                        })) return 3;
                        if (ui.selected.buttons.length == 1 && player.isDamaged()) return 2;
                        if (!ui.selected.buttons.length) return 1;
                        return 0;
                    });
                    'step 1'
                    if (result.links) {
                        player.logSkill('minifangtong');
                        var num = result.links.length;
                        player.loseToDiscardpile(result.links);
                        event.num = num;
                    }
                    else event.finish();
                    'step 2'
                    switch (num) {
                        case 1:
                            player.draw();
                            break;
                        case 2:
                            if (player.isDamaged()) player.recover();
                            break;
                        case 3:
                            player.chooseTarget('对一名角色造成2点雷属性伤害', true).set('ai', function (target) {
                                var player = _status.event.player;
                                return get.damageEffect(target, player, player, 'thunder');
                            });
                            break;
                    }
                    if (num != 3) event.finish();
                    'step 3'
                    if (result.bool) {
                        player.line(result.targets[0]);
                        result.targets[0].damage(2, 'thunder');
                    }
                },
            },
            minizhoufu: {
                audio: 'rezhoufu',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he');
                },
                filterCard: true,
                selectCard: [0, 1],
                filterTarget(card, player, target) {
                    if (player == target) return false;
                    if (!ui.selected.cards.length) return target.getExpansions('minizhoufu2').length;
                    return !target.getExpansions('minizhoufu2').length;
                },
                check(card) {
                    return 6 - get.value(card);
                },
                usable: 1,
                position: 'he',
                discard: false,
                lose: false,
                delay: false,
                content() {
                    if (!cards.length && target.getExpansions('minizhoufu2').length) {
                        var cardx = target.getExpansions('minizhoufu2');
                        target.loseToDiscardpile(cardx);
                    }
                    else {
                        if (!target.storage.minizhoufu2_markcount) target.storage.minizhoufu2_markcount = 0;
                        target.addToExpansion(cards, player, 'give').gaintag.add('minizhoufu2');
                    }
                },
                ai: {
                    order: 1,
                    result: {
                        target(player, target) {
                            if (target.getExpansions('minizhoufu2').length && target.hp < 3) return -1;
                            return -2;
                        },
                    },
                },
                group: ['minizhoufu_judge', 'minizhoufu_losehp'],
                subSkill: {
                    judge: {
                        audio: 'rezhoufu',
                        trigger: { global: 'judgeBefore' },
                        forced: true,
                        filter(event, player) {
                            return !event.directresult && event.player.getExpansions('minizhoufu2').length;
                        },
                        logTarget: 'player',
                        content() {
                            var cards = [trigger.player.getExpansions('minizhoufu2')[0]];
                            trigger.directresult = cards[0];
                        },
                    },
                    losehp: {
                        audio: 'rezhoufu',
                        trigger: { global: 'phaseEnd' },
                        forced: true,
                        filter(event, player) {
                            return game.hasPlayer(function (current) {
                                return current.hasHistory('lose', function (evt) {
                                    if (!evt || !evt.xs || !evt.xs.length) return false;
                                    for (var i in evt.gaintag_map) {
                                        if (evt.gaintag_map[i].includes('minizhoufu2')) return true;
                                    }
                                    return false;
                                });
                            });
                        },
                        logTarget(current) {
                            return game.filterPlayer(function (current) {
                                return current.hasHistory('lose', function (evt) {
                                    if (!evt || !evt.xs || !evt.xs.length) return false;
                                    for (var i in evt.gaintag_map) {
                                        if (evt.gaintag_map[i].includes('minizhoufu2')) return true;
                                    }
                                    return false;
                                });
                            }).sortBySeat();
                        },
                        content() {
                            var targets = game.filterPlayer(function (current) {
                                return current.hasHistory('lose', function (evt) {
                                    if (!evt || !evt.xs || !evt.xs.length) return false;
                                    for (var i in evt.gaintag_map) {
                                        if (evt.gaintag_map[i].includes('minizhoufu2')) return true;
                                    }
                                    return false;
                                });
                            }).sortBySeat();
                            while (targets.length) {
                                targets.shift().loseHp();
                            }
                        },
                    },
                },
            },
            minizhoufu2: { intro: { content: 'expansion' } },
            minizhoufu3: {},
            miniyingbing: {
                audio: 'reyingbin',
                trigger: { global: 'useCard' },
                forced: true,
                filter(event, player) {
                    var cards = event.player.getExpansions('minizhoufu2');
                    return cards.length && get.color(cards[0]) == get.color(event.card);
                },
                logTarget: 'player',
                content() {
                    'step 0'
                    player.draw();
                    'step 1'
                    trigger.player.storage.minizhoufu2_markcount++;
                    if (trigger.player.storage.minizhoufu2_markcount >= 2) {
                        var cards = trigger.player.getExpansions('minizhoufu2');
                        trigger.player.loseToDiscardpile(cards);
                    }
                    else trigger.player.markSkill('minizhoufu2');
                },
            },
            miniguhuo: {
                audio: 'guhuo_guess',
                trigger: { player: 'useCardAfter' },
                filter(event, player) {
                    var bool = player.getHistory('sourceDamage', function (evt) {
                        return evt.card && evt.card == event.card;
                    }).length;
                    if (bool && player.hasSkill('miniguhuo_silent')) return false;
                    if (get.type(event.card) != 'trick' && event.card.name != 'sha') return false;
                    return get.tag(event.card, 'damage');
                },
                forced: true,
                content() {
                    'step 0'
                    var bool = player.getHistory('sourceDamage', function (evt) {
                        return evt.card && evt.card == trigger.card;
                    }).length, cards = trigger.cards.filterInD();
                    if (bool) player.addTempSkill('miniguhuo_silent');
                    else if (cards.length) {
                        player.addTempSkill('miniguhuo_card', 'phaseEnd');
                        player.addToExpansion(cards, 'gain2').gaintag.add('miniguhuo_card');
                    }
                    'step 1'
                    player.draw();
                },
                subSkill: {
                    silent: { charlotte: true },
                    card: {
                        charlotte: true,
                        intro: {
                            content: 'expansion',
                            markcount: 'expansion',
                        },
                        onremove(player, skill) {
                            var cards = player.getExpansions(skill);
                            if (cards.length) player.gain(cards, 'gain2');
                        },
                    },
                },
            },
            miniyaowu: {
                audio: 'yaowu',
                trigger: { player: 'damageBegin3' },
                filter(event, player) {
                    if (!event.card || event.card.name !== 'sha') return false;
                    const color = get.color(event.card);
                    return color === 'black' || (color === 'red' && event.source?.isIn());
                },
                forced: true,
                async content(event, trigger, player) {
                    const color = get.color(event.card);
                    if (color === 'black') await player.draw();
                    if (color === 'red' && trigger.source?.isIn()) trigger.source.draw();
                },
            },
            minireyaowu: {
                audio: 'new_reyaowu',
                audioname: ['sb_huaxiong'],
                inherit: 'miniyaowu',
                async content(event, trigger, player) {
                    const color = get.color(event.card);
                    if (color === 'black') await player.draw();
                    if (color === 'red' && trigger.source?.isIn()) trigger.source.draw();
                    if (get.itemtype(trigger.cards) === 'cards' && trigger.cards.someInD('od')) player.gain(trigger.cards.filterInD('od'), 'gain2');
                },
            },
            miniyangwei: {
                mod: {
                    cardUsable(card, player, num) {
                        if (typeof card == 'object' && player == _status.currentPhase) {
                            var cardx = player.storage.miniyangwei_mark;
                            if (cardx && get.name(card) == 'sha' && get.color(cardx) != 'none' && get.color(cardx) != get.color(card)) {
                                return Infinity;
                            }
                        }
                    },
                    aiOrder(player, card, num) {
                        if (typeof card == 'object' && player.isPhaseUsing()) {
                            var cardx = player.storage.miniyangwei_mark;
                            if (cardx && get.name(card) == 'sha' && get.color(cardx) != 'none' && get.color(cardx) != get.color(card)) {
                                return num + 10;
                            }
                        }
                    },
                },
                audio: 'sbyangwei',
                trigger: { player: 'phaseUseEnd' },
                filter(event, player) {
                    return player.isDamaged() && player.getHistory('useCard', evt => evt.card.name == 'sha').length > 2;
                },
                forced: true,
                locked: false,
                content() {
                    player.recover();
                },
                group: 'miniyangwei_phase',
                subSkill: {
                    phase: {
                        audio: 'sbyangwei',
                        trigger: { player: 'useCardAfter' },
                        filter(event, player) {
                            return player.isPhaseUsing() && event.card.name == 'sha' && ['black', 'red'].includes(get.color(event.card));
                        },
                        forced: true,
                        content() {
                            'step 0'
                            if (!player.storage.miniyangwei_mark) {
                                player.when('phaseUseAfter').then(() => delete player.storage.miniyangwei_mark);
                            }
                            player.storage.miniyangwei_mark = trigger.card;
                            player.addTempSkill('miniyangwei_count', 'phaseUseAfter');
                            'step 1'
                            game.broadcastAll((ind, player) => {
                                var bgColor = lib.skill.dchuiling.subSkill.hint.markColor[ind][0];
                                var text = '<span style="color: ' + lib.skill.dchuiling.subSkill.hint.markColor[ind][1] + '">杀</span>';
                                if (!player.marks.miniyangwei_count) player.markSkill('miniyangwei_count');
                                player.marks.miniyangwei_count.firstChild.style.backgroundColor = bgColor;
                                player.marks.miniyangwei_count.firstChild.innerHTML = text;
                            }, ['black', 'none', 'red'].indexOf(get.color(trigger.card)), player);
                        },
                    },
                    count: {
                        trigger: { player: 'useCard1' },
                        filter(event, player) {
                            var card = player.storage.miniyangwei_mark;
                            if (!card || !player.isPhaseUsing()) return false;
                            return get.name(event.card) == 'sha' && get.color(card) != 'none' && get.color(card) != get.color(event.card);
                        },
                        direct: true,
                        firstDo: true,
                        content() {
                            player.removeSkill('miniyangwei_count');
                            trigger.addCount = false;
                            if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                        },
                        mark: true,
                        marktext: '杀',
                        intro: { content: storage => '本阶段可使用一张无次数限制且不计入次数的' + ['黑', '红'][['black', 'red'].indexOf(get.color(storage))] + '色【杀】' },
                    },
                },
            },
            miniqiaomeng: {
                audio: 'qiaomeng',
                trigger: { source: 'damageBegin1' },
                direct: true,
                filter(event, player) {
                    if (event._notrigger.includes(event.player)) return false;
                    return event.card && event.card.name == 'sha' && event.player.countGainableCards(player, 'hej');
                },
                content() {
                    'step 0'
                    player.gainPlayerCard(get.prompt('miniqiaomeng', trigger.player), 'hej', trigger.player).set('logSkill', ['miniqiaomeng', trigger.player]);
                    'step 1'
                    if (result.bool) {
                        var card = result.cards[0];
                        if (get.subtype(card) == 'equip3' || get.subtype(card) == 'equip4') trigger.num++;
                    }
                },
            },
            miniyicong: {
                audio: 'reyicong',
                mod: {
                    globalFrom(from, to, current) {
                        return current - Math.max(0, from.getHp());
                    },
                    globalTo(from, to, current) {
                        return current + Math.max(0, to.getDamagedHp());
                    },
                },
                ai: { threaten: 0.8 },
            },
            minishuangxiong: {
                audio: 'olshuangxiong',
                group: ['minishuangxiong_effect', 'minishuangxiong_jianxiong'],
                subSkill: {
                    effect: {
                        audio: 'olshuangxiong',
                        trigger: { player: 'phaseDrawBegin1' },
                        filter(event, player) {
                            return !event.numFixed;
                        },
                        prompt2: () => '放弃摸牌，亮出牌堆顶的三张牌并选择获得其中一种颜色的所有牌，本回合你可以将与这些牌颜色不同的一张手牌当作【决斗】使用。',
                        async content(event, trigger, player) {
                            trigger.changeToZero();
                            var cards = get.cards(3, true);
                            var videoId = lib.status.videoId++;
                            game.broadcastAll(function (player, id, cards) {
                                var str = ('双雄' + ((player == game.me && !_status.auto) ? '：获得其中一种颜色的牌' : ''));
                                var dialog = ui.create.dialog(str, cards);
                                dialog.videoId = id;
                            }, player, videoId, cards);
                            var time = get.utc();
                            game.addVideo('showCards', player, ['双雄', get.cardsInfo(cards)]);
                            game.addVideo('delay', null, 2);
                            var result, list = cards.reduce((list, card) => list.add(get.color(card)), []);
                            if (list.length == 1) result = { control: list[0] };
                            else {
                                //加大颜色兼容性
                                var colors = ['red', 'black', 'none'];
                                list.sort((a, b) => colors.indexOf(b) - colors.indexOf(a));
                                if (list.includes('none')) list[list.indexOf('none')] = 'none2';
                                list.reverse();
                                result = await player.chooseControl(list).set('ai', () => {
                                    var getNum = (cards, color) => cards.reduce((num, card) => num + (get.color(card) == color ? 1 : 0), 0);
                                    var controls = _status.event.controls.slice();
                                    controls.sort((a, b) => getNum(_status.event.cards, b) - getNum(_status.event.cards, a));
                                    return controls[0];
                                }).set('cards', cards).forResult();
                            }
                            var color = result.control;
                            if (color == 'none2') color = 'none';
                            cards = cards.filter(card => get.color(card) == color);
                            time = 1000 - (get.utc() - time);
                            if (time > 0) game.delay(0, time);
                            game.broadcastAll('closeDialog', videoId);
                            if (cards.length) {
                                player.gain(cards, 'gain2');
                                player.addTempSkill('olshuangxiong_effect');
                                player.markAuto('olshuangxiong_effect', [get.color(cards[0], false)]);
                            }
                        },
                    },
                    jianxiong: {
                        audio: 'olshuangxiong',
                        trigger: { player: 'damageEnd' },
                        filter(event, player) {
                            var evt = event.getParent();
                            if (!evt || evt.name != 'juedou') return false;
                            return lib.skill.minishuangxiong.subSkill.jianxiong.getCards(event, player).length;
                        },
                        prompt: (event, player) => '获得' + get.translation(lib.skill.minishuangxiong.subSkill.jianxiong.getCards(event, player)),
                        content() {
                            player.gain(lib.skill.minishuangxiong.subSkill.jianxiong.getCards(trigger, player), 'gain2');
                        },
                        getCards(event, player) {
                            var evt = event.getParent();
                            var cards = evt[player == evt.player ? 'targetCards' : 'playerCards'].slice();
                            return cards.filter(card => get.position(card) == 'd');
                        },
                    },
                },
            },
            // 高顺
            minixianzhen: {
                group: 'minixianzhen_miss',
                audio: 'xianzhen',
                usable: 1,
                trigger: { source: 'damageBegin1' },
                filter(event, player) {
                    return event.card && event.card.name == 'sha' && event.notLink();
                },
                forced: true,
                content() {
                    trigger.num++;
                },
                subSkill: {
                    miss: {
                        audio: 'xianzhen',
                        trigger: { player: 'shaMiss' },
                        filter(event, player) {
                            return player.countUsed('sha', true) == 1;
                        },
                        usable: 1,
                        forced: true,
                        content() {
                            player.draw();
                        },
                    },
                },
            },
            minijinjiu: {
                mod: {
                    cardname(card, player) {
                        if (card.name == 'jiu') return 'sha';
                    },
                },
                ai: {
                    respondSha: true,
                    skillTagFilter(player) {
                        if (!player.countCards('h', 'jiu')) return false;
                    },
                },
                group: 'minijinjiu_gain',
                global: 'minijinjiu_usejiu',
                audio: 'jinjiu',
                popup: false,
                silent: true,
                firstDo: true,
                trigger: { player: 'useCard1' },
                filter(event, player) {
                    if (event.addCount === false) return false;
                    return event.card.name == 'sha' && event.cards && event.cards.length == 1 && event.cards[0].name == 'jiu';
                },
                forced: true,
                content() {
                    trigger.addCount = false;
                    if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                },
                subSkill: {
                    gain: {
                        trigger: { global: 'useCardAfter' },
                        forced: true,
                        audio: 'jinjiu',
                        filter(event, player) {
                            return event.player != player && event.card.isCard && event.card.name == 'jiu' && event.cards.filterInD().length > 0;
                        },
                        logTarget: 'player',
                        content() {
                            player.gain(trigger.cards.filterInD(), 'gain2');
                        },
                    },
                    usejiu: {
                        mod: {
                            cardEnabled(card, player) {
                                if (card.name == 'jiu' && _status.currentPhase && _status.currentPhase != player && _status.currentPhase.hasSkill('minijinjiu')) return false;
                            },
                            cardSavable(card, player) {
                                if (card.name == 'jiu' && _status.currentPhase && _status.currentPhase != player && _status.currentPhase.hasSkill('minijinjiu')) return false;
                            },
                        },
                    },
                },
            },
            minirexianzhen: {
                audio: 'rexianzhen',
                inherit: 'xianzhen',
                async content(event, trigger, player) {
                    const { target } = event;
                    const next = player.chooseToCompare(target);
                    const result = await next.forResult();
                    if (result?.bool) {
                        player.markAuto(event.name + '_effect', [target]);
                        player.addTempSkill(event.name + '_effect');
                        const cards = [result.player].filter(i => get.position(i, true) == 'd' && player.hasUseTarget(i));
                        if (cards[0]) await player.chooseUseTarget(cards[0], null, false);
                    } else {
                        const toGain = [];
                        for (const lose_list of next.lose_list) {
                            let [comparer, cards] = lose_list;
                            if (!Array.isArray(cards)) cards = [cards];
                            for (const card of cards) {
                                if (get.name(card, comparer) == 'sha' && get.position(card, true) == 'd') toGain.push(card);
                            }
                        }
                        if (toGain.length) await player.gain(toGain, 'gain2');
                        player.addTempSkill(event.name + '_buff');
                    }
                },
                group: ['minirexianzhen_damage', 'minirexianzhen_draw'],
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        mod: {
                            targetInRange(card, player, target) {
                                if (player.getStorage('minirexianzhen_effect').includes(target)) return true;
                            },
                            cardUsableTarget(card, player, target) {
                                if (player.getStorage('minirexianzhen_effect').includes(target)) return true;
                            }
                        },
                        ai: {
                            unequip: true,
                            skillTagFilter(player, tag, arg) {
                                if (!arg?.target || !player.getStorage('minirexianzhen_effect').includes(arg.target)) return false;
                            },
                        },
                        intro: { content: '本回合无视$的防具且对其使用牌没有次数和距离限制' },
                    },
                    buff: {
                        charlotte: true,
                        onremove: true,
                        mod: {
                            cardEnabled(card) {
                                if (card.name == 'sha') return false;
                            },
                            ignoredHandcard(card, player) {
                                if (get.name(card, player) == 'sha') return true;
                            },
                            cardDiscardable(card, player, name) {
                                if (name == 'phaseDiscard' && get.name(card, player) == 'sha') return false;
                            },
                        },
                    },
                    damage: {
                        audio: 'rexianzhen',
                        trigger: { source: 'damageBegin1' },
                        filter(event, player) {
                            return player == _status.currentPhase && game.getGlobalHistory('everything', evt => {
                                return evt.name == 'damage' && evt.source == player;
                            }, event).indexOf(event) == 0;
                        },
                        forced: true,
                        locked: false,
                        async content(event, trigger, player) {
                            trigger.num++;
                        },
                    },
                    draw: {
                        audio: 'rexianzhen',
                        trigger: { player: 'shaMiss' },
                        forced: true,
                        locked: false,
                        async content(event, trigger, player) {
                            await player.draw();
                        },
                    }
                },
            },
            minirejinjiu: {
                mod: {
                    cardname(card, player) {
                        if (card.name == 'jiu') return 'sha';
                    },
                    cardnumber(card) {
                        if (card.name == 'jiu') return 13;
                    },
                },
                audio: 'rejinjiu',
                inherit: 'minijinjiu',
            },
            minishendao: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'judge' },
                direct: true,
                content() {
                    'step 0'
                    var str = '你的' + (trigger.judgestr || '') + '判定牌为' + get.translation(trigger.player.judging[0]) + '，是否修改判定花色？';
                    player.chooseControl('spade', 'heart', 'diamond', 'club', 'cancel2').set('prompt', str).set('ai', function () {
                        var judging = _status.event.judging;
                        var trigger = _status.event.getTrigger();
                        var res1 = trigger.judge(judging);
                        var list = lib.suit.slice(0);
                        var attitude = get.attitude(player, trigger.player);
                        if (attitude == 0) return 0;
                        var getj = function (suit) {
                            return trigger.judge({
                                name: get.name(judging),
                                nature: get.nature(judging),
                                suit: suit,
                                number: get.number(judging),
                            })
                        };
                        list.sort(function (a, b) {
                            return (getj(b) - getj(a)) * Math.sign(attitude);
                        });
                        if ((getj(list[0]) - res1) * attitude > 0) return list[0];
                        return 'cancel2';
                    }).set('judging', trigger.player.judging[0]);
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('minishendao');
                        player.popup(result.control + 2);
                        game.log(player, '将判定结果改为了', '#y' + get.translation(result.control + 2));
                        trigger.fixedResult = {
                            suit: result.control,
                            color: get.color({ suit: result.control }),
                        };
                    }
                },
                ai: {
                    rejudge: true,
                    tag: {
                        rejudge: 0.3,
                    },
                },
            },
            minixinsheng: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'damageEnd' },
                frequent: true,
                content() {
                    'step 0'
                    event.cards = get.cards(3);
                    game.cardsGotoOrdering(event.cards);
                    event.videoId = lib.status.videoId++;
                    game.broadcastAll(function (player, id, cards) {
                        var str;
                        if (player == game.me && !_status.auto) str = '新生：获得花色各不相同的牌各一张';
                        else str = '新生';
                        var dialog = ui.create.dialog(str, cards);
                        dialog.videoId = id;
                    }, player, event.videoId, event.cards);
                    event.time = get.utc();
                    game.addVideo('showCards', player, ['新生', get.cardsInfo(event.cards)]);
                    game.addVideo('delay', null, 2);
                    'step 1'
                    var next = player.chooseButton([0, 3], true);
                    next.set('dialog', event.videoId);
                    next.set('filterButton', function (button) {
                        for (var i = 0; i < ui.selected.buttons.length; i++) {
                            if (get.suit(ui.selected.buttons[i].link) == get.suit(button.link)) return false;
                        }
                        return true;
                    });
                    next.set('ai', function (button) {
                        return get.value(button.link, _status.event.player);
                    });
                    'step 2'
                    if (result.bool && result.links) event.cards2 = result.links;
                    else event.finish();
                    var time = 1000 - (get.utc() - event.time);
                    if (time > 0) game.delay(0, time);
                    'step 3'
                    game.broadcastAll('closeDialog', event.videoId);
                    var cards2 = event.cards2;
                    player.gain(cards2, 'gain2');
                    'step 4'
                    lib.skill.old_shenzhu.content(event, trigger, player);
                },
            },
            miniweidi: {
                audio: 'weidi',
                preHidden: true,
                trigger: { player: 'phaseDiscardEnd' },
                filter(event, player) {
                    var cards = [];
                    game.getGlobalHistory('cardMove', function (evt) {
                        if (evt.name == 'cardsDiscard' && evt.getParent('phaseDiscard') == event) cards.addArray(evt.cards.filterInD('d'));
                    });
                    game.countPlayer2(function (current) {
                        current.getHistory('lose', function (evt) {
                            if (evt.type != 'discard' || evt.getParent('phaseDiscard') != event) return;
                            cards.addArray(evt.cards.filterInD('d'));
                        })
                    });
                    return cards.length;
                },
                direct: true,
                content() {
                    'step 0'
                    var cards = [];
                    game.getGlobalHistory('cardMove', function (evt) {
                        if (evt.name == 'cardsDiscard' && evt.getParent('phaseDiscard') == trigger) cards.addArray(evt.cards.filterInD('d'));
                    });
                    game.countPlayer2(function (current) {
                        current.getHistory('lose', function (evt) {
                            if (evt.type != 'discard' || evt.getParent('phaseDiscard') != trigger) return;
                            cards.addArray(evt.cards.filterInD('d'));
                        })
                    });
                    player.chooseCardButton(cards, '伪帝：是否将一张牌交给一名其他角色？').set('ai', function (button) {
                        var player = _status.event.player;
                        if (game.hasPlayer(function (current) {
                            return current != player && get.attitude(player, current) > 0;
                        })) return get.value(button.link);
                        return 0;
                    }).set('cards', cards).set('filterButton', function (button) {
                        return _status.event.cards.includes(button.link);
                    }).setHiddenSkill('miniweidi');
                    'step 1'
                    if (result.bool) {
                        event.card = result.links[0];
                        player.chooseTarget('将' + get.translation(event.card) + '交给一名其他角色', lib.filter.notMe, true).set('ai', function (target) {
                            var player = _status.event.player;
                            return get.attitude(player, target) * get.value(event.card, target) * (target.hasSkillTag('nogain') ? 0.1 : 1);
                        });
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('miniweidi', target);
                        target.gain(card, 'gain2');
                    }
                },
            },
            minimingce: {
                audio: 'mingce',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return game.hasPlayer(function (target) {
                        return target != player && game.hasPlayer(function (current) {
                            return target.canUse({ name: 'sha' }, current, false) && target.inRange(current);
                        });
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseCardTarget({
                        prompt: get.prompt2('minimingce'),
                        filterTarget(card, player, target) {
                            if (ui.selected.targets.length) return ui.selected.targets[0].canUse({ name: 'sha' }, target, false) && ui.selected.targets[0].inRange(target);
                            return target != player;
                        },
                        selectTarget: 2,
                        filterCard: () => false,
                        selectCard: -1,
                        complexSelect: true,
                        targetprompt: ['出杀者', '出杀目标'],
                        ai2(target) {
                            var player = _status.event.player, list = [];
                            for (var i of game.filterPlayer()) {
                                if (i == player) continue;
                                for (var j of game.filterPlayer()) {
                                    if (j == i || !i.inRange(j)) continue;
                                    list.push([get.effect(j, { name: 'sha', isCard: true }, i, player), i, j]);
                                }
                            }
                            if (!list.length) return 0;
                            list.sort((a, b) => b[0] - a[0]);
                            if (list[0][0] <= 0) return 0;
                            if (!ui.selected.targets.length) return target == list[0][1] ? 10 : 0;
                            return target == list[0][2] ? 10 : 0;
                        },
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minimingce');
                        player.line2(result.targets);
                        result.targets[0].useCard({ name: 'sha', isCard: true }, result.targets[1], false, 'noai');
                    }
                },
            },
            miniremingce: {
                audio: 'remingce',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return game.hasPlayer(target => {
                        return target != player || game.hasPlayer(current => target.canUse({ name: 'sha' }, current, false) && target.inRange(current));
                    });
                },
                async cost(event, trigger, player) {
                    const goon = game.hasPlayer(target => {
                        return game.hasPlayer(current => target.canUse({ name: 'sha' }, current, false) && target.inRange(current));
                    });
                    const choiceList = ['令一名角色视为对其攻击范围内另一名你指定的角色使用一张【杀】，此【杀】结算后若此【杀】造成伤害，你摸两张牌', '选择一名其他角色，与其各摸一张牌，且其下回合使用【杀】的次数上限+1'];
                    const choices = [];
                    if (goon) choices.push('选项一');
                    else choiceList[0] = '<span style="opacity:0.5">' + choiceList[0] + '</span>';
                    if (game.hasPlayer(target => player != target)) choices.push('选项二');
                    else choiceList[1] = '<span style="opacity:0.5">' + choiceList[1] + '</span>';
                    const { control } = await player.chooseControl(choices, 'cancel2').set('choiceList', choiceList).set('prompt', get.prompt(event.name.slice(0, -5))).set('ai', () => {
                        const player = get.player();
                        const eff1 = Math.max.apply(Math, game.filterPlayer().map(i => i.getUseValue({ name: 'sha', isCard: true }, false))), eff2 = Math.max.apply(Math, game.filterPlayer(i => player != i).map(i => get.effect(i, { name: 'draw' }, player, player) + get.effect(player, { name: 'draw' }, player, player)));
                        if (eff1 < 0 && eff1 < 0) return 'cancel2';
                        return eff1 > eff2 ? 0 : 1;
                    }).forResult();
                    if (control == 'cancel2') return;
                    const bool = control == '选项一';
                    const index = bool ? 0 : 1, num = bool ? 2 : 1;
                    const next = player.chooseTarget(get.prompt(event.name.slice(0, -5)), choiceList[index], true, num);
                    if (bool) {
                        next.set('filterTarget', (card, player, target) => {
                            if (ui.selected.targets.length) return ui.selected.targets[0].canUse({ name: 'sha' }, target, false) && ui.selected.targets[0].inRange(target);
                            return game.hasPlayer(current => target.canUse({ name: 'sha' }, current, false) && target.inRange(current));
                        });
                        next.set('complexSelect', true);
                        next.set('targetprompt', ['出杀者', '出杀目标']);
                        next.set('ai', target => {
                            const player = get.player();
                            let list = [];
                            for (var i of game.filterPlayer()) {
                                for (var j of game.filterPlayer()) {
                                    if (j == i || !i.inRange(j)) continue;
                                    list.push([get.effect(j, { name: 'sha', isCard: true }, i, player), i, j]);
                                }
                            }
                            if (!list.length) return 0;
                            list.sort((a, b) => b[0] - a[0]);
                            if (list[0][0] <= 0) return 0;
                            if (!ui.selected.targets.length) return target == list[0][1] ? 10 : 0;
                            return target == list[0][2] ? 10 : 0;
                        });
                    }
                    else {
                        next.set('filterTarget', lib.filter.notMe);
                        next.set('ai', target => {
                            const player = get.player();
                            return get.effect(target, { name: 'draw' }, player, player);
                        });
                    }
                    event.result = await next.forResult();
                },
                async content(event, trigger, player) {
                    const { targets } = event;
                    if (targets.length > 1) {
                        await targets[0].useCard({ name: 'sha', isCard: true }, targets[1], false, 'noai');
                        if (targets[0].hasHistory('sourceDamage', evt => evt.getParent(3) == event)) await player.draw(2);
                    }
                    else {
                        await game.asyncDraw([player, targets[0]].sortBySeat());
                        targets[0].addTempSkill(event.name + '_effect', { player: 'phaseAfter' });
                        targets[0].addMark(event.name + '_effect', 1, false);
                    }
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name == 'sha' && player == _status.currentPhase) return num + player.countMark('miniremingce_effect');
                            },
                        },
                        intro: { content: '使用【杀】的次数上限+#' },
                    }
                },
            },
            minizhichi: {
                audio: 'zhichi',
                inherit: 'zhichi',
                content() {
                    player.addTempSkill(event.name + '_effect');
                },
                subSkill: {
                    effect: {
                        audio: 'zhichi',
                        trigger: { player: 'damageBegin4', target: 'useCardToBefore' },
                        charlotte: true,
                        forced: true,
                        filter(event, player) {
                            return get.type(event.card) == 'trick' || event.name == 'damage';
                        },
                        content() {
                            player.chat('喜！');
                            trigger.cancel();
                        },
                        mark: true,
                        intro: { content: '防止你受到的伤害且普通锦囊牌对你无效' },
                        ai: {
                            maixie: true,
                            maixie_hp: true,
                            nofire: true,
                            nothunder: true,
                            nodamage: true,
                            effect: {
                                target(card, player, target, current) {
                                    if (get.type(card) == 'trick' || get.tag(card, 'damage')) return 'zeroplayertarget';
                                },
                            },
                        },
                    }
                }
            },
            miniluanji: {
                audio: 'luanji',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return player.countCards('hs') > 1;
                },
                direct: true,
                clearTime: true,
                async content(event, trigger, player) {
                    const next = player.chooseToUse();
                    next.set('openskilldialog', '乱击：是否将两张手牌当作【万箭齐发】使用？');
                    next.set('norestore', true);
                    next.set('_backupevent', `${event.name}_backup`);
                    next.set('custom', {
                        add: {},
                        replace: { window() { } },
                    });
                    next.backup(`${event.name}_backup`);
                    next.logSkill = event.name;
                },
                subSkill: {
                    backup: {
                        viewAs: { name: 'wanjian' },
                        filterCard(card) {
                            return get.itemtype(card) == 'card';
                        },
                        position: 'hs',
                        selectCard: 2,
                        check(card) {
                            return 5 - get.value(card);
                        },
                        log: false,
                    }
                }
            },
            minireluanji: {
                audio: 'reluanji',
                enable: 'phaseUse',
                viewAs: { name: 'wanjian' },
                filterCard(card, player) {
                    if (!player.storage.minireluanji) return true;
                    return !player.storage.minireluanji.includes(get.suit(card));
                },
                position: 'hs',
                selectCard: 2,
                check(card) {
                    var player = _status.event.player;
                    var targets = game.filterPlayer(function (current) {
                        return player.canUse('wanjian', current);
                    });
                    var num = 0;
                    for (var i = 0; i < targets.length; i++) {
                        var eff = Math.sign(get.effect(targets[i], { name: 'wanjian' }, player, player));
                        if (targets[i].hp == 1) {
                            eff *= 1.5;
                        }
                        num += eff;
                    }
                    if (!player.needsToDiscard(-1)) {
                        if (targets.length >= 7) {
                            if (num < 2) return 0;
                        }
                        else if (targets.length >= 5) {
                            if (num < 1.5) return 0;
                        }
                    }
                    return 6 - get.value(card);
                },
                ai: {
                    basic: {
                        order: 8.9
                    }
                },
                group: ['minireluanji_count', 'minireluanji_reset', 'minireluanji_damage', 'minireluanji_draw'],
                subSkill: {
                    reset: {
                        trigger: { player: 'phaseAfter' },
                        silent: true,
                        content() {
                            delete player.storage.minireluanji;
                            delete player.storage.minireluanji2;
                        }
                    },
                    count: {
                        trigger: { player: 'useCard' },
                        silent: true,
                        filter(event) {
                            return event.skill == 'minireluanji';
                        },
                        content() {
                            player.storage.minireluanji2 = trigger.card;
                            if (!player.storage.minireluanji) {
                                player.storage.minireluanji = [];
                            }
                            for (var i = 0; i < trigger.cards.length; i++) {
                                player.storage.minireluanji.add(get.suit(trigger.cards[i]));
                            }
                        }
                    },
                    damage: {
                        trigger: { source: 'damage' },
                        forced: true,
                        silent: true,
                        popup: false,
                        filter(event, player) {
                            return player.storage.minireluanji2 && event.card == player.storage.minireluanji2;
                        },
                        content() {
                            delete player.storage.minireluanji2;
                        },
                    },
                    draw: {
                        trigger: { player: 'useCardAfter' },
                        forced: true,
                        silent: true,
                        popup: false,
                        filter(event, player) {
                            return player.storage.minireluanji2 && event.card == player.storage.minireluanji2;
                        },
                        content() {
                            player.draw(trigger.targets.length);
                            delete player.storage.minireluanji2;
                        },
                    },
                }
            },
            minixueyi: {
                audio: 'xueyi',
                audioname: ['re_yuanshao'],
                enable: 'chooseToUse',
                trigger: { global: 'phaseBefore', player: 'enterGame' },
                filter(event, player) {
                    if (event.name == 'chooseToUse') {
                        if (!player.hasMark('minixueyi')) return false;
                        if (event.type == 'dying') return player == event.dying;
                        if (event.parent.name == 'phaseUse') return true;
                        return false;
                    }
                    if (!game.hasPlayer(current => current.group == 'qun')) return false
                    return event.name != 'phase' || game.phaseNumber == 0;
                },
                forced: true,
                zhuSkill: true,
                content() {
                    if (event.getParent(2).name == 'chooseToUse') {
                        player.removeMark('minixueyi', 1);
                        player.recover();
                        player.draw();
                    }
                    else player.addMark('minixueyi', game.countPlayer(current => current.group == 'qun'));
                },
                marktext: '裔',
                intro: {
                    name2: '裔',
                    content: 'mark',
                },
                mod: {
                    maxHandcard(player, num) {
                        return num + (player.countMark('minixueyi') * 2);
                    },
                },
                ai: {
                    order: 7,
                    save: true,
                    skillTagFilter(player, tag, target) {
                        if (player != target || !player.hasMark('minixueyi')) return false;
                    },
                    result: {
                        player(player) {
                            return player.isDamaged() ? 1 : -1;
                        },
                    },
                },
            },
            minijiuchi: {
                audio: 'jiuchi',
                enable: 'chooseToUse',
                filterCard(card) {
                    return get.color(card) == 'black';
                },
                viewAs: { name: 'jiu' },
                viewAsFilter(player) {
                    if (!player.countCards('hs', { color: 'black' })) return false;
                    return true;
                },
                prompt: '将一张黑色手牌当酒使用',
                check(card) {
                    if (_status.event.type == 'dying') return 1 / Math.max(0.1, get.value(card));
                    return 4 - get.value(card);
                },
            },
            minibenghuai: {
                audio: 'benghuai',
                inherit: 'benghuai',
                content() {
                    var next = game.createEvent('minibenghuai_benghuai');
                    next.player = player;
                    next.setContent(lib.skill.benghuai.content);
                    player.draw();
                },
            },
            miniwansha: {
                audio: 'wansha',
                audioname: ['re_jiaxu'],
                audioname2: { shen_simayi: "jilue_wansha" },
                global: 'miniwansha2',
                trigger: { global: 'dying' },
                forced: true,
                preHidden: true,
                filter(event, player, name) {
                    return _status.currentPhase == player && event.player != player;
                },
                content() { },
            },
            miniwansha2: {
                mod: {
                    cardSavable(card, player) {
                        const target = _status.currentPhase;
                        if (!target?.isIn()) return;
                        if ((target.hasSkill('miniwansha') || target.hasSkill('minirewansha')) && target != player) {
                            if (card.name == 'tao') return false;
                        }
                    },
                    cardEnabled(card, player) {
                        return lib.skill.miniwansha2.mod.cardSavable.apply(this, arguments);
                    },
                },
            },
            minirewansha: {
                inherit: 'miniwansha',
                group: 'minirewansha_effect',
                subSkill: {
                    effect: {
                        audio: 'wansha',
                        audioname: ['re_jiaxu'],
                        audioname2: { shen_simayi: "jilue_wansha" },
                        trigger: {
                            player: 'phaseUseBegin',
                        },
                        filter(event, player) {
                            return game.hasPlayer(current => current != player && current.hp > 1);
                        },
                        async cost(event, trigger, player) {
                            event.result = await player.chooseTarget(get.prompt('minirewansha'), '令一名体力值大于1的其他角色失去1点体力，本阶段结束时其回复1点体力', (card, player, target) => {
                                return target != player && target.hp > 1;
                            }).set('ai', target => {
                                const player = get.player();
                                return get.effect(target, { name: 'losehp' }, player, player);
                            }).forResult();
                        },
                        async content(event, trigger, player) {
                            const target = event.targets[0];
                            player.line(target);
                            await target.loseHp();
                            player.when('phaseUseEnd').then(() => {
                                if (target.isIn()) target.recover();
                            }).vars({ target: target });
                        },
                    }
                }
            },
            minimieji: {
                audio: 'xinmieji',
                enable: 'phaseUse',
                usable: 1,
                filter(event, player) {
                    return player.countCards('he', { color: 'black' }) > 0;
                },
                filterCard(card) {
                    return get.color(card) == 'black';
                },
                position: 'he',
                filterTarget(card, player, target) {
                    return target != player && target.countCards('h');
                },
                discard: false,
                delay: false,
                check(card) {
                    return 8 - get.value(card);
                },
                loseTo: 'cardPile',
                insert: true,
                content() {
                    'step 0'
                    player.$throw(1, 1000);
                    game.log(player, '将一张牌置于了牌堆顶');
                    game.delayx();
                    'step 1'
                    target.chooseToDiscard('he', true).set('prompt', '请弃置一张锦囊牌，或依次弃置两张非锦囊牌。');
                    'step 2'
                    if ((!result.cards || get.type(result.cards[0], 'trick', result.cards[0].original == 'h' ? target : false) != 'trick') && target.countCards('he', function (card) {
                        return get.type2(card) != 'trick';
                    })) {
                        target.chooseToDiscard('he', true, function (card) {
                            return get.type2(card) != 'trick';
                        }).set('prompt', '请弃置第二张非锦囊牌');
                    }
                },
                ai: {
                    order: 9,
                    result: {
                        target: -1,
                    },
                },
            },
            minishibei: {
                audio: 'shibei',
                trigger: { player: 'damageEnd' },
                forced: true,
                check(event, player) {
                    return player.getHistory('damage', function (evt) {
                        return evt != event
                    }).length == 0;
                },
                content() {
                    if (player.getHistory('damage', function (evt) {
                        return evt != trigger
                    }).length > 0) {
                        player.loseHp();
                    }
                    else {
                        player.recover();
                        player.draw();
                    }
                },
                subSkill: {
                    damaged: {},
                    ai: {},
                },
                ai: {
                    maixie_defend: true,
                    threaten: 0.9,
                    effect: {
                        target(card, player, target) {
                            if (player.hasSkillTag('jueqing')) return;
                            if (target.hujia) return;
                            if (player._minishibei_tmp) return;
                            if (target.hasSkill('minishibei_ai')) return;
                            if (_status.event.getParent('useCard', true) || _status.event.getParent('_wuxie', true)) return;
                            if (get.tag(card, 'damage')) {
                                if (target.getHistory('damage').length > 0) {
                                    return [1, -2];
                                }
                                else {
                                    if (get.attitude(player, target) > 0 && target.hp > 1) {
                                        return 0;
                                    }
                                    if (get.attitude(player, target) < 0 && !player.hasSkillTag('damageBonus')) {
                                        if (card.name == 'sha') return;
                                        var sha = false;
                                        player._minishibei_tmp = true;
                                        var num = player.countCards('h', function (card) {
                                            if (card.name == 'sha') {
                                                if (sha) {
                                                    return false;
                                                }
                                                else {
                                                    sha = true;
                                                }
                                            }
                                            return get.tag(card, 'damage') && player.canUse(card, target) && get.effect(target, card, player, player) > 0;
                                        });
                                        delete player._minishibei_tmp;
                                        if (player.hasSkillTag('damage')) {
                                            num++;
                                        }
                                        if (num < 2) {
                                            var enemies = player.getEnemies();
                                            if (enemies.length == 1 && enemies[0] == target && player.needsToDiscard()) {
                                                return;
                                            }
                                            return 0;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },
            //华佗
            minijijiu: {
                mod: {
                    aiValue(player, card, num) {
                        if (get.name(card) != 'tao' && get.color(card) != 'red') return;
                        var cards = player.getCards('hs', function (card) {
                            return get.name(card) == 'tao' || get.color(card) == 'red';
                        });
                        cards.sort(function (a, b) {
                            return (get.name(a) == 'tao' ? 1 : 2) - (get.name(b) == 'tao' ? 1 : 2);
                        });
                        var geti = function () {
                            if (cards.includes(card)) {
                                return cards.indexOf(card);
                            }
                            return cards.length;
                        };
                        return Math.max(num, [6.5, 4, 3, 2][Math.min(geti(), 2)]);
                    },
                    aiUseful() {
                        return lib.skill.minijijiu.mod.aiValue.apply(this, arguments);
                    },
                },
                locked: false,
                audio: 'jijiu',
                audioname: ['re_huatuo'],
                enable: 'chooseToUse',
                viewAsFilter(player) {
                    return player != _status.currentPhase && player.countCards('hes', { color: 'red' }) > 0;
                },
                filterCard(card) {
                    return get.color(card) == 'red';
                },
                position: 'hes',
                viewAs: { name: 'tao' },
                prompt: '将一张红色牌当作【桃】使用，然后你可以弃置一名其他角色的一张手牌',
                check(card) {
                    return 1 / (get.value(card) || 0.5);
                },
                onuse(result, player) {
                    player.addTempSkill('minijijiu_qixi');
                },
                subSkill: {
                    qixi: {
                        charlotte: true,
                        trigger: { player: 'useCardAfter' },
                        filter(event, player) {
                            return event.skill == 'minijijiu' && game.hasPlayer(function (target) {
                                return target != player && target.countDiscardableCards(player, 'h');
                            });
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseTarget(get.prompt('minijijiu'), '弃置一名其他角色的一张手牌', function (card, player, target) {
                                return target != player && target.countDiscardableCards(player, 'h');
                            }).set('ai', function (target) {
                                var player = _status.event.player;
                                return get.effect(target, { name: 'guohe_copy2' }, player, player);
                            });
                            'step 1'
                            if (result.bool) {
                                player.line(result.targets);
                                player.discardPlayerCard(result.targets[0], 'h', true);
                            }
                        },
                    },
                },
            },
            minireqingnang: {
                audio: 'new_reqingnang',
                enable: 'phaseUse',
                filterTarget: true,
                selectTarget: [1, Infinity],
                multitarget: true,
                multiline: true,
                usable: 1,
                content() {
                    'step 0'
                    targets.forEach(target => {
                        target.gainMaxHp();
                        target.recover();
                    });
                    player.when('phaseBegin').vars({ targets: targets }).then(() => targets.forEach(target => target.loseMaxHp()));
                    'step 1'
                    if (targets.length > 1) player.chooseToDiscard(targets.length - 1, 'he', true);
                },
                ai: {
                    order: 1,
                    result: { target: 1 },
                },
            },
            miniqingnang: {
                audio: 'qingnang',
                inherit: 'qingnang',
                filterCard: false,
            },
            minileiji: {
                mod: { maxHandcard: (player, num) => num + 2 },
                audio: 'xinleiji',
                trigger: { player: ['useCard', 'respond'] },
                filter(event, player) {
                    return event.card.name == 'shan' || event.card.name == 'shandian';
                },
                direct: true,
                content() {
                    'step 0';
                    player.chooseTarget(get.prompt('minileiji'), '令一名其他角色进行判定', lib.filter.notMe).set('ai', function (target) {
                        if (target.hasSkill('hongyan')) return 0;
                        return get.damageEffect(target, _status.event.player, _status.event.player, 'thunder');
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minileiji', result.targets, 'thunder');
                        event.target = result.targets[0];
                        event.target.judge(function (card) {
                            var suit = get.suit(card);
                            if (suit == 'spade') return -4;
                            if (suit == 'club') return -2;
                            return 0;
                        }).judge2 = function (result) {
                            return result.bool == false ? true : false;
                        };
                    }
                    else event.finish();
                    'step 2'
                    if (result.suit == 'club') {
                        target.damage('thunder');
                        player.recover();
                    }
                    else if (result.suit == 'spade') target.damage(2, 'thunder');
                },
                ai: {
                    useShan: true,
                    effect: {
                        target(card, player, target, current) {
                            if (get.tag(card, 'respondShan') && !player.hasSkillTag('directHit_ai', true, {
                                target: target,
                                card: card,
                            }, true)) {
                                var hastarget = game.hasPlayer(function (current) {
                                    return get.attitude(target, current) < 0;
                                });
                                var be = target.countCards('e', { color: 'black' });
                                if (target.countCards('h', 'shan') && be) {
                                    if (!target.hasSkill('xinguidao')) return 0;
                                    return [0, hastarget ? target.countCards('he') / 2 : 0];
                                }
                                if (target.countCards('h', 'shan') && target.countCards('h') > 2) {
                                    if (!target.hasSkill('xinguidao')) return 0;
                                    return [0, hastarget ? target.countCards('h') / 4 : 0];
                                }
                                if (target.countCards('h') > 3 || (be && target.countCards('h') >= 2)) {
                                    return [0, 0];
                                }
                                if (target.countCards('h') == 0) {
                                    return [1.5, 0];
                                }
                                if (target.countCards('h') == 1 && !be) {
                                    return [1.2, 0];
                                }
                                if (!target.hasSkill('xinguidao')) return [1, 0.05];
                                return [1, Math.min(0.5, (target.countCards('h') + be) / 4)];
                            }
                        },
                    },
                },
            },
            minihuangtian: {
                audio: 'huangtian2',
                trigger: { global: ['useCardAfter', 'responseAfter'] },
                filter(event, player) {
                    if (event.player === player || !player.hasZhuSkill('minihuangtian', event.player)) return false;
                    return event.card.name === 'shan' && event.player.group == 'qun' && event.cards.someInD('od');
                },
                prompt2(event, player) {
                    return '获得' + get.translation(event.cards.filterInD());
                },
                usable: 1,
                zhuSkill: true,
                logTarget: 'player',
                content() {
                    player.gain(trigger.cards.filterInD(), 'gain2');
                },
                global: 'minihuangtian_global',
                subSkill: {
                    global: {
                        forceaudio: true,
                        audio: 'huangtian2',
                        enable: 'phaseUse',
                        filter(event, player) {
                            if (player.group !== 'qun' || !player.hasCard(card => lib.skill.minihuangtian_global.filterCard(card, player), 'h')) return false;
                            return game.hasPlayer(target => lib.skill.minihuangtian_global.filterTarget(null, player, target));
                        },
                        filterCard(card, player) {
                            return card.name == 'shan' || card.name == 'shandian';
                        },
                        filterTarget(card, player, target) {
                            if (player.getStorage('minihuangtian_used').includes(target)) return false;
                            return target !== player && target.hasZhuSkill('minihuangtian', player);
                        },
                        prompt() {
                            var player = _status.event.player;
                            var list = game.filterPlayer(target => lib.skill.minihuangtian_global.filterTarget(null, player, target));
                            var str = '将一张【闪】或【闪电】交给' + get.translation(list);
                            if (list.length > 1) str += '中的一人';
                            return str;
                        },
                        discard: false,
                        lose: false,
                        delay: false,
                        content() {
                            player.addTempSkill('minihuangtian_used', 'phaseUseAfter');
                            player.markAuto('minihuangtian_used', [target]);
                            target.gain(cards, player, 'give');
                        },
                        ai: {
                            expose: 0.3,
                            order: 10,
                            result: { target: 1 },
                        },
                    },
                    used: {
                        charlotte: true,
                        onremove: true,
                    },
                },
            },
            minixinhuangtian: {
                audio: 'xinhuangtian2',
                audioname: ['re_zhangjiao'],
                inherit: 'minihuangtian',
                filter(event, player) {
                    if (event.player === player || !player.hasZhuSkill('minixinhuangtian', event.player)) return false;
                    return event.card.name === 'shan' && event.player.group == 'qun' && event.cards.someInD('od');
                },
                global: 'minixinhuangtian_global',
                subSkill: {
                    global: {
                        forceaudio: true,
                        audio: 'xinhuangtian2',
                        audioname: ['re_zhangjiao'],
                        enable: 'phaseUse',
                        filter(event, player) {
                            if (player.group !== 'qun' || !player.hasCard(card => lib.skill.minixinhuangtian_global.filterCard(card, player), 'h')) return false;
                            return game.hasPlayer(target => lib.skill.minixinhuangtian_global.filterTarget(null, player, target));
                        },
                        filterCard(card, player) {
                            return card.name == 'shan' || card.name == 'shandian' || get.suit(card) == 'spade';
                        },
                        filterTarget(card, player, target) {
                            if (player.getStorage('minixinhuangtian_used').includes(target)) return false;
                            return target !== player && target.hasZhuSkill('minixinhuangtian', player);
                        },
                        prompt() {
                            var player = _status.event.player;
                            var list = game.filterPlayer(target => lib.skill.minixinhuangtian_global.filterTarget(null, player, target));
                            var str = '将一张【闪】或【闪电】或黑桃手牌交给' + get.translation(list);
                            if (list.length > 1) str += '中的一人';
                            return str;
                        },
                        discard: false,
                        lose: false,
                        delay: false,
                        content() {
                            player.addTempSkill('minixinhuangtian_used', 'phaseUseAfter');
                            player.markAuto('minixinhuangtian_used', [target]);
                            target.gain(cards, player, 'give');
                        },
                        ai: {
                            expose: 0.3,
                            order: 10,
                            result: { target: 1 },
                        },
                    },
                    used: {
                        charlotte: true,
                        onremove: true,
                    },
                },
            },
            miniyinlang: {
                global: 'miniyinlang_use',
                audio: 'yinlang',
                trigger: { player: 'phaseUseEnd' },
                direct: true,
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current.group && current.group != 'unknown';
                    });
                },
                content() {
                    'step 0'
                    var list = [];
                    game.countPlayer(function (current) {
                        if (current.group && current.group != 'unknown') list.add(current.group);
                    });
                    list.sort(function (a, b) {
                        return lib.group.indexOf(a) - lib.group.indexOf(b);
                    });
                    list.push('cancel2');
                    player.chooseControl(list).set('prompt', get.prompt2('miniyinlang')).set('ai', function () {
                        return _status.event.choice;
                    }).set('choice', function () {
                        var getn = function (group) {
                            return game.countPlayer(function (current) {
                                if (current.group != group || current == player) return false;
                                if (get.attitude(current, player) > 0) return -0.5;
                                if (!current.inRange(player)) return 1;
                                return 0.6;
                            });
                        }
                        list.sort((a, b) => getn(b) - getn(a));
                        return list[0];
                    }());
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('miniyinlang', game.filterPlayer(function (current) {
                            return current.group == result.control;
                        }));
                        game.log(player, '选择了', '#y' + get.translation(result.control + 2));
                        for (var i of game.players) {
                            if (i == player || i.group == result.control) i.addMark('miniyinlang', 1);
                        }
                    }
                },
                marktext: '生', intro: { name: '引狼', name2: '生', content: 'mark' },
                subSkill: {
                    use: {
                        mod: {
                            playerEnabled(card, player, target) {
                                if (game.hasPlayer(function (current) {
                                    return current.hasSkill('miniyinlang');
                                }) && player.hasMark('miniyinlang') && !target.hasMark('miniyinlang')) return false;
                            },
                        },
                    },
                },
            },
            minixiusheng: {
                audio: 'xiusheng',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current.hasMark('miniyinlang');
                    });
                },
                forced: true,
                logTarget(event, player) {
                    return game.filterPlayer(function (current) {
                        return current.hasMark('miniyinlang');
                    });
                },
                content() {
                    var num = 0;
                    for (var i of game.players) {
                        if (i.hasMark('miniyinlang')) {
                            var numx = i.countMark('miniyinlang');
                            i.removeMark('miniyinlang', numx);
                            num += numx;
                        }
                    }
                    player.draw(num);
                },
                ai: { combo: 'miniyinlang' },
            },
            minihuaibi: {
                mod: {
                    maxHandcard(player, num) {
                        if (player.storage.miniyinlang) return num + game.countPlayer(function (current) {
                            return current.countMark('miniyinlang');
                        });
                    },
                },
                group: 'minihuaibi_discard',
                audio: 'huaibi',
                trigger: { player: 'damageEnd' },
                filter(event, player) {
                    return event.source && event.source.hasMark('miniyinlang');
                },
                forced: true,
                zhuSkill: true,
                content() {
                    player.draw();
                },
                ai: { combo: 'miniyinlang' },
                subSkill: {
                    discard: {
                        audio: 'huaibi',
                        trigger: { player: 'phaseDiscardBefore' },
                        filter(event, player) {
                            return game.hasPlayer(function (current) {
                                return current.hasMark('miniyinlang');
                            }) && player.countCards('h') > player.hp;
                        },
                        forced: true,
                        firstDo: true,
                        content() { },
                    },
                },
            },
            minikuangfu: {
                audio: 'xinkuangfu',
                enable: 'phaseUse',
                filterTarget(card, player, target) {
                    if (player == target) return player.countCards('e', function (card) {
                        return lib.filter.cardDiscardable(card, player);
                    }) > 0;
                    return target.countDiscardableCards(player, 'e') > 0;
                },
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current.countCards('e');
                    });
                },
                usable: 1,
                delay: false,
                content() {
                    'step 0'
                    if (player == target) player.chooseToDiscard('e', true);
                    else player.discardPlayerCard(target, 'e', true);
                    'step 1'
                    player.chooseUseTarget('sha', true, false, 'nodistance');
                    'step 2'
                    var bool = game.hasPlayer2(function (current) {
                        return current.getHistory('damage', function (evt) {
                            return evt.getParent(4) == event;
                        }).length > 0
                    });
                    if (bool) player.draw(2);
                },
                ai: {
                    order() {
                        return get.order({ name: 'sha' }) - 0.3;
                    },
                    result: {
                        target(player, target) {
                            var att = get.attitude(player, target);
                            if (att < 0) return -2;
                            if (target == player) return 1;
                            return 0;
                        },
                    },
                },
            },
            minilihun: {
                audio: 'lihun',
                inherit: 'lihun',
                filterTarget: lib.filter.notMe,
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current != player && current.countCards('h');
                    });
                },
                filterCard: () => false,
                selectCard: -1,
            },
            minizhuiji: {
                mod: {
                    globalFrom(from, to) {
                        if (from.hp >= to.hp) return -Infinity;
                    },
                },
                trigger: { player: 'useCardToPlayered' },
                logTarget: 'target',
                filter(event, player) {
                    if (event.card.name != 'sha') return false;
                    return event.target.hp >= player.hp;
                },
                forced: true,
                preHidden: true,
                logTarget: 'target',
                content() {
                    trigger.getParent().directHit.push(trigger.target);
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (arg.card.name != 'sha') return false;
                        return arg.target.hp > player.hp;
                    },
                },
            },
            minishichou: {
                group: ['minishichou2', 'minishichou4'],
                audio: 'ol_shichou',
                trigger: { player: 'useCard2' },
                filter(event, player) {
                    return event.card && event.card.name == 'sha' && game.hasPlayer(function (current) {
                        return !event.targets.includes(current) && lib.filter.filterTarget(event.card, player, current);
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    var num = Math.min(player.getDamagedHp() + 1, game.countPlayer(function (current) {
                        return !trigger.targets.includes(current) && lib.filter.filterTarget(trigger.card, player, current);
                    }));
                    player.chooseTarget(get.prompt('minishichou'), '令至多' + get.cnNumber(num) + '名其他角色也成为' + get.translation(trigger.card) + '的目标', [1, num], function (card, player, target) {
                        var evt = _status.event.getTrigger();
                        return target != player && !evt.targets.includes(target) && lib.filter.targetEnabled2(evt.card, player, target) && lib.filter.targetInRange(evt.card, player, target);
                    }).ai = function (target) {
                        return get.effect(target, { name: 'sha' }, _status.event.player);
                    };
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets;
                        player.logSkill('minishichou', targets);
                        player.line(targets, trigger.card.nature);
                        trigger.targets.addArray(targets);
                    }
                },
            },
            minishichou2: {
                audio: 'ol_shichou',
                trigger: { source: 'damageSource' },
                filter(event, player) {
                    return event.card && event.card.name == 'sha' && player.countMark('minishichou3') < 3;
                },
                forced: true,
                locked: false,
                content() {
                    var num = Math.min(trigger.num, 3 - player.countMark('minishichou3'));
                    player.draw(num);
                    player.addTempSkill('minishichou3');
                    player.addMark('minishichou3', num, false);
                },
            },
            minishichou3: { charlotte: true, onremove: true },
            minishichou4: {
                audio: 'ol_shichou',
                trigger: { player: 'useCardAfter' },
                filter(event, player) {
                    return event.card.name == 'sha' && !player.getHistory('sourceDamage', function (evt) {
                        return evt.card == event.card;
                    }).length;
                },
                forced: true,
                locked: false,
                content() {
                    var card = get.cardPile2(function (card) {
                        return card.name == 'sha';
                    });
                    if (card) player.gain(card, 'gain2');
                },
            },
            minilijian: {
                audio: 'lijian',
                trigger: { player: ['useCard2', 'useCardToPlayer'] },
                filter(event, player) {
                    if (event.minilijian || !event.targets) return false;
                    return (event.card.name == 'sha' || event.card.name == 'juedou') && game.hasPlayer(function (current) {
                        return current != player && current.hasSex('male') && !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current);
                    });
                },
                usable: 1,
                direct: true,
                content() {
                    'step 0'
                    trigger.minilijian = true;
                    player.chooseTarget(get.prompt('minilijian'), '为' + get.translation(trigger.card) + '增加一个目标', function (card, player, target) {
                        var evt = _status.event.getTrigger();
                        return !evt.targets.includes(target) && target != player && target.hasSex('male') && lib.filter.targetEnabled2(evt.card, player, target);
                    }).set('ai', function (target) {
                        var evt = _status.event.getTrigger();
                        return get.effect(target, evt.card, evt.player, evt.player);
                    });
                    'step 1'
                    if (result.bool) {
                        if (player != game.me && !player.isOnline()) game.delayx();
                        event.target = result.targets[0];
                    }
                    else {
                        player.storage.counttrigger.minilijian--;
                        event.finish();
                    }
                    'step 2'
                    player.logSkill('minilijian', target);
                    trigger.targets.push(target);
                    game.log(target, '成为了', trigger.card, '的额外目标');
                },
            },
            minijiqiao: {
                audio: 'jiqiao',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return player.countCards('he') - player.countCards('he', { type: 'trick' }) > 0;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseToDiscard(get.prompt2('minijiqiao'), [1, player.countCards('he') - player.countCards('he', { type: 'trick' })], 'he', function (card) {
                        return get.type2(card) != 'trick';
                    }).set('ai', function (card) {
                        if (card.name == 'bagua') return 10;
                        return 7 - get.value(card);
                    }).logSkill = 'jiqiao';
                    'step 1'
                    if (result.bool) {
                        event.cards = get.cards(2 * result.cards.length);
                        player.showCards(event.cards);
                    }
                    else event.finish();
                    'step 2'
                    var gained = [];
                    var tothrow = [];
                    if (event.cards?.length) {
                        for (var i = 0; i < event.cards.length; i++) {
                            if (get.type2(event.cards[i]) == 'trick') gained.push(event.cards[i]);
                            else tothrow.push(event.cards[i]);
                        }
                    }
                    if (gained.length) player.gain(gained, 'gain2');
                    else {
                        var card = get.cardPile(function (card) {
                            return get.type2(card) == 'trick';
                        });
                        if (card) player.gain(card, 'gain2');
                    }
                    if (tothrow.length) game.cardsDiscard(tothrow);
                },
            },
            minilinglong: {
                derivation: ['bagua_skill', 'minijizhi', 'qicai'],
                audio: 'linglong',
                group: ['linglong_bagua', 'minilinglong_jizhi'],
                locked: true,
                mod: {
                    maxHandcard(player, num) {
                        if (player.getEquips(3).length || player.getEquips(4).length) return;
                        return num + 1;
                    },
                    targetInRange(card, player, target, now) {
                        if (player.countCards('e')) return;
                        var type = get.type(card);
                        if (type == 'trick' || type == 'delay') return true;
                    },
                },
                init(player, skill) {
                    player.addExtraEquip(skill, 'bagua', true, player => player.hasEmptySlot(2) && lib.card['bagua']);
                },
                onremove(player, skill) {
                    player.removeExtraEquip(skill);
                },
            },
            minilinglong_jizhi: {
                audio: 'rejizhi',
                inherit: 'minijizhi',
                filter(event, player) {
                    return !player.countCards('e') && get.type2(event.card) == 'trick';
                },
            },
            minifuqi: {
                group: 'minifuqi_tieji',
                audio: 'fuqi',
                trigger: { player: 'useCard' },
                filter(event, player) {
                    return event.card && (get.type(event.card) == 'trick' || get.type(event.card) == 'basic' && !['shan', 'tao', 'jiu', 'du'].includes(event.card.name)) && game.hasPlayer(function (current) {
                        return current != player && get.distance(current, player) <= 2;
                    });
                },
                forced: true,
                content() {
                    var targets = game.filterPlayer(function (current) {
                        return current != player && get.distance(current, player) <= 2;
                    });
                    for (var target of targets) target.popup('无法响应');
                    trigger.directHit.addArray(targets);
                },
                ai: {
                    ignoreSkill: true,
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (tag == 'directHit_ai') return get.distance(arg.target, player) <= 2;
                        if (!arg || arg.isLink || !arg.card || !get.tag(arg.card, 'damage')) return false;
                        if (!arg.skill || !lib.skill[arg.skill] || lib.skill[arg.skill].charlotte || get.is.locked(arg.skill) || !arg.target.getSkills(true, false).includes(arg.skill)) return false;
                    },
                },
                subSkill: {
                    tieji: {
                        audio: 'fuqi',
                        trigger: { source: 'damageSource' },
                        filter(event, player) {
                            return event.player != player && event.player.isIn();
                        },
                        forced: true,
                        logTarget: 'player',
                        content() {
                            trigger.player.addTempSkill('fengyin');
                        },
                    },
                },
            },
            minijiaozi: {
                audio: 'jiaozi',
                trigger: { source: 'damageBegin1' },
                filter(event, player) {
                    return player.isMaxHandcard();
                },
                forced: true,
                content() {
                    trigger.num++;
                },
                ai: { presha: true },
            },
            minitianming: {
                audio: 'tianming',
                trigger: { target: 'useCardToTargeted' },
                filter(event, player) {
                    return event.card.name == 'sha';
                },
                check(event, player) {
                    var cards = player.getCards('he');
                    if (cards.length <= 2) {
                        for (var i = 0; i < cards.length; i++) {
                            if (cards[i].name == 'shan' || cards[i].name == 'tao') return false;
                        }
                    }
                    return true;
                },
                content() {
                    'step 0'
                    player.chooseToDiscard(2, true, 'he');
                    player.draw(2);
                    'step 1'
                    player.chooseTarget('是否令一名角色弃置两张牌，然后摸两张牌？').set('ai', function (target) {
                        var cards = target.getCards('he');
                        if (cards.length <= 2) {
                            for (var i = 0; i < cards.length; i++) {
                                if (cards[i].name == 'shan' || cards[i].name == 'tao') return 0;
                            }
                        }
                        return get.attitude(player, target) * (target == player ? 1.2 : 1);
                    });
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target);
                        target.chooseToDiscard(2, true, 'he');
                        target.draw(2);
                    }
                },
                ai: {
                    effect: {
                        target(card, player, target, current) {
                            if (card.name == 'sha') return [1, 0.5];
                        },
                    },
                },
            },
            minimizhao: {
                audio: 'mizhao',
                inherit: 'mizhao',
                check(card) {
                    var player = _status.event.player;
                    if (ui.selected.cards.length && !game.hasPlayer(function (current) {
                        return get.attitude(player, current) > 0;
                    })) return -1;
                    return 1 / (get.value(card) || 0.5);
                },
                selectCard: [1, Infinity],
                ai: {
                    order: 1,
                    result: {
                        target(player, target) {
                            var num1 = game.countPlayer(function (current) {
                                return get.attitude(player, current) > 0;
                            }), num2 = game.countPlayer(function (current) {
                                return get.attitude(player, current) < 0;
                            });
                            if (target.hasSkillTag('nogain')) return 0;
                            if (num1 > 0 && num2 > 0) return 1;
                            if (player.countCards('h', card => get.value(card) > 0)) return 0;
                            if (num1 == 0 && num2 > 1) return -1;
                            return 0;
                        },
                    },
                },
            },
            minibeige: {
                audio: 'beige',
                audioname: ['re_caiwenji', 'ol_caiwenji'],
                trigger: { global: 'damageEnd' },
                filter(event, player) {
                    return event.card && event.card.name == 'sha' && event.source && event.player.isIn() && player.countCards('he');
                },
                direct: true,
                preHidden: true,
                content() {
                    'step 0'
                    player.chooseToDiscard('he', get.prompt2('minibeige', trigger.player)).set('ai', function (card) {
                        var player = _status.event.player;
                        var target = _status.event.list[0];
                        var source = _status.event.list[1];
                        var att1 = get.attitude(player, target);
                        var att2 = get.attitude(player, source);
                        switch (get.suit(card)) {
                            case 'heart': case 'diamond':
                                if (att1 > 0) return 10 - get.value(card);
                                return 0;
                                break;
                            case 'club':
                                if (att2 < 0) return (7 - get.value(card)) * (source.countCards('he') ? 1 : 0);
                                return 0;
                                break;
                            case 'spade':
                                if (att2 > 0 && source.isTurnedOver()) return 20 - get.value(card);
                                if (att2 < 0 && !source.isTurnedOver()) return 10 - get.value(card);
                                return 0;
                                break;
                        }
                    }).setHiddenSkill('minibeige').set('list', [trigger.player, trigger.source]).logSkill = 'minibeige';
                    'step 1'
                    if (result.bool) {
                        switch (get.suit(result.cards[0])) {
                            case 'heart': case 'diamond':
                                player.line(trigger.player);
                                trigger.player.recover();
                                trigger.player.draw(2);
                                break;
                            case 'club':
                                player.line(trigger.source);
                                trigger.source.chooseToDiscard('he', 2, true);
                                break;
                            case 'spade':
                                player.line(trigger.source);
                                trigger.source.turnOver();
                                break;
                        }
                    }
                },
                ai: { expose: 0.25 },
            },
            minizhuikong: {
                audio: 'zhuikong',
                trigger: { global: 'phaseZhunbeiBegin' },
                check(event, player) {
                    if (get.attitude(player, event.player) < -2) {
                        var cards = player.getCards('h');
                        if (cards.length > player.hp) return true;
                        for (var i = 0; i < cards.length; i++) {
                            var useful = get.useful(cards[i]);
                            if (useful < 5) return true;
                            if (get.number(cards[i]) > 9 && useful < 7) return true;
                        }
                    }
                    return false;
                },
                filter(event, player) {
                    return player.canCompare(event.player);
                },
                logTarget: 'player',
                content() {
                    'step 0'
                    player.chooseToCompare(trigger.player);
                    'step 1'
                    if (result.bool) trigger.player.addTempSkill('zishou2');
                    else {
                        trigger.player.addTempSkill('minizhuikong_distance');
                        trigger.player.storage.minizhuikong_distance.push(player);
                    }
                },
                subSkill: {
                    distance: {
                        init(player) {
                            player.storage.minizhuikong_distance = [];
                        },
                        charlotte: true,
                        onremove: true,
                        mod: {
                            globalFrom(from, to, distance) {
                                if (from.storage.minizhuikong_distance.includes(to)) return -Infinity;
                            },
                        },
                    },
                },
            },
            miniqiuyuan: {
                audio: 'qiuyuan',
                trigger: { target: 'useCardToTarget' },
                filter(event, player) {
                    return event.card.name == 'sha' && game.players.length > 2;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('miniqiuyuan'), [1, 3], function (card, player, target) {
                        return target != player && !_status.event.targets.includes(target) && _status.event.playerx.canUse('sha', target, false);
                    }).set('ai', function (target) {
                        var trigger = _status.event.getTrigger();
                        var player = _status.event.player;
                        return get.effect(target, trigger.card, trigger.player, player);
                    }).set('targets', trigger.targets).set('playerx', trigger.player);
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        event.targets = targets;
                        player.logSkill('miniqiuyuan', targets);
                        event.num = 0;
                        event.list = [];
                    }
                    else event.finish();
                    'step 2'
                    var target = targets[num];
                    event.target = target;
                    target.chooseCard({ name: 'shan' }, '交给' + get.translation(player) + '一张【闪】，或成为' + get.translation(trigger.card) + '的额外目标并弃置一张牌');
                    'step 3'
                    if (result.bool) player.gain(result.cards, target, 'giveAuto');
                    else {
                        trigger.getParent().targets.push(target);
                        trigger.getParent().triggeredTargets2.push(target);
                        game.log(target, '成为了', trigger.card, '的额外目标');
                        target.chooseToDiscard('he', true);
                    }
                    if (event.num < event.targets.length - 1) {
                        event.num++;
                        event.goto(2);
                    }
                    'step 4'
                    game.delayx();
                },
                ai: {
                    expose: 0.2,
                    effect: {
                        target(card, player, target) {
                            if (card.name != 'sha') return;
                            var players = game.filterPlayer();
                            if (get.attitude(player, target) <= 0) {
                                for (var i = 0; i < players.length; i++) {
                                    var target2 = players[i];
                                    if (player != target2 && target != target2 && player.canUse(card, target2, false) &&
                                        get.effect(target2, { name: 'shacopy', nature: card.nature, suit: card.suit }, player, target) > 0 &&
                                        get.effect(target2, { name: 'shacopy', nature: card.nature, suit: card.suit }, player, player) < 0) {
                                        if (target.hp == target.maxHp) return 0.3;
                                        return 0.6;
                                    }
                                }
                            }
                            else {
                                for (var i = 0; i < players.length; i++) {
                                    var target2 = players[i];
                                    if (player != target2 && target != target2 && player.canUse(card, target2, false) &&
                                        get.effect(target2, { name: 'shacopy', nature: card.nature, suit: card.suit }, player, player) > 0) {
                                        if (player.canUse(card, target2)) return;
                                        if (target.hp == target.maxHp) return [0, 1];
                                        return [0, 0];
                                    }
                                }
                            }
                        },
                    },
                },
            },
            //张琪瑛
            //欢杀版本已改为十周年新版，实际扩展版本已经入牢字辈了（）
            minidianhua: {
                audio: 'xinfu_dianhua',
                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                frequent: true,
                content() {
                    player.chooseToGuanxing(1 + lib.suit.filter(suit => player.hasMark(`xinfu_falu_${suit}`)).length);
                },
            },
            //乌巢酒仙
            minicangchu: {
                mod: {
                    maxHandcard(player, num) {
                        return num + player.countMark('minicangchu');
                    },
                },
                group: ['minicangchu2', 'minicangchu3'],
                audio: 'cangchu',
                trigger: { global: 'phaseBefore', player: 'enterGame' },
                filter(event, player) {
                    if (event.name == 'phase' && game.phaseNumber != 0) return false;
                    return player.countMark('minicangchu') < game.countPlayer();
                },
                forced: true,
                content() {
                    player.addMark('minicangchu', Math.min(3, game.countPlayer() - player.countMark('minicangchu')));
                },
                marktext: '粮',
                intro: { content: 'mark', name: '粮' },
            },
            minicangchu2: {
                audio: 'cangchu',
                trigger: { player: ['gainAfter', 'recoverEnd'], global: 'loseAsyncAfter' },
                filter(event, player) {
                    return player != _status.currentPhase && player.countMark('minicangchu') < game.countPlayer() && (event.name == 'recover' || event.getg(player).length);
                },
                forced: true,
                usable: 1,
                content() {
                    player.addMark('minicangchu', 1);
                },
            },
            minicangchu3: {
                audio: 'cangchu',
                trigger: { global: 'die' },
                filter(event, player) {
                    return player.countMark('minicangchu') > game.countPlayer();
                },
                forced: true,
                content() {
                    player.removeMark('minicangchu', player.countMark('minicangchu') - game.countPlayer());
                },
            },
            miniliangying: {
                audio: 'reliangying',
                trigger: { player: 'phaseDiscardBegin' },
                direct: true,
                content() {
                    'step 0'
                    var map = {};
                    var list = [];
                    for (var i = 1; i <= player.countMark('minicangchu'); i++) {
                        var cn = get.cnNumber(i, true);
                        map[cn] = i;
                        list.push(cn);
                    }
                    list.push('cancel2');
                    event.map = map;
                    player.chooseControl(list).set('prompt', get.prompt('miniliangying')).set('prompt2', '摸至多' + get.cnNumber(player.countMark('minicangchu')) + '张牌，然后交给等量的角色各一张牌').set('ai', function () {
                        var player = _status.event.player;
                        var num = Math.min(player.countMark('minicangchu'), game.countPlayer(function (current) {
                            return get.attitude(player, current) > 0;
                        }));
                        if (num > 0) return get.cnNumber(num, true);
                        return 'cancel2';
                    });
                    'step 1'
                    event.list = [];
                    if (result.control == 'cancel2') { event.finish(); return; }
                    player.logSkill('miniliangying');
                    var num = event.map[result.control] || 1;
                    event.num = num;
                    player.draw(num);
                    if (_status.connectMode) game.broadcastAll(function () { _status.noclearcountdown = true });
                    'step 2'
                    var num = Math.min(event.num, player.countCards('he'), game.players.length - 1);
                    var next = player.chooseCardTarget({
                        prompt: '粮营：将' + get.cnNumber(num - 1) + '至' + get.cnNumber(num) + '张牌交给其他角色',
                        position: 'he',
                        animate: false,
                        filterCard(card) {
                            for (var CT of _status.event.list) {
                                if (CT.card == card) return false;
                            }
                            return true;
                        },
                        filterTarget(card, player, target) {
                            for (var CT of _status.event.list) {
                                if (CT.target == target) return false;
                            }
                            return target != player;
                        },
                        ai1(card) {
                            if (card.name == 'shan') return 1;
                            return Math.random();
                        },
                        ai2(target) {
                            var player = _status.event.player;
                            return get.attitude(player, target);
                        },
                    });
                    next.set('list', event.list);
                    if (num - event.list.length > 1) next.set('forced', true);
                    'step 3'
                    if (result.bool) {
                        var num = Math.min(event.num, player.countCards('he'), game.players.length - 1);
                        var CT = {
                            target: result.targets[0],
                            card: result.cards[0],
                        };
                        player.addGaintag(result.cards, 'olsujian_given');
                        event.list.push(CT);
                        if (num - event.list.length >= 1) event.goto(2);
                    }
                    else if (!event.list.length > 0) event.finish();
                    'step 4'
                    if (_status.connectMode) {
                        game.broadcastAll(function () { delete _status.noclearcountdown; game.stopCountChoose() });
                    }
                    var list = [];
                    var cards = [];
                    for (var obj of event.list) {
                        cards.push(obj.card);
                        list.push([obj.target, obj.card]);
                        player.line(obj.target);
                    }
                    game.loseAsync({
                        gain_list: list,
                        player: player,
                        cards: cards,
                        giver: player,
                        animate: 'giveAuto',
                    }).setContent('gaincardMultiple');
                },
            },
            minishishou: {
                audio: 'reshishou',
                trigger: { player: ['useCard', 'damageEnd'] },
                filter(event, player) {
                    if (!player.countMark('minicangchu')) return false;
                    return (event.name == 'damage') ? (event.hasNature('fire')) : (event.card && event.card.name == 'jiu');
                },
                forced: true,
                content() {
                    player.removeMark('minicangchu', 1);
                },
            },
            minizongkui: {
                audio: 'zongkui',
                trigger: { global: 'phaseBefore', player: ['phaseBegin', 'enterGame'] },
                filter(event, player, name) {
                    if (name == 'phaseBefore' && game.phaseNumber > 0) return false;
                    return game.hasPlayer(function (current) {
                        if ((name == 'phaseBefore' || name == 'enterGame') && !current.isMinHp()) return false;
                        return current != player && !current.hasMark('zongkui_mark');
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    event.logged = false;
                    if (event.triggername == 'phaseBefore' || event.triggername == 'enterGame') {
                        player.logSkill('minizongkui');
                        event.logged = true;
                    }
                    var targets = game.filterPlayer(function (current) {
                        if ((event.triggername == 'phaseBefore' || event.triggername == 'enterGame') && !current.isMinHp()) return false;
                        return current != player && !current.hasMark('zongkui_mark');
                    });
                    if ((event.triggername == 'phaseBefore' || event.triggername == 'enterGame') && targets.length == 1) {
                        event._result = { bool: true, targets: targets };
                    }
                    else {
                        var next = player.chooseTarget(event.logged ? '请选择【纵傀】的目标' : get.prompt('zongkui'), '令一名' + ((event.triggername == 'phaseBefore' || event.triggername == 'enterGame') ? '体力值最小的' : '') + '其他角色获得“傀”标记', function (card, player, target) {
                            if (_status.event.round && !target.isMinHp()) return false;
                            return target != player && !target.hasMark('zongkui_mark');
                        }).set('ai', function (target) {
                            var num = target.isMinHp() ? 0.5 : 1;
                            return num * get.threaten(target);
                        }).set('round', event.triggername == 'phaseBefore' || event.triggername == 'enterGame');
                        if (event.triggername == 'phaseBefore' || event.triggername == 'enterGame') next.set('forced', true);
                    }
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        if (!event.logged) player.logSkill('minizongkui', target);
                        else player.line(target);
                        target.addMark('zongkui_mark', 1);
                        game.delayx();
                    }
                },
            },
            miniguju: {
                audio: 'guju',
                inherit: 'guju',
                content() {
                    player.draw();
                },
            },
            minilianzhu: {
                audio: 'lianzhu',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he');
                },
                filterTarget: lib.filter.notMe,
                filterCard: true,
                check(card) {
                    var num = get.value(card);
                    if (get.color(card) == 'black') {
                        if (num >= 6) return 0;
                        return 9 - num;
                    }
                    else return 7 - num;
                },
                usable: 1,
                discard: false,
                lose: false,
                delay: false,
                position: 'he',
                content() {
                    'step 0'
                    player.give(cards, target);
                    'step 1'
                    if (get.color(cards[0], player) == 'red') {
                        player.chooseDrawRecover(2, true);
                        event.finish();
                    }
                    else {
                        target.chooseToDiscard('he', 2, '弃置两张牌，或令' + get.translation(player) + '摸两张牌').set('ai', function (card) {
                            if (!_status.event.goon) return -get.value(card);
                            return 6 - get.value(card);
                        }).set('goon', get.attitude(target, player) <= 0);
                    }
                    'step 2'
                    if (!result.bool) player.draw(2);
                },
                ai: {
                    order: 3,
                    expose: 0.2,
                    result: {
                        target(player, target) {
                            if (ui.selected.cards.length && get.color(ui.selected.cards[0]) == 'red') {
                                var att = get.attitude(player, target);
                                return 2 + Math.sign(att) + att / 114514;
                            }
                            return -1;
                        },
                    },
                },
            },
            minixiahui: {
                audio: 'xiahui',
                mod: {
                    ignoredHandcard(card, player) {
                        if (get.color(card, player) == 'black') return true;
                    },
                    cardDiscardable(card, player, name) {
                        if (name == 'phaseDiscard' && get.color(card, player) == 'black') return false;
                    },
                },
                trigger: { global: 'phaseEnd' },
                forced: true,
                logTarget: 'player',
                filter(event, player) {
                    var target = event.player;
                    return target != player && target.getHistory('lose', function (evt) {
                        for (var i in evt.gaintag_map) {
                            if (evt.gaintag_map[i].includes('minixiahui')) return true;
                        }
                    }).length;
                },
                content() {
                    trigger.player.loseHp();
                },
                group: 'minixiahui_gain',
                subSkill: {
                    gain: {
                        trigger: { global: 'gainEnd' },
                        forced: true,
                        popup: false,
                        filter(event, player) {
                            if (player == event.player) return false;
                            var evt = event.getl(player);
                            return evt?.cards2 && evt.cards2.filter(function (card) {
                                return get.color(card, player) == 'black';
                            }).length > 0;
                        },
                        content() {
                            trigger.player.addSkill('minixiahui_block');
                            var cards = trigger.getl(player).cards2.filter(function (card) {
                                return get.color(card, player) == 'black';
                            });
                            trigger.player.addGaintag(cards, 'minixiahui');
                        },
                    },
                    block: {
                        mod: {
                            cardEnabled2(card) {
                                if (get.itemtype(card) == 'card' && card.hasGaintag('minixiahui')) return false;
                            },
                            cardDiscardable(card) {
                                if (card.hasGaintag('minixiahui')) return false;
                            },
                        },
                        charlotte: true,
                        forced: true,
                        popup: false,
                        trigger: { player: 'changeHp' },
                        filter(event, player) {
                            return event.num < 0;
                        },
                        content() {
                            player.removeSkill('minixiahui_block');
                        },
                        onremove(player) {
                            player.removeGaintag('minixiahui');
                        },
                    },
                },
            },
            minilveming: {
                audio: 'xinfu_lveming',
                inherit: 'xinfu_lveming',
                filterTarget(card, player, target) {
                    return player != target && target.countCards('e') <= player.countCards('e');
                },
                mark: false,
                content() {
                    'step 0'
                    var list = Array.from({ length: 13 }).map((_, i) => i + 1);
                    list = list.map((i) => get.strNumber(i));
                    target.chooseControl(list).set('ai', function () {
                        return get.rand(0, 12);
                    }).set('prompt', '掠命：请选择一个点数').set('prompt2', '若' + get.translation(player) + '的判定点数与你选择的点数相同，则对你造成2点伤害，否则其随机获得你区域里的一张牌');
                    'step 1'
                    if (result.control) {
                        target.$damagepop(result.control, 'thunder');
                        event.num = result.index + 1;
                        game.log(target, '选择的点数为', '#y' + get.strNumber(event.num));
                        player.judge(function (card) {
                            if (card.number == _status.event.getParent('minilveming').num) return 4;
                            return 0;
                        });
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) target.damage(2);
                    else player.gain(target.getCards('hej').randomGet(), target, 'giveAuto', 'bySelf');
                },
            },
            minitunjun: {
                mark: true,
                limited: true,
                audio: 'xinfu_tunjun',
                enable: 'phaseUse',
                filterTarget: true,
                skillAnimation: true,
                animationColor: 'metal',
                content() {
                    'step 0'
                    player.awakenSkill('minitunjun');
                    event.num = player.getAllHistory('useSkill', function (evt) {
                        return evt.skill == 'minilveming';
                    }).length + 1;
                    event.toequip = [];
                    'step 1'
                    var equip = get.cardPile(function (card) {
                        var bool1 = true;
                        for (var i = 0; i < event.toequip.length; i++) {
                            if (get.type(card) == 'equip' && get.subtype(card) == get.subtype(event.toequip[i])) bool1 = false;
                        }
                        return (get.type(card) == 'equip' && !event.toequip.includes(card) && target.canEquip(card) && bool1);
                    });
                    if (equip) event.toequip.push(equip);
                    else event.num = 0;
                    event.num--;
                    'step 2'
                    if (event.num > 0) event.goto(1);
                    'step 3'
                    for (var i = 0; i < event.toequip.length; i++) {
                        target.chooseUseTarget(event.toequip[i], true).set('animate', false).set('nopopup', true);
                    }
                },
                ai: {
                    order: 1,
                    result: {
                        player(player, target) {
                            if (get.attitude(player, target) <= 0) return 0;
                            if (target.countCards('e') + player.getAllHistory('useSkill', function (evt) {
                                return evt.skill == 'minilveming';
                            }).length < 3) return 0;
                            return 1 / (target.countCards('e') + 1);
                        },
                    },
                },
            },
            minijixu: {
                audio: 'xinfu_jixu',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h');
                },
                filterTarget: lib.filter.notMe,
                selectTarget: [1, 4],
                usable: 1,
                multitarget: true,
                multiline: true,
                content() {
                    'step 0'
                    targets.sortBySeat();
                    event.num = 0;
                    'step 1'
                    if (!event.caicuolist) event.caicuolist = [];
                    targets[event.num].chooseBool('是否押杀？').ai = function (event, player) {
                        var evt = _status.event.getParent();
                        if (get.attitude(targets[event.num], evt.player) > 0) return evt.player.countCards('h', 'sha') ? false : true;
                        return Math.random() < 0.5;
                    };
                    'step 2'
                    var target = targets[event.num];
                    var num1 = result.bool ? 1 : -1;
                    var num2 = player.countCards('h', 'sha') ? 1 : -1;
                    if (num1 != num2) {
                        event.caicuolist.push(target);
                        target.chat('猜错');
                        game.log(target, '猜', '#y错', '了');
                    }
                    else {
                        target.chat('猜对');
                        game.log(target, '猜', '#g对', '了');
                    }
                    event.num++;
                    game.delay();
                    if (event.num < targets.length) event.goto(1);
                    'step 3'
                    if (event.caicuolist.length) {
                        for (var i of event.caicuolist) {
                            player.discardPlayerCard(i, 'he', true);
                            player.useCard({ name: 'sha', isCard: true }, i, false);
                        }
                    }
                    var num = targets.length - event.caicuolist.length + 1;
                    player.addTempSkill('minijixu_hand');
                    player.draw(num);
                    player.addMark('minijixu_hand', num, false);
                },
                ai: {
                    order() {
                        return get.order({ name: 'sha' }) + 0.6;
                    },
                    result: {
                        target(player, target) {
                            return get.effect(target, { name: 'guohe_copy2' }, player, target);
                        },
                    },
                    expose: 0.25,
                },
                subSkill: {
                    hand: {
                        charlotte: true,
                        onremove: true,
                        mod: {
                            maxHandcard(player, num) {
                                return num + player.countMark('minijixu_hand');
                            },
                        },
                        intro: { content: '手牌上限+#' },
                    },
                },
            },
            //许劭
            minipingjian: {
                getList() {
                    const list = Object.keys(lib.characterPack.MiNikill).concat(_status.extra_pingjianList || []);
                    return list.filter(i => !_status.banned_pingjianList?.includes(i) && (!get.character(i, 4) || !get.character(i, 4).includes('unseen')));
                },
                init(player) {
                    player.addSkill('minipingjian_remove');
                    if (!player.storage.minipingjian_remove) player.storage.minipingjian_remove = {};
                },
                onremove(player) {
                    player.removeSkill('minipingjian_remove');
                },
                group: 'minipingjian_use',
                audio: 'pingjian',
                trigger: { player: ['damageEnd', 'phaseJieshuBegin'] },
                frequent: true,
                content() {
                    'step 0'
                    var allList = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                    var list = [], skills = [], map = [];
                    allList.randomSort();
                    var name2 = event.triggername;
                    for (var i = 0; i < allList.length; i++) {
                        var name = allList[i];
                        var skills2 = lib.character[name][3];
                        for (var j = 0; j < skills2.length; j++) {
                            if (player.getStorage('minipingjian').includes(skills2[j])) continue;
                            if (player.hasSkill(skills2[j], null, null, false)) continue;
                            if (skills.includes(skills2[j])) {
                                list.add(name);
                                if (!map[name]) map[name] = [];
                                map[name].push(skills2[j]);
                                skills.add(skills2[j]);
                                continue;
                            }
                            var list2 = [skills2[j]];
                            game.expandSkills(list2);
                            for (var k = 0; k < list2.length; k++) {
                                var info = lib.skill[list2[k]];
                                if (!info || !info.trigger || !info.trigger.player || info.silent || info.limited || info.juexingji || info.hiddenSkill ||
                                    info.dutySkill || (info.zhuSkill && !player.isZhu2()) || info.groupSkill || (info.priority && typeof info.priority == 'number') || info.firstDo || info.lastDo) continue;
                                if (info.trigger.player == name2 || Array.isArray(info.trigger.player) && info.trigger.player.includes(name2)) {
                                    if (/*info.init||*/info.onChooseToUse || info.ai && (info.ai.combo || info.ai.notemp || info.ai.neg)) continue;
                                    if (info.init) info.init(player, list2[k]);
                                    if (info.filter) {
                                        try {
                                            var bool = info.filter(trigger, player, name2);
                                            if (!bool) continue;
                                        }
                                        catch (e) {
                                            continue;
                                        }
                                    }
                                    list.add(name);
                                    if (!map[name]) map[name] = [];
                                    map[name].push(skills2[j]);
                                    skills.add(skills2[j]);
                                    break;
                                }
                            }
                        }
                        if (list.length > 2) break;
                    }
                    if (skills.length) player.chooseControl(skills).set('dialog', ['请选择要发动的技能', [list, 'character']]);
                    else event.finish();
                    'step 1'
                    player.markAuto('minipingjian', [result.control]);
                    player.addTempSkill(result.control);
                    player.storage.minipingjian_remove[result.control] = (trigger.name == 'damage' ? trigger : 'phaseJieshu');
                },
                derivation: 'Mbaby_characterlist_faq',
            },
            minipingjian_use: {
                audio: 'pingjian',
                enable: 'phaseUse',
                usable: 1,
                content() {
                    'step 0'
                    var allList = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                    var list = [], skills = [], map = [];
                    allList.randomSort();
                    for (var i = 0; i < allList.length; i++) {
                        var name = allList[i];
                        var skills2 = lib.character[name][3];
                        for (var j = 0; j < skills2.length; j++) {
                            if (player.getStorage('minipingjian').includes(skills2[j])) continue;
                            if (player.hasSkill(skills2[j], null, null, false) || get.is.locked(skills2[j], player)) continue;
                            var info = get.plainText(lib.translate[skills2[j] + '_info'] || '');
                            if (skills.includes(skills2[j]) || (info.includes('当你于出牌阶段') && !info.includes('当你于出牌阶段外'))) {
                                list.add(name);
                                if (!map[name]) map[name] = [];
                                map[name].push(skills2[j]);
                                skills.add(skills2[j]);
                                continue;
                            }
                            var list2 = [skills2[j]];
                            game.expandSkills(list2);
                            for (var k = 0; k < list2.length; k++) {
                                var info = lib.skill[list2[k]];
                                if (!info || !info.enable || info.charlotte || info.limited || info.juexingji || info.hiddenSkill || info.dutySkill || (info.zhuSkill && !player.isZhu2()) || info.groupSkill) continue;
                                if ((info.enable == 'phaseUse' || (Array.isArray(info.enable) && info.enable.includes('phaseUse'))) ||
                                    (info.enable == 'chooseToUse' || (Array.isArray(info.enable) && info.enable.includes('chooseToUse')))) {
                                    if (/*info.init||*/info.onChooseToUse || info.ai && (info.ai.combo || info.ai.notemp || info.ai.neg)) continue;
                                    var evt = event.getParent(2);
                                    if (info.init) info.init(player, list2[k]);
                                    //if (info.onChooseToUse) info.onChooseToUse(evt);
                                    if (info.filter) {
                                        try {
                                            var bool = info.filter(evt, player);
                                            if (!bool) continue;
                                        }
                                        catch (e) {
                                            continue;
                                        }
                                    }
                                    else if (info.viewAs && typeof info.viewAs != 'function') {
                                        try {
                                            if (evt.filterCard && !evt.filterCard(info.viewAs, player, evt)) continue;
                                            if (info.viewAsFilter && info.viewAsFilter(player) == false) continue;
                                        }
                                        catch (e) {
                                            continue;
                                        }
                                    }
                                    list.push(name);
                                    if (!map[name]) map[name] = [];
                                    map[name].push(skills2[j]);
                                    skills.add(skills2[j]);
                                    break;
                                }
                            }
                        }
                        if (list.length > 2) break;
                    }
                    if (skills.length) player.chooseControl(skills).set('dialog', ['请选择要发动的技能', [list, 'character']]);
                    else event.finish();
                    'step 1'
                    player.markAuto('minipingjian', [result.control]);
                    player.addTempSkill(result.control);
                    player.storage.minipingjian_remove[result.control] = 'phaseUse';
                },
                ai: {
                    order: 12,
                    result: { player: 1 },
                },
            },
            minipingjian_remove: {
                group: 'minipingjian_skill',
                charlotte: true,
                trigger: { player: ['phaseUseEnd', 'damageEnd', 'phaseJieshuBegin'] },
                filter(event, player) {
                    return Object.keys(player.storage.minipingjian_remove).find(function (skill) {
                        if (event.name != 'damage') return player.storage.minipingjian_remove[skill] == event.name;
                        return player.storage.minipingjian_remove[skill] == event;
                    });
                },
                direct: true,
                lastDo: true,
                priority: -Infinity,
                content() {
                    var skills = Object.keys(player.storage.minipingjian_remove).filter(function (skill) {
                        if (trigger.name != 'damage') return player.storage.minipingjian_remove[skill] == trigger.name;
                        return player.storage.minipingjian_remove[skill] == trigger;
                    });
                    player.removeSkill(skills);
                    for (var skill of skills) delete player.storage.minipingjian_remove[skill];
                },
            },
            minipingjian_skill: {
                charlotte: true,
                trigger: { player: ['useSkill', 'logSkillBegin'] },
                filter(event, player) {
                    if (get.info(event.skill).charlotte) return false;
                    var skill = event.sourceSkill || event.skill;
                    return player.storage.minipingjian_remove[skill];
                },
                direct: true,
                firstDo: true,
                priority: Infinity,
                content() {
                    var skill = trigger.sourceSkill || trigger.skill;
                    player.removeSkill(skill);
                    delete player.storage.minipingjian_remove[skill];
                },
            },
            //貂蝉
            minirelijian: {
                onChooseToUse(event) {
                    if (event.type == 'phase' && !game.online && !event.minirelijian_targets) {
                        var evtx = event.getParent('phaseUse');
                        var list = [], player = event.player;
                        for (var target of game.filterPlayer2()) {
                            if (target.getHistory('damage', function (evt) {
                                return evt.card && evt.card.name == 'juedou' && evt.getParent(3).name == 'minirelijian' && evt.getParent(3).player == player;
                            }).length) list.push(target);
                        }
                        event.set('minirelijian_targets', list);
                    }
                },
                audio: 'lijian',
                audioname: ['re_diaochan'],
                enable: 'phaseUse',
                filter(event, player) {
                    return game.hasPlayer(function (target) {
                        if (event.minirelijian_targets.includes(target)) return false;
                        return game.hasPlayer(function (current) {
                            if (event.minirelijian_targets.includes(current)) return false;
                            return current != target && current.canUse({ name: 'juedou' }, target);
                        });
                    });
                },
                filterTarget(card, player, target) {
                    if (_status.event.minirelijian_targets.includes(target)) return false;
                    if (ui.selected.targets.length) return target.canUse({ name: 'juedou' }, ui.selected.targets[0]);
                    return game.hasPlayer(function (current) {
                        return current.canUse({ name: 'juedou' }, target);
                    });
                },
                selectTarget: 2,
                targetprompt: ['先出杀', '后出杀'],
                multitarget: true,
                filterCard: true,
                check(card) {
                    return 10 - get.value(card);
                },
                position: 'he',
                usable: 2,
                content() {
                    targets[1].useCard({ name: 'juedou', isCard: true }, 'nowuxie', targets[0], 'noai').animate = false;
                    game.delay(0.5);
                },
                ai: {
                    order: 8,
                    expose: 0.4,
                    threaten: 4.8,
                    result: {
                        target(player, target) {
                            if (!ui.selected.targets.length) return -3;
                            return get.effect(target, { name: 'juedou' }, ui.selected.targets[0], target);
                        },
                    },
                },
            },
            minibiyue: {
                audio: 'rebiyue',
                trigger: { player: 'phaseJieshuBegin' },
                forced: true,
                locked: false,
                content() {
                    player.draw(1 + player.getHistory('useSkill', function (evt) {
                        return evt.skill == 'minirelijian';
                    }).length);
                },
            },
            //何太后
            minizhendu: {
                audio: 'zhendu',
                trigger: { global: 'phaseUseBegin' },
                filter(event, player) {
                    return event.player.isIn() && player.countCards('he') && event.player.hasUseTarget({ name: 'jiu' }, null, true);
                },
                direct: true,
                preHidden: true,
                content() {
                    'step 0'
                    var nono = (Math.abs(get.attitude(player, trigger.player)) < 3);
                    if (player == trigger.player || get.damageEffect(trigger.player, player, player) <= 0 || !trigger.player.hasUseTarget({ name: 'jiu' }, null, true)) nono = true;
                    if (trigger.player.hp > 2) nono = true;
                    if (trigger.player.hp > 1 && player.countCards('h') < 3 && (trigger.player.canUse('sha', player) && !player.countCards('h', 'shan') && trigger.player.countCards('h') >= 3)) nono = true;
                    var next = player.chooseToDiscard(get.prompt2('minizhendu', trigger.player), 'he');
                    next.set('ai', function (card) {
                        if (_status.event.nono) return -1;
                        return 7 - get.useful(card);
                    });
                    next.set('logSkill', ['minizhendu', trigger.player]);
                    next.set('nono', nono);
                    next.setHiddenSkill('minizhendu');
                    'step 1'
                    if (result.bool) trigger.player.chooseUseTarget({ name: 'jiu' }, true, 'noTargetDelay', 'nodelayx');
                    else event.finish();
                    'step 2'
                    if (result.bool && trigger.player != player) {
                        trigger.player.damage();
                        trigger.player.addTempSkill('minizhendu2');
                        trigger.player.addMark('minizhendu2', 1, false);
                    }
                },
                ai: { expose: 0.3 },
            },
            minizhendu2: {
                mark: true,
                marktext: '毒',
                charlotte: true,
                onremove: true,
                intro: { content: '计算与其他角色的距离+#' },
                mod: {
                    globalFrom(from, to, distance) {
                        return distance + from.countMark('minizhendu2');
                    },
                },
            },
            miniqiluan: {
                group: 'miniqiluan_draw',
                audio: 'qiluan2',
                trigger: { global: 'dying' },
                prompt: '是否发动【戚乱】摸一张牌？',
                preHidden: true,
                frequent: true,
                content() {
                    player.draw();
                },
                subfrequent: ['use'],
                subSkill: {
                    draw: {
                        audio: 'qiluan2',
                        trigger: { source: 'dieAfter' },
                        prompt: '是否发动【戚乱】摸两张牌？',
                        forced: true,
                        locked: false,
                        preHidden: true,
                        content() {
                            player.draw(2);
                        },
                    },
                },
            },
            //孙悟空
            minisevenbian: {
                onChooseToUse(event) {
                    if (event.type == 'phase' && !game.online && !event['minisevenbian_type']) {
                        var evtx = event.getParent('phaseUse');
                        var list = ['basic', 'trick', 'equip'], player = event.player;
                        player.getHistory('lose', function (evt) {
                            var evt2 = evt.getParent();
                            if (evt2.name == 'useSkill' && evt2.skill == 'minisevenbian') list.remove(get.type2(evt.cards2[0]));
                        });
                        event.set('minisevenbian_type', list);
                    }
                },
                nobracket: true,
                audio: 'ext:活动武将/audio/skill:1',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he', function (card) {
                        return event['minisevenbian_type'].includes(get.type2(card));
                    });
                },
                filterCard(card, player) {
                    return _status.event['minisevenbian_type'].includes(get.type2(card));
                },
                check(card) {
                    var player = _status.event.player;
                    if (player.hasSkill('minisevenbian_' + get.type2(card))) return -1;
                    return 5 - get.value(card);
                },
                position: 'he',
                prepare(cards, player) {
                    player.$throw(cards, 1000);
                    game.log(player, '将', cards, '置入了弃牌堆');
                },
                discard: false,
                loseTo: 'discardPile',
                visible: true,
                content() {
                    var list = ['basic', 'trick', 'equip'];
                    var type = list[(list.indexOf(get.type2(cards[0])) + 1) % 3];
                    var card = get.cardPile2(function (card) {
                        return get.type2(card) == type;
                    });
                    if (card) {
                        player.gain(card, 'draw');
                        game.log(player, '获得了一张', '#g' + get.translation(type) + '牌');
                    }
                    else {
                        player.chat('无牌可得了吗？');
                        game.log('但是牌堆中已经没有', '#g' + get.translation(type) + '牌', '了！');
                        player.addTempSkill('minisevenbian_' + get.type2(cards[0]), 'washCard');
                    }
                },
                ai: {
                    order: 1,
                    result: { player: 1 },
                },
                subSkill: { basic: { charlotte: true }, trick: { charlotte: true }, equip: { charlotte: true } },
            },
            miniruyi: {
                locked: true,
                audio: 'ext:活动武将/audio/skill:1',
                derivation: 'miniruyi_jingubang',
                group: ['miniruyi_jingubang', 'miniruyi_jingubang2'],
                init(player, skill) {
                    player.addExtraEquip(skill, 'miniruyi_jingubang', true, player => player.hasEmptySlot(1) && lib.card['miniruyi_jingubang']);
                },
                onremove(player, skill) {
                    player.removeExtraEquip(skill);
                },
                ai: {
                    effect: {
                        target(card, player, target) {
                            if (player == target && get.type(card) == 'equip' && get.subtype(card) == 'equip1') {
                                if (!target.hasEmptySlot(1)) return;
                                return 0;
                            }
                        },
                    },
                },
            },
            miniruyi_jingubang: {
                init(player) {
                    if (!player.storage.miniruyi_jingubang) player.storage.miniruyi_jingubang = 1;
                },
                onremove: true,
                mod: {
                    attackRange(player, num) {
                        if (!player.getEquip('miniruyi_jingubang') && !player.hasEnabledSlot(1)) return;
                        if (_status.miniruyiCheck) return num + _status.miniruyiCheck - 1;
                        return num + player.storage.miniruyi_jingubang - 1;
                    },
                },
                equipSkill: true,
                audioname2: { Mbaby_sunwukong: 'miniruyi' },
                trigger: { player: 'phaseBegin' },
                filter(event, player) {
                    return player.hasEmptySlot(1) || player.getEquip('miniruyi_jingubang');
                },
                direct: true,
                content() {
                    'step 0'
                    var cards = player.getEquips('miniruyi_jingubang');
                    player.chooseControl('1', '2', '3', '4', 'cancel2').set('prompt', '是否调整' + (cards.length ? get.translation(cards) : '如意金箍棒') + '的攻击范围？').set('choiceList', [
                        '将' + (card ? get.translation(card) : '如意金箍棒') + '的攻击范围调整为1 → 你使用【杀】不计入次数限制',
                        '将' + (card ? get.translation(card) : '如意金箍棒') + '的攻击范围调整为2 → 你于回合内使用的第一张【杀】造成的伤害+1',
                        '将' + (card ? get.translation(card) : '如意金箍棒') + '的攻击范围调整为3 → 你使用【杀】无法被响应',
                        '将' + (card ? get.translation(card) : '如意金箍棒') + '的攻击范围调整为4 → 你使用【杀】可以额外指定一个目标'
                    ]).set('ai', function () {
                        var player = _status.event.player;
                        if (!player.hasSha()) return '4';
                        for (var i = 0; i <= 3; i++) {
                            _status.miniruyiCheck = [2, 1, 3, 4][i];
                            if (game.hasPlayer(function (current) {
                                return player.canUse({ name: 'sha' }, current) && get.effect(current, { name: 'sha' }, player, player) > 0;
                            })) {
                                delete _status.miniruyiCheck;
                                return i + 1;
                            }
                        }
                        if (_status.miniruyiCheck) delete _status.miniruyiCheck;
                        return '4';
                    });
                    'step 1'
                    if (result.control != 'cancel2') {
                        var num = parseInt(result.control), cards = player.getEquips('miniruyi_jingubang');
                        player.logSkill('miniruyi_jingubang');
                        player.storage.miniruyi_jingubang = num;
                        player.popup(num);
                        game.log(player, '将', '#g' + (cards.length ? get.translation(cards) : '如意金箍棒'), '的攻击范围调整为', '#y' + num);
                    }
                },
            },
            miniruyi_jingubang2: {
                mod: {
                    selectTarget(card, player, range) {
                        if (!player.getEquip('miniruyi_jingubang') && !player.hasEmptySlot(1)) return;
                        var num = player.storage.miniruyi_jingubang;
                        if (card.name == 'sha' && range[1] != -1 && num == 4) range[1]++;
                    },
                },
                equipSkill: true,
                audioname2: { Mbaby_sunwukong: 'miniruyi' },
                trigger: { player: 'useCard' },
                filter(event, player) {
                    var num = player.storage.miniruyi_jingubang;
                    if (event.card.name != 'sha' || !player.hasEnabledSlot(1)) return false;
                    if (!player.getEquip('miniruyi_jingubang') && !player.hasEnabledSlot(1)) return false;
                    if (num == 2) return player.getHistory('useCard', function (evt) {
                        return evt.card.name == 'sha';
                    }).indexOf(event) == 0 && _status.currentPhase && player == _status.currentPhase;
                    return num != 4;
                },
                forced: true,
                locked: false,
                content() {
                    var num = player.storage.miniruyi_jingubang;
                    switch (num) {
                        case 1:
                            trigger.addCount = false;
                            if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                            game.log(trigger.card, '不计入次数');
                            break;
                        case 2:
                            trigger.baseDamage++;
                            game.log(trigger.card, '造成的伤害+1');
                            break;
                        case 3:
                            trigger.directHit.addArray(game.players);
                            game.log(trigger.card, '不可被响应');
                            break;
                    }
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (!player.getEquip('miniruyi_jingubang') && !player.hasEnabledSlot(1)) return false;
                        return arg.card.name == 'sha' && ((_status.miniruyiCheck && _status.miniruyiCheck == 3) || player.storage.miniruyi_jingubang == 3);
                    },
                },
            },
            miniqitian: {
                audio: 'ext:活动武将/audio/skill:1',
                derivation: ['minihuoyan', 'minijindouyun'],
                trigger: { player: ['changeHp', 'enterGame'], global: 'phaseBefore' },
                filter(event, player) {
                    if (player.hp != 1) return false;
                    return event.name != 'phase' || game.phaseNumber == 0;
                },
                juexingji: true,
                forced: true,
                skillAnimation: true,
                animationColor: 'fire',
                content() {
                    'step 0'
                    player.awakenSkill('miniqitian');
                    player.loseMaxHp();
                    'step 1'
                    player.addSkills(['minihuoyan', 'minijindouyun']);
                },
            },
            minihuoyan: {
                locked: true,
                ai: {
                    viewHandcard: true,
                    skillTagFilter(player, arg, target) {
                        return target != player && !_status.auto;
                    },
                },
            },
            minijindouyun: {
                nobracket: true,
                locked: true,
                mod: {
                    globalFrom(from, to, distance) {
                        return distance - 1;
                    },
                    globalTo(from, to, distance) {
                        return distance + 1;
                    },
                },
            },
            //大懒猫
            minizuzhou: {
                audio: 'ext:活动武将/audio/skill:1',
                trigger: { global: 'phaseBegin' },
                check(event, player) {
                    if (player.hp + player.countCards('hs', { name: 'tao' }) <= 1) return false;
                    if (event.player == player) return player.countCards('h', { name: ['sha', 'shan'] }) >= 3 && player.countCards('h', { name: 'sha' }) < 3 && player.countCards('h', { name: 'shan' }) < 3;
                    return get.attitude(player, event.player) < 0 && event.player.countCards('h', { name: 'sha' }) > 2;
                },
                logTarget: 'player',
                content() {
                    'step 0'
                    player.loseHp();
                    'step 1'
                    player.chooseControl().set('choiceList', [
                        '令' + get.translation(trigger.player) + '本回合手牌中所有的【杀】视为【闪】',
                        '令' + get.translation(trigger.player) + '本回合手牌中所有的【闪】视为【杀】',
                    ]).set('ai', function () {
                        var player = _status.event.player;
                        return player == _status.event.target ? 1 : 0;
                    }).set('target', trigger.player);
                    'step 2'
                    trigger.player.addTempSkill('minizuzhou2');
                    trigger.player.storage.minizuzhou2 = result.index;
                },
                ai: { expose: 0.2 },
            },
            minizuzhou2: {
                charlotte: true,
                onremove: true,
                mod: {
                    cardname(card, player, name) {
                        var list = ['sha', 'shan'];
                        if (player.storage.minizuzhou2 == 1) list.reverse();
                        if (card.name == list[0]) return list[1];
                    },
                },
            },
            minimoyu: {
                audio: 'ext:活动武将/audio/skill:1',
                trigger: { player: 'phaseUseBegin' },
                check(event, player) {
                    return player.hp + player.countCards('hs', { name: 'tao' }) <= 2;
                },
                content() {
                    player.addTempSkill('minimoyu2');
                    player.addMark('minimoyu2', 2, false);
                    player.addTempSkill('minimoyu3', { player: 'minimoyu3After' });
                    player.addMark('minimoyu3', 2, false);
                },
            },
            minimoyu2: {
                group: 'zishou2',
                charlotte: true,
                onremove: true,
                mod: {
                    maxHandcard(player, num) {
                        return num + player.countMark('minimoyu2');
                    },
                },
                trigger: { player: 'phaseEnd' },
                filter(event, player) {
                    return player.isDamaged();
                },
                forced: true,
                content() {
                    player.recover();
                },
            },
            minimoyu3: {
                charlotte: true,
                onremove: true,
                trigger: { player: 'phaseBegin' },
                firstDo: true,
                direct: true,
                content() {
                    player.addTempSkill('minimoyu4');
                    player.addMark('minimoyu4', 2, false);
                },
            },
            minimoyu4: {
                charlotte: true,
                onremove: true,
                audio: 'minimoyu',
                trigger: { player: 'phaseDrawBegin2' },
                filter(event, player) {
                    return !event.numFixed;
                },
                forced: true,
                content() {
                    trigger.num += player.countMark('minimoyu4');
                },
            },
            minisanlian: {
                audio: 'ext:活动武将/audio/skill:1',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h', function (card) {
                        return lib.skill.minisanlian.filterCard(card, player);
                    });
                },
                filterCard(card, player) {
                    if (ui.selected.cards.length) {
                        var cardx = ui.selected.cards[0];
                        return get.type2(card) == get.type2(cardx);
                    }
                    return player.countCards('h', function (cardx) {
                        return get.type2(card) == get.type2(cardx);
                    }) >= 3;
                },
                selectCard: 3,
                check(card) {
                    return 6 - get.value(card);
                },
                complexCard: true,
                content() {
                    'step 0'
                    player.draw(player.getDamagedHp());
                    'step 1'
                    for (var i of game.filterPlayer().sortBySeat(player)) {
                        player.line(i);
                        i.damage();
                    }
                    var card = cards[0];
                    for (var cardx of cards) {
                        if (get.name(cardx, player) != get.name(card, player)) {
                            event.finish();
                            break;
                        }
                    }
                    'step 2'
                    for (var i of game.filterPlayer().sortBySeat(player)) {
                        if (i == player) continue;
                        player.line(i);
                        player.discardPlayerCard(i, 'he', true);
                    }
                },
                ai: {
                    order: 10,
                    result: {
                        player(player) {
                            if (player.hp + player.countCards('hs', { name: ['tao', 'jiu'] }) < 2) return -1;
                            return game.countPlayer(function (current) {
                                return Math.sign(get.damageEffect(current, player, player));
                            });
                        },
                    },
                },
            },
            //王荣
            miniminsi: {
                audio: 'minsi',
                inherit: 'minsi',
                content() {
                    player.draw(cards.length * 2).gaintag = ['miniminsi2'];
                    player.addTempSkill('miniminsi2');
                },
            },
            miniminsi2: {
                onremove(player) {
                    player.removeGaintag('miniminsi2');
                },
                mod: {
                    targetInRange(card, player, target) {
                        if (!card.cards) return;
                        for (var i of card.cards) {
                            if (!i.hasGaintag('miniminsi2')) return;
                        }
                        return true;
                    },
                    ignoredHandcard(card, player) {
                        if (card.hasGaintag('miniminsi2')) return true;
                    },
                    cardDiscardable(card, player, name) {
                        if (name == 'phaseDiscard' && card.hasGaintag('miniminsi2')) return false;
                    },
                    aiOrder(player, card, num) {
                        if (get.itemtype(card) == 'card' && card.hasGaintag('miniminsi2')) return num - 0.1;
                    },
                },
            },
            minijijing: {
                audio: 'jijing',
                trigger: { player: 'damageEnd' },
                frequent: true,
                content() {
                    'step 0'
                    player.judge();
                    'step 1'
                    player.chooseToDiscard('是否弃置任意张点数之和不小于' + get.cnNumber(num) + '的牌并回复1点体力？', 'he').set('selectCard', function () {
                        var num = 0;
                        for (var i = 0; i < ui.selected.cards.length; i++) {
                            num += get.number(ui.selected.cards[i]);
                        }
                        if (num >= _status.event.num) return ui.selected.cards.length;
                        return ui.selected.cards.length + 2;
                    }).set('ai', function (card) {
                        return 6 - get.value(card);
                    }).set('num', result.number).set('complexCard', true);
                    'step 2'
                    if (result.bool) player.recover();
                },
            },
            minimanwang: {
                init() {
                    lib.skill.sppanqin.subSkill.eff.filter = function (event, player) {
                        return event.card.name == 'nanman' && event.getParent(2).name == 'sppanqin' && player.countMark('spmanwang') < 4 && (player.hasSkill('spmanwang') || player.hasSkill('minimanwang')) && event.cards.length <= event.targets.length;
                    };
                },
                derivation: ['sppanqin', 'minihuoshou'],
                audio: 'spmanwang',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he') > 0;
                },
                filterCard: true,
                position: 'he',
                selectCard: [1, Infinity],
                check(card) {
                    var player = _status.event.player;
                    var max = Math.min(player.isDamaged() ? 3 : 2, 4 - player.countMark('spmanwang'));
                    if (!max && !player.hasSkill('sppanqin')) return 0;
                    if (max == 0 && ui.selected.length > 0) return 0;
                    return 7 - ui.selected.cards.length - get.value(card);
                },
                content() {
                    'step 0'
                    var num = Math.min(cards.length, 4 - player.countMark('spmanwang'));
                    if (num >= 1) player.addSkill('sppanqin');
                    if (num >= 2) player.draw();
                    if (num >= 3) player.recover();
                    if (num >= 4) {
                        player.draw(2);
                        player.removeSkills('sppanqin');
                    }
                    'step 1'
                    player.addTempSkill('minihuoshou', { player: 'phaseBegin' });
                },
                ai: {
                    order: 2,
                    result: {
                        player(player, target) {
                            if (player.getUseValue({ name: 'nanman' }) <= 0) return 0;
                            if (player.getStat('skill').spmanwang && player.hasSkill('sppanqin')) return 0;
                            return 1;
                        },
                    },
                },
            },
            //银河射手
            miniliushi: {
                audio: 'cxliushi',
                inherit: 'cxliushi',
                group: 'miniliushi_damage',
                subSkill: {
                    damage: {
                        audio: 'cxliushi',
                        trigger: { source: 'damageSource' },
                        filter(event, player) {
                            return event.card && event.card.name == 'sha';
                        },
                        logTarget: 'player',
                        forced: true,
                        locked: false,
                        content() {
                            trigger.player.addMark('cxliushi2', 1);
                            trigger.player.addSkill('cxliushi2');
                        },
                    },
                },
            },
            //
            minilulve: {
                audio: 'lulve',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    var hs = player.countCards('h');
                    return hs > 0 && game.hasPlayer(function (target) {
                        var ts = target.countCards('h');
                        return target != player && ts > 0 && hs >= ts;
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minilulve'), function (card, player, target) {
                        var hs = player.countCards('h'), ts = target.countCards('h');
                        return target != player && ts > 0 && hs >= ts;
                    }).set('ai', function (target) {
                        var player = _status.event.player, att = get.attitude(player, target);
                        if (target.isTurnedOver()) return att / 10;
                        if (!player.hasShan() && target.canUse({ name: 'sha', isCard: true }, player, false) && get.effect(player, { name: 'sha', isCard: true }, target, player) < 0 && player.hp < 4) return 0;
                        return -att * Math.sqrt(target.countCards('h'));
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minilulve', target);
                        var str = get.translation(player);
                        target.chooseControl().set('choiceList', [
                            '将所有手牌交给' + str + '，然后其将武将牌翻面',
                            '将武将牌翻面，然后视为对' + str + '使用【杀】',
                        ]).set('ai', function () {
                            var player = _status.event.player, target = _status.event.getParent().player;
                            if (player.isTurnedOver()) return 1;
                            if (!target.hasShan() && player.canUse({ name: 'sha', isCard: true }, target, false) && get.effect(target, { name: 'sha', isCard: true }, player, player) < 0) return 0;
                            return Math.random() < 0.5 ? 0 : 1;
                        });
                    }
                    else event.finish();
                    'step 2'
                    if (result.index == 0) {
                        target.give(target.getCards('h'), player);
                        player.turnOver();
                        event.finish();
                    }
                    else target.turnOver();
                    'step 3'
                    if (target.canUse({ name: 'sha', isCard: true }, player, false)) target.useCard({ name: 'sha', isCard: true }, player, false);
                },
            },
            //曹节
            minishouxi: {
                audio: 'shouxi',
                trigger: { target: 'useCardToTargeted' },
                filter(event, player) {
                    if (event.card.name != 'sha' || !event.player.isIn()) return false;
                    return get.inpileVCardList(info => {
                        if (player.getStorage('minishouxi').includes(info[2]) || info[3]) return false;
                        return ['basic', 'trick', 'delay'].includes(info[0]);
                    }).length;
                },
                async cost(event, trigger, player) {
                    const target = trigger.player;
                    const list = get.inpileVCardList(info => {
                        if (player.getStorage('minishouxi').includes(info[2]) || info[3]) return false;
                        return ['basic', 'trick', 'delay'].includes(info[0]);
                    })
                    const result = await player.chooseButton([get.prompt(event.name.slice(0, -5), target), [list, 'vcard']]).set('ai', button => {
                        if (_status.event.num > 0) return 0;
                        return 1 + Math.random();
                    }).set('num', get.effect(player, trigger.card, target, player)).forResult();
                    event.result = {
                        bool: result?.bool,
                        cost_data: result?.links,
                    }
                },
                logTarget: 'player',
                async content(event, trigger, player) {
                    const target = trigger.player;
                    const links = event.cost_data, name = links[0][2], str = get.translation(name);
                    player.markAuto(event.name, [name]);
                    player.popup(str);
                    game.log(player, '声明了', '#g【' + str + '】');
                    const { bool } = await target.chooseToDiscard('he', (card) => get.name(card) == _status.event.namex).set('ai', card => 10 - get.value(card) * (_status.event.att < 0 ? 1 : 0)).set('att', get.attitude(target, player)).set('namex', name).set('dialog', ['###守玺###弃置一张【' + str + '】，否则此【杀】对' + get.translation(player) + '无效且' + get.translation(player) + '从牌堆中获得一张【' + str + '】', [links, 'vcard']]).forResult();
                    if (bool && player.countGainableCards(target, 'he')) await target.gainPlayerCard(player, 'he', true);
                    else {
                        trigger.getParent().excluded.add(player);
                        const card = get.cardPile2(card => card.name == name);
                        if (card) await player.gain(card, 'gain2');
                    }
                },
                ai: {
                    effect: {
                        target(card, player, target, current) {
                            if (_status.event.name == 'minishouxi') return;
                            if (card.name != 'sha' || get.attitude(player, target) > 0) return;
                            var list = lib.inpile.filter(i => {
                                if (target.getStorage('minishouxi').includes(i)) return false;
                                var type = get.type2(i);
                                return type == 'basic' || type == 'trick';
                            });
                            if (!player.countCards('he', cardx => lib.filter.cardDiscardable(cardx, player) && list.includes(cardx.name))) return 0.2;
                        },
                    },
                },
            },
            minihuimin: {
                //写在前面当filter位置[doge]
                group: 'minihuimin_log',
                audio: 'huimin',
                subSkill: {
                    log: {
                        trigger: { player: 'phaseJieshuBegin' },
                        filter(event, player) {
                            return game.hasPlayer(function (current) {
                                return current.countCards('h') <= current.hp;
                            });
                        },
                        direct: true,
                        content() {
                            'step 0'
                            var num = 1, sum = 0;
                            for (var target of game.filterPlayer()) {
                                if (target.countCards('h') > target.hp) continue;
                                sum++;
                                var att = get.attitude(player, target);
                                if (att > 0) num++;
                                if (att < 0) num--;
                            }
                            var info = '摸' + get.cnNumber(sum) + '张牌';
                            var func = function () {
                                for (var target of game.filterPlayer()) {
                                    var bool = (target.countCards('h') > target.hp);
                                    target.prompt('<span class=\"texiaotext\" style=\"color:' + (bool ? '#FF0000' : '#00FF00') + '\">' + (bool ? '×' : '√') + '</span>');
                                }
                            };
                            if (event.player == game.me) func();
                            else if (event.isOnline()) player.send(func);
                            if (sum > 1) info += '，然后展示' + get.cnNumber(sum - 1) + '张手牌，然后你选择一名手牌数小于等于体力值的角色，从该角色开始，所有手牌数小于等于体力值的角色依次选择并获得其中一张';
                            player.chooseBool(get.prompt('minihuimin'), info).set('choice', num >= 0);
                            'step 1'
                            if (result.bool) {
                                player.logSkill('minihuimin');
                                var next = game.createEvent('minihuimin');
                                next.player = player;
                                next.setContent(lib.skill.minihuimin.content);
                            }
                        },
                    },
                },
                content() {
                    'step 0'
                    event.list = game.filterPlayer(function (current) {
                        return current.countCards('h') <= current.hp;
                    }).sortBySeat();
                    player.draw(event.list.length);
                    if (event.list.length == 1) event.finish();
                    'step 1'
                    player.chooseTarget(true, function (card, player, target) {
                        var list = _status.event.list;
                        return list.includes(target);
                    }, '惠民：请选择一名角色作为分牌起点').set('ai', function (target) {
                        var player = _status.event.player;
                        var list = _status.event.list;
                        var att = get.attitude(player, target);
                        var getNum = function (target) {
                            var num = 0, targets = list.slice(0);
                            for (var i = 0; i < targets.length; i++) {
                                if (att > 0) num += (targets.length - i);
                                if (att < 0) num -= (targets.length - i);
                            }
                            return num;
                        };
                        return getNum(target);
                    }).set('list', event.list);
                    'step 2'
                    if (result.bool) {
                        player.line(result.targets, 'green');
                        var index = event.list.indexOf(result.targets[0]);
                        if (index < 0) index = 0;
                        var tmp = event.list.splice(index);
                        event.list = tmp.concat(event.list);
                        var yuanzhong = event.list[event.list.length - 1];//掉队的冤种[doge]
                        game.log(player, '选择了', result.targets, '作为分牌起点'/*+'，',yuanzhong,'被',player,'落下'*/);
                        yuanzhong.chat(['我成冤种了', '555没我份', '怎能如此对我', '太狠心啦2333'].randomGet());
                        event.list.remove(yuanzhong);
                        if (event.list.length > 0) player.chooseCard('h', '选择要分配的手牌', event.list.length, true);
                        else event.finish();
                    }
                    'step 3'
                    var cards = result.cards;
                    player.lose(cards, ui.ordering);
                    event.togain = cards;
                    if (result.bool && cards.length) {
                        var dialog = ui.create.dialog('惠民', cards, true);
                        _status.dieClose.push(dialog);
                        dialog.videoId = lib.status.videoId++;
                        event.dialogID = dialog.videoId;
                        game.addVideo('cardDialog', null, ['惠民', get.cardsInfo(cards), dialog.videoId]);
                        game.broadcast(function (cards, id) {
                            var dialog = ui.create.dialog('惠民', cards, true);
                            _status.dieClose.push(dialog);
                            dialog.videoId = id;
                        }, cards, dialog.videoId);
                    }
                    else event.finish();
                    'step 4'
                    game.delay();
                    'step 5'
                    if (event.list.length && event.togain.length) {
                        event.current = event.list.shift();
                        var next = event.current.chooseButton(true, function (button) {
                            return get.value(button.link, _status.event.player);
                        });
                        next.set('dialog', event.dialogID);
                        next.set('closeDialog', false);
                        next.set('dialogdisplay', true);
                        next.set('cardFilter', event.togain.slice(0));
                        next.set('filterButton', function (button) {
                            return _status.event.cardFilter.includes(button.link);
                        })
                    }
                    else {
                        for (var i = 0; i < ui.dialogs.length; i++) {
                            if (ui.dialogs[i].videoId == event.dialogID) {
                                var dialog = ui.dialogs[i];
                                dialog.close();
                                _status.dieClose.remove(dialog);
                                break;
                            }
                        }
                        if (event.togain.length) {
                            game.cardsDiscard(event.togain);
                        }
                        game.broadcast(function (id) {
                            var dialog = get.idDialog(id);
                            if (dialog) {
                                dialog.close();
                                _status.dieClose.remove(dialog);
                            }
                        }, event.dialogID);
                        game.addVideo('cardDialog', null, event.dialogID);
                        event.finish();
                    }
                    'step 6'
                    var card = result.links[0], target = event.current;
                    if (card) {
                        target.gain(card, 'gain2');
                        event.togain.remove(card);
                    }
                    var capt = get.translation(target) + '选择了' + get.translation(card);
                    game.broadcastAll(function (card, id, name, capt) {
                        var dialog = get.idDialog(id);
                        if (dialog) {
                            dialog.content.firstChild.innerHTML = capt;
                            for (var i = 0; i < dialog.buttons.length; i++) {
                                if (dialog.buttons[i].link == card) {
                                    dialog.buttons[i].querySelector('.info').innerHTML = name;
                                    break;
                                }
                            }
                            game.addVideo('dialogCapt', null, [dialog.videoId, dialog.content.firstChild.innerHTML]);
                        }
                    }, card, event.dialogID, function (target) {
                        if (target._tempTranslate) return target._tempTranslate;
                        var name = target.name;
                        if (lib.translate[name + '_ab']) return lib.translate[name + '_ab'];
                        return get.translation(name);
                    }(target), capt);
                    if (event.togain.length) event.goto(5);
                    else {
                        for (var i = 0; i < ui.dialogs.length; i++) {
                            if (ui.dialogs[i].videoId == event.dialogID) {
                                var dialog = ui.dialogs[i];
                                dialog.close();
                                _status.dieClose.remove(dialog);
                                break;
                            }
                        }
                        if (event.togain.length) {
                            game.cardsDiscard(event.togain);
                        }
                        game.broadcast(function (id) {
                            var dialog = get.idDialog(id);
                            if (dialog) {
                                dialog.close();
                                _status.dieClose.remove(dialog);
                            }
                        }, event.dialogID);
                        game.addVideo('cardDialog', null, event.dialogID);
                        event.finish();
                    }
                },
            },
            //唐姬
            minikangge: {
                group: ['minikangge_draw', 'minikangge_dying'],
                audio: 'kangge',
                trigger: { player: 'phaseBegin' },
                filter(event, player) {
                    return game.countPlayer() > 1;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget('请选择【抗歌】的目标', '其于回合外摸牌后，你摸等量的牌；其进入濒死状态时，你可令其回复体力至1点；其死亡后，你弃置所有牌并失去1点体力', lib.filter.notMe, true).set('ai', function (target) {
                        return get.attitude(_status.event.player, target) > 0;
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('minikangge', target);
                        player.addSkill('minikangge_clear');
                        player.storage.minikangge = target;
                        player.markSkill('minikangge');
                        game.delayx();
                    }
                },
                intro: { content: '已指定$为目标' },
                subSkill: {
                    draw: {
                        audio: 'kangge',
                        trigger: {
                            global: ['gainAfter', 'loseAsyncAfter'],
                        },
                        forced: true,
                        filter(event, player) {
                            if (player.countMark('minikangge_draw') >= 3) return false;
                            var target = player.storage.minikangge;
                            return target && target != _status.currentPhase && event.getg(target).length > 0;
                        },
                        logTarget: 'player',
                        content() {
                            var num = Math.min(3 - player.countMark('minikangge_draw'), trigger.getg(player.storage.minikangge).length);
                            player.addMark('minikangge_draw', num, false);
                            player.draw(num);
                        },
                    },
                    clear: {
                        trigger: { global: 'phaseBeginStart' },
                        forced: true,
                        firstDo: true,
                        popup: false,
                        charlotte: true,
                        filter(event, player) {
                            return player.countMark('minikangge_draw') > 0;
                        },
                        content() {
                            player.removeMark('minikangge_draw', player.countMark('minikangge_draw'), false);
                        },
                    },
                    dying: {
                        audio: 'kangge',
                        trigger: { global: 'dying' },
                        logTarget: 'player',
                        filter(event, player) {
                            return event.player == player.storage.minikangge && event.player.hp < 1 && !player.hasSkill('minikangge_temp');
                        },
                        check(event, player) {
                            return get.attitude(player, event.player) > 0;
                        },
                        prompt2: '令其将体力值回复至1点',
                        round: 1,
                        content() {
                            trigger.player.recover(1 - trigger.player.hp);
                        },
                    },
                },
            },
            minijielie: {
                audio: 'jielie',
                trigger: { player: 'damageBegin4' },
                direct: true,
                content() {
                    'step 0'
                    var target = player.storage.minikangge, str;
                    if (target) {
                        event.target = target;
                        str = '，且令' + get.translation(target) + '从弃牌堆中获得等量的花色牌';
                    }
                    else str = '';
                    player.chooseControl(lib.suit.slice(0), 'cancel2').set('prompt', get.prompt('minijielie')).set('prompt2', '防止伤害并改为失去等量体力' + str).set('ai', function () {
                        var player = _status.event.player;
                        var target = player.storage.minikangge;
                        if (target && get.attitude(player, target) <= 0) return 'cancel2';
                        return lib.suit.randomGet();
                    });
                    'step 1'
                    if (result.control != 'cancel2') {
                        event.suit = result.control;
                        player.logSkill('minijielie');
                        trigger.cancel();
                        player.loseHp();
                        if (!target) event.finish();
                    }
                    else event.finish();
                    'step 2'
                    player.line(target);
                    var cards = [];
                    while (cards.length < trigger.num) {
                        var card = get.discardPile(function (card) {
                            return get.suit(card, false) == event.suit && !cards.includes(card);
                        });
                        if (card) cards.push(card);
                        else break;
                    }
                    if (cards.length) target.gain(cards, 'gain2');
                },
            },
            //李白
            minishixian: {
                derivation: ['minishixian_qiangjinjiu', 'minishixian_jingyesi', 'minishixian_xiakexing', 'minishixian_xinglunan'],
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseBegin' },
                forced: true,
                frequent: true,
                async content(event, trigger, player) {
                    if (player.additionalSkills.minishixian) await player.removeAdditionalSkills('minishixian');
                    let cards = get.cards(4, true);
                    await player.showCards(cards, get.translation(player) + '发动了【诗仙】');
                    const map = { 'heart': 'minishixian_qiangjinjiu', 'diamond': 'minishixian_jingyesi', 'spade': 'minishixian_xiakexing', 'club': 'minishixian_xinglunan' };
                    const skills = Object.values(map).filter(suit => cards.some(card => map[get.suit(card, false)] == suit));
                    if (skills.length) await player.addAdditionalSkills('minishixian', skills);
                    cards = cards.filter(card => cards.some(cardx => cardx != card && get.suit(card, player) == get.suit(cardx, player)));
                    if (cards.length) {
                        const result = await player.chooseBool('诗仙：是否获得' + get.translation(cards) + '？').set('frequentSkill', 'minishixian').forResult();
                        if (result?.bool) player.gain(cards, 'gain2');
                    }
                },
                subSkill: {
                    //将进酒
                    qiangjinjiu: {
                        nobracket: true,
                        audio: 'ext:活动武将/audio/skill:1',
                        trigger: { global: 'phaseBegin' },
                        filter(event, player) {
                            if (event.player == player) return false;
                            return player.countCards('h') && event.player.countCards('he');
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseToDiscard(get.prompt2('minishixian_qiangjinjiu', trigger.player)).set('ai', function (card) {
                                var player = _status.event.player;
                                var target = _status.event.target;
                                if (get.attitude(player, target) > 0) return 0;
                                return 6 - get.value(card);
                            }).set('target', trigger.player).logSkill = ['minishixian_qiangjinjiu', trigger.player];
                            'step 1'
                            if (result.bool) {
                                if (!trigger.player.countCards('e')) event._result = { bool: true, index: 1 };
                                else player.chooseControl().set('choiceList', [
                                    '弃置' + get.translation(trigger.player) + '装备区里的所有装备牌',
                                    '获得' + get.translation(trigger.player) + '手牌中的所有【酒】（若其手牌中没有【酒】则改为获得其一张牌）',
                                ]).set('ai', () => 0);
                            }
                            else event.finish();
                            'step 2'
                            if (result.index == 0) {
                                trigger.player.discard(trigger.player.getCards('e')).discarder = player;
                                var card = get.cardPile2(card => card.name == 'jiu');
                                if (card) trigger.player.gain(card, 'gain2');
                            }
                            else {
                                if (trigger.player.countCards('h', { name: 'jiu' })) player.gain(trigger.player.getCards('h', { name: 'jiu' }), trigger.player, 'give');
                                else player.gainPlayerCard(trigger.player, 'he', true);
                            }
                        },
                    },
                    //静夜思
                    jingyesi: {
                        nobracket: true,
                        audio: 'ext:活动武将/audio/skill:1',
                        trigger: { player: ['phaseUseEnd', 'phaseDiscardEnd'] },
                        direct: true,
                        content() {
                            'step 0'
                            var card = get[trigger.name == 'phaseDiscard' ? 'bottomCards' : 'cards']()[0];
                            if (trigger.name == 'phaseDiscard') {
                                player.logSkill('minishixian_jingyesi');
                                player.gain(card, 'gain2');
                                event.finish();
                            }
                            else {
                                event.card = card;
                                player.chooseControl('ok').set('dialog', ['静夜思', [card]]);
                                player.chooseUseTarget(card, false).logSkill = 'minishixian_jingyesi';
                            }
                            'step 1'
                            if (!result.bool) ui.cardPile.insertBefore(card, ui.cardPile.firstChild);
                            game.updateRoundNumber();
                        },
                    },
                    //侠客行
                    xiakexing: {
                        nobracket: true,
                        audio: 'ext:活动武将/audio/skill:1',
                        trigger: { player: 'useCard', source: 'damageSource' },
                        filter(event, player) {
                            if (event.name == 'useCard') return get.translation(event.card.name).indexOf('剑') != -1 && player.hasUseTarget(get.autoViewAs({ name: 'wanjian' }, []));
                            return event.card && event.card.name == 'sha' && player.getEquips(1).length && event.player.isIn() && player.canCompare(event.player);
                        },
                        direct: true,
                        content() {
                            'step 0'
                            if (trigger.name == 'useCard') {
                                player.logSkill('minishixian_xiakexing');
                                player.chooseUseTarget(true, { name: 'wanjian' }, []);
                                event.finish();
                            }
                            else player.chooseBool('是否和' + get.translation(trigger.player) + '拼点？', '若你赢，其减1点体力上限；若你没赢，弃置你装备区里的武器牌').set('choice', player.hasCard(function (card) {
                                return get.value(card) <= 5 || get.number(card) > 10;
                            }) && (get.attitude(player, trigger.player) <= 0 || trigger.player.countCards('h') >= 4));
                            'step 1'
                            if (result.bool) {
                                player.logSkill('minishixian_xiakexing', trigger.player);
                                player.chooseToCompare(trigger.player);
                            }
                            else event.finish();
                            'step 2'
                            if (result.bool) trigger.player.loseMaxHp();
                            else {
                                var cards = player.getEquips(1);
                                if (cards.length) player.discard(cards);
                            }
                        },
                    },
                    //行路难
                    xinglunan: {
                        nobracket: true,
                        audio: 'ext:活动武将/audio/skill:1',
                        trigger: { global: 'useCardAfter' },
                        filter(event, player) {
                            if (player == _status.currentPhase || event.card.name != 'sha' || event.player == player) return false;
                            return event.targets && event.targets.includes(player);
                        },
                        forced: true,
                        locked: false,
                        content() {
                            player.addTempSkill('minishixian_xingluBuff', { player: 'phaseBegin' });
                            player.addMark('minishixian_xingluBuff', 1, false);
                        },
                    },
                    xingluBuff: {
                        nobracket: true,
                        charlotte: true,
                        onremove: true,
                        intro: { content: '其他角色计算与你的距离+#' },
                        mod: {
                            globalTo(from, to, distance) {
                                return distance + to.countMark('minishixian_xingluBuff');
                            },
                        },
                    },
                },
            },
            //郭图
            minijigong: {
                audio: 'jigong',
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseControl('一张', '两张', '三张', 'cancel2').set('prompt', get.prompt2('minijigong')).set('ai', () => '三张');
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('minijigong');
                        player.addTempSkill('minijigong2');
                        player.draw(1 + result.index);
                    }
                },
            },
            minijigong2: {
                charlotte: true,
                mod: {
                    maxHandcardBase(player) {
                        if (game.online) return (player.getStat('damage') || 0) + 1;
                        var num = 0;
                        player.getHistory('sourceDamage', function (evt) {
                            num += evt.num;
                        });
                        return num + 1;
                    },
                },
                audio: 'jigong',
                trigger: { player: 'phaseDiscardBegin' },
                filter(event, player) {
                    if (player.isHealthy()) return false;
                    var num = 0;
                    player.getHistory('sourceDamage', function (evt) {
                        num += evt.num;
                    });
                    if (!num) return false;
                    var num2 = 0;
                    player.getHistory('gain', function (evt) {
                        var evtx = evt.getParent(2);
                        if (evtx.name == 'minijigong' && evtx.player == player) num2 += evt.cards.length;
                    });
                    return num >= num2;
                },
                forced: true,
                content() {
                    player.recover();
                },
            },
            minishifei: {
                audio: 'shifei',
                enable: ['chooseToUse', 'chooseToRespond'],
                filter(event, player) {
                    if (!_status.currentPhase || event.minishifei) return false;
                    if (!event.filterCard({ name: 'shan', isCard: true }, player, event)) return false;
                    if (event.name != 'chooseToUse' && !lib.filter.cardRespondable({ name: 'shan', isCard: true }, player, event)) return false;
                    return true;
                },
                checkx(event, player) {
                    if (get.attitude(player, _status.currentPhase) > 0) return true;
                    var num = (event.shanRequired || 1);
                    if (player.countCards('hs', { name: 'shan' }) - num > 1) return false;
                    return game.hasPlayer(function (current) {
                        if (current == _status.currentPhase) return false;
                        return _status.currentPhase.countCards('h') + 1 <= current.countCards('h');
                    });
                },
                delay: false,
                content() {
                    'step 0'
                    player.line(_status.currentPhase, 'green');
                    _status.currentPhase.draw();
                    'step 1'
                    if (_status.currentPhase.isMaxHandcard(true)) {
                        var evt = event.getParent(2);
                        evt.set('minishifei', true);
                        evt.goto(0);
                        event.finish();
                        return;
                    }
                    if (game.hasPlayer(current => current.countCards('he'))) {
                        player.chooseTarget('选择一名角色弃置其一张牌', true, function (card, player, target) {
                            return target.countCards('he');
                        }).set('ai', function (target) {
                            var player = _status.event.player;
                            return get.effect(target, { name: 'guohe_copy2' }, player, player);
                        });
                    }
                    else event._result = { bool: false };
                    'step 2'
                    var evt = event.getParent(2);
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target, 'green');
                        player.discardPlayerCard(target, 'he', true);
                        evt.result = { bool: true, card: { name: 'shan', isCard: true }, cards: [] };
                        evt.redo();
                    }
                    else {
                        evt.set('minishifei', true);
                        evt.goto(0);
                    }
                },
                ai: {
                    order: 8,
                    respondShan: true,
                    result: {
                        player(player) {
                            return lib.skill.minishifei.checkx(_status.event, player) ? 1 : 0;
                        },
                    },
                    effect: {
                        target(card, player, target, current) {
                            if (get.tag(card, 'respondShan') && current < 0) {
                                if (!player.isMaxHandcard()) return 0;
                            }
                        },
                    },
                },
            },
            //南华老仙
            minijinghe: {
                audio: 'jinghe',
                inherit: 'jinghe',
                filter(event, player) {
                    return !player.hasSkill('minijinghe_clear');
                },
                content() {
                    'step 0'
                    player.when('phaseBegin').then(() => game.countPlayer(current => current.removeAdditionalSkills('minijinghe_' + player.playerid)));
                    player.showCards(cards, get.translation(player) + '发动了【经合】');
                    event.skills = lib.skill.minijinghe.derivation.randomGets(4);
                    player.addTempSkill('minijinghe_clear', { player: 'phaseBegin' });
                    event.targets.sortBySeat();
                    event.num = 0;
                    'step 1'
                    event.target = targets[num];
                    event.num++;
                    event.target.chooseControl(event.skills, 'cancel2').set('choiceList', event.skills.map(function (i) {
                        return '<div class="skill">【' + get.translation(lib.translate[i + '_ab'] || get.translation(i).slice(0, 2)) + '】</div><div>' + get.skillInfoTranslation(i, player) + '</div>';
                    })).set('displayIndex', false).set('prompt', '选择获得一个技能');
                    'step 2'
                    var skill = result.control;
                    if (skill != 'cancel2') {
                        event.skills.remove(skill);
                        target.addAdditionalSkills('minijinghe_' + player.playerid, skill);
                        target.popup(skill);
                        game.log(target, '获得了技能', '#g【' + get.translation(skill) + '】');
                    }
                    if (event.num < event.targets.length) event.goto(1);
                    if (target != game.me && !target.isOnline2()) game.delayx();
                },
                ai: {
                    threaten: 3,
                    order: 10,
                    result: { target: 1 },
                },
                derivation: ['minileiji', 'minipianyi', 'new_retuxi', 'minimingce', 'minizhiyan', 'nhyinbing', 'nhhuoqi', 'nhguizhu', 'nhxianshou', 'nhlundao', 'nhguanyue', 'nhyanzheng'],
            },
            minigongxiu: {
                audio: 'gongxiu',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return player.getHistory('useSkill', evt => evt.skill == 'minijinghe').length;
                },
                direct: true,
                content() {
                    'step 0'
                    event.list1 = [];
                    event.list2 = [];
                    event.addIndex = 0;
                    var choices = [];
                    game.countPlayer(function (current) {
                        if (current.additionalSkills['minijinghe_' + player.playerid]) event.list1.push(current);
                        else event.list2.push(current);
                    });
                    event.list1.sortBySeat();
                    if (event.list1.length) choices.push('令' + get.translation(event.list1) + (event.list1.length > 1 ? '各' : '') + '摸一张牌');
                    else event.addIndex++;
                    event.list2.sortBySeat();
                    if (event.list2.length) choices.push('令' + get.translation(event.list2) + (event.list2.length > 1 ? '各' : '') + '弃置一张手牌');
                    player.chooseControl('cancel2').set('choiceList', choices).set('prompt', get.prompt('minigongxiu')).set('', function () {
                        var evt = _status.event.getParent();
                        if (evt.list2.filter(function (current) {
                            return get.attitude(player, current) <= 0 && !current.hasSkillTag('noh');
                        }).length - evt.list1.length > 1) return 1 - evt.addIndex;
                        return 0;
                    });
                    'step 1'
                    if (result.control != 'cancel2') {
                        if (result.index + event.addIndex == 0) {
                            player.logSkill('minigongxiu', event.list1);
                            game.asyncDraw(event.list1);
                        }
                        else {
                            player.logSkill('minigongxiu', event.list2);
                            for (var i of event.list2) i.chooseToDiscard('h', true);
                            event.finish();
                        }
                    }
                    else event.finish();
                    'step 2'
                    game.delayx();
                },
            },
            //严夫人
            minichanni: {
                audio: 'channi',
                inherit: 'channi',
                content() {
                    'step 0'
                    player.give(cards, target);
                    player.addTempSkill('minichanni_effect');
                    'step 1'
                    if (target.countCards('h') > 0) {
                        game.broadcastAll(function (num) {
                            lib.skill.minichanni_backup.selectCard = [1, num];
                        }, cards.length);
                        var next = target.chooseToUse();
                        next.set('openskilldialog', '将至多' + get.cnNumber(cards.length) + '张手牌当做【决斗】使用');
                        next.set('norestore', true);
                        next.set('addCount', false);
                        next.set('_backupevent', 'minichanni_backup');
                        next.set('custom', {
                            add: {},
                            replace: { window() { } }
                        });
                        next.backup('minichanni_backup');
                    }
                },
                subSkill: {
                    backup: {
                        filterCard(card) {
                            return get.itemtype(card) == 'card';
                        },
                        viewAs: { name: 'juedou' },
                        position: 'h',
                        filterTarget: lib.filter.targetEnabled,
                        check: (card) => get.name(card) == 'sha' ? 7 : 5.5 - get.value(card),
                        log: false,
                        precontent() {
                            delete event.result.skill;
                        },
                    },
                    effect: {
                        charlotte: true,
                        trigger: { global: 'damageBegin2' },
                        filter(event, player) {
                            if (!player.countCards('h') || !event.card || event.card.name !== 'juedou') return false;
                            const evtx = event.getParent(2);
                            if (!evtx || evtx.name !== 'useCard' || evtx.card.name !== 'juedou') return false;
                            const evt = event.getParent(5);
                            return evt.skill == 'minichanni' && evt.player == player && evt.targets[0] == event.player;
                        },
                        prompt2(event, player) {
                            return '弃置所有手牌，防止即将对' + get.translation(event.player) + '造成的伤害';
                        },
                        content() {
                            player.discard(player.getCards('h'));
                            trigger.cancel();
                        },
                        group: 'minichanni_draw',
                    },
                    draw: {
                        charlotte: true,
                        trigger: { global: 'damageSource' },
                        filter(event, player) {
                            if (!event.source?.isIn() || !event.card || event.card.name !== 'juedou') return false;
                            const evtx = event.getParent(2);
                            if (!evtx || evtx.name !== 'useCard' || evtx.card.name !== 'juedou' || !evtx.cards.length) return false;
                            const evt = event.getParent(5);
                            return evt.skill == 'minichanni' && evt.player == player && evt.targets[0] == event.source;
                        },
                        forced: true,
                        popup: false,
                        content() {
                            trigger.source.draw(trigger.getParent(2).cards.length);
                        },
                    },
                },
            },
            mininifu: {
                audio: 'nifu',
                trigger: { global: 'phaseEnd' },
                filter(event, player) {
                    return player.countCards('h') < 3;
                },
                forced: true,
                content() {
                    player.drawTo(3);
                },
            },
            //公孙渊
            minihuaiyi: {
                audio: 'huaiyi',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h');
                },
                usable: 1,
                async content(event, trigger, player) {
                    await player.showHandcards();
                    const hs = player.getCards('h');
                    if (!hs.length) return;
                    const color = get.color(hs[0], player);
                    if (hs.some((card, index) => {
                        return index > 0 && get.color(card) !== color;
                    })) {
                        const list = [], bannedList = [], indexs = Object.keys(lib.color);
                        player.getCards('h').forEach(card => {
                            const color = get.color(card, player);
                            list.add(color);
                            if (!lib.filter.cardDiscardable(card, player, 'minihuaiyi')) {
                                bannedList.add(color);
                            }
                        });
                        list.removeArray(bannedList);
                        list.sort((a, b) => indexs.indexOf(a) - indexs.indexOf(b));
                        let result;
                        if (!list.length) {
                            return;
                        } else if (list.length === 1) {
                            result = { control: list[0] };
                        } else {
                            result = await player.chooseControl(list.map(i => `${i}2`)).set('ai', () => {
                                const player = get.player();
                                if (player.countCards('h', { color: 'red' }) == 1 && player.countCards('h', { color: 'black' }) > 1) {
                                    return 1;
                                }
                                return 0;
                            }).set('prompt', '请选择弃置一种颜色的所有手牌').forResult();
                        }
                        if (!result?.control) return;
                        const control = result.control.slice(0, -1);
                        const cards = player.getCards('h', { color: control }), num = cards.length;
                        await player.discard(cards);
                        result = await player.chooseTarget(`你可以选择至多${get.cnNumber(num)}名有牌的角色，获得这些角色的各一张牌。`, [1, num], (card, player, target) => {
                            return target.countGainableCards(player, target != player ? 'he' : 'e');
                        }).set("ai", target => {
                            return -get.attitude(get.player(), target) + 0.5;
                        }).forResult();
                        if (!result?.targets?.length) return;
                        player.line(result.targets, 'green');
                        for (const target of result.targets.sortBySeat()) {
                            if (target.isIn() && target.countGainableCards(player, target != player ? 'he' : 'e')) {
                                await player.gainPlayerCard(target, target != player ? 'he' : 'e', true);
                            }
                        }
                    }
                },
                ai: {
                    order: 9,
                    result: {
                        player(player, target) {
                            return game.countPlayer(current => current.countGainableCards(player, 'he') && get.effect(current, { name: 'shunshou_copy2' }, player, player) > 0);
                        },
                    },
                },
            },
            minirehuaiyi: {
                audio: 'rehuaiyi',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h');
                },
                usable: 1,
                content() {
                    'step 0'
                    player.showHandcards(get.translation(player) + '发动了【怀异】');
                    if (!player.countDiscardableCards(player, 'h')) event.finish();
                    'step 1'
                    player.chooseToDiscard('h', [1, Infinity], function (card, player) {
                        return !ui.selected.cards.some(cardx => get.color(cardx, player) != get.color(card, player));
                    }, true).set('complexCard', true).set('ai', function (card) {
                        var player = _status.event.player;
                        var num = game.countPlayer(current => current.countGainableCards(player, 'he') && get.effect(current, { name: 'shunshou_copy2' }, player, player) > 0);
                        if (ui.selected.cards.length >= num) return 0;
                        var suits = {};
                        for (var i of player.getDiscardableCards(player, 'h')) {
                            if (!suits[get.suit(i, player)]) suits[get.suit(i, player)] = 1;
                            else suits[get.suit(i, player)]++;
                        }
                        if (!Object.keys(suits).some(suit => suits[suit] < num)) {
                            return num / (get.value(card) || 0.5);
                        }
                        if (suits[get.suit(card, player)] >= num) return (num / suits[get.suit(card, player)]) / (get.value(card) || 0.5);
                        return 0;
                    });
                    'step 2'
                    if (!result.bool) { event.finish(); return; }
                    var color = get.color(result.cards[0], player);
                    var cards = player.getCards('h', card => get.color(card) == color && player.canRecast(card));
                    if (cards.length) player.recast(cards);
                    event.num = result.cards.length;
                    'step 3'
                    player.chooseTarget('请选择至多' + get.cnNumber(event.num) + '名有牌的其他角色，获得这些角色的各一张牌。', [1, num], function (card, player, target) {
                        return target != player && target.countGainableCards(player, 'he') > 0;
                    }).set('ai', function (target) {
                        return -get.attitude(_status.event.player, target) + 0.5;
                    });
                    'step 4'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        player.line(targets);
                        player.gainMultiple(targets, 'he');
                    }
                },
                ai: {
                    order: 9,
                    result: {
                        player(player, target) {
                            return game.countPlayer(current => current.countGainableCards(player, 'he') && get.effect(current, { name: 'shunshou_copy2' }, player, player) > 0);
                        },
                    },
                },
            },
            //群张辽
            minimubing: {
                audio: 'mubing',
                enable: 'phaseUse',
                usable: 1,
                delay: 0,
                async content(event, trigger, player) {
                    var cards = get.cards(4, true);
                    var dialog = ['募兵：请选择你要获得的牌和弃置的牌'];
                    dialog.push('<div class="text center">牌堆顶（已选点数和：0）</div>');
                    dialog.push(cards);
                    if (player.countCards('h') > 0) {
                        dialog.push('<div class="text center">手牌（已选点数和：0）</div>');
                        dialog.push(player.getCards('h'));
                    }
                    var result = await player.chooseButton(dialog).set('filterButton', button => {
                        return !get.owner(button.link) || lib.filter.cardDiscardable(button.link, _status.event.player);
                    }).set('ai', button => {
                        var player = _status.event.player;
                        if (get.owner(button.link)) {
                            var sum = _status.event.sum;
                            var num = 0;
                            for (var i of ui.selected.buttons) {
                                if (get.owner(i.link)) num += i.number;
                            }
                            if (num >= sum) return 0;
                            if (button.link.number + num >= sum) return 15 - get.value(button.link);
                            if (!ui.selected.buttons.some(but => get.owner(but.link))) {
                                var min = _status.event.min;
                                if (button.link.number < min && !player.countCards('h', function (card) {
                                    return card != button.link && button.link.number + card.number > min;
                                })) return 0;
                                return button.link.number;
                            }
                            return Math.max(5 - get.value(button.link), button.link.number);
                        }
                        return get.value(button.link, player);
                    }).set('sum', cards.reduce((num, card) => num += get.value(card, player) > 0 ? get.number(card, false) : 0, 0)).set('min', cards.find(card => {
                        return !cards.some(cardx => cardx != card && cardx.number < card.number);
                    }).number).set('filterOk', () => {
                        return ui.selected.buttons.reduce((num, but) => num += but.link.number * (get.owner(but.link) ? 1 : -1), 0) >= 0;
                    }).set('selectButton', () => {
                        var dialog = get.idDialog(event.videoId);
                        if (dialog) {
                            var num1 = 0, num2 = 0;
                            ui.selected.buttons.forEach(but => {
                                if (!get.owner(but.link)) num1 += but.link.number;
                                else num2 += but.link.number;
                            });
                            dialog.content.childNodes[1].innerHTML = '<div class="text center">牌堆顶（已选点数和：' + num1 + '）</div>';
                            if (dialog.content.childNodes[3]) dialog.content.childNodes[3].innerHTML = '<div class="text center">手牌（已选点数和：' + num2 + '）</div>';
                        }
                        return [1, Infinity];
                    }).forResult();
                    if (result.bool) {
                        var gain = result.links.filter(i => cards.includes(i));
                        var discard = result.links.filter(i => !cards.includes(i));
                        cards.removeArray(gain);
                        if (discard.length) player.discard(discard);
                        if (gain.length) player.gain(gain, 'gain2').gaintag.add('minimubing');
                    }
                    if (cards.length) {
                        player.$throw(cards, 1000);
                        game.cardsDiscard(cards);
                        game.log(cards, '被置入了弃牌堆');
                    }
                },
                onremove(player) {
                    player.removeGaintag('minimubing');
                },
                ai: {
                    order: 9,
                    result: { player: 1 },
                },
            },
            miniziqu: {
                audio: 'ziqu',
                trigger: { source: 'damageBegin2' },
                filter(event, player) {
                    return !player.getStorage('miniziqu_round').includes(event.player) && event.player.countCards('he') > 0;
                },
                check(event, player) {
                    var target = event.player;
                    var eff = get.damageEffect(target, player, player);
                    if (get.attitude(player, target) > 0) {
                        if (eff >= 0) return false;
                        return true;
                    }
                    if (eff <= 0) return true;
                    if (target.hp == 1) return false;
                    if (event.num > 1) return false;
                    var cards = target.getCards('he');
                    for (var i = 0; i < cards.length; i++) {
                        if (get.number(cards[i]) > 10) return true;
                    }
                    return false;
                },
                logTarget: 'player',
                content() {
                    'step 0'
                    player.addTempSkill('miniziqu_round', 'roundStart');
                    player.markAuto('miniziqu_round', [trigger.player]);
                    trigger.cancel();
                    if (trigger.player != player) {
                        trigger.player.chooseCard(true, 'he', function (card, player) {
                            return !player.countCards('he', function (cardx) {
                                return cardx.number > card.number;
                            });
                        });
                    }
                    else event.finish();
                    'step 1'
                    if (result.bool) trigger.player.give(result.cards, player);
                },
                subSkill: {
                    round: {
                        charlotte: true,
                        mark: true,
                        intro: { content: '本轮已对$发动过此技能' },
                    },
                },
            },
            minidiaoling: {
                audio: 'diaoling',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h', card => card.hasGaintag('minimubing')) && game.countPlayer() > 1;
                },
                filterCard(card, player) {
                    return card.hasGaintag('minimubing');
                },
                selectCard: [1, Infinity],
                filterTarget: lib.filter.notMe,
                check(card) {
                    var player = _status.event.player;
                    if (ui.selected.cards.some(cardx => Math.abs(get.number(cardx, player) - get.number(card, player)) <= 1)) return 10 - get.value(card);
                    return 5 - get.value(card);
                },
                complexCard: true,
                complexSelect: true,
                discard: false,
                lose: false,
                delay: 0,
                content() {
                    'step 0'
                    player.give(cards, target);
                    'step 1'
                    var nums = [];
                    for (var card of cards) nums.add(get.number(card, player));
                    nums.sort((a, b) => a - b);
                    if (cards.length > 1 && cards.length == nums.length && nums[nums.length - 1] - nums[0] == nums.length - 1) {
                        player.chooseTarget('请选择至多' + get.cnNumber(nums.length - 1) + '名有牌的其他角色，获得这些角色的各一张牌。', [1, nums.length - 1], function (card, player, target) {
                            return target != player && target.countGainableCards(player, 'he') > 0;
                        }).set('ai', function (target) {
                            return -get.attitude(_status.event.player, target) + 0.5;
                        });
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        player.line(targets);
                        player.gainMultiple(targets, 'he');
                    }
                },
                ai: {
                    order: 8,
                    result: { target: 1 },
                },
            },
            //SP张郃
            minizhouxuan: {
                group: 'minizhouxuan_use',
                audio: 'spolzhouxuan',
                trigger: { player: 'phaseDiscardBegin' },
                filter(event, player) {
                    return player.countCards('h') > 0 && player.getExpansions('minizhouxuan').length < 5;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseCard('h', get.prompt('minizhouxuan'), [1, 5 - player.getExpansions('minizhouxuan').length], '将至多' + get.cnNumber(5 - player.getExpansions('minizhouxuan').length) + '张手牌置于武将牌上').set('ai', function (card) {
                        if (ui.selected.cards.length >= player.needsToDiscard()) return 6 - get.value(card);
                        return 100 - get.useful(card);
                    });
                    'step 1'
                    if (result.bool) {
                        var cards = result.cards;
                        player.logSkill('minizhouxuan');
                        player.addToExpansion(cards, player, 'give').gaintag.add('minizhouxuan');
                    }
                },
                marktext: '旋',
                intro: {
                    content: 'expansion',
                    markcount: 'expansion',
                },
                onremove(player, skill) {
                    var cards = player.getExpansions(skill);
                    if (cards.length) player.loseToDiscardpile(cards);
                },
                subSkill: {
                    use: {
                        trigger: { player: ['useCard', 'respond'] },
                        filter(event, player) {
                            if (player.getExpansions('minizhouxuan').length) return true;
                            return event.name != 'respond' && event.cards?.length;
                        },
                        direct: true,
                        content() {
                            'step 0'
                            if (player.getExpansions('minizhouxuan').length) {
                                player.logSkill('minizhouxuan');
                                var bool = (!player.isMaxHandcard(true));
                                player.draw(bool ? player.getExpansions('minizhouxuan').length : 1);
                                player.loseToDiscardpile(player.getExpansions('minizhouxuan').randomGets(bool && player.getExpansions('minizhouxuan').length > 1 ? 2 : 1));
                                event.finish();
                            }
                            else player.chooseBool(get.prompt('minizhouxuan'), '令' + get.translation(trigger.cards) + '结算完毕后置于武将牌上，称为“旋”').set('choice', (get.type(trigger.card) != 'equip' || (trigger.card.name == 'baiyin' && player.isDamaged())) && get.type(trigger.card) != 'delay');
                            'step 1'
                            if (result.bool) {
                                player.logSkill('minizhouxuan');
                                player.addTempSkill('minizhouxuan_use2');
                                player.markAuto('minizhouxuan_use2', [trigger.card]);
                            }
                        },
                    },
                    use2: {
                        charlotte: true,
                        onremove: true,
                        trigger: { player: 'useCardAfter' },
                        filter(event, player) {
                            return event.cards.filterInD('oej').length && player.getStorage('minizhouxuan_use2').includes(event.card);
                        },
                        forced: true,
                        popup: false,
                        content() {
                            player.addToExpansion(trigger.cards.filterInD('oej'), 'gain2').gaintag.add('minizhouxuan');
                        },
                    },
                },
            },
            //嫦娥
            minidaoyao: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                filter(card, player) {
                    return player.countDiscardableCards(player, 'h');
                },
                filterCard: lib.filter.cardDiscardable,
                check(card) {
                    return 6 - get.value(card);
                },
                usable: 1,
                content() {
                    var card = get.cardPile2(card => card.name == 'tao');
                    if (card) player.gain(card, 'gain2');
                    player.draw(2 + (card ? 0 : 1));
                },
                ai: {
                    order: 9,
                    result: { player: 1 },
                },
            },
            minibenyue: {
                derivation: 'miniguanghan',
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    global: ['loseAsyncAfter'],
                    player: ['recoverEnd', 'gainAfter'],
                },
                filter(event, player) {
                    if (event.name == 'gain' || event.name == 'loseAsync') {
                        if (!event.getg(player).some(card => card.name == 'tao')) return false;
                        return player.countCards('h', { name: 'tao' }) >= 3;
                    }
                    else {
                        var num = 0;
                        game.getAllGlobalHistory('changeHp', evt => {
                            if (evt.getParent().name == 'recover' && evt.player == player) num += evt.num;
                        });
                        return num >= 3;
                    }
                },
                forced: true,
                juexingji: true,
                skillAnimation: true,
                animationColor: 'silver',
                content() {
                    'step 0'
                    player.awakenSkill('minibenyue');
                    'step 1'
                    if (player.maxHp < 15) player.gainMaxHp(15 - player.maxHp);
                    'step 2'
                    player.addSkills('miniguanghan');
                },
            },
            miniguanghan: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'damageEnd' },
                filter(event, player) {
                    if (!event.player.isIn()) return false;
                    return lib.skill.miniguanghan.logTarget(event, player).length;
                },
                logTarget(event, player) {
                    var target = event.player;
                    return game.filterPlayer(current => {
                        if (current != target.getPrevious() && current != target.getNext()) return false;
                        return current != player;
                    });
                },
                forced: true,
                content() {
                    'step 0'
                    event.targets = lib.skill.miniguanghan.logTarget(trigger, player).sortBySeat();
                    'step 1'
                    var target = event.targets.shift();
                    event.target = target;
                    target.chooseToDiscard('h', '广寒：弃置一张手牌，或失去1点体力').set('ai', card => {
                        var player = _status.event.player;
                        if (card.name == 'tao' || card.name == 'jiu') return 0;
                        if (player.hasSkill('zhaxiang') && player.hp > 1) return 0;
                        return 6 - get.value(card);
                    });
                    'step 2'
                    if (!result.bool) target.loseHp(trigger.num);
                    if (event.targets.length) event.goto(1);
                },
                ai: { threaten: 5 },
            },
            //朱儁
            minigongjian: {
                audio: 'gongjian',
                inherit: 'gongjian',
                content() {
                    'step 0'
                    event.targets = trigger.parent.gongjian_targets.filter(function (target) {
                        return trigger.targets.includes(target);
                    });
                    event.num = 0;
                    'step 1'
                    var target = targets[num];
                    player.discardPlayerCard(target, true, 'he', [1, 2]).set('forceAuto', true);
                    'step 2'
                    event.num++;
                    if (event.num < targets.length) event.goto(1);
                    else {
                        var cards = [];
                        game.getGlobalHistory('cardMove', function (evt) {
                            if (evt.player && evt.hs && evt.type == 'discard' && evt.getParent(3) == event) {
                                for (var i of evt.hs) {
                                    if (get.type(i, evt.player) == 'basic' && get.position(i, true) == 'd') cards.add(i);
                                }
                            }
                        });
                        if (cards.length) player.gain(cards, 'gain2');
                    }
                },
            },
            minizjjuxiang: {
                inherit: 'jsrgjuxiang',
                checkx(event, player) {
                    var target = _status.currentPhase;
                    if (!target || get.attitude(player, target) <= 0) return false;
                    var evt = event.getParent('phaseDiscard'), evt2 = event.getParent('phaseJieshu');
                    if (evt?.name == 'phaseDiscard' || evt2 && evt.name == 'phaseJieshu') return false;
                    if (target.getCardUsable({ name: 'sha' }) >= target.countCards('hs', 'sha')) return false;
                    if (!target.hasValueTarget({ name: 'sha' })) return false;
                    return true;
                },
                direct: true,
                content() {
                    'step 0'
                    var target = _status.currentPhase;
                    var cards = trigger.getg(player).filter(i => player.getCards('h').includes(i)).slice();
                    var str = '弃置任意张此次获得的牌';
                    if (target?.isIn()) {
                        event.target = target;
                        str += '，令' + get.translation(target) + '本回合使用【杀】的次数+X（X为你以此法弃置的花色数）';
                    }
                    player.chooseToDiscard(get.prompt('minizjjuxiang'), str, (card, player) => _status.event.cards.includes(card), [1, cards.length]).set('ai', card => {
                        if (!_status.event.goon) return 0;
                        var player = _status.event.player, target = _status.currentPhase;
                        if (ui.selected.cards.some(cardx => get.suit(cardx, player) == get.suit(card, player))) return 0;
                        var num = target.countCards('hs', card => card.name == 'sha') - target.getCardUsable({ name: 'sha' });
                        if (ui.selected.cards.length < num) return 7 - get.value(card);
                        return 0;
                    }).set('cards', cards).set('complexCard', true).set('goon', lib.skill.minizjjuxiang.checkx(trigger, player)).logSkill = 'minizjjuxiang';
                    'step 1'
                    if (result.bool) {
                        if (target?.isIn()) {
                            var num = result.cards.reduce((list, card) => list.add(get.suit(card, player)), []).length;
                            target.addTempSkill('jsrgjuxiang_sha');
                            target.addMark('jsrgjuxiang_sha', num, false);
                            var evt = trigger.getParent('phaseUse');
                            if (evt?.name == 'phaseUse' && !evt.skill) {
                                evt.player.addTempSkill('jsrgjuxiang_buff', 'phaseUseAfter');
                                evt.player.addMark('jsrgjuxiang_buff', num, false);
                            }
                        }
                    }
                },
            },
            //吕布
            miniwushuang: {
                mod: {
                    selectTarget(card, player, range) {
                        if (card.name == 'sha' && range[1] != -1) range[1]++;
                    },
                },
                audio: 'wushuang',
                audioname: ['Mnian_lvbu', 're_lvbu', 'lvlingqi'],
                audioname2: { Mmiao_lvlingqi: 'miniwushuang_Mmiao_lvlingqi' },
                trigger: { player: 'useCardToPlayered', target: 'useCardToTargeted' },
                filter(event, player) {
                    return (event.card.name == 'sha' && event.player == player) || event.card.name == 'juedou';
                },
                logTarget(event, player) {
                    return player == event.player ? event.target : event.player;
                },
                forced: true,
                content() {
                    const target = lib.skill.miniwushuang.logTarget(trigger, player);
                    if (trigger.card.name == 'sha') {
                        const id = target.playerid;
                        const map = trigger.getParent().customArgs;
                        if (!map[id]) map[id] = {};
                        if (typeof map[id].shanRequired == 'number') map[id].shanRequired++;
                        else map[id].shanRequired = 2;
                    }
                    else {
                        const id = target.playerid;
                        const idt = trigger.target.playerid;
                        const map = trigger.getParent().customArgs;
                        if (!map[idt]) map[idt] = {};
                        if (!map[idt].shaReq) map[idt].shaReq = {};
                        if (!map[idt].shaReq[id]) map[idt].shaReq[id] = 1;
                        map[idt].shaReq[id]++;
                    }
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        //if(player.hasSkill('miniwuchang')&&arg.target.group==player.group) return false;
                        if (!arg || !arg.card || !arg.target) return false;
                        if (arg.card.name == 'sha' && arg.target.countCards('hs', { name: 'shan' }) > 1) return false;
                        if (arg.card.name == 'juedou' && Math.floor(arg.target.countCards('hs', { name: 'sha' }) / 2) > player.countCards('hs', { name: 'sha' })) return false;
                    },
                },
                subSkill: { Mmiao_lvlingqi: { audio: 'ext:活动武将/audio/skill:2' } },
            },
            miniwuchang: {
                audio: 'liyu',
                trigger: { source: 'damageBegin1' },
                filter(event, player) {
                    if (event.player.group != player.group) return false;
                    if (event.getParent().type != 'card' || !['sha', 'juedou'].includes(event.card.name)) return false;
                    var history = event.player.getHistory('useCard').concat(event.player.getHistory('respond'));
                    return !history.some(evt => evt.respondTo && evt.respondTo[1] == event.card);
                },
                logTarget: 'player',
                prompt2: (event, player) => '令即将对' + get.translation(event.player) + '造成的伤害+1，然后你变更至其他势力',
                check: (event, player) => get.attitude(player, event.player) < 0 && get.damageEffect(event.player, player, player) > 0 && !event.player.hasSkillTag('filterDamage', true, { player: player, card: event.card }),
                content() {
                    trigger.num++;
                    player.addTempSkill('miniwuchang_change');
                    trigger['miniwuchang_' + player.playerid] = trigger.player.group;
                },
                group: 'miniwuchang_draw',
                subSkill: {
                    change: {
                        charlotte: true,
                        trigger: { global: ['damageAfter', 'damageZero', 'damageCancelled'] },
                        filter(event, player) {
                            return event['miniwuchang_' + player.playerid];
                        },
                        forced: true,
                        popup: false,
                        content() {
                            'step 0'
                            var list = lib.group.slice();
                            list.removeArray([/*'shen',*/trigger['miniwuchang_' + player.playerid]]);
                            player.chooseControl(list).set('prompt', '无常：请选择你要变更的势力').set('ai', () => {
                                var player = _status.event.player;
                                var aim = _status.event.getTrigger().player;
                                var list = _status.event.list;
                                var list2 = list.filter(group => game.hasPlayer(target => target != aim && target.group == group && get.attitude(player, target) < 0));
                                if (list2.length) {
                                    list2.sort((a, b) => game.countPlayer(target => target != aim && target.group == b && get.attitude(player, target) < 0) - game.countPlayer(target => target != aim && target.group == a && get.attitude(player, target) < 0));
                                    return list2[0];
                                }
                                return list.randomGet();
                            }).set('list', list);
                            'step 1'
                            if (result.control) {
                                var group = result.control;
                                player.popup(group + '2', get.groupnature(group, 'raw'));
                                player.changeGroup(group);
                            }
                        },
                    },
                    draw: {
                        audio: 'liyu',
                        enable: 'phaseUse',
                        filterTarget: lib.filter.notMe,
                        prompt: '令一名其他角色摸一张牌，然后你将势力变更至与其相同并从牌堆中获得一张【杀】',
                        usable: 1,
                        content() {
                            'step 0'
                            target.draw();
                            if (target.group != player.group) player.changeGroup(target.group);
                            'step 1'
                            var card = get.cardPile2(card => card.name == 'sha');
                            if (card) player.gain(card, 'gain2');
                        },
                        ai: {
                            order(item, player) {
                                var bool = player.countCards('hs', card => get.name(card) == 'juedou' && player.hasValueTarget(card));
                                return get.order({ name: bool ? 'juedou' : 'sha' }, player) + 0.3;
                            },
                            result: {
                                target(player, target) {
                                    var cards = player.getCards('hs', card => ['sha', 'juedou'].includes(get.name(card)) && player.hasValueTarget(card));
                                    var att = Math.sign(get.attitude(player, target));
                                    if (!cards.length) return 1;
                                    var list = [];
                                    cards.forEach(card => {
                                        if (card.name != 'sha' || player.getCardUsable('sha') > 0) {
                                            var targets = game.filterPlayer(current => player.canUse(card, current) && get.effect(current, card, player, player) > 0 && get.attitude(player, current) < 0);
                                            if (targets.length) {
                                                targets.sort((a, b) => get.effect(b, card, player, player) - get.effect(a, card, player, player));
                                                list.push([targets[0], get.effect(targets[0], card, player, player)]);
                                            }
                                        }
                                    });
                                    if (!list.length) return 3 * (Math.sign(att + 0.5) + (att > 0 ? 1 : 0));
                                    list.sort((a, b) => b[1] - a[1]);
                                    if (list[0][0].group != target.group) return Math.sign(att - 0.5) + (att >= 0 ? 1.5 : 0);
                                    return 3 * (Math.sign(att + 0.5) + (att > 0 ? 1 : 0)) + (list[0][0] == target ? 1 : 0);
                                },
                            },
                        },
                    },
                },
            },
            //孔融
            minilirang: {
                audio: 'splirang',
                trigger: { global: 'phaseBefore', player: ['enterGame', 'phaseZhunbeiBegin'] },
                filter(event, player) {
                    if (player.storage.minilirang?.isIn()) return false;
                    return event.name != 'phase' || game.phaseNumber == 0;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minilirang'), '选择一名其他角色，其摸牌阶段额外摸一张牌，你获得其弃牌阶段弃置的牌', lib.filter.notMe).set('ai', target => get.attitude(_status.event.player, target));
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('minilirang', target);
                        player.storage.minilirang = target;
                        player.markSkill('minilirang');
                        player.when({ global: 'die' }).filter((event, player) => event.player == player.storage.minilirang).then(() => {
                            player.unmarkSkill('minilirang');
                            delete player.storage.minilirang;
                        });
                        player.addExpose(0.3);
                    }
                },
                group: ['minilirang_yingzi', 'minilirang_guzheng'],
                intro: { content: '已指定$为“礼让”角色' },
                subSkill: {
                    yingzi: {
                        audio: 'splirang',
                        trigger: { global: 'phaseDrawBegin2' },
                        filter(event, player) {
                            var target = player.storage.minilirang;
                            return target && target == event.player && !event.numFixed;
                        },
                        forced: true,
                        locked: false,
                        logTarget: 'player',
                        content() {
                            trigger.num++;
                        },
                    },
                    guzheng: {
                        audio: 'splirang',
                        trigger: { global: 'phaseDiscardEnd' },
                        filter(event, player) {
                            var target = player.storage.minilirang;
                            return target && target == event.player && lib.skill.twlijian.getCards(event).length;
                        },
                        forced: true,
                        locked: false,
                        logTarget: 'player',
                        content() {
                            player.gain(lib.skill.twlijian.getCards(trigger), 'gain2');
                        },
                    },
                },
            },
            minizhengyi: {
                audio: 'spmingshi',
                trigger: { global: 'damageBegin4' },
                filter(event, player) {
                    var target = player.storage.minilirang;
                    if (!target || !target.isIn()) return false;
                    var list = event.minizhengyi || [];
                    var list2 = [player, target];
                    return list2.includes(event.player) && list2.some(current => event.player != current && !list.includes(current));
                },
                direct: true,
                async content(event, trigger, player) {
                    var target = player.storage.minilirang;
                    var current = trigger.player == player ? target : player;
                    var result = await current.chooseBool('争义：是否代替' + get.translation(trigger.player) + '承受本次伤害并摸一张牌？').set('choice', lib.skill.twgonghuan.check(trigger, current)).forResult();
                    if (result.bool) {
                        current.logSkill('minizhengyi', trigger.player);
                        game.log(current, '为', trigger.player, '承受了此次伤害');
                        var list = trigger.minizhengyi ? trigger.minizhengyi.slice() : [];
                        list.addArray([player, target]);
                        trigger.cancel();
                        current.draw();
                        current.damage(trigger.source ? trigger.source : 'nosource', trigger.nature, trigger.num).set('card', trigger.card).set('cards', trigger.cards).minizhengyi = list;
                    }
                },
            },
            minixiaowu: {
                audio: 'xiaowu',
                inherit: 'xiaowu',
                contentAfter() {
                    var targetsx = event.getParent()._xiaowu_targets;
                    var num1 = targets.length - targetsx.length;
                    var num2 = num1 - targetsx.length;
                    if (num1 > 0) player.addMark('shawu', Math.ceil(num1 / 2));
                    if (num2 < 0) {
                        player.line(targetsx, 'fire');
                        for (var i of targetsx) i.damage();
                    }
                },
            },
            minihuaping: {
                audio: 'huaping',
                inherit: 'huaping',
                content() {
                    player.awakenSkill('minihuaping');
                    var skills = trigger.player.getSkills(null, false, false).filter(function (i) {
                        var info = get.info(i);
                        return info && !info.charlotte;
                    });
                    player.changeSkills(skills, ['minixiaowu']);
                    var num = player.countMark('shawu');
                    if (num > 0) {
                        player.removeMark('shawu', num);
                        player.draw(num);
                    }
                },
            },
            //谋袁绍
            minisbluanji: {
                audio: 'sbluanji',
                inherit: 'sbluanji',
                filter(event, player) {
                    if (event.name == 'chooseToUse') return player.countCards('hs', card => get.info('minisbluanji').filterCard(card, player)) > 1;
                    const evt = event.getParent(2), history = player.getHistory('gain', evtx => evtx.getParent(2).name == 'minisbluanji');
                    return evt.name == 'wanjian' && evt.getParent().player == player && event.player != player && history.reduce((list, evt) => {
                        list.addArray(evt.cards); return list;
                    }, []).length < 3;
                },
                filterCard(card, player) {
                    return !player.getStorage('minisbluanji_used').includes(get.color(card));
                },
                check(card) {
                    const player = get.event().player, eff = get.info('sbluanji').check(card);
                    if (ui.selected.cards.length && get.color(card) == get.color(ui.selected.cards[0])) return 2.5 * eff;
                    return eff;
                },
                complexCard: true,
                precontent() {
                    player.addTempSkill('minisbluanji_used');
                    player.markAuto('minisbluanji_used', event.result.cards.map(i => get.color(i, player)));
                },
                group: 'minisbluanji_discard',
                subSkill: {
                    used: { charlotte: true, onremove: true },
                    discard: {
                        audio: 'sbluanji',
                        trigger: { source: 'damageSource' },
                        filter(event, player) {
                            return event.card && event.card.name == 'wanjian' && event.player.isIn() && event.player.countCards('he');
                        },
                        usable: 3,
                        prompt2: (event, player) => '弃置' + get.translation(event.player) + '的一张牌',
                        check: (event, player) => get.effect(event.player, { name: 'guohe_copy2' }, player, player) > 0,
                        logTarget: 'player',
                        content() {
                            player.discardPlayerCard('he', trigger.player, true);
                        },
                    },
                },
            },
            minisbxueyi: {
                audio: 'sbxueyi',
                inherit: 'sbxueyi',
                filter(event, player) {
                    return event.target.group == 'qun';
                },
                mod: {
                    maxHandcard(player, num) {
                        return num + 2 * game.countPlayer(current => current.group == 'qun');
                    },
                },
            },
            //马腾
            minixiongzheng: {
                audio: 'twxiongzheng',
                onremove: true,
                trigger: { global: "roundStart" },
                filter(event, player) {
                    return game.hasPlayer(target => target !== player.storage.minixiongzheng_target);
                },
                async cost(event, trigger, player) {
                    event.result = await player
                        .chooseTarget(get.prompt("minixiongzheng"), "选择一名未选择过的角色，称为“雄争”角色", (card, player, target) => {
                            return target !== player.storage.minixiongzheng_target;
                        })
                        .set("ai", target => {
                            var player = _status.event.player,
                                att = get.attitude(player, target);
                            if (game.roundNumber <= 1 && player.hasUnknown()) return 0;
                            return -att;
                        })
                        .forResult();
                },
                async content(event, trigger, player) {
                    var target = event.targets[0];
                    player.storage.minixiongzheng_target = target;
                    player.addTempSkill("minixiongzheng_mark", "roundStart");
                    target.addTempSkill("minixiongzheng_threaten", "roundStart");
                    await game.delayx();
                },
                subSkill: {
                    mark: {
                        intro: {
                            content: "$参与了〖雄争〗的争斗",
                            onunmark: true,
                        },
                        charlotte: true,
                        onremove: true,
                        trigger: { global: "damage" },
                        firstDo: true,
                        direct: true,
                        filter(event, player) {
                            return event.player == player.storage.minixiongzheng_target && get.itemtype(event.source) == "player";
                        },
                        content() {
                            player.markAuto("minixiongzheng_mark", [trigger.source]);
                        },
                        group: "minixiongzheng_effect",
                    },
                    threaten: {
                        mark: true,
                        intro: { content: "本轮〖雄争〗目标" },
                        ai: { threaten: 10 },
                    },
                    effect: {
                        charlotte: true,
                        audio: 'twxiongzheng',
                        trigger: { global: "roundEnd" },
                        filter(event, player) {
                            const sha = new lib.element.VCard({ name: "sha" });
                            return game.hasPlayer(target => player.getStorage("minixiongzheng_mark").includes(target) || player.canUse(sha, target, false));
                        },
                        async cost(event, trigger, player) {
                            const target = player.storage.minixiongzheng_target;
                            const sha = new lib.element.VCard({ name: "sha" });
                            const list = game.filterPlayer(target => player.getStorage("minixiongzheng_mark").includes(target));
                            const list2 = game.filterPlayer(target => player.canUse(sha, target, false));
                            let choiceList = ["视为对任意名本轮未对" + get.translation(target) + "造成过伤害的角色使用一张【杀】", "令任意名本轮对" + get.translation(target) + "造成过伤害的角色摸两张牌"];
                            let choices = [];
                            if (list2.length) {
                                choices.push("选项一");
                                choiceList[0] += "（" + get.translation(list2) + "）";
                            } else choiceList[0] = '<span style="opacity:0.5">' + choiceList[0] + "</span>";
                            if (list.length) {
                                choices.push("选项二");
                                choiceList[1] += "（" + get.translation(list) + "）";
                            } else choiceList[1] = '<span style="opacity:0.5">' + choiceList[1] + "</span>";
                            choices.push("cancel2");
                            const control = await player
                                .chooseControl(choices)
                                .set("prompt", "雄争：是否选择一项？")
                                .set("choiceList", choiceList)
                                .set("list", list)
                                .set("list2", list2)
                                .set("ai", function () {
                                    const { player, list, list2 } = get.event();
                                    const eff1 = list.reduce((acc, target) => {
                                        if (target === player) return acc;
                                        const eff = get.effect(target, { name: "sha" }, player, player);
                                        if (eff > 0) return acc + eff;
                                        return acc;
                                    }, 0),
                                        eff2 = list2.reduce((acc, target) => {
                                            const eff = get.effect(target, { name: "draw" }, player, player);
                                            if (eff > 0) return acc + eff;
                                            return acc;
                                        }, 0);
                                    if (eff2 > eff1 && _status.event.controls.includes("选项二")) return "选项二";
                                    if (eff1 > 0) return 0;
                                    return "cancel2";
                                })
                                .forResult("control");
                            event.result = {
                                bool: control && control !== "cancel2",
                                cost_data: [control, [list2, list]],
                            };
                        },
                        async content(event, trigger, player) {
                            const goon = event.cost_data[0] === "选项一";
                            const list = event.cost_data[1][goon ? 0 : 1];
                            const prompt = "雄争：请选择任意名满足条件的角色，" + (goon ? "视为依次对这些角色使用一张【杀】" : "令这些角色摸两张牌");
                            const result = await player
                                .chooseTarget(
                                    prompt,
                                    (card, player, target) => {
                                        const { goon, list } = get.event();
                                        if (!list.includes(target)) return false;
                                        return !goon || player.canUse(new lib.element.VCard({ name: "sha" }), target, false);
                                    },
                                    [1, list.length]
                                )
                                .set("goon", goon)
                                .set("list", list)
                                .set("ai", target => {
                                    const { goon, player } = get.event();
                                    return get.effect(target, { name: goon ? "sha" : "draw" }, player, player);
                                })
                                .forResult();
                            if (result?.bool && result.targets?.length) {
                                const targets = result.targets.sortBySeat();
                                player.line(targets);
                                if (goon) {
                                    const sha = new lib.element.VCard({ name: "sha" });
                                    await player.useCard(sha, targets, false);
                                } else {
                                    await game.asyncDraw(targets, 2);
                                    await game.delayx();
                                }
                            }
                        },
                    },
                },
            },
            miniluannian: {
                audio: 'twluannian',
                global: 'miniluannian_global',
                zhuSkill: true,
                subSkill: {
                    global: {
                        audio: 'twluannian',
                        enable: 'phaseUse',
                        usable: 1,
                        forceaudio: true,
                        onChooseToUse(event) {
                            if (!game.online) {
                                var num = 1;
                                game.countPlayer2(current => {
                                    num += current.getRoundHistory('useSkill', evt => evt.skill == 'miniluannian_global').length;
                                });
                                event.set('miniluannian_num', num);
                            }
                        },
                        filter(event, player) {
                            if (!event.miniluannian_num) return false;
                            return player.group == 'qun' && player.countCards('he') >= event.miniluannian_num && game.hasPlayer(function (current) {
                                return current.storage.minixiongzheng_target?.isIn() && current != player && current.hasZhuSkill('miniluannian', player)
                            });
                        },
                        filterCard: true,
                        position: 'he',
                        prompt() {
                            var player = _status.event.player;
                            var num = _status.event.miniluannian_num
                            var list = game.filterPlayer(function (current) {
                                return current.hasZhuSkill('miniluannian', player);
                            }).map(i => i.storage.minixiongzheng_target).sortBySeat();
                            return '弃置' + get.cnNumber(num) + '张牌，对' + get.translation(list) + (list.length > 1 ? '中的一人' : '') + '造成1点伤害';
                        },
                        selectCard() {
                            return _status.event.miniluannian_num;
                        },
                        complexSelect: true,
                        complexCard: true,
                        filterTarget(card, player, target) {
                            return game.filterPlayer(function (current) {
                                return current.hasZhuSkill('miniluannian', player);
                            }).map(i => i.storage.minixiongzheng_target).includes(target);
                        },
                        selectTarget() {
                            return game.filterPlayer(function (current) {
                                return current.hasZhuSkill('miniluannian', _status.event.player);
                            }).map(i => i.storage.minixiongzheng_target).filter(i => i && i.isIn()).length > 1 ? 1 : -1;
                        },
                        check(card) {
                            return 6 - get.value(card);
                        },
                        content() {
                            target.damage();
                        },
                        ai: {
                            order: 7,
                            result: {
                                target(player, target) {
                                    return get.damageEffect(target, player, target);
                                }
                            },
                            expose: 0.25,
                        },
                    },
                },
            },
            minizecai: {
                audio: 'dczecai',
                inherit: 'dczecai',
                derivation: 'minijizhi',
                async cost(event, trigger, player) {
                    const target = lib.skill.dczecai.getMax();
                    let str = '令一名角色获得〖集智〗直到下一轮结束';
                    if (target) str += '；若选择的目标为' + get.translation(target) + '，则其获得一个额外的回合';
                    const next = player.chooseTarget(get.prompt(event.skill), str).set('maximum', target).set("ai", target => {
                        const { player, maximum } = get.event();
                        if (target != maximum) return 0;
                        return get.attitude(player, target);
                    })
                    next.set('targetprompt2', next.targetprompt2.concat([
                        target => {
                            const event = get.event();
                            if (!target.isIn() || !event.filterTarget(null, event.player, target)) return false;
                            return target === event.maximum ? '额外回合' : '';
                        },
                    ]));
                    event.result = await next.forResult();
                },
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    const targetx = lib.skill.dczecai.getMax();
                    const target = event.targets[0];
                    target.addTempSkill('minizecai_effect', 'roundEnd');
                    await target.addAdditionalSkills('minizecai_effect', 'minijizhi');
                    if (target == targetx) target.insertPhase();
                },
            },
            minijianjie: {
                audio: 'xinfu_jianjie',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return player.phaseNumber <= 1;
                },
                forced: true,
                locked: false,
                async content(event, trigger, player) {
                    const result = await player.chooseTarget('荐杰：选择一名角色获得“龙印”', true).set('ai', target => get.attitude(get.event().player, target)).forResult();
                    if (result?.targets?.length) {
                        const target = result.targets[0];
                        player.line(target, 'fire');
                        lib.skill.minijianjie.addMark('huoji', player, target);
                        await game.delayx();
                        if (game.hasPlayer(current => current != target)) {
                            const result = await player.chooseTarget('荐杰：选择一名角色获得“凤印”', (card, player, target) => {
                                return target != get.event().target;
                            }, true).set('ai', target => get.attitude(get.event().player, target)).set('target', target).forResult();
                            if (result?.targets?.length) {
                                const targetx = result.targets[0];
                                player.line(targetx, 'thunder');
                                lib.skill.minijianjie.addMark('lianhuan', player, targetx);
                                await game.delayx();
                            }
                        }
                    }
                },
                group: ['minijianjie_use', 'minijianjie_die'],
                derivation: ['minijianjie_huoji', 'minijianjie_lianhuan', 'minijianjie_yeyan'],
                hasMark(mark, player, target) {
                    if (!target) return player.getStorage('minijianjie_' + mark).length > 0;
                    return target.getStorage('minijianjie_' + mark).includes(player);
                },
                addMark(mark, player, target) {
                    const storage = target.storage.minijianjie_yeyan;
                    mark = 'minijianjie_' + mark;
                    target.addAdditionalSkill(`${mark}_${player.playerid}`, mark);
                    target.markAuto(mark, [player]);
                    target.storage.minijianjie_yeyan = storage;
                    game.log(player, '令', target, '获得了', `#g“${mark == 'minijianjie_huoji' ? '龙印' : '凤印'}”`);
                },
                removeMark(mark, player, target, log) {
                    if (lib.skill.minijianjie.hasMark(mark, player, target, log)) {
                        mark = 'minijianjie_' + mark;
                        target.removeAdditionalSkill(`${mark}_${player.playerid}`);
                        target.unmarkAuto(mark, [player]);
                        if (log) game.log(target, '移去了', player, '给予的', `#g“${mark == 'minijianjie_huoji' ? '龙印' : '凤印'}”`);
                        else game.log(player, '移去了', target, '的', `#g“${mark == 'minijianjie_huoji' ? '龙印' : '凤印'}”`);
                    }
                },
                getBigFire(player) {
                    if (player.getDiscardableCards(player, 'h').reduce((list, card) => list.add(get.suit(card, player)), []).length < 4) return false;
                    const targets = game.filterPlayer(target => get.damageEffect(target, player, player, 'fire') && target.hp <= 3 && !target.hasSkillTag('filterDamage', null, { player: player }));
                    if (!targets.length) return false;
                    if (targets.length == 1 || targets.some(target => get.attitude(player, target) < 0 && target.identity && target.identity.indexOf('zhu') != -1)) {
                        let suits = player.getDiscardableCards(player, 'h').reduce((map, card) => {
                            const suit = get.suit(card, player);
                            if (!map[suit]) map[suit] = [];
                            return map;
                        }, {}), cards = [];
                        Object.keys(suits).forEach(i => {
                            suits[i].addArray(player.getDiscardableCards(player, 'h').filter(card => get.suit(card) == i));
                            cards.add(suits[i].sort((a, b) => get.value(a) - get.value(b))[0]);
                        });
                        return true;
                    }
                    return false;
                },
                subSkill: {
                    use: {
                        audio: 'xinfu_jianjie',
                        enable: 'phaseUse',
                        filter(event, player) {
                            if (player.phaseNumber <= 1) return false;
                            const skill = lib.skill.minijianjie;
                            return game.hasPlayer(current => skill.hasMark('huoji', player, current) || skill.hasMark('lianhuan', player, current));
                        },
                        filterTarget(card, player, target) {
                            if (ui.selected.targets.length) return true;
                            const skill = lib.skill.minijianjie;
                            return skill.hasMark('huoji', player, target) || skill.hasMark('lianhuan', player, target);
                        },
                        selectTarget: 2,
                        complexSelect: true,
                        complexTarget: true,
                        multitarget: true,
                        prompt: '出牌阶段限一次，你可以移动场上的“龙印”或“凤印”',
                        targetprompt: ['失去印', '获得印'],
                        usable: 1,
                        async content(event, trigger, player) {
                            const targets = event.targets;
                            const skill = lib.skill.minijianjie, bool1 = skill.hasMark('huoji', player, targets[0]), bool2 = skill.hasMark('lianhuan', player, targets[0]);
                            let mark;
                            if (bool1 && bool2) {
                                const result = await player.chooseControl('龙印', '凤印').set('prompt', '选择要移动的“印”').forResult();
                                if (result?.control) mark = result.control;
                            }
                            else mark = (bool1 ? '龙印' : '凤印');
                            if (mark) {
                                mark = (mark == '龙印' ? 'huoji' : 'lianhuan');
                                skill.removeMark(mark, player, targets[0]);
                                skill.addMark(mark, player, targets[1]);
                                await game.delayx();
                            }
                        },
                        ai: {
                            order: 8,
                            expose: 0.25,
                            result: {
                                target(player, target) {
                                    if (!ui.selected.targets.length) return get.attitude(player, target) < 0 ? -999 : -3;
                                    return target.countCards('h') + 1;
                                },
                            },
                        },
                    },
                    die: {
                        audio: 'xinfu_jianjie',
                        trigger: { global: 'die' },
                        filter(event, player) {
                            const skill = lib.skill.minijianjie;
                            return skill.hasMark('huoji', player, event.player) || skill.hasMark('lianhuan', player, event.player);
                        },
                        forced: true,
                        logTarget: 'player',
                        async content(event, trigger, player) {
                            if (lib.skill.minijianjie.hasMark('huoji', player, trigger.player)) {
                                const result = await player.chooseTarget('荐杰：选择一名角色获得“龙印”', true).set('ai', target => get.attitude(get.event().player, target)).forResult();
                                if (result?.targets?.length) {
                                    const target = result.targets[0];
                                    player.line(target, 'fire');
                                    lib.skill.minijianjie.addMark('huoji', player, target);
                                    await game.delayx();
                                }
                            }
                            if (lib.skill.minijianjie.hasMark('lianhuan', player, trigger.player)) {
                                const result = await player.chooseTarget('荐杰：选择一名角色获得“凤印”', true).set('ai', target => get.attitude(get.event().player, target)).forResult();
                                if (result?.targets?.length) {
                                    const target = result.targets[0];
                                    player.line(target, 'thunder');
                                    lib.skill.minijianjie.addMark('lianhuan', player, target);
                                    await game.delayx();
                                }
                            }
                        },
                    },
                    huoji: {
                        marktext: '龙',
                        intro: {
                            name: '龙印',
                            content: '<li>①出牌阶段限三次，你可以将一张红色牌当作【火攻】使用。②当你使用【火攻】需要弃牌时，你可以观看牌堆顶的四张牌，选择其中一张符合要求的牌作为需要弃置的牌，然后将其余的牌放回牌堆顶。<br><li>若你同时拥有“凤印”，则你视为拥有技能〖业炎〗。',
                        },
                        inherit: 'rehuoji',
                        audio: false,
                        viewAsFilter(player) {
                            const storage = player.getStorage('minijianjie_huoji');
                            if (!storage.some(source => source.isIn() && source.hasSkill('minijianjie'))) return false;
                            return player.hasCard(card => get.color(card) == 'red', 'she');
                        },
                        usable: 3,
                        group: ['minijianjie_yeyan', 'minijianjie_viewAs'],
                    },
                    viewAs: {
                        charlotte: true,
                        inherit: 'minihuoji',
                        audio: false,
                        filter(event, player) {
                            const storage = player.getStorage('minijianjie_huoji');
                            if (!storage.some(source => source.isIn() && source.hasSkill('minijianjie'))) return false;
                            return lib.skill.minihuoji.filter(event, player);
                        },
                        group: 'minijianjie_yeyan',
                    },
                    lianhuan: {
                        marktext: '凤',
                        intro: {
                            name: '凤印',
                            content: '<li>出牌阶段限三次。你可以将一张♣牌当作【铁索连环】使用或重铸。<br><li>若你同时拥有“龙印”，则你视为拥有技能〖业炎〗。',
                        },
                        inherit: 'lianhuan',
                        charlotte: true,
                        audio: false,
                        filter(event, player) {
                            const storage = player.getStorage('minijianjie_lianhuan');
                            if (!storage.some(source => {
                                return source.isIn() && source.hasSkill('minijianjie');
                            })) return false;
                            if (!player.hasCard(card => get.suit(card) == 'club', 'she')) return false;
                            return event.type == 'phase' || event.filterCard(get.autoViewAs({ name: 'tiesuo' }, 'unsure'), player, event);
                        },
                        usable: 3,
                        group: 'minijianjie_yeyan',
                    },
                    yeyan: {
                        inherit: 'yeyan',
                        audio: false,
                        filter(event, player) {
                            if (player.storage.minijianjie_yeyan) return false;
                            const huoji = player.getStorage('minijianjie_huoji'), lianhuan = player.getStorage('minijianjie_lianhuan');
                            return huoji.length > 0 && lianhuan.some(source => huoji.includes(source) && source.isIn() && source.hasSkill('minijianjie'));
                        },
                        check(card) {
                            if (!lib.skill.minijianjie.getBigFire(get.event().player)) return -1;
                            return 1 / (get.value(card) || 0.5);
                        },
                        contentBefore() {
                            player.awakenSkill('minijianjie_yeyan');
                            player.addTempSkill('minijianjie_effect', 'minijianjie_yeyanAfter');
                        },
                        ai: {
                            order: 1,
                            fireAttack: true,
                            result: {
                                target(player, target) {
                                    if (player.hasUnknown()) return 0;
                                    const att = Math.sign(get.attitude(player, target));
                                    const targets = game.filterPlayer(target => get.damageEffect(target, player, player, 'fire') && (!lib.skill.minijianjie.getBigFire(player) || (target.hp <= 3 && !target.hasSkillTag('filterDamage', null, { player: player }))));
                                    if (!targets.includes(target)) return 0;
                                    if (lib.skill.minijianjie.getBigFire(player)) {
                                        if (ui.selected.targets.length) return 0;
                                        if (!(targets.length == 1 || (att < 0 && target.identity && target.identity.indexOf('zhu') != -1))) return 0;
                                    }
                                    return att * get.damageEffect(target, player, player, 'fire');
                                },
                            },
                        },
                    },
                    effect: {
                        charlotte: true,
                        trigger: { player: 'loseHpBefore' },
                        filter(event, player) {
                            return event.getParent().name == 'minijianjie_yeyan';
                        },
                        firstDo: true,
                        forced: true,
                        popup: false,
                        content() {
                            trigger.cancel();
                            const skill = lib.skill.minijianjie, huoji = player.getStorage('minijianjie_huoji').slice(), lianhuan = player.getStorage('minijianjie_lianhuan').slice();
                            huoji.forEach(source => skill.removeMark('huoji', source, player, true));
                            lianhuan.forEach(source => skill.removeMark('lianhuan', source, player, true));
                        },
                    },
                },
            },
            miniyinshi: {
                audio: 'xinfu_yinshi',
                trigger: { player: 'damageBegin4' },
                filter(event, player) {
                    const skill = lib.skill.minijianjie;
                    if (skill.hasMark('huoji', player) && skill.hasMark('lianhuan', player)) return false;
                    if (!player.hasEmptySlot(2)) return false;
                    return event.hasNature() || get.type(event.card, 'trick') == 'trick';
                },
                forced: true,
                async content(event, trigger, player) {
                    trigger.cancel();
                },
                ai: {
                    notrick: true,
                    nofire: true,
                    nothunder: true,
                    effect: {
                        target(card, player, target, current) {
                            const skill = lib.skill.minijianjie;
                            if (skill.hasMark('huoji', target) && skill.hasMark('lianhuan', target)) return false;
                            if (player == target && get.subtype(card) == 'equip2') {
                                if (get.equipValue(card) <= 8) return 0;
                            }
                            if (!target.hasEmptySlot(2)) return;
                            if (get.tag(card, 'natureDamage')) return 'zerotarget';
                            if (get.type(card) == 'trick' && get.tag(card, 'damage')) {
                                return 'zeroplayertarget';
                            }
                        },
                    },
                },
            },
            //邹氏
            minihuoshui: {
                audio: 'huoshui',
                enable: 'phaseUse',
                filter(event, player) {
                    return game.hasPlayer(target => {
                        if (target == player || player.getStorage('minihuoshui_used').includes(target)) return false;
                        return (!player.hasSkill('minihuoshui_0') && !target.hasSkill('fengyin')) || (!player.hasSkill('minihuoshui_1') && target.countCards('h')) || (!player.hasSkill('minihuoshui_2') && target.countDiscardableCards(player, 'e'));
                    });
                },
                usable: 3,
                chooseButton: {
                    dialog(event, player) {
                        var dialog = ui.create.dialog('祸水：选择一名一名其他角色…', 'hidden');
                        dialog.add([[
                            ['0', '令其本回合非锁定技失效'],
                            ['1', '观看其手牌并获得其中一张牌'],
                            ['2', '弃置其装备区所有牌'],
                        ], 'textbutton']);
                        return dialog;
                    },
                    filter(button, player) {
                        if (player.hasSkill('minihuoshui_' + button.link, null, null, false)) return false;
                        return game.hasPlayer(target => {
                            if (target == player || player.getStorage('minihuoshui_used').includes(target)) return false;
                            return (button.link == '0' && !target.hasSkill('fengyin')) || (button.link == '1' && target.countCards('h')) || (button.link == '2' && target.countDiscardableCards(player, 'e'));
                        });
                    },
                    check: () => 1 + Math.random(),
                    backup(links, player) {
                        return {
                            audio: 'huoshui',
                            num: links[0],
                            filterTarget(card, player, target) {
                                if (target == player || player.getStorage('minihuoshui_used').includes(target)) return false;
                                const num = lib.skill.minihuoshui_backup.num;
                                return (num == '0' && !target.hasSkill('fengyin')) || (num == '1' && target.countCards('h')) || (num == '2' && target.countDiscardableCards(player, 'e'));
                            },
                            async content(event, trigger, player) {
                                const target = event.target, num = lib.skill.minihuoshui_backup.num;
                                if (!player.storage.minihuoshui_used) {
                                    player.when({ global: 'phaseAfter' }).then(() => delete player.storage.minihuoshui_used);
                                }
                                player.markAuto('minihuoshui_used', [target]);
                                player.addTempSkill('minihuoshui_' + num);
                                switch (num) {
                                    case '0':
                                        target.addTempSkill('fengyin');
                                        break;
                                    case '1':
                                        if (!target.countGainableCards(player, 'h')) await player.viewHandcards(target);
                                        await player.gainPlayerCard(target, 'h', true, 'visible');
                                        break;
                                    case '2':
                                        await target.discard(target.getDiscardableCards(player, 'e')).set('discarder', player);
                                        break;
                                }
                            },
                            ai: {
                                result: {
                                    target(player, target) {
                                        const num = lib.skill.minihuoshui_backup.num;
                                        if (num == '1') return -target.countCards('h');
                                        if (num == '2') return -target.countDiscardableCards(player, 'e');
                                        return -target.getSkills(null, false, false).filter(skill => !get.is.locked(skill)).length - 1;
                                    },
                                },
                            },
                        }
                    },
                    prompt(links) {
                        return '祸水：' + [
                            ['令一名角色本回合非锁定技失效'],
                            ['观看一名角色的手牌并获得其中一张牌'],
                            ['弃置一名角色装备区所有牌']
                        ][parseInt(links[0])];
                    },
                },
                ai: {
                    order: 9,
                    result: { player: 1 },
                },
                subSkill: {
                    backup: {},
                    '0': { charlotte: true },
                    '1': { charlotte: true },
                    '2': { charlotte: true },
                },
            },
            miniqingcheng: {
                audio: 'qingcheng',
                inherit: 'reqingcheng',
                filter(event, player) {
                    return game.hasPlayer(target => lib.skill.miniqingcheng.filterTarget(null, player, target));
                },
                filterTarget(card, player, target) {
                    return target != player && target.countCards('h') <= player.countCards('h') + player.getDamagedHp();
                },
                ai: {
                    order: 10,
                    result: {
                        player(player, target) {
                            if (target.countCards('h')) return -Math.max(get.value(target.getCards('h'), player) - get.value(player.getCards('h'), player), 0);
                            return 0;
                        },
                    },
                },
            },
            //王允
            minilianji: {
                inherit: 'xinlianji',
                filterTarget(card, player, target) {
                    const cardx = new lib.element.VCard({ name: 'sha', isCard: true });
                    if (!ui.selected.targets.length) return target != player && game.hasPlayer(current => target.canUse(cardx, current, false));
                    return ui.selected.targets[0].canUse(cardx, target, false);
                },
                filterCard: false,
                async content(event, trigger, player) {
                    const targets = event.targets, sha = new lib.element.VCard({ name: 'sha', isCard: true });
                    let card = get.cardPile2(card => get.subtype(card) == 'equip1' && targets[0].hasUseTarget(card));
                    if (card) {
                        if (card.name == 'qinggang' && !lib.inpile.includes('qibaodao')) {
                            card.remove();
                            card = game.createCard('qibaodao', card.suit, card.number);
                        }
                        await targets[0].chooseUseTarget(card, true, 'nopopup', 'nothrow');
                    }
                    else {
                        player.chat('没有装备牌了吗');
                        game.log('但是牌堆里已经没有装备牌了！');
                    }
                    if (targets[0].canUse(sha, targets[1], false)) await targets[0].useCard(sha, targets[1], false);
                    const cards = targets[0].getEquips(1);
                    if (cards.length) {
                        const result = await player.chooseTarget('将' + get.translation(cards) + '交给一名角色', true).set('ai', target => {
                            const { player, cards } = get.event();
                            return (target.hasSkillTag('nogain') ? 0 : get.attitude(player, target)) * Math.max(0.1, target.getUseValue(cards[0]));
                        }).set('cards', cards).forResult();
                        if (result?.bool) await result.targets[0].gain(cards, targets[0], 'give').set('giver', player);
                    }
                },
            },
            minimoucheng: {
                audio: 'moucheng',
                inherit: 'xinmoucheng',
                trigger: { player: 'phaseBegin' },
                filter(event, player) {
                    return game.hasPlayer2(current => {
                        return current.getAllHistory('sourceDamage', function (evt) {
                            if (!evt.card || evt.card.name != 'sha' || evt.getParent().type != 'card') return false;
                            var evt2 = evt.getParent(3);
                            return evt2?.name == 'minilianji' && evt2.player == player;
                        }).length > 0;
                    });
                },
                content() {
                    player.awakenSkill('minimoucheng');
                    player.addSkills('xinjingong');
                },
            },
            //小闪
            minishanshan: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { target: 'useCardToTargeted' },
                filter(event, player) {
                    if (event.player == event.target) return false;
                    if (event.card.name != 'sha' && get.type(event.card) != 'trick') return false;
                    return player.hasShan() || _status.connectMode;
                },
                direct: true,
                async content(event, trigger, player) {
                    const result = await player.chooseToRespond(get.prompt('minishanshan'), (card, player) => {
                        return get.name(card) == 'shan';
                    }).set('prompt2', '打出一张【闪】令' + get.translation(trigger.card) + '无效，然后你摸一张牌').set('ai', card => {
                        const player = get.player();
                        const trigger = get.event().getTrigger();
                        return -get.effect(player, trigger.card, trigger.target, player);
                    }).set('logSkill', 'minishanshan').forResult();
                    if (result?.bool) {
                        trigger.getParent().excluded.add(player);
                        await player.draw();
                    }
                },
                group: 'minishanshan_qingguo',
                subSkill: {
                    qingguo: {
                        audio: 'minishanshan',
                        inherit: 'reqingguo',
                        mod: {
                            aiValue(player, card, num) {
                                if (get.name(card) != 'shan' && get.type(card) != 'equip') return;
                                var cards = player.getCards('hs', card => {
                                    return get.name(card) == 'shan' || get.type(card) == 'equip';
                                });
                                cards.sort((a, b) => (get.name(b) == 'shan' ? 1 : 2) - (get.name(a) == 'shan' ? 1 : 2));
                                var geti = function () {
                                    if (cards.includes(card)) return cards.indexOf(card);
                                    return cards.length;
                                };
                                if (get.name(card) == 'shan') return Math.min(num, [6, 4, 3][Math.min(geti(), 2)]) * 0.6;
                                return Math.max(num, [6.5, 4, 3][Math.min(geti(), 2)]);
                            },
                            aiUseful() {
                                return lib.skill.minishanshan.subSkill.qingguo.mod.aiValue.apply(this, arguments);
                            },
                        },
                        filterCard(card) {
                            return get.type(card) == 'equip';
                        },
                        viewAsFilter(player) {
                            if (!player.countCards('hes', { type: 'equip' })) return false;
                        },
                        prompt: '将一张装备牌当作【闪】使用或打出',
                        ai: {
                            order: 0.001,
                            respondShan: true,
                            skillTagFilter(player) {
                                if (!player.countCards('hes', { type: 'equip' })) return false;
                            },
                            effect: {
                                target(card, player, target, current) {
                                    if (get.tag(card, 'respondShan') && current < 0) return 0.7;
                                },
                            },
                        },
                    },
                },
            },
            minianshi: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'roundStart' },
                filter(event, player) {
                    return Array.from({ length: 5 }).map((_, i) => i + 1).some(num => !player.getStorage('minianshi_effect').includes(num));
                },
                forced: true,
                async content(event, trigger, player) {
                    const num = Array.from({ length: 5 }).map((_, i) => i + 1).filter(num => !player.getStorage('minianshi_effect').includes(num)).randomGet();
                    player.addTempSkill('minianshi_effect', 'roundStart');
                    player.markAuto('minianshi_effect', [num]);
                },
                subSkill: {
                    effect: {
                        intro: {
                            markcount: () => 0,
                            content(storage, player) {
                                const list = [
                                    '一名角色使用或打出【杀】时，其弃置所有手牌',
                                    '本轮结束时，所有未于本轮使用、打出或弃置过【闪】的角色各受到你对其造成的1点雷属性伤害',
                                    '一名角色的装备区的牌数发生变化后，其弃置所有装备牌',
                                    '一名角色使用或打出【桃】或【酒】后，其本回合无法使用或打出手牌',
                                    '一名角色使用单目标锦囊牌指定目标时，你摸一张牌',
                                ];
                                const nums = Array.from({ length: 5 }).map((_, i) => i + 1).filter(num => storage.includes(num));
                                let str = '';
                                for (const i of nums) {
                                    if (!player.isUnderControl(true) && !storage.includes('showed_' + parseFloat(i))) continue;
                                    str += '<li>';
                                    str += list[i - 1];
                                    str += '<br>';
                                }
                                if (str == '') return '这是小闪的秘密哦';
                                return str.slice(0, -4);
                            },
                        },
                        charlotte: true,
                        onremove: true,
                        audio: 'minianshi',
                        trigger: { global: ['loseAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter', 'useCardToPlayer', 'useCard', 'respond', 'roundEnd'] },
                        filter(event, player, name) {
                            const storage = player.getStorage('minianshi_effect');
                            if (name === 'roundEnd') {
                                return storage.includes(2) && game.hasPlayer(target => {
                                    return !target.getRoundHistory('useCard', null).slice().concat(target.getRoundHistory('respond', null)).some(evt => {
                                        return evt.card.name == 'shan';
                                    }) && !target.getRoundHistory('lose', evt => {
                                        return evt.type == 'discard' && evt.cards2 && evt.cards2.some(card => get.name(card, target) == 'shan' || get.name(card, false) == 'shan');
                                    }).length;
                                });
                            }
                            if (event.name == 'useCard' || event.name == 'respond') {
                                if (storage.includes(1) && event.card.name == 'sha' && event.player.countCards('h')) return true;
                                if (storage.includes(4) && (event.card.name == 'tao' || event.card.name == 'jiu')) return true;
                                return false;
                            }
                            if (event.name == 'useCardToPlayer') {
                                if (!storage.includes(5) || get.type2(event.card) != 'trick') return false;
                                const info = get.info(event.card);
                                return info && !info.notarget && (info.toself || info.singleCard || !info.selectTarget || info.selectTarget == 1);
                            }
                            if (!storage.includes(3)) return false;
                            if (event.name == 'equip') {
                                if (!event.player.countCards('e')) return false;
                                const evt = event.getl(event.player);
                                return !evt || evt.cards.length != 1;
                            }
                            return game.hasPlayer(target => {
                                if (!target.countCards('e')) return false;
                                const evt = event.getl(target);
                                return evt?.es?.length;
                            });
                        },
                        logTarget(event, player, name) {
                            if (name === 'roundEnd') {
                                return game.filterPlayer(target => {
                                    return !target.getRoundHistory('useCard', null).slice().concat(target.getRoundHistory('respond', null)).some(evt => {
                                        return evt.card.name == 'shan';
                                    }) && !target.getRoundHistory('lose', evt => {
                                        return evt.type == 'discard' && evt.cards2 && evt.cards2.some(card => get.name(card, target) == 'shan' || get.name(card, false) == 'shan');
                                    }).length;
                                }).sortBySeat();
                            }
                            if (event.name == 'useCard' || event.name == 'respond' || event.name == 'useCardToPlayer' || event.name == 'equip') {
                                return event.player;
                            }
                            return game.filterPlayer(target => {
                                if (!target.countCards('e')) return false;
                                const evt = event.getl(target);
                                return evt?.es?.length;
                            }).sortBySeat();
                        },
                        forced: true,
                        async content(event, trigger, player) {
                            const storage = player.getStorage('minianshi_effect'), targets = event.targets;
                            if (event.triggername === 'roundEnd') {
                                player.markAuto('minianshi_effect', ['showed_2']);
                                for (const target of targets) await target.damage(1, 'thunder');
                            }
                            if (trigger.name == 'useCard' || trigger.name == 'respond') {
                                const target = targets[0];
                                if (trigger.card.name == 'sha' && target.countDiscardableCards(target, 'h')) {
                                    player.markAuto('minianshi_effect', ['showed_1']);
                                    await target.discard(target.getDiscardableCards(target, 'h'));
                                }
                                if (trigger.card.name == 'tao' || trigger.card.name == 'jiu') {
                                    player.markAuto('minianshi_effect', ['showed_4']);
                                    target.addTempSkill('minianshi_ban');
                                }
                            }
                            else if (trigger.name == 'useCardToPlayer') {
                                player.markAuto('minianshi_effect', ['showed_5']);
                                await player.draw();
                            }
                            else {
                                player.markAuto('minianshi_effect', ['showed_3']);
                                for (const target of targets) await target.discard(target.getDiscardableCards(target, 'e'));
                            }
                        },
                    },
                    ban: {
                        mod: {
                            cardEnabled2(card) {
                                if (get.position(card) == 'h') return false;
                            },
                        },
                        charlotte: true,
                        mark: true,
                        intro: { content: '不能使用或打出手牌' },
                    },
                },
            },
            //张鲁
            miniyishe: {
                audio: 'yishe',
                inherit: 'yishe',
                filter: () => true,
                frequent: true,
                onremove(player) {
                    const cards = player.getExpansions('yishe');
                    if (cards.length) player.loseToDiscardpile(cards);
                },
            },
            minibushi: {
                audio: 'bushi',
                inherit: 'bushi',
                async cost(event, trigger, player) {
                    const { player: target } = trigger;
                    const result = await player.chooseButton([
                        '###' + get.prompt('minibushi', target) + '###<div class="text center">选择一张“米”，令' + get.translation(target) + '获得</div>',
                        player.getExpansions('yishe'),
                    ]).set('ai', button => {
                        const { player, target } = get.event();
                        return get.attitude(player, target) * get.value(button.link, target);
                    }).set('target', target).forResult();
                    event.result = {
                        bool: result?.bool,
                        cost_data: result?.links,
                    };
                },
                logTarget: 'player',
                ai: { combo: 'miniyishe' },
            },
            minimidao: {
                audio: 'midao',
                inherit: 'midao',
                async content(event, trigger, player) {
                    const result = await player.chooseButton([
                        get.translation(trigger.player) + '的' + (trigger.judgestr || '') + '判定为' + get.translation(trigger.player.judging[0]) + '，' + get.prompt('minimidao'),
                        player.getExpansions('yishe'), 'hidden',
                    ]).set('filterButton', button => {
                        const player = get.event().player, card = button.link;
                        const mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                        if (mod2 != 'unchanged') return mod2;
                        const mod = game.checkMod(card, player, 'unchanged', 'cardRespondable', player);
                        if (mod != 'unchanged') return mod;
                        return true;
                    }).set('ai', button => {
                        const card = button.link, trigger = get.event().getTrigger();
                        const player = get.event().player, judging = get.event().judging;
                        const result = trigger.judge(card) - trigger.judge(judging) + 0.00001;
                        const attitude = get.attitude(player, trigger.player);
                        return result * attitude;
                    }).set('judging', trigger.player.judging[0]).forResult();
                    if (result?.links?.length) {
                        event.forceDie = true;
                        const { links } = result;
                        await player.respond(links, 'minimidao', 'highlight', 'noOrdering');
                        if (trigger.player.judging[0].clone) {
                            trigger.player.judging[0].clone.classList.remove('thrownhighlight');
                            game.broadcast(card => {
                                if (card.clone) card.clone.classList.remove('thrownhighlight');
                            }, trigger.player.judging[0]);
                            game.addVideo('deletenode', player, get.cardsInfo([trigger.player.judging[0].clone]));
                        }
                        await game.cardsDiscard(trigger.player.judging[0]);
                        trigger.player.judging[0] = links[0];
                        trigger.orderingCards.addArray(links);
                        game.log(trigger.player, '的判定牌改为', links[0]);
                        await game.delay(2);
                        await player.draw();
                    }
                },
                ai: {
                    combo: 'miniyishe',
                    rejudge: true,
                    tag: { rejudge: 0.6 },
                },
            },
            //张宁
            minitianze: {
                audio: 'tianze',
                inherit: 'tianze',
                trigger: { global: 'useCardAfter' },
                filter(event, player) {
                    return player != event.player && event.player.isIn() && get.color(event.card) == 'black' && event.player.hasHistory('lose', evt => {
                        return evt?.hs?.length && evt.getParent() == event;
                    }) && event.player.isPhaseUsing() && player.hasCard(card => {
                        if (_status.connectMode && get.position(card) == 'h') return true;
                        return get.color(card, player) == 'black';
                    }, 'he') && !player.hasSkill('minitianze_block');
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseToDiscard('he', (card, player) => {
                        return get.color(card, player) == 'black';
                    }, get.prompt('minitianze', trigger.player), '弃置一张黑色牌并对其造成1点伤害').set('ai', card => {
                        if (!get.event().goon) return 0;
                        return 8 - get.value(card);
                    }).set('goon', get.damageEffect(trigger.player, player, player) > 0).set('logSkill', ['minitianze', trigger.player]).forResult();
                },
                popup: false,
                async content(event, trigger, player) {
                    player.addTempSkill('minitianze_block');
                    if (get.mode() != 'identity' || player.identity != 'nei') player.addExpose(0.2);
                    await trigger.player.damage();
                    await game.delayx();
                },
                group: 'minitianze_draw',
            },
            minidifa: {
                audio: 'difa',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.hasCard(card => get.info('minidifa').filterCard(card, player), 'h');
                },
                filterCard(card, player) {
                    return get.color(card) == 'red' && player.canRecast(card);
                },
                check(card) {
                    return 7 - get.value(card);
                },
                position: 'h',
                usable: 1,
                discard: false,
                lose: false,
                delay: 0,
                async content(event, trigger, player) {
                    await player.recast(event.cards);
                    const list = lib.inpile.filter(name => get.type2(name) == 'trick');
                    if (!list.length) return;
                    const result = await player.chooseButton(['地法：选择获得一张锦囊牌', [list, 'vcard']], true).set('ai', button => {
                        if (!get.cardPile2(card => card.name == button.link[2])) return 0;
                        return get.event().player.getUseValue({ name: button.link[2] });
                    }).forResult();
                    if (result?.links?.length) {
                        const { links } = result;
                        const card = get.cardPile2(card => card.name == links[0][2]);
                        if (card) await player.gain(card, 'gain2');
                        else {
                            player.chat('无牌可得？！');
                            game.log('但是牌堆中已经没有', '#y【' + get.translation(links[0][2]) + '】', '了！');
                        }
                    }
                },
                ai: {
                    order: 9,
                    result: {
                        player(player) {
                            return lib.inpile.some(name => get.type2(name) == 'trick' && player.getUseValue({ name: name }) > 0);
                        },
                    },
                },
            },
            minicixiao: {
                audio: 'cixiao',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return game.hasPlayer(target => {
                        return target != player && !target.hasSkill('minipanshi', null, false, false);
                    });
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt(event.skill), (card, player, target) => {
                        return target != player && !target.hasSkill('minipanshi', null, false, false);
                    }).set('ai', target => {
                        var player = _status.event.player;
                        var att = -get.attitude(player, target);
                        return att * target.countCards('h');
                    }).set('prompt2', '令一名没有“义子”标记的其他角色获得“义子”标记').forResult();
                },
                async content(event, trigger, player) {
                    const source = event.targets[0], card = new lib.element.VCard({ name: 'sha' });
                    await source.addSkills('minipanshi');
                    if (source.hasUseTarget(card, true) && player.countCards('h')) {
                        const result = await player.chooseCardTarget({
                            prompt: '是否交给' + get.translation(source) + '一张手牌并令其视为对其攻击范围内你选择的另一名角色使用一张【杀】？',
                            filterCard: true,
                            position: 'h',
                            filterTarget(cardx, player, target) {
                                const source = get.event().source, card = new lib.element.VCard({ name: 'sha' });
                                return source.canUse(card, target, true);
                            },
                            ai1(card) {
                                return 7.5 - get.value(card);
                            },
                            ai2(target) {
                                const player = get.event().player, source = get.event().source, card = new lib.element.VCard({ name: 'sha' });
                                return get.effect(target, card, source, player);
                            },
                        }).set('source', source).forResult();
                        if (result?.cards?.length && result.targets?.length) {
                            const { cards, targets } = result;
                            const target = targets[0];
                            await player.give(cards, source);
                            await source.useCard(card, target, false);
                        }
                    }
                },
                derivation: 'minipanshi',
            },
            minipanshi: {
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return player.countCards('h') > 0 && game.hasPlayer(current => {
                        return current != player && current.hasSkill('minicixiao');
                    });
                },
                forced: true,
                content() {
                    'step 0'
                    var targets = game.filterPlayer(function (current) {
                        return current != player && current.hasSkill('minicixiao');
                    });
                    if (targets.length == 1) {
                        event.target = targets[0];
                        player.chooseCard('h', true, '叛弑：将一张手牌交给' + get.translation(targets));
                    }
                    else player.chooseCardTarget({
                        prompt: '叛弑：将一张手牌交给' + get.translation(targets) + '中的一名角色',
                        filterCard: true,
                        position: 'h',
                        targets: targets,
                        forced: true,
                        filterTarget(card, player, target) {
                            return _status.event.targets.includes(target);
                        },
                    });
                    'step 1'
                    if (result.bool) {
                        if (!target) target = result.targets[0];
                        player.line(target);
                        player.give(result.cards, target);
                    }
                },
                mark: true,
                marktext: '子',
                intro: {
                    name: '义子',
                    content: '我是儿子',
                },
                group: 'minipanshi_damage',
                subSkill: {
                    damage: {
                        trigger: { source: 'damageBegin1' },
                        filter(event, player) {
                            return player.isPhaseUsing() && event.card && event.card.name == 'sha' && event.player.hasSkill('minicixiao');
                        },
                        forced: true,
                        logTarget: 'player',
                        content() {
                            trigger.num++;
                            player.removeSkills('minipanshi');
                            var evt = event.getParent('phaseUse');
                            if (evt?.player == player) evt.skipped = true;
                        },
                    },
                },
            },
            minidushi: {
                audio: 'dushi',
                global: 'minidushi_buff',
                trigger: { player: 'dyingAfter' },
                forced: true,
                forceDie: true,
                async content(event, trigger, player) {
                    if (player.isAlive()) await player.removeSkills('minidushi');
                    if (game.hasPlayer(target => target != player && !target.hasSkill('minidushi', null, false, false))) {
                        const result = await player.chooseTarget('请选择【毒逝】的目标', (card, player, target) => {
                            return target != player && !target.hasSkill('minidushi', null, false, false);
                        }, '令一名其他角色获得【毒逝】', true).set('ai', target => {
                            return -get.attitude(_status.event.player, target);
                        }).set('forceDie', true).forResult();
                        if (result?.targets?.length) {
                            const target = result.targets[0];
                            player.line(target);
                            target.markSkill('minidushi');
                            await target.addSkills('minidushi');
                        }
                    }
                },
                intro: { content: '您已经获得弘农王的诅咒' },
                subSkill: {
                    buff: {
                        mod: {
                            cardSavable(card, player, target) {
                                if (card.name == 'tao' && target != player && target.hasSkill('minidushi')) return false;
                            },
                        },
                    },
                },
            },
            miniheqia: {
                audio: 'heqia',
                enable: 'phaseUse',
                filter(event, player) {
                    return game.hasPlayer(current => current.countCards(current == player ? 'he' : 'h') > 0);
                },
                filterCard: true,
                position: 'he',
                selectCard() {
                    if (ui.selected.targets.length && !ui.selected.targets[0].countCards('h')) return [1, Infinity];
                    return [0, Infinity];
                },
                filterTarget(card, player, target) {
                    if (player == target) return false;
                    if (!ui.selected.cards.length) return target.countCards('h') > 0;
                    return true;
                },
                check(card) {
                    const player = get.event().player;
                    if (!!game.hasPlayer(function (current) {
                        return current != player && get.attitude(player, current) <= 0 && current.countCards('h') > 0;
                    }) || ui.selected.cards.length) return 0 - get.value(card);
                    return 1 / Math.max(1, get.value(card));
                },
                usable: 1,
                complexCard: true,
                discard: false,
                lose: false,
                delay: 0,
                content() {
                    'step 0'
                    player.addTempSkill('miniheqia_add');
                    'step 1'
                    if (cards.length) {
                        player.give(cards, target);
                        event.source = target;
                        event.num = cards.length;
                        event.goto(4);
                    }
                    'step 2'
                    var he = target.getCards('he');
                    if (he.length > 0) {
                        if (he.length > 1) target.chooseCard('he', true, [1, Infinity], '选择交给' + get.translation(player) + '任意张牌').set('ai', (card) => -get.value(card));
                        else event._result = { bool: true, cards: he };
                    }
                    else event.finish();
                    'step 3'
                    if (result.bool) {
                        event.source = player;
                        target.give(result.cards, player);
                        event.num = result.cards.length;
                    }
                    else event.finish();
                    'step 4'
                    if (source?.isIn() && source.countCards('h') > 0) {
                        var list = [];
                        for (var name of lib.inpile) {
                            if (get.type(name) != 'basic') continue;
                            if (source.hasUseTarget({ name: name }, false)) list.push(['基本', '', name]);
                            if (name == 'sha') {
                                for (var nature of lib.inpile_nature) {
                                    if (source.hasUseTarget({ name: name, nature: nature }, false)) list.push(['基本', '', name, nature]);
                                }
                            }
                        }
                        if (list.length) {
                            source.chooseButton(['是否将一张手牌当做一种基本牌使用？', [list, 'vcard']]).set('ai', (button) => _status.event.player.getUseValue({ name: button.link[2], nature: button.link[3] }, false));
                        }
                        else event.finish();
                    }
                    else event.finish();
                    'step 5'
                    if (result.bool) {
                        var card = { name: result.links[0][2], nature: result.links[0][3] };
                        game.broadcastAll(card => {
                            lib.skill.heqia_backup.viewAs = card;
                        }, card);
                        var next = source.chooseToUse();
                        next.set('openskilldialog', '将一张手牌当做' + get.translation(card) + '使用');
                        next.set('norestore', true);
                        next.set('addCount', false);
                        next.set('_backupevent', 'heqia_backup');
                        next.set('custom', {
                            add: {},
                            replace: { window() { } }
                        });
                        next.backup('heqia_backup');
                    }
                },
                ai: {
                    order: 9,
                    result: {
                        target(player, target) {
                            return (get.attitude(player, target) - 0.1) * (ui.selected.cards.length ? 1 : -1);
                        },
                    },
                },
                subSkill: {
                    add: {
                        charlotte: true,
                        trigger: { global: 'useCard2' },
                        filter(event, player) {
                            var evt = event.getParent(2);
                            if (evt.name != 'miniheqia' || evt.player != player || !event.targets || evt.num <= event.targets.length) return false;
                            var card = event.card, info = get.info(card);
                            if (info.allowMultiple == false) return false;
                            if (event.targets && !info.multitarget) {
                                if (game.hasPlayer(function (current) {
                                    return !event.targets.includes(current) && lib.filter.targetEnabled2(card, event.player, current);
                                })) return true;
                            }
                            return false;
                        },
                        direct: true,
                        content() {
                            'step 0'
                            var num = trigger.getParent(2).num - trigger.targets.length;
                            var prompt2 = '是否为' + get.translation(trigger.card) + '增加至多' + get.cnNumber(num) + '个目标？';
                            trigger.player.chooseTarget(prompt2, [1, num], function (card, player, target) {
                                var player = _status.event.player;
                                return !_status.event.targets.includes(target) && lib.filter.targetEnabled2(_status.event.card, player, target);
                            }).set('ai', function (target) {
                                var trigger = _status.event.getTrigger();
                                var player = _status.event.player;
                                return get.effect(target, trigger.card, player, player);
                            }).set('card', trigger.card).set('targets', trigger.targets);
                            'step 1'
                            if (result.bool) {
                                trigger.player.line(result.targets);
                                game.log(result.targets, '也成为了', trigger.card, '的目标')
                                trigger.targets.addArray(result.targets);
                            }
                        },
                    },
                },
            },
            //李采薇
            miniqibie: {
                audio: 'qibie',
                inherit: 'qibie',
                filter(event, player) {
                    return player.hasCard(card => _status.connectMode || lib.filter.cardDiscardable(card, player), 'h');
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseToDiscard(get.prompt('miniqibie'), 'h', [1, Infinity]).set('ai', lib.skill.zhiheng.check).set('logSkill', 'miniqibie').forResult();
                },
                popup: false,
                async content(event, trigger, player) {
                    await player.recover();
                    await player.draw(event.cards.length + 1);
                },
            },
            //黄祖
            minixiaojuan: {
                audio: 'dcxiaojuan',
                inherit: 'dcxiaojuan',
                filter(event, player) {
                    return event.targets.length == 1 && player != event.target && event.target.countCards('h');
                },
                check(event, player) {
                    var target = event.target;
                    if (get.attitude(player, target) >= 0) return false;
                    if (get.color(event.card) == 'none') return true;
                    return target.countCards('h');
                },
                content() {
                    'step 0'
                    var target = trigger.target;
                    event.target = target;
                    var num = Math.ceil(target.countCards('h') / 2);
                    if (num > 0) player.discardPlayerCard(target, 'h', num, true);
                    else event.finish();
                    'step 1'
                    var suit = get.suit(trigger.card);
                    if (result.bool && lib.suit.includes(suit) && player.countCards('h') > 1) {
                        var bool = false;
                        for (var i of result.cards) {
                            if (get.suit(i, target) == suit) {
                                bool = true;
                                break;
                            }
                        }
                        if (!bool) event.finish();
                    }
                    else event.finish();
                    'step 2'
                    if (player.countCards('h') > 0) player.chooseToDiscard('h', 1, true);
                },
            },
            //white tigger
            minizhidao: {
                audio: 'zhidao',
                inherit: 'zhidao',
                mod: {
                    aiOrder(player, card, num) {
                        if (num > 0 && !player.hasSkill('minizhidao_buff') && !get.tag(card, 'damage') && (!lib.filter.targetEnabled(card, player, player) || get.effect(player, card, player) <= 0)) return num + 10;
                    },
                },
                filter(event, player) {
                    if (event._notrigger.includes(event.player)) return false;
                    return player.isPhaseUsing() && event.player.isIn() && event.player.countCards('hej') > 0 && event.player != player && !player.hasSkill('minizhidao_buff');
                },
                logTarget: 'player',
                async content(event, trigger, player) {
                    const target = trigger.player;
                    let num = 0;
                    if (target.countCards('h')) num++;
                    if (target.countCards('e')) num++;
                    if (target.countCards('j')) num++;
                    if (num) await player.gainPlayerCard(target, num, 'hej', true).set('filterButton', button => {
                        for (var i = 0; i < ui.selected.buttons.length; i++) {
                            if (get.position(button.link) == get.position(ui.selected.buttons[i].link)) return false;
                        }
                        return true;
                    });
                    player.addTempSkill('minizhidao_buff');
                    player.markAuto('minizhidao_buff', [target]);
                },
                subSkill: {
                    buff: {
                        charlotte: true,
                        onremove: true,
                        intro: {
                            content: '本回合不能对$使用牌',
                        },
                        mod: {
                            playerEnabled(card, player, target) {
                                if (player.getStorage('minizhidao_buff').includes(target)) return false;
                            },
                        }
                    }
                }
            },
            minybhijili: {
                audio: 'jili',
                inherit: 'jili',
                async content(event, trigger, player) {
                    trigger.getParent().targets.add(player);
                    trigger.player.line(player, 'green');
                    player.when({ global: 'useCardAfter' }).filter(evt => evt == trigger.getParent() && game.hasPlayer(current => current.hasHistory('damage', evt => evt.card && evt.card == trigger.card))).then(() => {
                        player.draw();
                    })
                },
            },
            //界坤姐
            minirejiuchi: {
                audio: 'oljiuchi',
                inherit: 'oljiuchi',
                filterCard(card) {
                    return get.color(card) == 'black';
                },
                position: 'hes',
                viewAsFilter(player) {
                    return player.hasCard(card => get.color(card) == 'black', 'hes');
                },
                prompt() {
                    if (get.event().name == 'chooseToUse') return '将一张黑色牌当酒使用';
                    return get.prompt('minirejiuchi');
                },
                prompt2: () => '摸一张牌并令【崩坏】于本回合失效',
                filter(event, player) {
                    if (event.name == 'chooseToUse') return player.hasCard(card => get.color(card) == 'black', 'hes')
                    return event.card && event.card.name == 'sha' && event.getParent(2).jiu == true;
                },
                forced: false,
                content() {
                    player.draw();
                    player.addTempSkill('minirejiuchi_air');
                },
                subSkill: {
                    air: {
                        charlotte: true,
                    },
                },
            },
            miniroulin: {
                audio: 'roulin',
                inherit: 'roulin',
                filter(event, player) {
                    if (event.card.name != 'sha') return false;
                    if (player.hasSkill('minirebenghuai_all', null, null, false)) return true;
                    if (player == event.player) {
                        return event.target.hasSex('female');
                    }
                    return event.player.hasSex('female');
                },
                async content(event, trigger, player) {
                    const id = (player == trigger.player ? trigger.target : player).playerid;
                    const map = trigger.getParent().customArgs;
                    if (!map[id]) map[id] = {};
                    if (typeof map[id].shanRequired == 'number') {
                        map[id].shanRequired++;
                    } else {
                        map[id].shanRequired = 2;
                    }
                    player.when({ global: 'useCardAfter' }).filter(evt => evt == trigger.getParent() && !game.hasPlayer(current => current.hasHistory('damage', evt => evt.card && evt.card == trigger.card))).then(() => {
                        let card = get.cardPile2(card => get.color(card) == 'black')
                        if (card) player.gain(card, 'draw');
                    })
                },
                ai: {
                    halfneg: true,
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (tag === 'directHit_ai') return;
                        if (arg.card.name != 'sha' || (!arg.target.hasSex('female') && !(player.hasSkill('minirebenghuai_all', null, null, false))) || arg.target.countCards('h', 'shan') > 1) return false;
                    },
                },
            },
            minirebenghuai: {
                audio: 'benghuai',
                inherit: 'benghuai',
                filter(event, player) {
                    return !player.isMinHp() && !player.hasSkill('minirejiuchi_air') && !player.hasSkill('rejiuchi_air') && !player.hasSkill('oljiuchi_air');
                },
                content() {
                    var next = game.createEvent('minibenghuai_benghuai');
                    next.player = player;
                    next.setContent(lib.skill.benghuai.content);
                    player.draw();
                },
                group: 'minirebenghuai_buff',
                subSkill: {
                    buff: {
                        trigger: {
                            player: 'phaseBegin',
                        },
                        filter(event, player) {
                            return player.isMinHp();
                        },
                        forced: true,
                        async content(event, trigger, player) {
                            player.addTempSkill('minirebenghuai_all');
                        },
                    },
                    all: {
                        charlotte: true,
                        mark: true,
                        intro: {
                            content: '本回合〖肉林〗对所有角色生效',
                        }
                    }
                }
            },
            //郭汜
            minitanbei: {
                audio: 'xinfu_tanbei',
                inherit: 'xinfu_tanbei',
                async content(event, trigger, player) {
                    const target = event.targets[0];
                    let result;
                    const goon = target.countCards('hej');
                    if (goon) result = await target.chooseControl().set('choiceList', ['令' + get.translation(player) + '获得你区域内的一张牌，然后其本回合内不能再对你使用牌。', '令' + get.translation(player) + '本回合内对你使用牌没有次数与距离限制。']).set('ai', () => {
                        var list = [0, 1];
                        return list.randomGet();
                    }).forResult();
                    else result = { index: 1 };
                    player.addTempSkill('tanbei_effect3');
                    if (result.index == 0) {
                        await player.gainPlayerCard(target, 'hej', true);
                        target.addTempSkill('tanbei_effect2');
                    } else {
                        target.addTempSkill('tanbei_effect1');
                    }
                },
            },
            minisidao: {
                audio: 'xinfu_sidao',
                trigger: {
                    player: 'useCardAfter',
                },
                filter(event, player) {
                    if (player.hasSkill('minisidao_sidaoy')) return false;
                    if (!event.targets || !event.targets.length || !event.isPhaseUsing(player)) return false;
                    const history = player.getHistory('useCard');
                    const index = history.indexOf(event) - 1;
                    if (index < 0) return false;
                    const evt = history[index];
                    if (!evt || !evt.targets || !evt.targets.length || !evt.isPhaseUsing(player)) return false;
                    return event.targets.some(current => evt.targets.includes(current) && current != player && current.countGainableCards(player, 'hej'));
                },
                async cost(event, trigger, player) {
                    const targets = player.getLastUsed(1).targets;
                    event.result = await player.chooseTarget(get.prompt2(event.name.slice(0, -5)), (card, player, target) => {
                        return get.event().targets.includes(target);
                    }).set('targets', game.filterPlayer(current => {
                        return current != player && targets.includes(current) && trigger.targets.includes(current) && current.countGainableCards(player, 'hej') > 0;
                    })).set('ai', target => {
                        const player = get.player();
                        let att = get.attitude(player, target);
                        if (att < 0) att = -Math.sqrt(-att);
                        else att = Math.sqrt(att);
                        return att * lib.card.shunshou.ai.result.target(player, target);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    player.addTempSkill('minisidao_sidaoy');
                    await player.gainPlayerCard(event.targets[0], 'hej', true);
                },
                subSkill: {
                    sidaoy: { charlotte: true },
                }
            },
            //老八
            minixingluan: {
                audio: 'xinfu_xingluan',
                trigger: { player: 'useCardAfter' },
                filter(event, player) {
                    return player.isPhaseUsing() && event.targets && event.targets.length == 1;
                },
                usable: 1,
                async content(event, trigger, player) {
                    const cards = [];
                    while (cards.length < 2) {
                        const card = get.cardPile2(card => {
                            return !cards.includes(card) && get.number(card) == 6;
                        });
                        if (!card) break;
                        cards.push(card);
                    }
                    if (!cards.length) await player.draw(6);
                    else {
                        const links = cards.length > 1 ? (await player.chooseButton(['兴乱：选择获得其中一张', cards], true).set('ai', button => {
                            return get.value(button.link, get.player());
                        }).forResult()).links : cards;
                        if (links?.length) await player.gain(links, 'gain2');
                    }
                },
            },
            //皇甫嵩
            minijuxia: {
                trigger: { player: 'compareFixing', target: 'compareFixing' },
                filter(event, player) {
                    if (event['num' + (event.player == player ? 1 : 2)] != 1) return false;
                    return !event.iwhile || event.player != player;
                },
                forced: true,
                content() {
                    trigger.forceWinner = player;
                },
                ai: {
                    forceWin: true,
                    skillTagFilter(player, _, arg) {
                        return arg?.card && get.number(arg.card, false) == 1;
                    },
                },
            },
            miniranshang: {
                audio: 'ranshang',
                inherit: 'ranshang',
                group: 'miniranshang_effect',
                subSkill: {
                    effect: {
                        audio: 'ranshang',
                        inherit: 'ranshang2',
                        content() {
                            const num = player.countMark('ranshang');
                            player.loseHp(num);
                            if (num >= 2) {
                                player.loseMaxHp(2);
                                player.draw(num);
                            }
                        },
                    },
                },
            },
            // 伏完
            minimoukui: {
                audio: 'dcmoukui',
                trigger: {
                    player: 'useCardToPlayered',
                    target: 'useCardToTargeted',
                },
                filter(event, player) {
                    return event.card?.name == 'sha';
                },
                async cost(event, trigger, player) {
                    const target = get.info(event.name.slice(0, -5)).logTarget(trigger, player);
                    const result = await player.chooseButton([
                        get.prompt(event.name.slice(0, -5)),
                        [
                            [
                                ['draw', '摸一张牌'],
                                ['discard', `弃置${get.translation(target)}的一张牌`],
                            ],
                            'textbutton',
                        ],
                    ]).set('filterButton', button => {
                        const { link } = button, { player, target } = get.event();
                        if (link == ' discard' && !target.countDiscardableCards(player, 'he')) return false;
                        return true;
                    }).set('ai', button => {
                        const { link } = button, { player, target } = get.event();
                        if (link == 'discard' && get.effect(target, { name: 'guohe_copy2' }, player) <= 0) return 0;
                        return 1;
                    }).set('selectButton', [1, 2]).set('target', target).forResult();
                    event.result = {
                        bool: result?.bool,
                        cost_data: result?.links,
                    }
                },
                logTarget: (event, player) => player == event.player ? event.target : event.player,
                async content(event, trigger, player) {
                    const target = get.info(event.name).logTarget(trigger, player);
                    const { cost_data: choices } = event;
                    if (choices.includes('draw')) {
                        game.log(player, '选择了', '#y选项一');
                        await player.draw();
                    }
                    if (choices.includes('discard')) {
                        game.log(player, '选择了', '#y选项二');
                        if (target.countDiscardableCards(player, 'he')) await player.discardPlayerCard(target, true, 'he').set('boolline', true);
                    }
                    if (choices.length >= 2) {
                        player.addTempSkill(event.name + '_conseq');
                        player.markAuto(event.name + '_conseq', [trigger.card]);
                    }
                    else {
                        player.addTempSkill(event.name + '_effect');
                        player.markAuto(event.name + '_effect', [[target, choices[0], trigger.getParent()]]);
                    }
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        trigger: {
                            global: 'useCardAfter',
                        },
                        filter(event, player) {
                            if (!game.hasPlayer(current => current.hasHistory('damage', evt => evt.card == event.card))) return false;
                            return player.getStorage('minimoukui_effect').some(list => list[2] === event);
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const storage = player.getStorage(event.name);
                            for (const [target, choice, evt] of storage) {
                                if (evt !== trigger) continue;
                                if (choice == 'draw') await player.draw();
                                else if (target.isIn() && target.countDiscardableCards(player, 'he')) await player.discardPlayerCard(target, true, 'he').set('boolline', true);
                            }
                            player.removeSkill(event.name);
                        },
                    },
                    conseq: {
                        charlotte: true,
                        onremove: true,
                        trigger: {
                            global: ['shaMiss', 'useCardToExcluded', 'eventNeutralized', 'shaCancelled'],
                        },
                        forced: true,
                        popup: false,
                        filter(event, player, name) {
                            const { card, target } = event;
                            if (!card) return false;
                            const cards = player.getStorage('minimoukui_conseq');
                            if (!cards.includes(card)) return false;
                            return player.countDiscardableCards(target, 'he');
                        },
                        async content(event, trigger, player) {
                            await game.delayx();
                            await trigger.target.discardPlayerCard(player, true, 'he').set('boolline', true);
                        },
                    }
                }
            },
            // 董翓
            minijiaoxia: {
                audio: 'dcjiaoxia',
                mod: {
                    cardUsableTarget(card, player, target) {
                        if (!player.isPhaseUsing()) return;
                        if (card.name == 'sha' && !player.getStorage('dcjiaoxia_mark').includes(target)) return true;
                    },
                    targetInRange(card, player, target) {
                        if (!player.isPhaseUsing()) return;
                        if (card.name == 'sha' && !player.getStorage('dcjiaoxia_mark').includes(target)) return true;
                    },
                },
                locked: false,
                enable: 'phaseUse',
                viewAs: {
                    name: 'sha',
                },
                viewAsFilter(player) {
                    return player.countCards('hs');
                },
                filterCard: true,
                position: 'hs',
                prompt: '将一张手牌当做【杀】使用',
                check(card) {
                    if (get.player().hasUseTarget(card)) return 1;
                    return 6 - get.value(card);
                },
                precontent() {
                    player.addTempSkill('minijiaoxia_effect');
                },
                group: 'dcjiaoxia_load',
                subSkill: {
                    effect: {
                        charlotte: true,
                        trigger: {
                            player: 'useCardAfter',
                        },
                        filter(event, player) {
                            return event.skill == 'minijiaoxia' && event.cards?.length == 1 && player.hasUseTarget(get.copy(event.cards[0])) && player.getHistory('sourceDamage', evt => evt.card == event.card).length && player.hasUseTarget(event.cards[0]);
                        },
                        async cost(event, trigger, player) {
                            event.result = await player.chooseUseTarget(trigger.cards[0], get.prompt(event.name.slice(0, -5)), false, false).set('prompt2', `使用${get.translation(trigger.cards[0])}`).set('logSkill', event.name.slice(0, -5)).forResult();
                        },
                        popup: false,
                        content() { },
                    }
                },
            },
            minihumei: {
                audio: 'dchumei',
                inherit: 'dchumei',
                usable(skill, player) {
                    return get.event()?.dchumei_num;
                },
                filter(event, player) {
                    if (typeof event.dchumei_num != 'number') return false;
                    return game.hasPlayer(target => lib.skill.minihumei.filterTarget(null, player, target));
                },
                filterTarget(card, player, target) {
                    const list = player.getStorage('minihumei_used');
                    if (!list.includes('draw')) return true;
                    if (!list.includes('give') && target.countCards('he')) return true;
                    if (!list.includes('recover') && target.isDamaged()) return true;
                    return false;
                },
                async content(event, trigger, player) {
                    const { target } = event, str = get.translation(target);
                    const result = await player.chooseButton([
                        '狐魅：请选择一项',
                        [
                            [
                                ['draw', '令' + str + '摸一张牌'],
                                ['give', '令' + str + '交给你一张牌'],
                                ['recover', '令' + str + '回复1点体力'],
                            ].filter(list => {
                                if (player.getStorage('minihumei_used').includes(list[0])) return false;
                                if (list[0] == 'give' && !target.countCards('he')) return false;
                                if (list[0] == 'recover' && target.isHealthy()) return false;
                                return true;
                            }),
                            'textbutton',
                        ],
                    ], true).set('filterButton', button => {
                        const { player, target } = get.event();
                        if (player.getStorage('minihumei_used').includes(button.link)) return false;
                        if (button.link == 'give' && !target.countCards('he')) return false;
                        if (button.link == 'recover' && target.isHealthy()) return false;
                        return true;
                    }).set('ai', button => {
                        const { player, target } = get.event();
                        switch (button.link) {
                            case 'draw': {
                                return get.effect(target, { name: 'draw' }, player, player);
                            }
                            case 'give': {
                                return get.effect(target, { name: 'shunshou_copy2' }, player, player);
                            }
                            case 'recover': {
                                return get.recoverEffect(target, player, player);
                            }
                        }
                        return 0;
                    }).set('target', target).forResult();
                    if (result?.links?.length) {
                        const { links } = result;
                        player.addTempSkill(event.name + '_used');
                        player.markAuto(event.name + '_used', links);
                        if (links[0] == 'draw') await target.draw();
                        else if (links[0] == 'give') await target.chooseToGive(player, 'he', true);
                        else await target.recover();
                    }
                },
                ai: {
                    order: 1,
                    result: {
                        target(player, target) {
                            const list = player.getStorage('minihumei_used');
                            if (!list.includes('draw')) return 1;
                            if (!list.includes('give')) return -1;
                            if (!list.includes('recover')) return 1;
                        },
                    },
                },
                subSkill: {
                    used: {
                        charlotte: true,
                        onremove: true,
                    },
                },
            },
            //管宁
            minidunshi: {
                hiddenCard(player, name) {
                    return player.storage.minidunshi?.includes(name) && !player.getStat('skill').minidunshi;
                },
                init(player, skill) {
                    player.storage[skill] = player.storage[skill] || ['sha', 'shan', 'tao', 'jiu'];
                    player.markSkill(skill);
                },
                audio: 'dunshi',
                enable: ['chooseToUse', 'chooseToRespond'],
                usable: 1,
                mark: true,
                intro: {
                    content(storage, player) {
                        if (!storage?.length) return '已无可用牌';
                        return '剩余可用牌：' + get.translation(storage);
                    },
                },
                filter(event, player) {
                    if (event.type == 'wuxie') return false;
                    var storage = player.storage.minidunshi;
                    return storage?.some(i => event.filterCard({ name: i, isCard: true }, player, event));
                },
                chooseButton: {
                    dialog(event, player) {
                        var list = [], storage = player.storage.minidunshi;
                        for (var i of storage) list.push(['基本', '', i]);
                        return ui.create.dialog('遁世', [list, 'vcard'], 'hidden');
                    },
                    filter(button, player) {
                        var evt = _status.event.getParent();
                        return evt.filterCard({ name: button.link[2], isCard: true }, player, evt);
                    },
                    check(button) {
                        var card = { name: button.link[2] }, player = _status.event.player;
                        if (_status.event.getParent().type != 'phase') return 1;
                        if (card.name == 'jiu') return 0;
                        if (card.name == 'sha' && player.hasSkill('jiu')) return 0;
                        return player.getUseValue(card, null, true);
                    },
                    backup(links, player) {
                        return {
                            audio: 'dunshi',
                            filterCard: () => false,
                            popname: true,
                            viewAs: {
                                name: links[0][2],
                                isCard: true,
                            },
                            selectCard: -1,
                            precontent() {
                                player.addTempSkill('minidunshi_damage');
                                player.storage.minidunshi_damage = event.result.card.name;
                            },
                        }
                    },
                    prompt(links, player) {
                        return '###遁世###<div class="text center">请选择【' + get.translation(links[0][2]) + '】的目标</div>';
                    },
                },
                ai: {
                    respondSha: true,
                    respondShan: true,
                    skillTagFilter(player, tag, arg) {
                        var storage = player.storage.minidunshi;
                        if (!storage?.length) return false;
                        if (player.getStat('skill').minidunshi) return false;
                        switch (tag) {
                            case 'respondSha': return (_status.event.type != 'phase' || (player == game.me || player.isUnderControl() || player.isOnline())) && storage.includes('sha');
                            case 'respondShan': return storage.includes('shan');
                            case 'save':
                                if (arg == player && storage.includes('jiu')) return true;
                                return storage.includes('tao');
                        }
                    },
                    order: 2,
                    result: {
                        player(player) {
                            if (_status.event.type == 'dying') return get.attitude(player, _status.event.dying);
                            return 1;
                        },
                    },
                },
                initList() {
                    var list, skills = [], banned = [], bannedInfo = ['游戏开始时'];
                    list = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                    for (var i of list) {
                        for (var j of lib.character[i][3]) {
                            var skill = lib.skill[j];
                            if (!skill || skill.zhuSkill || banned.includes(j)) continue;
                            if (skill.ai && (skill.ai.combo || skill.ai.notemp || skill.ai.neg)) continue;
                            const infox = get.plainText(get.skillInfoTranslation(j));
                            if (bannedInfo.some(item => infox.includes(item))) continue;
                            const info = get.plainText(get.translation(j));
                            if ('仁/义/礼/智/信'.split('/').some(item => info.includes(item))) skills.add(j);
                        }
                    }
                    _status.minidunshi_list = skills;
                },
                derivation: 'Mbaby_characterlist_faq',
                subSkill: {
                    backup: { audio: 'dunshi' },
                    damage: {
                        charlotte: true,
                        onremove: true,
                        audio: 'dunshi',
                        trigger: { global: 'damageBegin2' },
                        filter(event, player) {
                            return event.source == _status.currentPhase;
                        },
                        forced: true,
                        logTarget: 'source',
                        async content(event, trigger, player) {
                            const cardname = player.storage[event.name], { source: target } = trigger;
                            player.removeSkill(event.name);
                            const list = [
                                `防止即将对${get.translation(trigger.player)}造成的伤害，并令${get.translation(target)}获得一个技能名中包含“仁/义/礼/智/信”的技能`,
                                `从〖遁世〗中删除【${get.translation(cardname)}】`,
                                '减1点体力上限，然后摸剩余选项数的牌',
                            ]
                            const next = player.chooseButton([
                                '遁世：请选择两项',
                                [list.map((item, i) => {
                                    return [i, item];
                                }), 'textbutton']
                            ]);
                            next.set('forced', true);
                            next.set('selectButton', 2);
                            next.set('ai', button => {
                                const player = get.player();
                                switch (button.link) {
                                    case 0:
                                        if (get.attitude(player, _status.currentPhase) > 0) return 3;
                                        return 0;
                                    case 1:
                                        return 1;
                                    case 2:
                                        let num = player.storage.minidunshi;
                                        for (const i of ui.selected.buttons) {
                                            if (i.link == 1) num++;
                                        }
                                        if (num > 0 && player.isDamaged()) return 2;
                                        return 0;
                                }
                            });
                            const { links } = await next.forResult();
                            if (!links?.length) return;
                            links.sort();
                            for (const i of links) {
                                game.log(player, '选择了', '#g【遁世】', '的', '#y选项' + get.cnNumber(i + 1, true));
                            }
                            const storage = player.storage.minidunshi;
                            if (links.includes(0)) {
                                trigger.cancel();
                                if (!_status.minidunshi_list) lib.skill.minidunshi.initList();
                                const list = _status.minidunshi_list.filter(i => !target.hasSkill(i, null, null, false)).randomGets(3);
                                if (list.length) {
                                    event.videoId = lib.status.videoId++;
                                    var func = function (skills, id, target) {
                                        var dialog = ui.create.dialog('forcebutton');
                                        dialog.videoId = id;
                                        dialog.add('令' + get.translation(target) + '获得一个技能');
                                        for (var i = 0; i < skills.length; i++) {
                                            dialog.add('<div class="popup pointerdiv" style="width:80%;display:inline-block"><div class="skill">【' + get.translation(skills[i]) + '】</div><div>' + lib.translate[skills[i] + '_info'] + '</div></div>');
                                        }
                                        dialog.addText(' <br> ');
                                    }
                                    if (player.isOnline()) player.send(func, list, event.videoId, target);
                                    else if (player == game.me) func(list, event.videoId, target);
                                    const { control } = await player.chooseControl(list).set('ai', function () {
                                        var controls = _status.event.controls;
                                        if (controls.includes('cslilu')) return 'cslilu';
                                        return controls[0];
                                    }).forResult();
                                    game.broadcastAll('closeDialog', event.videoId);
                                    if (control) await target.addSkills(control);
                                }
                            }
                            if (links.includes(1)) {
                                storage.remove(cardname);
                                player.markSkill('minidunshi');
                            }
                            if (links.includes(2)) {
                                await player.loseMaxHp();
                                if (storage.length > 0) await player.draw(storage.length);
                            }
                        },
                    },
                },
            },
            //韩遂
            mininiluan: {
                audio: 'niluan',
                enable: ['chooseToUse', 'chooseToRespond'],
                filter(event, player) {
                    return player.hasCard(lib.skill.mininiluan.filterCard, 'hes');
                },
                viewAs: { name: 'sha' },
                check(card) {
                    return 5 - get.value(card);
                },
                filterCard: { color: 'black' },
                position: 'hes',
                group: 'mininiluan_clear',
                prompt: '将一张黑色牌当作【杀】使用或打出',
                ai: {
                    respondSha: true,
                    skillTagFilter(player) {
                        return player.hasCard(card => {
                            if (_status.connectMode && get.position(card) === 'h') return true;
                            return get.color(card) === lib.skill.mininiluan.filterCard.color;
                        }, 'hes');
                    },
                },
                subSkill: {
                    clear: {
                        audio: 'niluan',
                        trigger: { player: 'useCardAfter' },
                        filter(event, player) {
                            if (event.card.name !== 'sha') return false;
                            return event.addCount !== false && !player.hasHistory('sourceDamage', evt => evt.card === event.card);
                        },
                        forced: true,
                        locked: false,
                        content() {
                            trigger.addCount = false;
                            if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                            game.log(trigger.card, '不计入次数限制');
                        },
                    },
                },
            },
            //蹋顿 怎么是这版本
            miniluanzhan: {
                audio: 'luanzhan',
                trigger: { player: 'useCardToPlayered', source: 'damageSource' },
                forced: true,
                locked: false,
                filter(event, player) {
                    if (event.name == 'damage') return true;
                    if (!event.isFirstTarget || (event.card.name != 'sha' && (get.color(event.card) != 'black' || get.type(event.card) != 'trick')) || !player.countMark('miniluanzhan')) return false;
                    const info = get.info(event.card);
                    if (info.allowMultiple == false || info.multitarget) return false;
                    return event.targets.length < player.countMark('miniluanzhan');
                },
                content() {
                    if (trigger.name == 'damage') player.addMark(event.name, 1, false);
                    else player.removeMark(event.name, Math.ceil(player.countMark(event.name) / 2), false);
                },
                intro: { content: 'mark' },
                ai: { notemp: true },
                group: 'miniluanzhan_add',
                subSkill: {
                    add: {
                        audio: 'luanzhan',
                        trigger: { player: 'useCard2' },
                        filter(event, player) {
                            if ((event.card.name != 'sha' && (get.color(event.card) != 'black' || get.type(event.card) != 'trick')) || !player.countMark('miniluanzhan')) return false;
                            const info = get.info(event.card);
                            if (info.allowMultiple == false) return false;
                            if (event.targets && !info.multitarget) {
                                return game.hasPlayer(current => {
                                    return !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current);
                                })
                            }
                            return false;
                        },
                        async cost(event, trigger, player) {
                            const num = player.countMark('miniluanzhan');
                            const { card, targets } = trigger;
                            const prompt2 = '为' + get.translation(card) + '增加至多' + get.cnNumber(num) + '个目标';
                            event.result = await player.chooseTarget(get.prompt('miniluanzhan'), (card, player, target) => {
                                const { card: card1, targets } = get.event();
                                if (targets.includes(target)) return false;
                                return lib.filter.targetEnabled2(card1, get.player(), target) && lib.filter.targetInRange(card1, get.player(), target);
                            }, [1, num]).set('prompt2', prompt2).set('ai', target => {
                                const trigger = get.event().getTrigger();
                                const player = get.player();
                                return get.effect(target, trigger.card, player, player);
                            }).set('card', card).set('targets', targets).forResult();
                        },
                        content() {
                            if (!event.isMine() && !event.isOnline()) game.delayx();
                            trigger.targets.addArray(event.targets);
                        },
                    }
                }
            },
            minireluanzhan: {
                audio: 'luanzhan',
                trigger: { player: 'useCardToPlayered', global: 'changeHp' },
                forced: true,
                locked: false,
                filter(event, player) {
                    if (event.name == 'changeHp') return event.num < 0;
                    if (!event.isFirstTarget || (event.card.name != 'sha' && (get.color(event.card) != 'black' || get.type(event.card) != 'trick')) || !player.countMark('minireluanzhan') || player.hasSkill('minireluanzhan_used')) return false;
                    const info = get.info(event.card);
                    if (info.allowMultiple == false || info.multitarget) return false;
                    return event.targets.length < player.countMark('minireluanzhan');
                },
                async content(event, trigger, player) {
                    if (trigger.name == 'changeHp') player.addMark(event.name, 1, false);
                    else {
                        player.addTempSkill(event.name + '_used');
                        const num = player.countMark(event.name);
                        player.removeMark(event.name, Math.ceil(player.countMark(event.name) / 2), false);
                        await player.draw(num);
                    }
                },
                intro: { content: 'mark' },
                ai: { notemp: true },
                group: 'minireluanzhan_add',
                subSkill: {
                    add: {
                        audio: 'luanzhan',
                        trigger: { player: 'useCard2' },
                        filter(event, player) {
                            if ((event.card.name != 'sha' && (get.color(event.card) != 'black' || get.type(event.card) != 'trick')) || !player.countMark('minireluanzhan')) return false;
                            const info = get.info(event.card);
                            if (info.allowMultiple == false) return false;
                            if (event.targets && !info.multitarget) {
                                return game.hasPlayer(current => {
                                    return !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current);
                                })
                            }
                            return false;
                        },
                        async cost(event, trigger, player) {
                            const num = player.countMark('minireluanzhan');
                            const { card, targets } = trigger;
                            const prompt2 = '为' + get.translation(card) + '增加至多' + get.cnNumber(num) + '个目标';
                            event.result = await player.chooseTarget(get.prompt('minireluanzhan'), (card, player, target) => {
                                const { card: card1, targets } = get.event();
                                if (targets.includes(target)) return false;
                                return lib.filter.targetEnabled2(card1, get.player(), target) && lib.filter.targetInRange(card1, get.player(), target);
                            }, [1, num]).set('prompt2', prompt2).set('ai', target => {
                                const trigger = get.event().getTrigger();
                                const player = get.player();
                                return get.effect(target, trigger.card, player, player);
                            }).set('card', card).set('targets', targets).forResult();
                        },
                        content() {
                            if (!event.isMine() && !event.isOnline()) game.delayx();
                            trigger.targets.addArray(event.targets);
                        },
                    },
                    used: {},
                }
            },
            //高览
            minixizhen: {
                audio: 'xizhen',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current != player && (player.canUse('sha', current, false) || player.canUse('juedou', current, false));
                    })
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minixizhen'), '视为对一名角色使用【杀】或【决斗】', function (card, player, target) {
                        return target != player && (player.canUse('sha', target, false) || player.canUse('juedou', target, false));
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        var eff1 = 0, eff2 = 0;
                        if (player.canUse('sha', target, false)) eff1 = get.effect(target, { name: 'sha' }, player, player);
                        if (player.canUse('juedou', target, false)) eff2 = get.effect(target, { name: 'juedou' }, player, player);
                        var effx = Math.max(eff1, eff2);
                        if (effx <= 0) return 0;
                        if (target.isHealthy()) effx *= 3;
                        if (get.attitude(player, target) > 0) effx *= 1.6;
                        return effx;
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minixizhen', target);
                        var list = [];
                        if (player.canUse('sha', target, false)) list.push('sha');
                        if (player.canUse('juedou', target, false)) list.push('juedou');
                        if (list.length == 1) event._result = { control: list[0] };
                        else player.chooseControl(list).set('prompt', '视为对' + get.translation(target) + '使用…').set('ai', function () {
                            var player = _status.event.player, target = _status.event.getParent().target;
                            var eff1 = get.effect(target, { name: 'sha' }, player, player), eff2 = get.effect(target, { name: 'juedou' }, player, player);
                            return eff1 > eff2 ? 0 : 1;
                        });
                    }
                    else event.finish();
                    'step 2'
                    player.useCard({ name: result.control, isCard: true }, target, false);
                    'step 3'
                    if (target.isIn()) {
                        player.storage.minixizhen_effect = target;
                        player.addTempSkill('minixizhen_effect', 'phaseUseAfter');
                    }
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        audio: 'xizhen',
                        trigger: { global: ['useCard', 'respond'] },
                        filter(event, player) {
                            return Array.isArray(event.respondTo) && event.respondTo[0] == player && player.storage.minixizhen_effect?.isIn();
                        },
                        forced: true,
                        logTarget(event, player) {
                            return player.storage.minixizhen_effect;
                        },
                        content() {
                            player.storage.minixizhen_effect.recover();
                            player.draw(2);
                        },
                        mark: 'character',
                        intro: { content: '已指定$为目标' },
                    },
                },
            },
            minizhenliang: {
                inherit: 'nzry_zhenliang',
                drawNum: 2,
                intro: {
                    content(storage, player) {
                        if (storage) return '你的回合外，一名角色使用或打出牌结算完成后，若此牌与“任”类别相同，则你可以令一名角色摸两张牌。';
                        return '出牌阶段限一次，你可以弃置一张与“任”颜色相同的牌并对攻击范围内的一名角色造成1点伤害。';
                    },
                },
                trigger: { global: ['useCardAfter', 'respondAfter'] },
                filter(event, player) {
                    const cards = player.getExpansions('nzry_mingren');
                    if (!cards.length) return false;
                    if (event.name === 'chooseToUse') {
                        if (player.storage.minizhenliang || player.hasSkill('minizhenliang_used', null, null, false)) return false;
                        const color = get.color(cards[0]);
                        if (!player.hasCard(card => get.color(card) === color && lib.filter.cardDiscardable(card, player))) return false;
                        return game.hasPlayer(current => player.inRange(current));
                    } else {
                        if (_status.currentPhase === player || !player.storage.minizhenliang) return false;
                        return get.type2(event.card) === get.type2(cards[0]);
                    }
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt('minizhenliang')).set('ai', target => {
                        const player = get.player();
                        return get.effect(target, { name: 'draw' }, player, player);
                    }).set('prompt2', `令一名角色摸两张牌`).forResult();
                },
                subSkill: { used: { charlotte: true } },
            },
            miniyouqi: {
                audio: 'dcyouqi',
                trigger: { global: 'loseAfter' },
                filter(event, player) {
                    if (event.getParent(3).name.indexOf('dcyinlu_') !== 0 || player == event.player) return false;
                    return true;
                },
                forced: true,
                content() {
                    player.gain(trigger.cards.filterInD('d'), 'gain2');
                },
            },
            //界袁术
            miniyongsi: {
                audio: 'drlt_yongsi',
                trigger: { player: ['phaseDrawBegin2', 'phaseDiscardBegin', 'phaseEnd'] },
                forced: true,
                filter(event, player) {
                    if (event.name == 'phaseDraw') return !event.numFixed;
                    if (event.name == 'phaseDiscard') return player.countCards('he');
                    return player.getHistory('sourceDamage').reduce((num, evt) => num + evt.num, 0) <= 1;
                },
                async content(event, trigger, player) {
                    const num = game.countGroup();
                    if (trigger.name == 'phaseDraw') trigger.num += num;
                    else if (trigger.name == 'phaseDiscard') await player.chooseToDiscard(num, 'he', true);
                    else await player.draw(num);
                },
            },
            minireweidi: {
                audio: 'drlt_weidi',
                getCards(event) {
                    const cards = [];
                    game.getGlobalHistory('cardMove', evt => {
                        if (evt.name == 'cardsDiscard' && evt.getParent('phaseDiscard') == event) cards.addArray(evt.cards.filterInD('d'));
                    });
                    game.countPlayer2(current => {
                        current.getHistory('lose', evt => {
                            if (evt.type != 'discard' || evt.getParent('phaseDiscard') != event) return;
                            cards.addArray(evt.cards.filterInD('d'));
                        })
                    });
                    return cards;
                },
                preHidden: true,
                trigger: { player: 'phaseDiscardEnd' },
                filter(event, player) {
                    return get.info('minireweidi').getCards(event).length;
                },
                async cost(event, trigger, player) {
                    const cards = get.info(event.skill).getCards(trigger);
                    const list = cards.map(card => get.color(card)).toUniqued();
                    const dialog = ui.create.dialog();
                    dialog.addText('伪帝：请选择一张颜色');
                    dialog.addAuto(cards);
                    const { control } = await player.chooseControl(list, 'cancel2').set('dialog', dialog).set('ai', () => {
                        const { player, cards, controls } = get.event();
                        if (!game.hasPlayer(current => current != player && get.attitude(player, current) > 0)) return 'cancel2';
                        const map = {}, list = [];
                        for (const color of controls.remove('cancel2')) {
                            if (typeof map[color] != 'number') map[color] = 0;
                            map[color] += cards.filter(card => get.color(card) == color).length;
                        } for (let i in map) {
                            if (map[i] > 0) list.push([i, map[i]]);
                        }
                        list.sort((a, b) => b[1] - a[1]);
                        return list[0][0];
                    }).set('cards', cards).forResult();
                    if (control == 'cancel2') return;
                    const give = cards.filter(card => get.color(card) == control);
                    const { targets } = await player.chooseTarget(lib.filter.notMe, get.prompt(event.skill), `选择一名其他角色交给其${get.translation(give)}`).set('ai', target => {
                        const { player, give } = get.event();
                        return get.attitude(player, target) * get.value(give, target) * (target.hasSkillTag('nogain') ? 0.1 : 1);
                    }).set('give', give).setHiddenSkill(event.skill).forResult();
                    event.result = {
                        bool: targets?.length,
                        targets: targets,
                        cost_data: give,
                    }
                },
                async content(event, trigger, player) {
                    const { targets: [target], cost_data: cards } = event;
                    await target.gain(cards, 'gain2').set('giver', player);
                    const color = get.color(cards[0]);
                    if (target.group != 'qun' || !target.hasCard(card => get.color(card) != color, 'he')) return;
                    const num = cards.length;
                    await target.chooseToGive(player, 'he', card => get.color(card) != get.event().color, num, true).set('color', color);
                },
            },
            //蔡邕
            minibizhuan: {
                audio: 'rebizhuan',
                inherit: 'rebizhuan',
                trigger: {
                    player: 'useCardAfter',
                    target: 'useCardToTargeted',
                },
                filter(event, player) {
                    if (event.name != 'useCard' && event.player == event.target) return false;
                    const num = 4 + Math.min(player.countMark('minitongbo'), game.countPlayer());
                    if (player.countExpansions('minibizhuan') >= num) return false;
                    return get.color(event.card) == 'black';
                },
                content() {
                    player.addToExpansion(get.cards(), 'gain2').gaintag.add(event.name);
                },
                mod: {
                    maxHandcard(player, num) {
                        return num + player.countExpansions('minibizhuan');
                    },
                },
            },
            minitongbo: {
                audio: 'retongbo',
                trigger: { player: 'phaseDrawAfter' },
                filter(event, player) {
                    return player.countExpansions('minibizhuan') && player.countCards('h');
                },
                async cost(event, trigger, player) {
                    const next = player.chooseToMove('通博：是否交换“书”和手牌？');
                    next.set('list', [
                        [get.translation(player) + '（你）的“书”', player.getExpansions('minibizhuan')],
                        ['你的牌', player.getCards('he')],
                    ]);
                    next.set('filterMove', (from, to) => {
                        return typeof to != 'number';
                    });
                    next.set('processAI', (list) => {
                        let player = get.player(),
                            cards = list[0][1].concat(list[1][1]),
                            cards2 = [];
                        cards.sort((a, b) => {
                            return get.useful(a) - get.useful(b);
                        });
                        cards2 = cards.splice(0, player.getExpansions('minibizhuan').length);
                        return [cards2, cards];
                    });
                    const result = await next.forResult();
                    event.result = {
                        bool: result?.moved?.[0]?.some(card => player.getCards('he').includes(card)),
                        cost_data: result?.moved,
                    };
                },
                async content(event, trigger, player) {
                    const { cost_data: moved } = event;
                    const pushs = moved[0], gains = moved[1];
                    pushs.removeArray(player.getExpansions('minibizhuan'));
                    gains.removeArray(player.getCards('he'));
                    if (!pushs.length || pushs.length != gains.length) return;
                    const next = player.addToExpansion(pushs, 'give', player);
                    next.gaintag.add('minibizhuan');
                    await next;
                    await player.gain(gains, 'gain2');
                    const expansions = player.getExpansions('minibizhuan');
                    if (expansions.length < 4) return;
                    if (_status.connectMode) game.broadcastAll(() => {
                        _status.noclearcountdown = true;
                    });
                    const given_map = {};
                    event.given_map = given_map;
                    let result;
                    while (Object.values(given_map).flat().length < 4) {
                        if (expansions.length > 1) {
                            result = await player.chooseCardButton('通博：请选择要分配的牌', expansions, [1, 4 - Object.values(given_map).flat().length], Object.values(given_map).length > 0).set('ai', button => {
                                const { player, goon } = get.event();
                                if (!goon) return 0;
                                if (ui.selected.buttons.length) return 0;
                                return get.value(button.link);
                            }).set('goon', game.hasPlayer(current => current != player && get.attitude(player, current) > 0)).forResult();
                        } else if (expansions.length === 1) result = { bool: true, links: expansions.slice(0) };
                        else return;
                        if (!result.bool) return;
                        const toGive = result.links;
                        result = await player.chooseTarget(`选择一名角色获得${get.translation(toGive)}`, true, lib.filter.notMe).set('ai', target => {
                            const { player, toEnemy } = get.event();
                            const att = get.attitude(player, target);
                            if (toEnemy) return -att;
                            else if (att > 0) return att / (1 + target.countCards('h'));
                            else return att / 100;
                        }).set('toEnemy', get.value(toGive[0], player, 'raw') < 0).forResult();
                        if (result.bool) {
                            expansions.removeArray(toGive);
                            if (result.targets.length) {
                                const id = result.targets[0].playerid;
                                if (!given_map[id]) given_map[id] = [];
                                given_map[id].addArray(toGive);
                            }
                            if (!expansions.length) break;
                        }
                        else break;
                    }
                    if (_status.connectMode) game.broadcastAll(() => {
                        delete _status.noclearcountdown;
                        game.stopCountChoose();
                    });
                    const gain_list = [];
                    for (const i in given_map) {
                        const source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                        player.line(source, 'green');
                        gain_list.push([source, given_map[i]]);
                        game.log(source, '获得了', given_map[i]);
                    }
                    if (gain_list.length) {
                        await game.loseAsync({
                            gain_list,
                            giver: player,
                            animate: 'gain2',
                        }).setContent('gaincardMultiple');
                        await player.recover();
                        player.addMark(event.name, 1, false);
                    }
                },
                marktext: '博',
                intro: {
                    content(storage, player) {
                        const num = 4 + Math.min(storage, game.countPlayer());
                        return '“书”的上限+' + num;
                    },
                },
                ai: { combo: 'minibizhuan' },
            },
            miniyingshui: {
                audio: 'reyingshui',
                inherit: 'reyingshui',
                filter(event, player) {
                    return player.countCards('he') > 0 && game.hasPlayer(target => get.info('miniyingshui').filterTarget(null, player, target));
                },
                filterTarget(card, player, target) {
                    return player.inRange(target) && !get.event()?.miniyingshui_list?.includes(target);
                },
                onChooseToUse(event) {
                    if (event.type === 'phase' && !game.online && !event.miniyingshui_list) {
                        event.set('miniyingshui_list', event.player.getHistory('useSkill', evt => evt.skill === 'miniyingshui').map(evt => evt.targets || []).flat());
                    }
                },
                async content(event, trigger, player) {
                    const { cards, target } = event;
                    await player.give(cards, target);
                    const next = target.chooseCard('he', [2, Infinity], '交给' + get.translation(player) + '至少两张装备牌，否则受到1点伤害', { type: 'equip' });
                    if (get.damageEffect(target, player, target) >= 0) next.set('ai', () => -1);
                    else next.set('ai', (card) => ui.selected.cards.length < 2 ? (6 - get.value(card)) : 0);
                    const result = await next.forResult();
                    if (result?.bool) await target.give(result.cards, player);
                    else {
                        await target.damage('nocard');
                        if (player.getStat('skill')[event.name] !== undefined) delete player.getStat('skill')[event.name];
                        player.popup(event.name);
                        game.log(player, '重置了技能', '#g【' + get.translation(event.name) + '】');
                    }
                },
            },
            //狼灭
            minilangmie: {
                audio: 'langmie',
                trigger: { global: 'phaseJieshuBegin' },
                filter(event, player) {
                    const target = event.player;
                    if (player === event.player || !player.hasCard(card => {
                        if (get.position(card) === 'h' && _status.connectMode) return true;
                        return lib.filter.cardDiscardable(card, player);
                    }, 'he')) return false;
                    if (target.getHistory('sourceDamage').reduce((sum, evt) => sum + evt.num, 0) >= 2) return true;
                    const history = target.getHistory('useCard');
                    return history.length > history.map(evt => get.type2(evt.card)).unique().length;
                },
                direct: true,
                async content(event, trigger, player) {
                    const target = trigger.player, list = [event.name, target], str = get.translation(target);
                    const goon1 = target.getHistory('sourceDamage').reduce((sum, evt) => sum + evt.num, 0) >= 2;
                    const history = target.getHistory('useCard');
                    const goon2 = history.length > history.map(evt => get.type2(evt.card)).unique().length;
                    if (goon2) {
                        const next = player.chooseToDiscard(get.prompt(list[0]), 'he', '弃置一张牌并摸两张牌');
                        next.logSkill = list[0];
                        next.set('ai', card => {
                            const player = get.player();
                            return get.effect(player, { name: 'wuzhong' }, player, player) - get.value(card);
                        });
                        const result = await next.forResult();
                        if (result.bool) await player.draw(2);
                    }
                    if (goon1) {
                        const next = player.chooseToDiscard(get.prompt(...list), 'he', '弃置一张牌，对' + get.translation(target) + '造成1点伤害');
                        next.logSkill = list;
                        next.set('ai', card => {
                            const player = get.player(), target = get.event().getTrigger().player;
                            return get.damageEffect(target, player, player) - get.value(card);
                        });
                        const result = await next.forResult();
                        if (result.bool) await target.damage();
                    }
                },
            },
            // SP徐晃
            minikuanmeng: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: ['damageEnd', 'recoverEnd', 'loseHpEnd'] },
                filter(event, player) {
                    if (game.getGlobalHistory('changeHp', evt => evt.player == player).map(evt => evt.getParent()).indexOf(event) !== 0) return false;
                    return !player.isDying();
                },
                async cost(event, trigger, player) {
                    const list = ['摸一张牌', '弃置一张牌', '摸两张牌', '弃置两张牌'].map((item, i) => [i, item]);
                    const next = player.chooseButton(['宽猛：请选择你要执行的选项', [list.slice(0, 2), 'tdnodes'], [list.slice(2, 4), 'tdnodes']]);
                    next.set('filterButton', button => {
                        const player = get.player();
                        const { link } = button;
                        if (link % 2 === 0) return true;
                        return player.countDiscardableCards(player, 'he') >= (link + 1) / 2;
                    });
                    next.set('ai', button => {
                        const player = get.player();
                        const { link } = button;
                        const num1 = player.getCards('h').filter(card => get.type(card) == 'basic').length;
                        const num2 = player.hp;
                        if (num1 > num2) {
                            const num = num1 - num2;
                            if (game.hasPlayer(current => player != current && get.attitude(player, current) < 0 && get.effect(current, { name: 'guohe_copy2' }, player, player) > 0) && player.countCards('h') > 2) {
                                if (link % 2 === 0) return 0;
                                if (link === (num % 2 + 1)) return 100;
                            }
                            if (link === 2) return 100;
                        }
                        else if (num1 < num2) {
                            const num = num2 - num1;
                            if (game.hasPlayer(current => player != current && get.attitude(player, current) > 0)) {
                                if (link % 2 === 1) return 0;
                                if (link === (num % 2 + 1)) return 100;
                            }
                        }
                        if (link === 2) return 100;
                        return 0;
                    });
                    const result = await next.forResult();
                    event.result = {
                        bool: result?.bool,
                        cost_data: result?.links,
                    }
                },
                async content(event, trigger, player) {
                    const { cost_data: [link] } = event;
                    const num = link <= 1 ? 1 : 2;
                    const fn = ['draw', 'chooseToDiscard'];
                    if (link % 2 === 1) fn.reverse();
                    const next = player[fn[0]](num, true, 'he');
                    if (fn[0] == 'chooseToDiscard') next.set('ai', card => {
                        const player = get.player();
                        const num1 = player.getCards('h').filter(card => get.type(card) == 'basic').length;
                        const num2 = player.hp;
                        const num = num1 - num2;
                        if (num > 0 && num <= 2 && get.type(card) == 'basic' && !card.hasGaintag('minixuefeng_effect')) return 100;
                        return 6 - get.value(card);
                    });
                    await next;
                    const hs = player.getCards('h');
                    if (hs.filter(card => get.type(card) == 'basic').length != player.hp || !game.hasPlayer(current => player != current)) return;
                    const result = await player.chooseTarget('宽猛：选择一名角色', `令其${fn[0] == 'draw' ? '摸' : '弃置'}${get.cnNumber(num)}张牌`, (card, player, target) => {
                        if (player == target) return false;
                        const { choice } = get.event();
                        return choice == 'draw' || target.countDiscardableCards(target, 'he');
                    }, true).set('ai', target => {
                        const player = get.player();
                        const { choice } = get.event();
                        if (choice == 'draw') return get.effect(target, { name: 'draw' }, player, player);
                        return get.effect(target, { name: 'guohe_copy2' }, player, player);
                    }).set('choice', fn[0]).forResult();
                    if (result?.bool && result?.targets?.length) {
                        const [target] = result.targets;
                        player.line(target, 'green');
                        await target[fn[0]](num, true, 'he');
                    }
                },
            },
            minixuefeng: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                usable: 1,
                filter(event, player) {
                    if (!player.countCards('h', { type: 'basic' })) return false;
                    return game.hasPlayer(target => get.info('minixuefeng').filterTarget(null, player, target));
                },
                filterCard(card, player) {
                    return get.type(card) == 'basic';
                },
                filterTarget(card, player, target) {
                    if (!ui.selected.targets.length) return player !== target;
                    return true;
                },
                selectTarget: 2,
                targetprompt: ['奉献者', '被奉献者'],
                complexTarget: true,
                discard: false,
                lose: false,
                delay: false,
                multitarget: true,
                check(card) {
                    return 7 - get.value(card);
                },
                async content(event, trigger, player) {
                    await player.showCards(event.cards);
                    const { targets: [source, target] } = event;
                    await game.delayx();
                    const effect = event.name + '_effect';
                    target.addSkill(effect);
                    let result;
                    if (!source.countCards('h', { type: 'basic' })) result = { bool: false };
                    else {
                        const next = source.chooseToGive(target, 'h', { type: 'basic' }, `交给${get.translation(target)}一张基本牌，否则你失去1点体力其回复1点体力`);
                        next.gaintag.add(effect);
                        next.set('ai', card => {
                            const { player, target } = get.event();
                            const att = get.attitude(player, target);
                            if (get.effect(player, { name: 'losehp' }, player, player) + get.recoverEffect(target, player, player) > 0) {
                                if (att > 0 && (get.tag(card, 'damage') || get.tag(card, 'recover'))) return 7 - get.value(card);
                                return 6 - get.value(card);
                            }
                            return 0;
                        });
                        result = await next.forResult();
                    }
                    if (result?.bool) {
                        await player.loseHp();
                        await target.recover();
                    }
                    else {
                        await source.loseHp();
                        await target.recover();
                        if (!player.countCards('h', { type: 'basic' })) return;
                        if (player == target) {
                            const result = await player.chooseCard('h', { type: 'basic' }, true, `请选择一张基本牌，此牌的伤害值/回复值+1`).set('ai', card => {
                                if (get.tag(card, 'damage') || get.tag(card, 'recover')) return 10;
                                return 6 - get.value(card);
                            }).forResult();
                            if (result?.bool && result?.cards?.length) player.addGaintag(result.cards, effect);
                        }
                        else {
                            const next = player.chooseToGive(target, 'h', { type: 'basic' }, true, `请交给${get.translation(target)}一张基本牌`);
                            next.gaintag.add(effect);
                            next.set('ai', card => {
                                const { player, target } = get.event();
                                const att = get.attitude(player, target);
                                if (att > 0 && (get.tag(card, 'damage') || get.tag(card, 'recover'))) return 7.5 - get.value(card);
                                return 6 - get.value(card);
                            });
                            await next;
                        }
                    }
                },
                ai: {
                    order(item, player) {
                        const friends = game.filterPlayer(current => get.attitude(player, current) > 0);
                        const enemies = game.filterPlayer(current => current != player && get.attitude(player, current) < 0);
                        if (friends.some(current => get.recoverEffect(current, player, player) > 0) && enemies.some(current => !current.countCards('h') || !current.countCards('h', { type: 'basic' }))) return 10;
                        if (player.getHp() > 1 || game.hasPlayer(current => get.attitude(current, player) > 0 && current.canSave(player))) return 8;
                        return 3;
                    },
                    result: {
                        target(player, target) {
                            if (!ui.selected.targets.length) {
                                const att = get.attitude(player, target);
                                if (att > 0) return 0;
                                const friends = game.filterPlayer(current => get.attitude(player, current) > 0);
                                if (friends.some(current => get.recoverEffect(current, player, player) > 0) && (!target.countCards('h') || !target.countCards('h', { type: 'basic' }))) return -4;
                                return -3;
                            }
                            const source = ui.selected.targets[0];
                            if (player.getHp() < 1 && !game.hasPlayer(current => get.attitude(current, player) > 0 && current.canSave(player))) return 0;
                            return 1 + target.getDamagedHp() + (target.countCards('h') < 3);
                        }
                    }
                },
                subSkill: {
                    backup: {},
                    effect: {
                        mod: {
                            aiOrder(player, card, num) {
                                if (get.itemtype(card) == 'card' && card.hasGaintag('minixuefeng_effect')) return num + 0.1;
                            },
                            aiValue(player, card, num) {
                                if (get.itemtype(card) == 'card' && card.hasGaintag('minixuefeng_effect')) return num + 5;
                            },
                            aiUseful() {
                                return lib.skill.minixuefeng_effect.mod.aiValue.apply(this, arguments);
                            },
                        },
                        charlotte: true,
                        onremove(player, skill) {
                            player.removeGaintag(skill);
                        },
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            if (!event.cards?.length) return false;
                            return player.hasHistory('lose', evt => {
                                if (evt.getParent() !== event) return false;
                                return Object.values(evt.gaintag_map).flat().includes('minixuefeng_effect');
                            });
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const tag = event.name;
                            const evtx = player.getHistory('lose', evt => {
                                if (evt.getParent() !== trigger) return false;
                                return Object.values(evt.gaintag_map).flat().includes(tag);
                            })[0];
                            let num = 0;
                            Object.values(evtx.gaintag_map).flat().forEach(tags => {
                                if (tags.includes(tag)) num++;
                            });
                            trigger.baseDamage += num;
                        },
                    }
                },
            },
            // 张让
            minitaoluan: {
                hiddenCard(player, name) {
                    return !player.getStorage('minitaoluan').includes(name) && player.countCards('hes', card => !player.getStorage('minitaoluan_used').includes(get.suit(card))) > 0 && lib.inpile.includes(name);
                },
                marktext: '乱',
                onremove: true,
                intro: { content: '已以此法使用过$' },
                audio: 'taoluan',
                enable: 'chooseToUse',
                filter(event, player) {
                    return player.countCards('hes', card => {
                        if (player.getStorage('minitaoluan_used').includes(get.suit(card))) return false;
                        return get.inpileVCardList(info => {
                            if (!['basic', 'trick'].includes(info[0])) return false;
                            if (player.getStorage('minitaoluan').includes(info[2])) return false;
                            return event.filterCard(get.autoViewAs({ name: info[2], nature: info[3], cards: [card] }, 'unsure'), player, event)
                        }).length;
                    });
                },
                chooseButton: {
                    dialog(event, player) {
                        const list = get.inpileVCardList(info => {
                            if (!['basic', 'trick'].includes(info[0])) return false;
                            if (player.getStorage('minitaoluan').includes(info[2])) return false;
                            return event.filterCard(get.autoViewAs({ name: info[2], nature: info[3] }, 'unsure'), player, event);
                        });
                        return ui.create.dialog('滔乱', [list, 'vcard']);
                    },
                    check(button) {
                        const player = get.player();
                        const card = { name: button.link[2], nature: button.link[3] };
                        return get.event().getParent().type == 'phase' ? player.getUseValue(card) : 1;
                    },
                    backup(links, player) {
                        return {
                            audio: 'taoluan',
                            filterCard(card, player) {
                                return !player.getStorage('minitaoluan_used').includes(get.suit(card));
                            },
                            popname: true,
                            check(card) {
                                return 7 - get.value(card);
                            },
                            position: 'hes',
                            viewAs: { name: links[0][2], nature: links[0][3] },
                            async precontent(event, trigger, player) {
                                player.addTempSkill('minitaoluan_used');
                                player.markAuto('minitaoluan_used', [get.suit(event.result.cards[0], player)]);
                                player.markAuto('minitaoluan', [event.result.card.name]);
                                player.addTempSkill('minitaoluan_effect');
                            },
                        };
                    },
                    prompt(links, player) {
                        return '将一张牌当做' + (get.translation(links[0][3]) || '') + get.translation(links[0][2]) + '使用';
                    },
                },
                ai: {
                    order(item, player) {
                        if (player && get.event().type == 'phase') {
                            let list = get.inpileVCardList(info => {
                                if (!['basic', 'trick'].includes(info[0])) return false;
                                if (player.getStorage('minitaoluan').includes(info[2])) return false;
                                return true;
                            }).map(card => {
                                return { name: card[2], nature: card[3] };
                            }).filter(card => player.getUseValue(card, true, true) > 0);
                            if (!list.length) return 0;
                            list.sort((a, b) => (player.getUseValue(b, true, true) || 0) - (player.getUseValue(a, true, true) || 0));
                            return get.order(list[0], player) * 0.99;
                        }
                        return 1;
                    },
                    save: true,
                    respondSha: true,
                    respondShan: true,
                    skillTagFilter(player, tag, arg) {
                        if (!player.countCards('hes', card => !player.getStorage('minitaoluan_used').includes(get.suit(card)))) return false
                        if (tag == 'respondSha' || tag == 'respondShan') {
                            if (arg == 'respond') return false;
                            return !player.getStorage('minitaoluan').includes(tag == 'respondSha' ? 'sha' : 'shan');
                        }
                        return !player.getStorage('minitaoluan').includes('tao') || (!player.getStorage('minitaoluan').includes('jiu') && arg == player);
                    },
                    result: {
                        player(player) {
                            return get.event().dying ? get.attitude(player, get.event().dying) : 1;
                        },
                    },
                    threaten: 1.9,
                },
                subSkill: {
                    backup: {},
                    used: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '本回合已使用花色:$' },
                    },
                    effect: {
                        charlotte: true,
                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                        locked: true,
                        popup: false,
                        filter(event, player) {
                            return event.skill == 'minitaoluan_backup' && game.hasPlayer(current => current != player);
                        },
                        async cost(event, trigger, player) {
                            event.result = await player.chooseTarget(true, lib.filter.notMe, `###滔乱###令一名其他角色选择一项：1.交给你一张与你以此法使用的牌类别不同的牌；2.本回合〖滔乱〗失效且回合结束时其失去1点体力`).set('ai', target => {
                                const player = get.player();
                                const att = get.attitude(player, target);
                                const list = get.inpileVCardList(info => {
                                    if (!['basic', 'trick'].includes(info[0])) return false;
                                    if (player.getStorage('minitaoluan').includes(info[2])) return false;
                                    return player.getUseValue({ name: info[2] }) > 0;
                                });
                                if (list.length && player.getStorage('minitaoluan_used').length < 4 && player.isPhaseUsing()) {
                                    if (att <= 0) return 0;
                                    if (!target.countCards('he', card => get.type2(card) != get.event().cardType)) return 0;
                                    return target.countCards('he') - 2;
                                }
                                return get.effect(target, { name: 'losehp' }, player, player);
                            }).forResult();
                        },
                        async content(event, trigger, player) {
                            const [target] = event.targets;
                            player.line(target, 'green');
                            const type = get.type2(trigger.card);
                            const result = await target.chooseToGive(player, `###滔乱###交给${get.translation(player)}一张不为${get.translation(type)}牌的牌，或令其〖滔乱〗无效直到回合结束${target == _status.currentPhase ? '且你于回合结束时失去1点体力' : ''}`, 'he', (card, player, target) => {
                                return get.type2(card) != get.event().cardType;
                            }).set('cardType', type).set('ai', card => {
                                const { player, target } = get.event();
                                const att = get.attitude(player, target);
                                if (att > 0) return 11 - get.value(card);
                                if (att < 0 && player.getHp() < 2 && !game.hasPlayer(current => get.attitude(current, player) > 0 && current.countCards('hs', card => current.canSaveCard(card, player))) && !game.hasPlayer(current => get.attitude(current, player) > 0 && current != player) && target.getStorage('minitaoluan_used').includes(get.suit(card))) return 10 - get.value(card);
                                return 0;
                            }).forResult();
                            if (!result?.bool) {
                                player.tempBanSkill('minitaoluan');
                                if (player == _status.currentPhase) {
                                    target.addTempSkill('minitaoluan_buff');
                                    target.addMark('minitaoluan_buff', 1, false);
                                }
                            }
                        },
                    },
                    buff: {
                        charlotte: true,
                        onremove: true,
                        trigger: { global: 'phaseEnd' },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const num = player.countMark(event.name);
                            player.removeSkill(event.name);
                            await player.loseHp(num);
                        },
                        intro: { content: '本回合结束时失去#点体力' },
                    }
                }
            },
            // SP刘备
            minizhuyi: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    player: 'gainAfter',
                    global: ['loseAsyncAfter', 'damageBegin4', 'phaseBegin'],
                },
                filter(event, player) {
                    const storage = player.getStorage('minizhuyi_used');
                    if (!player.hasCard(card => {
                        if (_status.connectMode) return true;
                        return lib.filter.cardDiscardable(card, player);
                    }, 'he')) return false;
                    if (['damage', 'phase'].includes(event.name)) return !storage.includes(event.name) && event.player.isIn();
                    return !storage.includes('gain') && event.getg?.(player)?.length;
                },
                async cost(event, trigger, player) {
                    if (['damage', 'phase'].includes(trigger.name)) {
                        const { player: target, source } = trigger;
                        const bool = trigger.name == 'damage';
                        const prompt = bool ? `${get.translation(target)}即将受到${source ? `来自${get.translation(source)}` : '无来源'}的${trigger.num}点伤害，你可以弃置一张牌，防止此伤害` : `弃置一张牌令${get.translation(target)}从牌堆获得一张基本牌`;
                        const goon = bool ? get.damageEffect(target, source, player, trigger.nature) < 0 : get.attitude(player, target) > 0;
                        event.result = await player.chooseToDiscard('he', 'chooseonly', get.prompt(event.skill, target), prompt).set('ai', card => {
                            const { goon } = get.event();
                            if (goon) return 7 - get.value(card);
                            return 0;
                        }).set('goon', goon).forResult();
                        if (event.result?.bool) event.result.targets = [target];
                    } else {
                        event.result = await player.chooseCardTarget({
                            prompt: get.prompt(event.skill),
                            prompt2: '弃置一张牌令一名角色摸两张牌',
                            filterTarget: true,
                            filterCard: lib.filter.cardDiscardable,
                            position: 'he',
                            ai1(card) {
                                return 6.5 - get.value(card);
                            },
                            ai2(target) {
                                const player = get.player();
                                return get.effect(target, { name: 'draw' }, player, player) * 2;
                            }
                        }).forResult();
                    }
                },
                async content(event, trigger, player) {
                    const { cards, targets: [target] } = event;
                    const name = ['damage', 'phase'].includes(trigger.name) ? trigger.name : 'gain';
                    player.addTempSkill(event.name + '_used', 'roundStart');
                    player.markAuto(event.name + '_used', [name]);
                    await player.discard(cards);
                    if (trigger.name == 'damage') trigger.cancel();
                    else if (trigger.name == 'phase') {
                        const card = get.cardPile(card => get.type(card) == 'basic');
                        if (card) {
                            const effect = event.name + '_effect';
                            target.addSkill(effect);
                            const next = target.gain(card, 'gain2');
                            next.gaintag.add(effect);
                            await next;
                        }
                    } else await target.draw(2);
                    const list = lib.inpile.filter(name => get.type(name) == 'basic' && !['sha'].concat(player.getStorage('minixiafeng')).includes(name));
                    if (['damage', 'phase', 'gain'].every(tag => game.getRoundHistory('everything', evt => evt.name == event.name && evt.player == player).some(evt => evt[`${event.name}_${tag}`])) && player.hasSkill('minixiafeng', null, null, false) && list.length) {
                        const result = await player.chooseButton(['逐义：你可以为〖侠锋〗添加一个基本牌牌名', [list, 'vcard']]).set('ai', button => {
                            const player = get.player();
                            const name = button.link[2];
                            if (name == 'du') return 0;
                            if (player.hasCard(card => get.name(card, player) == name), 'hs') return 10;
                            return 1;
                        }).forResult();
                        if (result?.bool && result?.links?.length) player.markAuto('minixiafeng', [result.links[0][2]]);
                    }
                },
                subSkill: {
                    used: {
                        charlotte: true,
                        onremove: true,
                    },
                    effect: {
                        mod: {
                            aiOrder(player, card, num) {
                                if (get.itemtype(card) == 'card' && card.hasGaintag('minizhuyi_effect')) return num + 0.1;
                            },
                            aiValue(player, card, num) {
                                if (get.itemtype(card) == 'card' && card.hasGaintag('minizhuyi_effect')) return num + 5;
                            },
                            aiUseful() {
                                return lib.skill.minizhuyi_effect.mod.aiValue.apply(this, arguments);
                            },
                        },
                        charlotte: true,
                        onremove(player, skill) {
                            player.removeGaintag(skill);
                        },
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            if (!event.cards?.length) return false;
                            return player.hasHistory('lose', evt => {
                                if ((evt.relatedEvent || evt.getParent()) !== event) return false;
                                return Object.values(evt.gaintag_map).flat().includes('minizhuyi_effect');
                            });
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const tag = event.name;
                            const evtx = player.getHistory('lose', evt => {
                                if ((evt.relatedEvent || evt.getParent()) !== trigger) return false;
                                return Object.values(evt.gaintag_map).flat().includes(tag);
                            })[0];
                            let num = 0;
                            Object.values(evtx.gaintag_map).flat().forEach(tags => {
                                if (tags.includes(tag)) num++;
                            });
                            trigger.baseDamage += num;
                        },
                    }
                }
            },
            minixiafeng: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'useCardAfter' },
                filter(event, player) {
                    if (!['sha'].concat(player.getStorage('minixiafeng')).includes(event.card.name)) return false;
                    return game.hasPlayer(current => {
                        return (current.isMinHp() && current.isDamaged()) || current.isMaxHp();
                    });
                },
                usable: 1,
                async cost(event, trigger, player) {
                    const result = await player.chooseButtonTarget({
                        createDialog: [
                            get.prompt(event.skill),
                            [
                                [
                                    ['damage', '对场上体力值最大的角色造成1点伤害'],
                                    ['recover', '令场上体力值最小的角色回复1点体力'],
                                ],
                                'tdnodes',
                            ],
                        ],
                        complexSelect: true,
                        filterButton(button) {
                            const { link } = button;
                            return link == 'damage' || game.hasPlayer(current => current.isMinHp() && current.isDamaged());
                        },
                        filterTarget(card, player, target) {
                            const { link } = ui.selected.buttons[0];
                            return (link == 'damage' && target.isMaxHp()) || (link == 'recover' && target.isMinHp() && target.isDamaged());
                        },
                        ai1(button) {
                            const { link } = button;
                            const player = get.player();
                            const list1 = game.filterPlayer(current => current.isMaxHp()).sort((a, b) => {
                                return get.damageEffect(b, player, player) - get.damageEffect(a, player, player);
                            }).map(current => get.damageEffect(current, player, player));
                            let list2 = [];
                            if (game.hasPlayer(current => current.isMinHp() && current.isDamaged())) {
                                list2 = game.filterPlayer(current => current.isMinHp() && current.isDamaged()).sort((a, b) => {
                                    return get.recoverEffect(b, player, player) - get.recoverEffect(a, player, player);
                                }).map(current => get.recoverEffect(current, player, player));
                            }
                            if (list2.length > 0) {
                                if (list1[0] >= list2[0] && list1[0] > 0 && link == 'damage') return 10;
                                if (list1[0] < list2[0] && list2[0] > 0 && link == 'recover') return 10;
                                return 0;
                            }
                            if (list1[0] > 0 && link == 'damage') return 10;
                            return 0;
                        },
                        ai2(target) {
                            if (!ui.selected?.buttons?.length) return 0;
                            const { link } = ui.selected.buttons[0];
                            const player = get.player();
                            if (link == 'damage') return get.damageEffect(target, player, player);
                            return get.recoverEffect(target, player, player);
                        },
                    }).forResult();
                    event.result = {
                        bool: result?.bool,
                        targets: result?.targets,
                        cost_data: result?.links,
                    }
                },
                async content(event, trigger, player) {
                    const { targets: [target], cost_data: [link] } = event;
                    await target[link]();
                },
                onremove: true,
                intro: { content: '已添加牌名：$' },
            },
            // 谋华雄
            minisbyangwei: {
                audio: 'olsbyangwei',
                inherit: 'olsbyangwei',
                group: ['olsbyangwei_discard', 'minisbyangwei_recover'],
                subSkill: {
                    recover: {
                        audio: 'olsbyangwei',
                        trigger: { player: 'phaseUseEnd' },
                        filter(event, player) {
                            return player.getHistory('useCard', evt => evt.card?.name == 'sha' && evt.getParent(event.name) == event).length > 2;
                        },
                        forced: true,
                        async content(event, trigger, player) {
                            await player.recover();
                        },
                    }
                }
            },
            // 纪灵
            minishuangren: {
                audio: 'shuangren',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return game.hasPlayer(current => player.canCompare(current))
                },
                preHidden: true,
                async cost(event, trigger, player) {
                    let goon = player.needsToDiscard() > 1 ? player.hasCard(card => {
                        return card.number > 10 && get.value(card) <= 5;
                    }) : player.hasCard(card => {
                        return (card.number >= 9 && get.value(card) <= 5) || get.value(card) <= 3;
                    });
                    event.result = await player.chooseTarget(get.prompt2(event.skill), (card, player, target) => {
                        return player.canCompare(target);
                    }).set('ai', target => {
                        const { player, goon } = get.event();
                        if (goon && get.attitude(player, target) < 0) return get.effect(target, { name: 'sha' }, player, player);
                        return 0;
                    }).set('goon', goon).setHiddenSkill(event.skill).forResult();
                },
                async content(event, trigger, player) {
                    const target = event.targets[0];
                    let result = await player.chooseToCompare(target).forResult();
                    if (result?.bool) {
                        const targets = game.filterPlayer(current => {
                            return player.canUse('sha', current, false) && get.distance(target, current) == 1;
                        })
                        if (!targets.length) return;
                        result = await player.chooseTarget('是否对至多两名与其距离为1的角色各使用一张杀？', [1, 2], (card, player, target) => {
                            return get.event().targetsx?.includes(target);
                        }).set('ai', target => {
                            const player = get.player();
                            return get.effect(target, { name: 'sha' }, player, player);
                        }).set('targetsx', targets).forResult();
                        if (result?.targets?.length) {
                            for (let targetx of result.targets.sortBySeat()) await player.useCard({ name: 'sha', isCard: true }, targetx, false);
                        }
                    }
                    else player.addTempSkill(event.name + '_effect', { player: 'phaseUseAfter' })
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        mod: {
                            cardEnabled(card) {
                                if (card.name == 'sha') return false;
                            },
                        },
                    }
                }
            },
            //星袁术
            ministarpizhi: {
                audio: 'starpizhi',
                inherit: 'starpizhi',
                trigger: {
                    player: 'phaseJieshuBegin',
                    global: 'die',
                },
                filter(event, player) {
                    let groups = player.getSkills().filter(skill => skill.startsWith('starcanxi_') && lib.group.includes(skill.slice(10))).map(group => group.slice(10));
                    if (event.name == 'phaseJieshu') return groups.length < lib.group.length;
                    if (!game.hasPlayer(current => current != event.player && current.group == event.player.group)) return true;
                    if (!player.getStorage('starcanxi_wangsheng').includes(event.player.group) && !player.getStorage('starcanxi_xiangsi').includes(event.player.group)) return false;
                    return groups.includes(event.player.group);
                },
                async content(event, trigger, player) {
                    if (trigger.name == 'die') {
                        let skills = player.getSkills().filter(skill => skill.startsWith('starcanxi_') && skill.slice(10) == trigger.player.group);
                        player.removeSkill(skills);
                    }
                    const num = lib.group.length - player.getSkills().filter(skill => skill.startsWith('starcanxi_') && lib.group.includes(skill.slice(10))).length;
                    if (num > 0) await player.draw(num);
                    if (player.isDamaged() && trigger.name == 'die') await player.recover();
                },
            },
            ministarzhonggu: {
                audio: 'starzhonggu',
                trigger: { player: 'phaseDrawBegin2' },
                filter(event, player) {
                    return !event.numFixed && game.roundNumber >= game.countPlayer(current => current.group == 'qun');
                },
                forced: true,
                zhuSkill: true,
                async content(event, trigger, player) {
                    trigger.num += 2;
                },
            },
            // SP孙坚
            miniyingyi: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'roundStart' },
                filter(event, player) {
                    return game.hasPlayer(current => current !== player);
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), lib.filter.notMe).set('ai', target => {
                        const player = get.player();
                        const num = Math.max(1, Math.floor(player.hp / 2));
                        if (game.filterPlayer(current => get.attitude(current, player) > 0).reduce((sum, current) => current.countCards('hs', card => current.canSaveCard(card, player)), 0) < num - player.hp) return 0;
                        return -get.sgnAttitude(player, target) * target.countCards('he');
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const num = Math.max(1, Math.floor(player.hp / 2));
                    await player.loseHp(num);
                    const [target] = event.targets;
                    const hs = target.getCards('he').filter(card => get.color(card, target) == 'black');
                    if (!hs.length) return;
                    let { cards } = await target.modedDiscard(hs);
                    while (cards.some(card => get.position(card) == 'd' && player.canUse(get.autoViewAs({ name: 'sha' }, [card]), target, false)) && player.isIn()) {
                        const card = cards.filterInD('d').filter(card => get.position(card) == 'd' && player.canUse(get.autoViewAs({ name: 'sha' }, [card]), target, false)).shift();
                        cards.remove(card);
                        const next = player.useCard({ name: 'sha' }, [card], target, false);
                        await next;
                        if (player.hasHistory('sourceDamage', evt => evt.getParent('useCard') == next)) break;
                    }
                    cards = cards.filterInD('d');
                    if (cards.length) await player.gain(cards, 'gain2');
                    else {
                        player.addTempSkill(event.name + '_effect', 'roundStart');
                        player.markAuto(event.name + '_effect', [target]);
                    }
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '本轮对$使用【杀】无次数限制' },
                        mod: {
                            cardUsableTarget(card, player, target) {
                                if (card.name == 'sha' && player.getStorage('miniyingyi_effect').includes(target)) return true;
                            },
                        },
                    }
                }
            },
            miniliezhi: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'useCardToPlayer' },
                filter(event, player) {
                    return event.targets.length == 1 && player != event.targets[0] && !event.targets[0].hasHistory('damage', evt => evt.source == player);
                },
                usable: 3,
                forced: true,
                async content(event, trigger, player) {
                    await player.draw(player.getHistory('useSkill', evt => evt.skill == event.name).length);
                },
            },
            // 何进
            minimouzhu: {
                audio: 'mouzhu',
                enable: 'phaseUse',
                usable: 1,
                filter(event, player) {
                    return game.hasPlayer(current => lib.skill.minimouzhu.filterTarget(null, player, current));
                },
                filterTarget(card, player, target) {
                    return player != target && target.countCards('h');
                },
                selectTarget: [1, Infinity],
                async content(event, trigger, player) {
                    const { target } = event;
                    if (!player.isIn() || !target.countCards('h')) return;
                    await target.chooseToGive(player, 'h', true);
                    if (!player.isIn() || player.countCards('h') <= target.countCards('h')) return;
                    let list = ['sha', 'juedou'].filter(name => target.canUse(get.autoViewAs({ name, isCard: true }, []), player, false)), result;
                    if (!list.length) {
                        return;
                    } else if (list.length == 1) {
                        result = { control: list[0] };
                    } else {
                        result = await target.chooseControl(list).set('prompt', `视为对${get.translation(player)}使用一张【杀】或【决斗】`).set('ai', function (event, player) {
                            const target = event.player;
                            return get.effect(player, { name: 'sha' }, target, target) >= get.effect(player, { name: 'juedou' }, target, target) ? 'sha' : 'juedou';
                        }).forResult();
                    }
                    if (result?.control) await target.useCard({ name: result.control, isCard: true }, player, 'noai');
                },
                ai: {
                    order: 7,
                    result: {
                        target: -1.2,
                        player(player, target) {
                            if (target.countCards('h') - player.countCards('h') > 1) {
                                return 1;
                            }
                            if (get.damageEffect(target, player, player, player) > 0) {
                                return 1;
                            }
                            if (player.hp > 3 || (player.countCards('h', 'sha') && player.countCards('h', 'shan'))) {
                                return 0;
                            }
                            if (player.hp > 2) {
                                return -1.1;
                            }
                            return -2;
                        }
                    }
                }
            },
            miniyanhuo: {
                inherit: 'spyanhuo',
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(get.prompt2(event.skill), [1, Infinity]).set('ai', target => {
                        const player = get.player();
                        return get.attitude(player, target);
                    }).set('forceDie', true).forResult()
                },
                async content(event, trigger, player) {
                    const targets = event.targets.sortBySeat();
                    for (const target of targets) {
                        target.addSkill(event.name + '_damage');
                        target.addMark(event.name + '_damage', 1, false);
                    }
                },
                subSkill: {
                    damage: {
                        charlotte: true,
                        onremove: true,
                        trigger: { player: 'useCard' },
                        forced: true,
                        filter(event, player) {
                            return event.card.name == 'sha' && player.hasMark('miniyanhuo_damage');
                        },
                        async content(event, trigger, player) {
                            trigger.baseDamage += player.countMark(event.name);
                        },
                        intro: { content: '使用【杀】的伤害值基数+$' },
                    }
                }
            },
            //陶谦
            minizhaohuo: {
                audio: 'zhaohuo',
                inherit: 'zhaohuo',
                async content(event, trigger, player) {
                    const num = player.maxHp - 1;
                    await player.loseMaxHp(num, true);
                    await player.draw(2 * num);
                },
            },
            //徐荣
            minixionghuo: {
                audio: 'xinfu_xionghuo',
                inherit: 'xinfu_xionghuo',
                group: ['xinfu_xionghuo_init', 'xinfu_xionghuo_damage', 'minixionghuo_effect'],
                subSkill: {
                    effect: {
                        audio: 'xinfu_xionghuo',
                        trigger: { global: 'phaseUseBegin' },
                        filter(event, player) {
                            return event.player.countMark('xinfu_xionghuo') > 0 && event.player != player;
                        },
                        line: false,
                        forced: true,
                        locked: false,
                        logTarget: 'player',
                        async content(event, trigger, player) {
                            const target = trigger.player;
                            target.clearMark('xinfu_xionghuo');
                            switch (get.rand(0, 2)) {
                                case 0: {
                                    player.line(target, 'fire');
                                    await target.damage('fire');
                                    target.addTempSkill('xinfu_xionghuo_disable');
                                    target.markAuto('xinfu_xionghuo_disable', [player]);
                                    break;
                                }
                                case 1: {
                                    player.line(target, 'water');
                                    await target.loseHp();
                                    target.addMark('xinfu_xionghuo_low', 1, false);
                                    target.addTempSkill('xinfu_xionghuo_low');
                                    break;
                                }
                                case 2: {
                                    player.line(target, 'green');
                                    let cards = [];
                                    ['h', 'e'].forEach(position => {
                                        const card = target.getGainableCards(player, position).randomGet();
                                        if (card) cards.push(card);
                                    });
                                    if (cards.length) await player.gain(cards.randomGets(2), target, 'giveAuto', 'bySelf');
                                    break;
                                }
                            }
                            await game.delay();
                        },
                    },
                },
            },
            minishajue: {
                audio: 'xinfu_shajue',
                inherit: 'xinfu_shajue',
                filter(event, player) {
                    return event.player !== player;
                },
                logTarget: 'player',
                async content(event, trigger, player) {
                    player.addMark('xinfu_xionghuo', 1);
                    if (trigger.player.hp < 0) {
                        const cards = trigger.getParent().cards;
                        if (get.itemtype(cards) === 'cards' && cards.someInD('od')) await player.gain(cards.filterInD('od'), 'gain2');
                    }
                },
                ai: { combo: ['xinfu_xionghuo', 'minixionghuo', 'minixionghuo'] },
            },
            //刘表
            minizishou: {
                audio: 'zishou',
                inherit: 'zishou',
                content() {
                    trigger.num += 2;
                    player.addTempSkill("zishou2");
                },
            },
            minizongshi: {
                audio: 'zongshi',
                mod: {
                    maxHandcard(player, num) {
                        return num + 2;
                    },
                },
            },
            //神
            miniwuqian: {
                derivation: 'wushuang',
                audio: 'ol_wuqian',
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    if (!_status.currentPhase || player != _status.currentPhase) return false;
                    if (!['sha', 'juedou'].includes(event.card.name) || !event.isFirstTarget) return false;
                    return player.getHistory('useCard', function (evt) {
                        return (evt.card.name == 'sha' || evt.card.name == 'juedou');
                    }).indexOf(event.getParent()) == 0;
                },
                forced: true,
                logTarget: 'targets',
                content() {
                    for (var target of trigger.targets) {
                        target.addTempSkill('qinggang2');
                        target.storage.qinggang2.add(trigger.card);
                        if (trigger.card.name == 'sha') {
                            var id = target.playerid;
                            var map = trigger.getParent().customArgs;
                            if (!map[id]) map[id] = {};
                            if (typeof map[id].shanRequired == 'number') map[id].shanRequired++;
                            else map[id].shanRequired = 2;
                        }
                        else {
                            var id = target.playerid;
                            var idt = target.playerid;
                            var map = trigger.getParent().customArgs;
                            if (!map[idt]) map[idt] = {};
                            if (!map[idt].shaReq) map[idt].shaReq = {};
                            if (!map[idt].shaReq[id]) map[idt].shaReq[id] = 1;
                            map[idt].shaReq[id]++;
                        }
                    }
                },
                ai: {
                    unequip_ai: true,
                    skillTagfilter(player, tag, arg) {
                        if (arg?.card && !player.getHistory('useCard', function (evt) {
                            return (evt.card.name == 'sha' || evt.card.name == 'juedou');
                        }).length && ['sha', 'juedou'].includes(arg.card.name)) return true;
                        return false;
                    },
                },
            },
            minishenfen: {
                mark: true,
                limited: true,
                audio: 'ol_shenfen',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.hp > 3;
                },
                skillAnimation: true,
                animationColor: 'metal',
                content() {
                    'step 0'
                    player.awakenSkill('minishenfen');
                    player.loseHp(3);
                    event.delay = false;
                    event.targets = game.filterPlayer();
                    event.targets.remove(player);
                    event.targets.sort(lib.sort.seat);
                    player.line(event.targets, 'green');
                    event.targets2 = event.targets.slice(0);
                    event.targets3 = event.targets.slice(0);
                    'step 1'
                    if (event.targets2.length) {
                        event.targets2.shift().damage('nocard');
                        event.redo();
                    }
                    'step 2'
                    if (event.targets.length) {
                        event.current = event.targets.shift()
                        if (event.current.countCards('e')) event.delay = true;
                        event.current.discard(event.current.getCards('e')).delay = false;
                    }
                    'step 3'
                    if (event.delay) game.delay(0.5);
                    event.delay = false;
                    if (event.targets.length) event.goto(2);
                    'step 4'
                    if (event.targets3.length) {
                        var target = event.targets3.shift();
                        target.chooseToDiscard(4, 'h', true).delay = false;
                        if (target.countCards('h')) event.delay = true;
                    }
                    'step 5'
                    if (event.delay) game.delay(0.5);
                    event.delay = false;
                    if (event.targets3.length) event.goto(4);
                },
                ai: {
                    order: 10,
                    result: {
                        player(player) {
                            if (player.hp < 5 || player.hasUnknown()) return 0;
                            return game.countPlayer(function (current) {
                                if (current != player) {
                                    return Math.sign(get.damageEffect(current, player, player));
                                }
                            });
                        },
                    },
                },
            },
            minishelie: {
                audio: 'shelie',
                inherit: 'shelie',
                forced: true,
            },
            minigongxin: {
                audio: 'gongxin',
                audioname: ['re_lvmeng'],
                audioname2: { gexuan: 'gongxin_gexuan' },
                trigger: { player: 'useCardToPlayered', target: 'useCardToTargeted' },
                filter(event, player) {
                    if (event.player == event.target || event.targets.length != 1) return false;
                    return (player == event.player ? event.target : event.player).countCards('h');
                },
                logTarget(event, player) {
                    return player == event.player ? event.target : event.player;
                },
                check(event, player) {
                    return get.attitude(player, player == event.player ? event.target : event.player) <= 0;
                },
                usable: 1,
                content() {
                    'step 0'
                    var target = (player == trigger.player ? trigger.target : trigger.player);
                    event.target = target;
                    event.videoId = lib.status.videoId++;
                    var cards = target.getCards('h');
                    if (player.isOnline2()) {
                        player.send(function (cards, id) {
                            ui.create.dialog('攻心', cards).videoId = id;
                        }, cards, event.videoId);
                    }
                    event.dialog = ui.create.dialog('攻心', cards);
                    event.dialog.videoId = event.videoId;
                    if (!event.isMine()) {
                        event.dialog.style.display = 'none';
                    }
                    player.chooseButton().set('filterButton', function (button) {
                        return get.color(button.link) == 'red';
                    }).set('dialog', event.videoId).set('ai', function (button) {
                        return get.value(button.link);
                    });
                    'step 1'
                    if (result.bool) {
                        event.card = result.links[0];
                        var func = function (card, id) {
                            var dialog = get.idDialog(id);
                            if (dialog) {
                                for (var i = 0; i < dialog.buttons.length; i++) {
                                    if (dialog.buttons[i].link == card) {
                                        dialog.buttons[i].classList.add('selectedx');
                                    }
                                    else {
                                        dialog.buttons[i].classList.add('unselectable');
                                    }
                                }
                            }
                        }
                        if (player.isOnline2()) {
                            player.send(func, event.card, event.videoId);
                        }
                        else if (event.isMine()) {
                            func(event.card, event.videoId);
                        }
                        player.chooseControl('获得此牌', '置于牌堆顶');
                    }
                    else {
                        if (player.isOnline2()) {
                            player.send('closeDialog', event.videoId);
                        }
                        event.dialog.close();
                        event.finish();
                    }
                    'step 2'
                    if (player.isOnline2()) {
                        player.send('closeDialog', event.videoId);
                    }
                    event.dialog.close();
                    var card = event.card;
                    if (result.control == '置于牌堆顶') {
                        player.showCards(card, '置于牌堆顶');
                        target.lose(card, ui.cardPile, 'insert', 'visible');
                        game.log(player, '将', event.card, '置于牌堆顶');
                    }
                    else player.gain(card, target, 'give');
                },
                ai: { expose: 0.25 },
            },
            minikuangfeng: {
                audio: 'kuangfeng',
                trigger: { player: 'phaseUseEnd' },
                filter(event, player) {
                    return player.getExpansions('qixing').length;
                },
                direct: true,
                content() {
                    'step 0'
                    var num = Math.min(game.countPlayer(), player.getExpansions('qixing').length);
                    player.chooseTarget(get.prompt2('minikuangfeng'), [1, num]).set('ai', target => {
                        var player = _status.event.player;
                        return get.damageEffect(target, player, player);
                    }).set('animate', false);
                    'step 1'
                    if (result.bool) {
                        var targets = event.targets = result.targets.sortBySeat();
                        player.chooseButton(['请选择要移去的“星”', player.getExpansions('qixing')], targets.length, true).set('ai', button => -get.value(button.link));
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        player.logSkill(event.name, targets);
                        player.loseToDiscardpile(result.links);
                    }
                    else event.finish();
                    'step 3'
                    for (var i of targets) i.damage();
                },
                ai: { combo: 'qixing' },
            },
            minidawu: {
                audio: 'dawu',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return player.getExpansions('qixing').length;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseButton([get.prompt('minidawu'), player.getExpansions('qixing')]).set('ai', button => {
                        var player = _status.event.player;
                        if (!game.hasPlayer(current => get.attitude(current, player) < 0)) return 0;
                        return 1 / Math.max(0.01, get.value(button.link));
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minidawu');
                        player.loseToDiscardpile(result.links);
                        player.addTempSkill('minidawu_damage', { player: 'phaseBegin' });
                    }
                },
                ai: { combo: 'qixing' },
                subSkill: {
                    damage: {
                        charlotte: true,
                        mark: true,
                        intro: { content: '受到的非属性伤害-1' },
                        trigger: { player: 'damageBegin3' },
                        filter(event) {
                            return event.num > 0 && !event.nature;
                        },
                        forced: true,
                        content() {
                            trigger.num--;
                        },
                        ai: {
                            effect: {
                                target(card, player, target) {
                                    if (player.hasSkillTag('jueqing', false, target)) return;
                                    if (get.nature(card)) return;
                                    var num = get.tag(card, 'damage');
                                    if (num) {
                                        if (num > 1) return 0.5;
                                        return 0;
                                    }
                                },
                            },
                        },
                    },
                },
            },
            miniguixin: {
                audio: 'guixin',
                trigger: { player: 'damageEnd' },
                check(event, player) {
                    if (player.isTurnedOver() || event.num > 1 || (game.countPlayer() - 1 < 5 && game.countPlayer(function (current) {
                        return get.attitude(player, current) <= 0 && current.countGainableCards(player, 'hej') > 0;
                    }) >= game.countPlayer(function (currentx) {
                        return get.attitude(player, currentx) > 0 && currentx.countGainableCards(player, 'hej') > 0;
                    }))) return true;
                    var num = game.countPlayer(function (current) {
                        if (current.countCards('he') && current != player && get.attitude(player, current) <= 0) return true;
                        if (current.countCards('j') && current != player && get.attitude(player, current) > 0) return true;
                    });
                    return num >= 2;
                },
                content() {
                    'step 0'
                    var targets = game.filterPlayer();
                    targets.remove(player);
                    targets.sort(lib.sort.seat);
                    event.targets = targets;
                    event.count = trigger.num;
                    'step 1'
                    event.count--;
                    event.num = 0;
                    event.numx = 0;
                    player.line(targets, 'green');
                    player.chooseControl('手牌区', '装备区', '判定区').set('ai', function () {
                        if (game.hasPlayer(function (current) {
                            return current.countCards('j') && current != player && get.attitude(player, current) > 0;
                        })) return 2;
                        return Math.floor(Math.random() * 3);
                    }).set('prompt', '请选择优先获得的区域');
                    'step 2'
                    event.range = {
                        手牌区: ['h', 'e', 'j'],
                        装备区: ['e', 'h', 'j'],
                        判定区: ['j', 'h', 'e'],
                    }[result.control || '手牌区'];
                    'step 3'
                    if (num < event.targets.length) {
                        var target = event.targets[num];
                        var range = event.range;
                        for (var i = 0; i < range.length; i++) {
                            var cards = target.getCards(range[i]);
                            if (cards.length) {
                                var card = cards.randomGet();
                                event.numx++;
                                player.gain(card, target, 'giveAuto', 'bySelf');
                                break;
                            }
                        }
                        event.num++;
                    }
                    'step 4'
                    if (num < event.targets.length) event.goto(3);
                    'step 5'
                    if (event.numx > 4 && !player.isTurnedOver()) player.turnOver();
                    'step 6'
                    if (event.count > 0 && player.hasSkill('miniguixin')) player.chooseBool(get.prompt2('new_guixin')).ai = function () {
                        return lib.skill.miniguixin.check({ num: event.count }, player);
                    };
                    else event.finish();
                    'step 7'
                    if (event.count && result.bool) event.goto(1);
                },
                ai: {
                    maixie: true,
                    maixie_hp: true,
                    threaten(player, target) {
                        if (target.hp == 1) return 2.5;
                        return 1;
                    },
                    effect: {
                        target(card, player, target) {
                            if (get.tag(card, 'damage')) {
                                if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                if (target.hp == 1) return 0.8;
                                if (target.isTurnedOver()) return [0, 3];
                                var num = game.countPlayer(function (current) {
                                    if (current.countCards('he') && current != player && get.attitude(player, current) <= 0) {
                                        return true;
                                    }
                                    if (current.countCards('j') && current != player && get.attitude(player, current) > 0) {
                                        return true;
                                    }
                                });
                                if (num > 2) return [0, 1];
                                if (num == 2) return [0.5, 1];
                            }
                        },
                    },
                },
            },
            miniwushen: {
                mod: {
                    cardnature(card) {
                        if (get.suit(card) == 'heart' && get.name(card) == 'sha') return false;
                    },
                    targetInRange(card) {
                        if (get.suit(card) == 'heart' && get.name(card) == 'sha') return true;
                    },
                },
                group: 'miniwushen_wusheng',
                audio: 'wushen',
                trigger: { source: 'damageBegin1' },
                forced: true,
                locked: false,
                filter(event, player) {
                    return event.card && event.card.name == 'sha' && get.suit(event.card) == 'heart';
                },
                content() {
                    trigger.num++;
                },
                ai: {
                    effect: {
                        target(card, player, target, current) {
                            if (get.tag(card, 'respondSha') && current < 0) return 0.6
                        },
                    },
                    directHit_ai: true,
                    skillTagfilter(player, tag, arg) {
                        return arg.card.name == 'sha' && get.suit(arg.card) == 'heart';
                    },
                },
                subSkill: {
                    wusheng: {
                        audio: 'wushen',
                        enable: ['chooseToRespond', 'chooseToUse'],
                        filterCard(card, player) {
                            return get.suit(card) == 'heart';
                        },
                        position: 'hs',
                        viewAs: { name: 'sha' },
                        viewAsFilter(player) {
                            if (!player.countCards('hs', { suit: 'heart' })) return false;
                            return true;
                        },
                        prompt: '将一张红桃手牌当作杀使用或打出',
                        check(card) {
                            var val = get.value(card);
                            if (_status.event.name == 'chooseToRespond') return 1 / Math.max(0.1, val);
                            return 8 - val;
                        },
                        ai: {
                            respondSha: true,
                            skillTagFilter(player) {
                                if (!player.countCards('hs', { suit: 'heart' })) return false;
                                return true;
                            },
                        },
                    },
                },
            },
            miniwuhun: {
                audio: 'wuhun2',
                group: ['miniwuhun_mark', 'miniwuhun_die'],
                trigger: { player: 'damageEnd' },
                filter(event, player) {
                    return event.source && event.source.isIn();
                },
                forced: true,
                logTarget: 'source',
                content() {
                    trigger.source.addMark('miniwuhun_mark', trigger.num);
                },
                subSkill: {
                    die: {
                        audio: 'wuhun2',
                        skillAnimation: true,
                        animationColor: 'soil',
                        trigger: { player: ['die', 'dyingAfter'] },
                        filter(event, player) {
                            if (event.name == 'dying' && !player.isIn()) return false;
                            return game.hasPlayer(current => current != player && current.hasMark('miniwuhun_mark'));
                        },
                        forced: true,
                        forceDie: true,
                        content() {
                            'step 0'
                            var num = game.findPlayer(target => target != player && !game.hasPlayer(current => current != player && current.countMark('miniwuhun_mark') > target.countMark('miniwuhun_mark'))).countMark('miniwuhun_mark');
                            player.chooseTarget('请选择【武魂】的目标', function (card, player, target) {
                                return target != player && target.countMark('miniwuhun_mark') == _status.event.num;
                            }).set('ai', function (target) {
                                return -get.attitude(_status.event.player, target);
                            }, true).set('forceDie', true).set('num', num);
                            'step 1'
                            if (result.bool) {
                                var target = result.targets[0];
                                event.target = target;
                                player.line(target, { color: [255, 255, 0] });
                                game.delay(2);
                            }
                            'step 2'
                            target.judge(card => ['tao', 'taoyuan'].includes(card.name) ? 10 : -10);
                            'step 3'
                            if (!result.bool) target.loseHp(5);
                        },
                    },
                    mark: {
                        marktext: '魇',
                        intro: {
                            name: '梦魇',
                            content: 'mark',
                        },
                    },
                },
                ai: {
                    threaten: 0.01,
                    notemp: true,
                },
            },
            miniyeyan: {
                audio: 'yeyan',
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('miniyeyan'), lib.filter.notMe).set('ai', target => {
                        var player = _status.event.player;
                        return get.damageEffect(target, player, player);
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('miniyeyan', result.targets[0]);
                        result.targets[0].damage('fire');
                    }
                },
            },
            miniqinyin: {
                audio: 'qinyin',
                trigger: { player: 'phaseDiscardEnd' },
                filter(event, player) {
                    return player.getHistory('lose', function (evt) {
                        return evt.type == 'discard' && evt.getParent('phaseDiscard') == event;
                    }).length;
                },
                direct: true,
                content() {
                    'step 0'
                    event.forceDie = true;
                    var list = ['失去体力', '回复体力', '摸牌', 'cancel2'];
                    player.chooseControl(list).set('ai', function () {
                        var player = _status.event.player;
                        var list = [
                            game.filterPlayer().reduce((sum, target) => sum + get.effect(target, { name: 'losehp' }, player, player), 0),
                            player.getUseValue({ name: 'taoyuan' }),
                            player.getUseValue({ name: 'wugu' }),
                            0,
                        ];
                        var num = list.slice().sort((a, b) => b - a)[0];
                        return _status.event.controls[list.indexOf(num)];
                    }).set('prompt', get.prompt2('miniqinyin'));
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('miniqinyin');
                        if (result.control == '失去体力') game.playAudio('skill', 'qinyin2');
                        else game.playAudio('skill', 'qinyin1');
                        if (result.control == '摸牌') game.asyncDraw(game.filterPlayer());
                        else {
                            game.filterPlayer().forEach(target => target[result.control == '失去体力' ? 'loseHp' : 'recover']());
                            event.finish();
                        }
                    }
                    else event.finish();
                    'step 2'
                    game.delayx();
                },
                ai: { expose: 0.2 },
            },
            minilongnu: {
                audio: 'nzry_longnu',
                trigger: { player: 'phaseUseBegin' },
                forced: true,
                content() {
                    'step 0'
                    var list = [
                        '失去1点体力并摸两张牌，本回合你的红色手牌均视为火杀且无距离限制',
                        '减1点体力上限，本回合你的黑色手牌均视为雷杀且无使用次数限制'
                    ];
                    player.chooseControl().set('choiceList', list).set('ai', function () {
                        if (player.countCards() <= 3 && player.maxHp - player.hp <= 1) return 0;
                        return 1;
                    });
                    'step 1'
                    if (result.index == 0) {
                        player.loseHp();
                        player.draw(2);
                        player.addTempSkill('minilongnu_1');
                    }
                    else {
                        player.loseMaxHp();
                        player.addTempSkill('minilongnu_2');
                    }
                },
                subSkill: {
                    '1': {
                        mod: {
                            cardname(card, player) {
                                if (get.color(card) == 'red') return 'sha';
                            },
                            cardnature(card, player) {
                                if (get.color(card) == 'red') return 'fire';
                            },
                            targetInRange(card) {
                                if (card.name == 'sha' && card.hasNature('fire')) return true;
                            },
                        },
                        ai: {
                            respondSha: true,
                            effect: {
                                target(card, player, target, current) {
                                    if (get.tag(card, 'respondSha') && current < 0) return 0.6
                                },
                            },
                        },
                    },
                    '2': {
                        mod: {
                            cardname(card, player) {
                                if (get.color(card) == 'black') return 'sha';
                            },
                            cardnature(card, player) {
                                if (get.color(card) == 'black') return 'thunder';
                            },
                            cardUsable(card, player) {
                                if (card.name == 'sha' && card.hasNature('thunder')) return Infinity;
                            },
                        },
                        ai: {
                            respondSha: true,
                            effect: {
                                target(card, player, target, current) {
                                    if (get.tag(card, 'respondSha') && current < 0) return 0.6
                                },
                            },
                        },
                    },
                },
                ai: {
                    fireAttack: true,
                    halfneg: true,
                },
            },
            minijieyig: {
                audio: 'nzry_jieying',
                locked: true,
                global: 'minijieyig_all',
                group: ['minijieyig_1', 'minijieyig_2', 'minijieyig_3'],
                subSkill: {
                    '1': {
                        audio: 'nzry_jieying',
                        trigger: { player: ['linkBefore', 'enterGame'], global: 'phaseBefore' },
                        forced: true,
                        filter(event, player) {
                            if (event.name == 'link') return player.isLinked();
                            return (event.name != 'phase' || game.phaseNumber == 0) && !player.isLinked();
                        },
                        content() {
                            if (trigger.name != 'link') player.link(true);
                            else trigger.cancel();
                        },
                    },
                    '2': {
                        trigger: { player: 'phaseJieshuBegin' },
                        direct: true,
                        filter(event, player) {
                            return game.hasPlayer(function (current) {
                                return current != player && !current.isLinked();
                            });
                        },
                        content() {
                            'step 0'
                            player.chooseTarget(get.prompt('minijieyig'), '横置一名其他角色', function (card, player, target) {
                                return target != player && !target.isLinked();
                            }).ai = function (target) {
                                return 1 + Math.random();
                            };
                            'step 1'
                            if (result.bool) {
                                player.logSkill('minijieyig', result.targets[0]);
                                result.targets[0].link(true);
                            }
                            else event.finish();
                        },
                    },
                    '3': {
                        audio: 'nzry_jieying',
                        trigger: { player: 'damageBegin2' },
                        forced: true,
                        content() {
                            player.draw();
                        },
                    },
                    all: {
                        mod: {
                            maxHandcard(player, num) {
                                if (player.isLinked()) return num + 2 * game.countPlayer(function (current) {
                                    return current.hasSkill('minijieyig');
                                });
                            },
                        },
                    },
                },
                ai: {
                    effect: {
                        target(card) {
                            if (card.name == 'tiesuo') return 'zeroplayertarget';
                        },
                    },
                },
            },
            miniduorui: {
                audio: 'drlt_duorui',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current != player && current.countCards('h');
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('miniduorui'), function (card, player, target) {
                        if (player == target) return false;
                        return target.countCards('h');
                    }).set('ai', function (target) {
                        return -get.attitude(player, target) * (target.getDamagedHp() + 1);
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('miniduorui', result.targets[0]);
                        player.gainPlayerCard(result.targets[0], 'h', true, 'visible');
                        result.targets[0].addTempSkill('miniduorui_target');
                    }
                    else event.finish();
                    'step 2'
                    player.popup(get.translation(get.color(result.cards[0])));
                    player.addTempSkill('miniduorui_' + get.color(result.cards[0]));
                },
                subSkill: {
                    target: { charlotte: true },
                    red: {
                        audio: 'drlt_duorui',
                        trigger: { player: 'useCard' },
                        forced: true,
                        filter(event, player) {
                            return event.card && get.color(event.card) == 'red';
                        },
                        content() {
                            trigger.directHit.addArray(game.filterPlayer(function (current) {
                                return current.hasSkill('miniduorui_target');
                            }));
                        },
                        ai: {
                            directHit_ai: true,
                            skillTagFilter(player, tag, arg) {
                                return arg.target.hasSkill('miniduorui_target') && get.color(arg.card) == 'red';
                            },
                        },
                    },
                    black: {
                        audio: 'drlt_duorui',
                        trigger: { player: 'useCard' },
                        forced: true,
                        filter(event, player) {
                            return event.card && get.color(event.card) == 'black';
                        },
                        content() {
                            trigger.directHit.addArray(game.filterPlayer(function (current) {
                                return current.hasSkill('miniduorui_target');
                            }));
                        },
                        ai: {
                            directHit_ai: true,
                            skillTagFilter(player, tag, arg) {
                                return arg.target.hasSkill('miniduorui_target') && get.color(arg.card) == 'black';
                            },
                        },
                    },
                },
            },
            minizhiti: {
                mod: {
                    cardUsable(card, player, num) {
                        if (card.name == 'sha' && game.countPlayer(function (current) {
                            return current.isDamaged();
                        }) > 2) return num + 1;
                    },
                },
                audio: 'drlt_zhiti',
                trigger: { player: 'phaseDrawBegin2' },
                forced: true,
                filter(event, player) {
                    return game.countPlayer(function (current) {
                        return current.isDamaged();
                    }) > 1;
                },
                content() {
                    trigger.num++;
                },
            },
            //劝退
            miniquanxue: {
                marktext: '学',
                intro: { content: 'mark', name2: '学' },
                audio: 'ext:活动武将/audio/skill:1',
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    game.addGlobalSkill('miniquanxue_remove');
                    player.chooseTarget(get.prompt2('miniquanxue'), [1, 2], lib.filter.notMe).set('ai', function (target) {
                        return !target.hasMark('miniquanxue') && -get.attitude(player, target);
                    });
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        player.logSkill('miniquanxue', targets);
                        for (var i of targets) i.addMark('miniquanxue', 1);
                    }
                },
                ai: {
                    threaten: 4.5,
                    expose: 0.25,
                },
                subSkill: {
                    remove: {
                        charlotte: true,
                        trigger: { player: 'phaseBegin' },
                        filter(event, player) {
                            return player.hasMark('miniquanxue') && game.hasPlayer(function (current) {
                                return current.hasSkill('miniquanxue');
                            });
                        },
                        forced: true,
                        content() {
                            'step 0'
                            player.removeMark('miniquanxue', player.countMark('miniquanxue'));
                            'step 1'
                            player.chooseControl().set('choiceList', [
                                '本回合不能对其他角色使用牌',
                                '失去1点体力',
                            ]).set('ai', function () {
                                if ((player.countCards('h') < player.getHandcardLimit()) || player.hp <= 2) return 0;
                                return 1;
                            });
                            'step 2'
                            if (result.index == 0) player.addTempSkill('miniquanxue_block');
                            else player.loseHp();
                        },
                    },
                    block: {
                        mark: true,
                        intro: { content: '不能对其他角色使用牌' },
                        mod: {
                            playerEnabled(card, player, target) {
                                if (player != target) return false;
                            },
                        },
                    },
                },
            },
            minishehu: {
                trigger: { player: 'useCardToPlayer' },
                filter(event, player) {
                    return event.card.name == 'sha' && event.target.hasMark('miniquanxue') && event.target.countCards('h');
                },
                forced: true,
                logTarget: 'target',
                content() {
                    player.discardPlayerCard('h', true, trigger.target);
                },
                ai: {
                    unequip_ai: true,
                    combo: 'miniquanxue',
                    skillTagFilter(player, tag, arg) {
                        if (arg?.name == 'sha' && arg.target && arg.target.hasMark('miniquanxue')) return true;
                        return false;
                    },
                },
            },
            minidingli: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'logSkill' },
                filter(event, player) {
                    return event.skill == 'miniquanxue_remove' && event.player != player;
                },
                check(event, player) {
                    if (event.player.hp >= player.hp && player.isHealthy()) return false;
                    return true;
                },
                round: 1,
                logTarget: 'player',
                content() {
                    if (trigger.player.hp >= player.hp) player.recover();
                    else player.draw(Math.min(2, player.hp - trigger.player.hp));
                },
                ai: { combo: 'miniquanxue' },
            },
            minirenjie: {
                group: 'minirenjie_lose',
                audio: 'renjie2',
                trigger: { player: ['enterGame', 'damageEnd'], global: 'phaseBefore' },
                filter(event, player) {
                    if (event.num == 'damage') return event.num > 0;
                    return event.name != 'phase' || game.phaseNumber == 0;
                },
                notemp: true,
                forced: true,
                content() {
                    player.addMark('minirenjie', trigger.num || 1);
                },
                marktext: '忍',
                intro: { name: '忍', content: 'mark' },
                subSkill: {
                    lose: {
                        audio: 'renjie2',
                        trigger: { player: 'loseAfter' },
                        filter(event, player) {
                            if (event.type != 'discard' || !event.cards2) return false;
                            var evt = event.getParent('phaseDiscard');
                            return evt?.name == 'phaseDiscard' && evt.player == player;
                        },
                        forced: true,
                        content() {
                            player.addMark('minirenjie', trigger.cards2.length);
                        },
                    },
                },
            },
            minijilve: {
                audio: 'jilue',
                derivation: ['minijilve_guicai', 'minijilve_fangzhu', 'minijilve_wansha', 'minijilve_jizhi'],
                group: ['minijilve_guicai', 'minijilve_fangzhu', 'minijilve_wansha', 'minijilve_jizhi'],
                trigger: { player: ['useSkill', 'logSkillBegin'] },
                filter(event, player) {
                    if (!lib.skill.minijilve.derivation.includes(event.skill)) return false;
                    return player.getHistory('useSkill', evt => lib.skill.minijilve.derivation.includes(evt.skill)).length == 1;
                },
                frequent: true,
                content() {
                    player.draw();
                },
                subSkill: {
                    guicai: {
                        audio: 'jilue_guicai',
                        trigger: { global: 'judge' },
                        filter(event, player) {
                            return player.countCards('hes') && player.hasMark('minirenjie');
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseCard(get.prompt2('minijilve_guicai'), 'hes', function (card) {
                                var player = _status.event.player;
                                var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                                if (mod2 != 'unchanged') return mod2;
                                var mod = game.checkMod(card, player, 'unchanged', 'cardRespondable', player);
                                if (mod != 'unchanged') return mod;
                                return true;
                            }).set('ai', function (card) {
                                var trigger = _status.event.getTrigger();
                                var player = _status.event.player;
                                var judging = _status.event.judging;
                                var result = trigger.judge(card) - trigger.judge(judging);
                                var attitude = get.attitude(player, trigger.player);
                                if (attitude == 0) {
                                    if (player.isDamaged() && get.suit(card, player) == 'heart') return 10;
                                    if (get.suit(card, player) == 'club') return 8;
                                    return 0;
                                }
                                if (attitude > 0) {
                                    if (result == 0) {
                                        if (player.isDamaged() && get.suit(card, player) == 'heart') return 10;
                                        if (get.suit(card, player) == 'club') return 8;
                                        return 0;
                                    }
                                    return result - get.value(card) / 2;
                                }
                                else {
                                    if (result == 0) {
                                        if (player.isDamaged() && get.suit(card) == 'heart') return 10;
                                        if (get.suit(card) == 'club') return 8;
                                        return 0;
                                    }
                                    return -result - get.value(card) / 2;
                                }
                            }).set('judging', trigger.player.judging[0]);
                            'step 1'
                            if (result.bool) player.respond(result.cards, 'highlight', 'minijilve_guicai', 'noOrdering');
                            else event.finish();
                            'step 2'
                            if (result.bool) {
                                player.removeMark('minirenjie', 1);
                                if (trigger.player.judging[0].clone) {
                                    trigger.player.judging[0].clone.delete();
                                    game.addVideo('deletenode', player, get.cardsInfo([trigger.player.judging[0].clone]));
                                }
                                game.cardsDiscard(trigger.player.judging[0]);
                                trigger.player.judging[0] = result.cards[0];
                                trigger.orderingCards.addArray(result.cards);
                                game.log(trigger.player, '的判定牌改为', result.cards[0]);
                                game.delay(2);
                                event.card = result.cards[0];
                            }
                            else event.finish();
                            'step 3'
                            if (get.suit(card, player) == 'heart') player.recover();
                            if (get.suit(card, player) == 'club') player.draw(2);
                        },
                        ai: {
                            rejudge: true,
                            tag: { rejudge: 1 },
                        },
                    },
                    fangzhu: {
                        audio: 'jilue_fangzhu',
                        trigger: { player: 'damageEnd' },
                        filter(event, player) {
                            return player.hasMark('minirenjie');
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseTarget(get.prompt2('minijilve_fangzhu'), lib.filter.notMe).ai = function (target) {
                                if (target.hasSkillTag('noturn')) return 0;
                                if (target.isTurnedOver()) return get.attitude(player, target);
                                return -get.attitude(player, target);
                            }
                            'step 1'
                            if (result.bool) {
                                var target = result.targets[0];
                                player.logSkill('minijilve_fangzhu', target);
                                player.removeMark('minirenjie', 1);
                                target.turnOver();
                                target.draw();
                            }
                        },
                        ai: {
                            maixie: true,
                            maixie_hp: true,
                            effect: {
                                target(card, player, target) {
                                    if (get.tag(card, 'damage')) {
                                        if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                        if (target.hp <= 1) return;
                                        if (!target.hasFriend()) return;
                                        var hastarget = false;
                                        var turnfriend = false;
                                        var players = game.filterPlayer();
                                        for (var i = 0; i < players.length; i++) {
                                            if (get.attitude(target, players[i]) < 0 && !players[i].isTurnedOver()) {
                                                hastarget = true;
                                            }
                                            if (get.attitude(target, players[i]) > 0 && players[i].isTurnedOver()) {
                                                hastarget = true;
                                                turnfriend = true;
                                            }
                                        }
                                        if (get.attitude(player, target) > 0 && !hastarget) return;
                                        if (turnfriend || target.hp == target.maxHp) return [0.5, 1];
                                        if (target.hp > 1) return [1, 0.5];
                                    }
                                },
                            },
                        },
                    },
                    wansha: {
                        audio: 'jilue_wansha',
                        trigger: { global: 'dying' },
                        filter(event, player) {
                            if (!_status.currentPhase || player.hasSkill('minijilve_miniwansha')) return false;
                            return player.hasMark('minirenjie') && player == _status.currentPhase;
                        },
                        check(event, player) {
                            return get.attitude(player, event.player) < 0;
                        },
                        logTarget: 'player',
                        content() {
                            player.removeMark('minirenjie', 1);
                            player.addTempSkill('minijilve_miniwansha', ['phaseBefore', 'phaseChange', 'phaseAfter']);
                            game.log(player, '获得了', '#g【完杀】', '效果');
                        },
                    },
                    miniwansha: {
                        charlotte: true,
                        global: 'minijilve_miniwanshax',
                        mark: true,
                        marktext: '杀',
                        intro: { content: () => lib.translate.miniwansha_info },
                    },
                    miniwanshax: {
                        mod: {
                            cardSavable(card, player) {
                                if (!_status.currentPhase || !_status.currentPhase.hasSkill('minijilve_miniwansha')) return;
                                if (player != _status.currentPhase && card.name == 'tao') return false;
                            },
                            cardEnabled(card, player) {
                                if (!_status.currentPhase || !_status.currentPhase.hasSkill('minijilve_miniwansha')) return;
                                if (player != _status.currentPhase && card.name == 'tao') return false;
                            },
                        },
                    },
                    jizhi: {
                        audio: 'jilue_jizhi',
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            return get.type2(event.card) == 'trick' && event.card.isCard && player.hasMark('minirenjie');
                        },
                        content() {
                            'step 0'
                            player.removeMark('minirenjie', 1);
                            player.draw();
                            'step 1'
                            var card = result[0];
                            event.card = card;
                            if (['basic', 'trick', 'equip'].includes(get.type2(card))) {
                                if (['basic', 'trick'].includes(get.type2(card))) {
                                    player.addTempSkill('minijizhi_' + get.type2(card));
                                    player.addMark('minijizhi_' + get.type2(card), 1, false);
                                    event.finish();
                                }
                                else player.chooseTarget('集智：是否将' + get.translation(card) + '置入一名其他角色的装备栏？', function (card, player, target) {
                                    return target != player && target.canEquip(_status.event.card);
                                }).set('card', card).set('ai', function (target) {
                                    var player = _status.event.player;
                                    var card = _status.event.card;
                                    if ((player.canEquip(_status.event.card) || get.equipValue(_status.event.card, target) < 0) && get.equipValue(card) > 0) return 0;
                                    return get.attitude(player, target);
                                });
                            }
                            else event.finish();
                            'step 2'
                            if (result.bool) {
                                var target = result.targets[0];
                                player.line(target);
                                player.$give(card, target, false);
                                game.delay(0.5);
                                target.equip(card);
                            }
                        },
                    },
                },
            },
            minijuejing: {
                mod: {
                    maxHandcard(player, num) {
                        return num + 3;
                    },
                },
                audio: 'xinjuejing',
                inherit: 'xinjuejing',
            },
            minilonghun: {
                audio: 'relonghun',
                inherit: 'relonghun',
                group: ['minilonghun_num', 'minilonghun_gain'],
                subSkill: {
                    num: {
                        charlotte: true,
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            return event.skill == 'minilonghun' && ['sha', 'tao'].includes(event.card.name) && event.cards?.length == 2;
                        },
                        forced: true,
                        popup: false,
                        content() {
                            trigger.baseDamage++;
                            player.draw();
                        },
                    },
                    gain: {
                        charlotte: true,
                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                        autodelay(event) {
                            return event.name == 'respond' ? 0.5 : false;
                        },
                        filter(event, player) {
                            return event.skill == 'minilonghun' && ['shan', 'wuxie'].includes(event.card.name) && event.cards?.length == 2 && _status.currentPhase && _status.currentPhase != player && _status.currentPhase.countGainableCards(player, 'he');
                        },
                        logTarget: () => _status.currentPhase,
                        forced: true,
                        popup: false,
                        content() {
                            player.line(_status.currentPhase, 'green');
                            player.gainPlayerCard(_status.currentPhase, 'he', true);
                        },
                    },
                },
            },
            minipoxi: {
                audio: 'drlt_poxi',
                enable: 'phaseUse',
                filterTarget(card, player, target) {
                    return target != player && target.countCards('h');
                },
                usable: 1,
                content() {
                    'step 0'
                    var chooseButton;
                    event.list1 = [];
                    event.list2 = [];
                    if (player.countCards('h')) chooseButton = player.chooseButton(3, ['你的手牌', player.getCards('h'), get.translation(target.name) + '的手牌', target.getCards('h')]);
                    else chooseButton = player.chooseButton(3, [get.translation(target.name) + '的手牌', target.getCards('h')]);
                    chooseButton.set('target', target);
                    chooseButton.set('ai', function (button) {
                        var player = _status.event.player;
                        var target = _status.event.target;
                        var ps = [];
                        var ts = [];
                        for (var i = 0; i < ui.selected.buttons.length; i++) {
                            var card = ui.selected.buttons[i].link;
                            if (target.getCards('h').includes(card)) ts.push(card);
                            else ps.push(card);
                        }
                        var card = button.link;
                        var owner = get.owner(card);
                        var val = get.value(card) || 1;
                        if (owner == target) {
                            if (ts.length > 1) return 0;
                            if (ts.length == 0 || player.hp > 3) return val;
                            return 2 * val;
                        }
                        return 7 - val;
                    });
                    chooseButton.set('filterButton', function (button) {
                        for (var i = 0; i < ui.selected.buttons.length; i++) {
                            if (get.suit(button.link) == get.suit(ui.selected.buttons[i].link)) return false;
                        };
                        return true;
                    });
                    'step 1'
                    if (result.bool) {
                        var list = result.links;
                        for (var i = 0; i < list.length; i++) {
                            if (get.owner(list[i]) == player) event.list1.push(list[i]);
                            else event.list2.push(list[i]);
                        }
                        if (event.list1.length && event.list2.length) {
                            game.loseAsync({
                                lose_list: [
                                    [player, event.list1],
                                    [target, event.list2]
                                ],
                                discarder: player,
                            }).setContent('discardMultiple');
                        }
                        else if (event.list2.length) target.discard(event.list2).discarder = player;
                        else player.discard(event.list1);
                    };
                    'step 2'
                    if (event.list1.length + event.list2.length != 3) return;
                    if (event.list1.length == 0) player.loseMaxHp();
                    if (event.list1.length == 2) {
                        player.recover();
                        player.draw();
                    }
                    if (event.list1.length == 3) player.draw(3);
                },
                ai: {
                    order: 13,
                    result: { target: -1 },
                },
            },
            minishenwei: {
                global: 'minishenwei_damage',
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return game.hasPlayer(current => !current.hasMark('minishenwei'));
                },
                direct: true,
                content() {
                    'step 0'
                    var num = (player.hp == 1 ? [1, 2] : 1);
                    player.chooseTarget(get.prompt2('minishenwei'), function (card, player, target) {
                        return !target.hasMark('minishenwei');
                    }, num).set('ai', function (target) {
                        var player = _status.event.player, num = 2;
                        if (target == player) num = 1;
                        return (get.attitude(player, target) - 4) * num;
                    });
                    'step 1'
                    if (result.bool) {
                        var targets = result.targets.slice().sortBySeat();
                        player.logSkill('minishenwei', targets);
                        targets.forEach(target => target.addMark('minishenwei', 1));
                    }
                },
                marktext: '卫',
                intro: { name2: '卫', content: 'mark' },
                ai: {
                    expose: 0.25,
                    threaten: 4.8,
                },
                subSkill: {
                    damage: {
                        trigger: { player: 'damageBegin4' },
                        filter(event, player) {
                            return player.hasMark('minishenwei') && game.hasPlayer(function (current) {
                                return current.hasSkill('minishenwei');
                            });
                        },
                        direct: true,
                        content() {
                            'step 0'
                            player.chooseTarget(get.prompt('minishenwei'), '将伤害转移给一名拥有〖神卫〗的角色', function (card, player, target) {
                                return target.hasSkill('minishenwei');
                            }).set('ai', function (target) {
                                var player = _status.event.player, att = get.attitude(player, target);
                                if (att > 0 && player.hp > 1 && target.hp <= 1) return 0;
                                return -att + 114514;
                            });
                            'step 1'
                            if (result.bool) {
                                var target = result.targets[0];
                                player.logSkill('minishenwei', target);
                                player.removeMark('minishenwei', player.countMark('minishenwei'));
                                event.trigger('removeShenWei');
                                trigger.player = target;
                            }
                        },
                    },
                },
            },
            minielai: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'removeShenWei' },
                filter(event, player) {
                    return player.isDamaged() || game.hasPlayer(function (current) {
                        return current != player && player.inRange(current);
                    });
                },
                forced: true,
                content() {
                    'step 0'
                    if (!game.hasPlayer(function (current) {
                        return current != player && player.inRange(current);
                    })) result.index = 0;
                    else if (player.isHealthy()) result.index = 1;
                    else player.chooseControl().set('choiceList', [
                        '回复1点体力',
                        '对攻击范围内的一名其他角色造成1点伤害'
                    ]).set('ai', function () {
                        var num = 3;
                        if (player.hasSkill('minikuangxi') && game.hasPlayer(function (current) {
                            return current.hasMark('minishenwei');
                        })) num--;
                        if (player.hp >= num && game.hasPlayer(function (current) {
                            return current != player && get.damageEffect(current, player, player) > 0;
                        })) return 1;
                        return 0;
                    });
                    'step 1'
                    if (result.index == 0) {
                        player.recover();
                        event.finish();
                    }
                    else player.chooseTarget('请选择【恶来】的目标', '对一名攻击范围内的一名其他角色造成1点伤害', true, function (card, player, target) {
                        return target != player && player.inRange(target);
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        return get.damageEffect(target, player, player) + 114514;
                    });
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target);
                        target.damage();
                    }
                },
                ai: { combo: 'minishenwei' },
            },
            minikuangxi: {
                trigger: { source: 'damageBegin1' },
                filter(event, player) {
                    return game.hasPlayer(function (current) {
                        return current.hasMark('minishenwei');
                    });
                },
                forced: true,
                content() {
                    trigger.num++;
                },
                ai: { combo: 'minishenwei' },
            },
            minijishi: {
                mod: {
                    maxHandcard(player, num) {
                        return num + 3;
                    },
                },
                audio: 'ext:活动武将/audio/skill:2',
                group: ['minijishi_recover', 'minijishi_lose'],
                marktext: '药',
                intro: { name2: '药', content: 'mark' },
                trigger: { global: 'phaseBefore', player: 'enterGame' },
                filter(event, player) {
                    if (player.countMark('minijishi') >= 3) return false;
                    return event.name != 'phase' || game.phaseNumber == 0;
                },
                forced: true,
                locked: false,
                content() {
                    player.addMark('minijishi', Math.min(3, 3 - player.countMark('minijishi')));
                },
                ai: { threaten: 10 },
                subSkill: {
                    recover: {
                        audio: 'minijishi',
                        trigger: { global: 'dying' },
                        filter(event, player) {
                            return event.player.hp <= 0 && player.hasMark('minijishi');
                        },
                        prompt2(event, player) {
                            return '令' + get.translation(event.player) + '回复体力至1点';
                        },
                        logTarget: 'player',
                        check(event, player) {
                            return get.recoverEffect(event.player, player, player) > 0;
                        },
                        content() {
                            player.removeMark('minijishi', 1);
                            trigger.player.recover(1 - trigger.player.hp);
                        },
                    },
                    lose: {
                        audio: 'minijishi',
                        trigger: {
                            player: 'loseAfter',
                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                        },
                        filter(event, player) {
                            var bool = false;
                            if (event.name == 'gain' && player == event.player) return false;
                            var evt = event.getl(player);
                            if (!evt || !evt.cards2 || !evt.cards2.length) return false;
                            for (var i of evt.cards2) {
                                if (get.color(i, player) == 'red' && i.original == 'h') bool = true;
                            }
                            if (!bool) return false;
                            return player != _status.currentPhase && player.countMark('minijishi') < 3;
                        },
                        forced: true,
                        locked: false,
                        content() {
                            var num = 0, evt = trigger.getl(player);
                            for (var i of evt.cards2) {
                                if (get.color(i, player) == 'red' && i.original == 'h' && num < 3 - player.countMark('minijishi')) num++;
                            }
                            player.addMark('minijishi', num);
                        },
                    },
                },
            },
            minitaoxian: {
                group: 'minitaoxian_use',
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'chooseToUse',
                filterCard(card) {
                    return get.suit(card) == 'heart';
                },
                viewAs: { name: 'tao' },
                viewAsFilter(player) {
                    if (!player.countCards('hes', { suit: 'heart' })) return false;
                    return true;
                },
                position: 'hes',
                prompt: '将一张红桃牌当作桃使用',
                check(card) {
                    if (_status.event.type == 'dying') return 1 / Math.max(0.1, get.value(card));
                    return 8 - get.value(card);
                },
                ai: { threaten: 10 },
                subSkill: {
                    use: {
                        audio: 'minitaoxian',
                        trigger: { global: 'useCard' },
                        filter(event, player) {
                            return event.player != player && event.card.name == 'tao';
                        },
                        forced: true,
                        locked: false,
                        content() {
                            player.draw();
                        },
                    },
                },
            },
            minishenzhen: {
                audio: 'ext:活动武将/audio/skill:1',
                trigger: { player: 'phaseZhunbeiBegin' },
                filter(event, player) {
                    return player.hasMark('minijishi');
                },
                direct: true,
                content() {
                    'step 0'
                    var map = {};
                    var list = [];
                    for (var i = 1; i <= player.countMark('minijishi'); i++) {
                        var cn = get.cnNumber(i, true);
                        map[cn] = i;
                        list.push(cn);
                    }
                    list.push('cancel2');
                    event.map = map;
                    player.chooseControl(list).set('prompt', get.prompt2('minishenzhen')).set('ai', function () {
                        var player = _status.event.player;
                        var num = Math.min(player.countMark('minijishi'), Math.max(game.countPlayer(function (current) {
                            return get.attitude(player, current) > 0 && current.isDamaged() && get.recoverEffect(current, player, player) > 0;
                        }), game.countPlayer(function (current) {
                            return get.attitude(player, current) < 0;
                        })));
                        if (num > 0) return get.cnNumber(num, true);
                        return 'cancel2';
                    });
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('minishenzhen');
                        var num = event.map[result.control] || 1;
                        event.num = num;
                        player.removeMark('minijishi', num);
                        player.chooseControl('回血', '扣血').set('prompt', '请选择一种效果').set('ai', function (card) {
                            if (game.countPlayer(function (current) {
                                return get.attitude(player, current) > 0 && current.isDamaged() && get.recoverEffect(current, player, player) > 0;
                            }) >= game.countPlayer(function (current) {
                                return get.attitude(player, current) < 0;
                            })) return '回血';
                            return '扣血';
                        });
                    }
                    else event.finish();
                    'step 2'
                    event.control = result.control;
                    switch (result.control) {
                        case '回血':
                            player.chooseTarget('请选择回复体力的目标', [1, Math.min(num, game.countPlayer(function (current) {
                                return current.isDamaged();
                            }))], true, function (card, player, target) {
                                return target.isDamaged();
                            }).set('ai', function (target) {
                                var player = _status.event.player;
                                return get.recoverEffect(target, player, player);
                            });
                            break;
                        case '扣血':
                            player.chooseTarget('请选择失去体力的目标', [1, Math.min(num, game.countPlayer())], true).set('ai', function (target) {
                                var player = _status.event.player;
                                return -get.attitude(player, target);
                            });
                            break;
                    }
                    'step 3'
                    if (result.bool) {
                        result.targets.sortBySeat();
                        player.line(result.targets);
                        game.log(player, '选择了', result.targets);
                        if (event.control == '回血') for (var i of result.targets) i.recover();
                        else for (var i of result.targets) i.loseHp();
                    }
                },
                ai: {
                    threaten: 10,
                    combo: 'minijishi',
                },
            },
            minigjtianyi: {
                audio: 'stianyi',
                derivation: 'minizuoxing',
                trigger: { player: 'phaseZhunbeiBegin' },
                forced: true,
                juexingji: true,
                skillAnimation: true,
                animationColor: 'gray',
                filter(event, player) {
                    return !game.hasPlayer(function (current) {
                        return !current.getAllHistory('damage').length;
                    });
                },
                content() {
                    'step 0'
                    player.awakenSkill('minigjtianyi');
                    player.gainMaxHp(2);
                    player.recover();
                    'step 1'
                    player.chooseTarget(true, '令一名角色获得【佐幸】').set('ai', function (target) {
                        return get.attitude(_status.event.player, target);
                    });
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target, 'green');
                        target.storage.minizuoxing = player;
                        target.addSkills('minizuoxing');
                    }
                },
            },
            minizuoxing: {
                audio: 'zuoxing',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    var target = player.storage.minizuoxing;
                    return player.hasSkill('minizuoxing') && target && target.isIn() && target.maxHp > 1;
                },
                check(event, player) {
                    var target = player.storage.minizuoxing;
                    if (get.attitude(player, target) <= 0) return true;
                    return target.maxHp > 3 && !player.hasJudge('lebu');
                },
                prompt(event, player) {
                    return get.prompt('minizuoxing') + '（令' + get.translation(player.storage.minizuoxing) + '减少1点体力上限，' + get.translation(player.storage.minizuoxing) + '当前体力上限：' + player.storage.minizuoxing.maxHp + '）';
                },
                content() {
                    player.line(player.storage.minizuoxing, 'fire');
                    player.storage.minizuoxing.loseMaxHp();
                    player.addTempSkill('minizuoxing_effect');
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        audio: 'zuoxing',
                        enable: 'phaseUse',
                        filter(event, player) {
                            if (player.hasSkill('minizuoxing_used', null, null, false)) return false;
                            for (var i of lib.inpile) {
                                if (get.type(i) == 'trick' && event.filterCard({ name: i, isCard: true }, player, event)) return true;
                            }
                            return false;
                        },
                        chooseButton: {
                            dialog(event, player) {
                                var list = [];
                                for (var i of lib.inpile) {
                                    if (get.type(i) == 'trick' && event.filterCard({ name: i, isCard: true }, player, event)) list.push(['锦囊', '', i]);
                                }
                                return ui.create.dialog('佐幸', [list, 'vcard']);
                            },
                            check(button) {
                                return _status.event.player.getUseValue({ name: button.link[2], isCard: true });
                            },
                            backup(links, player) {
                                return {
                                    audio: 'zuoxing',
                                    viewAs: {
                                        name: links[0][2],
                                        isCard: true,
                                    },
                                    filterCard: () => false,
                                    selectCard: -1,
                                    popname: true,
                                    precontent() {
                                        player.addTempSkill('minizuoxing_used', 'phaseUseEnd');
                                    },
                                }
                            },
                            prompt(links, player) {
                                return '请选择' + get.translation(links[0][2]) + '的目标';
                            },
                        },
                        ai: {
                            order: 1,
                            result: { player: 1 },
                        },
                    },
                    used: { charlotte: true },
                },
            },
            minihuishi: {
                audio: 'sghuishi',
                enable: 'phaseUse',
                limited: true,
                skillAnimation: true,
                animationColor: 'water',
                filterTarget: true,
                selectTarget() {
                    var player = _status.event.player;
                    for (var target of game.filterPlayer()) {
                        var list = target.getSkills(null, false, false).filter(function (skill) {
                            if (target.awakenedSkills.includes(skill)) return false;
                            return lib.skill[skill]?.juexingji;
                        });
                        var bool1 = (!list.length && player.maxHp >= 3);
                        var bool2 = (list.length && player.maxHp >= game.players.length);
                        target.prompt((bool1 ? '可摸牌' : '') + ((bool1 && bool2) ? '<br>' : '') + (bool2 ? '可觉醒' : ''));
                    }
                    return 1;
                },
                content() {
                    'step 0'
                    player.awakenSkill('minihuishi');
                    var list = target.getSkills(null, false, false).filter(function (skill) {
                        if (target.awakenedSkills.includes(skill)) return false;
                        return lib.skill[skill]?.juexingji;
                    });
                    if (!list.length && player.maxHp >= 3) {
                        target.draw(4);
                        event.goto(2);
                        return;
                    }
                    if (list.length && player.maxHp >= game.players.length) {
                        if (list.length == 1) event._result = { control: list[0] };
                        else player.chooseControl(list).set('prompt', '选择一个觉醒技，令' + get.translation(target) + '可无视条件发动该技能');
                    }
                    else event.goto(2);
                    'step 1'
                    target.storage.minihuishi_mark = result.control;
                    target.markSkill('minihuishi_mark');
                    var info = lib.skill[result.control];
                    if (info.filter && !info.charlotte && !info.minihuishi_filter) {
                        info.minihuishi_filter = info.filter;
                        info.filter = function (event, player) {
                            if (player.storage.minihuishi_mark) return true;
                            return this.minihuishi_filter.apply(this, arguments);
                        };
                    }
                    'step 2'
                    player.loseMaxHp(2);
                },
                subSkill: { mark: { intro: { content: '发动【$】时无视条件' } } },
                ai: {
                    order: 0.1,
                    expose: 0.2,
                    result: {
                        target(player, target) {
                            if (player.maxHp < 5) return 0;
                            var list = target.getSkills(null, false, false).filter(function (skill) {
                                return lib.skill[skill]?.juexingji;
                            });
                            if (list.length && player.maxHp >= game.players.length) return 10 * list.length;
                            if (target.hasJudge('lebu') || target.hasSkillTag('nogain')) return 0;
                            if (!list.length && player.maxHp >= 3) return 4;
                            return 0;
                        },
                    },
                },
            },
            minishenfu: {
                audio: 'shenfu',
                trigger: { player: ['phaseEnd', 'phaseAfter'] },
                filter(event, player, name) {
                    if (name == 'phaseEnd') return true;
                    return player.getHistory('useSkill', function (evt) {
                        return evt.skill == 'minishenfu';
                    }).length;
                },
                direct: true,
                content() {
                    'step 0'
                    if (event.triggername == 'phaseAfter') {
                        player.logSkill('minishenfu');
                        player.draw(Math.min(5, player.getHistory('useSkill', function (evt) {
                            return evt.skill == 'minishenfu';
                        }).length - 1));
                        event.finish();
                        return;
                    }
                    event.targets = [];
                    event.goto(player.countCards('h') % 2 == 1 ? 1 : 4);
                    'step 1'
                    player.chooseTarget(get.prompt('minishenfu'), '对一名其他角色造成1点雷属性伤害', function (card, player, target) {
                        return target != player && !_status.event.getParent().targets.includes(target);
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        return get.damageEffect(target, player, player, 'thunder') * (target.hp == 1 ? 2 : 1);
                    });
                    'step 2'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        targets.push(target);
                        player.logSkill('minishenfu', target, 'thunder');
                        target.damage('thunder');
                    }
                    else event.finish();
                    'step 3'
                    if (target.isDead()) event.goto(1);
                    else event.finish();
                    'step 4'
                    if (!game.hasPlayer(function (target) {
                        return !event.targets.includes(target);
                    })) { event.finish(); return; }
                    player.chooseTarget(get.prompt('minishenfu'), '令一名角色摸一张牌或弃置其一张手牌', function (card, player, target) {
                        return !_status.event.getParent().targets.includes(target);
                    }).set('ai', function (target) {
                        var att = get.attitude(_status.event.player, target);
                        var delta = target.hp - target.countCards('h');
                        if (Math.abs(delta) == 1 && Math.sign(delta) == Math.sign(att)) return 3 * Math.abs(att);
                        if (att > 0 || target.countCards('h') > 0) return Math.abs(att);
                        return 0;
                    });
                    'step 5'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minishenfu', target, 'wood');
                        targets.push(target);
                        if (target.countCards('h') == 0) event._result = { index: 0 };
                        else player.chooseControl('摸一张牌', '弃置卡牌').set('prompt', '选择一项令' + get.translation(target) + '执行…').set('goon', get.attitude(player, target) > 0 ? 0 : 1).set('ai', () => _status.event.goon);
                    }
                    else event.finish();
                    'step 6'
                    if (result.index == 0) target.draw();
                    else player.discardPlayerCard(target, 'he', true);
                    'step 7'
                    if (target.hp == target.countCards('h')) event.goto(4);
                },
                ai: { expose: 0.25 },
            },
            minireqixian: {
                mod: {
                    maxHandcardBase(player, num) {
                        return 7;
                    },
                },
                trigger: { player: 'phaseUseEnd' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseCard(get.prompt('minireqixian'), '将一张牌移出游戏，于回合结束时归还手牌中', 'he').set('ai', function (card) {
                        var player = _status.event.player;
                        if (player.countCards('h') % 2 == 0 && get.position(card) == 'h' && game.hasPlayer(function (target) {
                            return get.damageEffect(target, player, player, 'thunder') > 0;
                        })) return 15;
                        if (get.position(card) == 'h' && player.needsToDiscard()) return 10;
                        if (get.position(card) == 'e' && get.value(card) <= 0) return 5;
                        return (get.position(card) == 'h' ? 2 : 1) * -get.value(card);
                    });
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minireqixian');
                        player.addTempSkill('minireqixian2', { player: 'minireqixian2After' });
                        player.addToExpansion(result.cards, player, 'give').gaintag.add('minireqixian2');
                    }
                },
            },
            minireqixian2: {
                charlotte: true,
                trigger: { player: 'phaseAfter' },
                forced: true,
                content() {
                    player.gain(player.getExpansions('minireqixian2'), 'gain2');
                },
                intro: {
                    content: 'expansion',
                    markcount: 'expansion',
                },
                onremove(player, skill) {
                    var cards = player.getExpansions(skill);
                    if (cards.length) player.loseToDiscardpile(cards);
                },
            },
            minifeifu: {
                mod: {
                    aiValue(player, card, num) {
                        if (get.name(card) != 'shan' && get.color(card) != 'black') return;
                        var cards = player.getCards('hs', function (card) {
                            return get.name(card) == 'shan' || get.color(card) == 'black';
                        });
                        cards.sort(function (a, b) {
                            return (get.name(b) == 'shan' ? 1 : 2) - (get.name(a) == 'shan' ? 1 : 2);
                        });
                        var geti = function () {
                            if (cards.includes(card)) {
                                return cards.indexOf(card);
                            }
                            return cards.length;
                        };
                        if (get.name(card) == 'shan') return Math.min(num, [6, 4, 3][Math.min(geti(), 2)]) * 0.6;
                        return Math.max(num, [6.5, 4, 3][Math.min(geti(), 2)]);
                    },
                    aiUseful() {
                        return lib.skill.minifeifu.mod.aiValue.apply(this, arguments);
                    },
                },
                audio: 'ext:活动武将/audio/skill:2',
                enable: ['chooseToRespond', 'chooseToUse'],
                filterCard(card) {
                    return get.color(card) == 'black';
                },
                locked: false,
                position: 'hes',
                viewAs: { name: 'shan' },
                viewAsFilter(player) {
                    if (!player.countCards('hes', { color: 'black' })) return false;
                },
                prompt: '将一张黑色牌当作【闪】使用或打出',
                check: () => 1,
                ai: {
                    order: 2,
                    respondShan: true,
                    skillTagFilter(player) {
                        if (!player.countCards('hes', { color: 'black' })) return false;
                    },
                    effect: {
                        target(card, player, target, current) {
                            if (get.tag(card, 'respondShan') && current < 0) return 0.6
                        },
                    },
                },
            },
            //神二乔
            minishuangshu: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseZhunbeiBegin' },
                frequent: true,
                content() {
                    var cards = get.cards(2), bool1 = false, bool2 = false;
                    game.cardsGotoOrdering(cards);
                    player.showCards(cards, get.translation(player) + '发动了【双姝】');
                    for (var i of cards) {
                        if (get.suit(i, false) == 'diamond') bool1 = true;
                        if (get.suit(i, false) == 'heart') bool2 = true;
                    }
                    if (bool1) {
                        game.log(player, '强化了技能', '#g【娉婷】');
                        player.addTempSkill('minishuangshu_pingting');
                        player.addMark('minishuangshu_pingting', 1, false);
                    }
                    if (bool2) {
                        game.log(player, '强化了技能', '#g【移筝】');
                        player.addTempSkill('minishuangshu_yizheng');
                        player.addMark('minishuangshu_yizheng', 1, false);
                    }
                    if (!bool1 && !bool2) player.gain(cards, 'gain2');
                    else game.cardsDiscard(cards);
                },
                subSkill: {
                    pingting: {
                        charlotte: true,
                        onremove: true,
                        marktext: '婷',
                        intro: { content: '本回合发动【娉婷】可多选择#项' },
                    },
                    yizheng: {
                        charlotte: true,
                        onremove: true,
                        marktext: '筝',
                        intro: { content: '本回合发动【移筝】可多选择#项' },
                    },
                },
            },
            minipingting: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseUseBegin' },
                direct: true,
                content() {
                    'step 0'
                    player.chooseButton([
                        '###' + get.prompt('minipingting') + '###' + '选择并于本阶段获得下列至多' + get.cnNumber(Math.min(4, 2 + player.countMark('minishuangshu_pingting'))) + '项效果', [[
                            ['distance', '本阶段使用的第一张牌无距离限制'],
                            ['return', '本阶段使用第二张牌指定目标后获得此牌'],
                            ['draw', '本阶段使用的第三张牌结算完成后摸两张牌'],
                            ['reuse', '本阶段使用的第四张牌额外结算一次'],
                        ], 'textbutton']
                    ]).set('ai', function (button) {
                        var player = _status.event.player;
                        var num = player.countCards('hs', function (card) {
                            return player.hasUseTarget(card) && player.getUseValue(card) > 0;
                        });
                        switch (button.link) {
                            case 'distance': {
                                if (game.hasPlayer(function (target) {
                                    return player.hasCard('hs', function (card) {
                                        return player.canUse(card, target, false) && player.canUse(card, target) && get.effect(target, card, player, player) > 0;
                                    });
                                })) return 1;
                                return 0.5;
                                break;
                            }
                            case 'return': {
                                if (num >= 2) return 2;
                                return 0.6;
                                break;
                            }
                            case 'draw': {
                                if (num >= 3) return 4;
                                return 0.7;
                                break;
                            }
                            case 'reuse': {
                                if (num >= 4) return 3;
                                return 0.8;
                                break;
                            }
                        }
                    }).set('selectButton', [1, player.hasSkill('minishuangshu_pingting') ? 3 : 2]);
                    'step 1'
                    if (result.bool) {
                        player.logSkill('minipingting');
                        for (var i of result.links) player.addTempSkill('minipingting_' + i, { player: 'phaseUseAfter' });
                    }
                },
                subSkill: {
                    distance: {
                        charlotte: true,
                        onremove: true,
                        mark: true,
                        marktext: '①',
                        intro: { content: '本阶段使用的第一张牌无距离限制' },
                        //为适配联机进行的代码退化[doge]
                        mod: {
                            targetInRange(card, player, target) {
                                //if(game.online){
                                if (!player.storage.minipingting_distance) return true;
                                //}
                                /*
                                else{
                                var evt=_status.event.getParent('phaseUse');
                                if(evt?.name=='phaseUse'&&!player.getHistory('useCard',function(evt2){
                                return evt2.getParent('phaseUse')==evt;
                                }).length) return true;
                                }
                                */
                            },
                        },
                        trigger: { player: 'useCard1' },
                        filter(event, player) {
                            return !player.storage.minipingting_distance/*&&player.isOnline()*/;
                        },
                        direct: true,
                        firstDo: true,
                        content() {
                            player.storage.minipingting_distance = true;
                        },
                    },
                    return: {
                        charlotte: true,
                        mark: true,
                        marktext: '②',
                        intro: { content: '本阶段使用第二张牌指定目标后获得此牌' },
                        audio: 'minipingting',
                        trigger: { player: 'useCardToPlayered' },
                        filter(event, player) {
                            if (!event.isFirstTarget) return false;
                            var evt = event.getParent('phaseUse');
                            return evt?.player == player && player.getHistory('useCard', function (evt2) {
                                return evt2.getParent('phaseUse') == evt;
                            }).indexOf(event.getParent()) == 1 && event.cards?.filterInD().length;
                        },
                        forced: true,
                        content() {
                            player.gain(trigger.cards.filterInD(), 'gain2');
                        },
                        ai: {
                            result: {
                                player(card, player, target) {
                                    var evt = _status.event.getParent('phaseUse');
                                    if (['equip', 'delay'].includes(get.type(card)) && evt?.player == player && player.getHistory('useCard', function (evt2) {
                                        return evt2.getParent('phaseUse') == evt;
                                    }).length == 1) return 0.3;
                                },
                            },
                        },
                    },
                    draw: {
                        charlotte: true,
                        mark: true,
                        marktext: '③',
                        intro: { content: '本阶段使用的第三张牌结算完成后摸两张牌' },
                        audio: 'minipingting',
                        trigger: { player: 'useCardAfter' },
                        filter(event, player) {
                            var evt = event.getParent('phaseUse');
                            return evt?.player == player && player.getHistory('useCard', function (evt2) {
                                return evt2.getParent('phaseUse') == evt;
                            }).indexOf(event) == 2;
                        },
                        forced: true,
                        content() {
                            player.draw(2);
                        },
                    },
                    reuse: {
                        charlotte: true,
                        mark: true,
                        marktext: '④',
                        intro: { content: '本阶段使用的第四张牌额外结算一次' },
                        audio: 'minipingting',
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            var evt = event.getParent('phaseUse');
                            return evt?.player == player && player.getHistory('useCard', function (evt2) {
                                return evt2.getParent('phaseUse') == evt;
                            }).indexOf(event) == 3 && event.targets;
                        },
                        forced: true,
                        content() {
                            trigger.effectCount++;
                            game.log(trigger.card, '额外结算一次');
                        },
                        ai: {
                            result: {
                                player(card, player, target) {
                                    var evt = _status.event.getParent('phaseUse');
                                    if (card.name == 'tiesuo' && evt?.player == player && player.getHistory('useCard', function (evt2) {
                                        return evt2.getParent('phaseUse') == evt;
                                    }).length == 3) return 'zerotarget';
                                },
                            },
                        },
                    },
                },
            },
            miniyizheng: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseUseEnd' },
                filter(event, player) {
                    return game.hasPlayer(target => {
                        return target.hasCard(card => lib.skill.miniyizheng.filterCardx(card, player), 'e');
                    });
                },
                check(event, player) {
                    return game.hasPlayer(target => {
                        return target.hasCard(card => lib.skill.miniyizheng.filterCardx(card, player, true), 'e');
                    });
                },
                filterCardx(card, player = get.event().player, ai) {
                    if (!Array.from({ length: 3 }).map((_, i) => i).includes(lib.skill.miniyizheng.filterType(card))) return false;
                    return player.canMoveCard(ai || null, true);
                },
                filterType(card) {
                    if (get.type(card) != 'equip' || !get.subtype(card)) return -1;
                    const num = parseInt(get.subtype(card).slice(5));
                    return [3, 4].includes(num) ? 0 : num;
                },
                async content(event, trigger, player) {
                    let moveCard = [], moveType = [], filter = (card, player) => {
                        if (moveCard.some(cardx => lib.skill.miniyizheng.filterType(cardx) == lib.skill.miniyizheng.filterType(card))) return false;
                        return lib.skill.miniyizheng.filterCardx(card, player);
                    }, limit = Math.min(3, 1 + player.countMark('minishuangshu_yizheng'));
                    while (moveCard.length < limit && game.hasPlayer(target => target.hasCard(card => filter(card, target), 'e'))) {
                        const forced = (!moveCard.length);
                        const result = await player.moveCard(filter, 'nojudge')
                            .set('prompt', '移筝：' + (forced ? '请' : '是否') + '移动场上的一张牌' + (forced ? '' : '？')).set('forced', forced)
                            .set('prompt2', '还可移动' + get.cnNumber(limit - moveCard.length) + '张' + (moveType.length ? ('非' + get.translation(moveType)) : '') + '牌').forResult();
                        if (result?.card) {
                            const { card } = result;
                            moveCard.push(card);
                            moveType.push(get.subtype(card));
                        }
                        else break;
                    }
                    switch (moveCard.length) {
                        case 1: await player.recover(); break;
                        case 2: player.addTempSkill('miniyizheng_draw', { player: 'phaseBegin' }); break;
                    }
                },
                subSkill: {
                    draw: {
                        charlotte: true,
                        mark: true,
                        intro: { content: '失去一张牌后，摸一张牌' },
                        audio: 'miniyizheng',
                        trigger: {
                            player: 'loseAfter',
                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                        },
                        filter(event, player) {
                            var evt = event.getl(player);
                            if (!evt || !evt.cards2 || !evt.cards2.length) return false;
                            return true;
                        },
                        forced: true,
                        content() {
                            player.draw(trigger.getl(player).cards2.length);
                        },
                    },
                },
            },
            //神二乔①号
            minishuangshu1: {
                audio: 'minishuangshu',
                trigger: { player: 'phaseBegin' },
                forced: true,
                content() {
                    const next = player.phaseDraw();
                    event.next.remove(next);
                    trigger.next.push(next);
                },
            },
            minishutu: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: ['recoverEnd', 'damageEnd'] },
                filter(event, player) {
                    const choice = game.getGlobalHistory('changeHp', evt => evt.getParent() === event)[0]?.choice;
                    return (choice === 'hp') ^ (event.name === 'damage');
                },
                direct: true,
                async content(event, trigger, player) {
                    const list = [event.name, null, null, null, [2 - (trigger.name === 'recover')]];
                    if (trigger.name === 'recover') {
                        for (let num = 1; num <= 2; num++) {
                            const result = await player.chooseControl(lib.color.red, 'cancel2').set('ai', () => {
                                return get.rand(0, 1);
                            }).set('prompt', get.prompt(event.name)).set('prompt2', '获得一张指定花色的红色牌').forResult();
                            if (result.control && result.control !== 'cancel2') {
                                if (num === 1) player.logSkill(...list);
                                player.chat(get.translation(result.control + 2));
                                const card = get.cardPile({ suit: result.control });
                                if (card) await player.gain(card, 'gain2');
                            }
                            else break;
                        }
                    }
                    else {
                        player.addTempSkill(event.name + '_directHit');
                        await player.chooseToUse(function (card, player, event) {
                            //if (get.itemtype(card) !== 'card' || (get.color(card) !== 'red' && get.color(card) !== 'unsure')) return false;
                            return lib.filter.filterCard.apply(this, arguments);
                        }, `${get.translation(event.name)}：是否使用一张牌（无次数限制且不可被响应）？`).set('logSkill', list).set('addCount', false);
                    }
                },
                subSkill: {
                    directHit: {
                        charlotte: true,
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            return event.getParent().name === 'chooseToUse' && event.getParent(2).name === 'minishutu' && event.getParent(2).player === player;
                        },
                        silent: true,
                        content() {
                            trigger.directHit.addArray(game.players);
                            game.log(trigger.card, '不可被响应');
                        },
                        ai: {
                            directHit_ai: true,
                            skillTagFilter(player) {
                                const event = get.event();
                                return event?.name === 'chooseToUse' && event.getParent().name === 'minishutu' && event.getParent().player === player;
                            },
                        },
                    },
                },
            },
            minitongdi: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: ['recoverEnd', 'damageEnd', 'loseHpEnd'] },
                filter(event, player) {
                    if (event.source !== player) return false;
                    const evt = event.getParent(2);
                    if (!(event.getParent().type === 'card' && evt.name === 'useCard' && evt.player === player && get.color(evt.card) === 'red')) return false;
                    if (typeof player.hp2 === 'number' && player.getHp() === Math.max(0, player.hp2) && player.isDamaged()) return true;
                    return player.countCards('h', { suit: 'heart' }) === player.countCards('h', { suit: 'diamond' }) && player.hasCard(card => {
                        if (_status.connectMode && get.color(card) === 'h') return true;
                        return get.color(card) === 'red' && lib.filter.cardDiscardable(card, player);
                    }, 'he');
                },
                direct: true,
                async content(event, trigger, player) {
                    if (typeof player.hp2 === 'number' && player.getHp() === Math.max(0, player.hp2) && player.isDamaged()) {
                        const result = await player.chooseBool(`${get.translation(event.name)}：是否回复1点体力？`).set('choice', get.recoverEffect(player, player, player) > 0).forResult();
                        if (result?.bool) {
                            player.logSkill(event.name);
                            await player.recover();
                        }
                    }
                    if (player.countCards('h', { suit: 'heart' }) === player.countCards('h', { suit: 'diamond' }) && player.hasCard(card => {
                        if (_status.connectMode && get.color(card) === 'h') return true;
                        return get.color(card) === 'red' && lib.filter.cardDiscardable(card, player);
                    }, 'he')) {
                        const result = await player.chooseCardTarget({
                            prompt: get.prompt(event.name),
                            prompt2: '弃置一张红色牌，对一名角色造成1点伤害',
                            filterCard(card, player) {
                                return get.color(card) === 'red' && lib.filter.cardDiscardable(card, player);
                            },
                            position: 'he',
                            filterTarget: true,
                            ai1(card) {
                                return 7 - get.value(card);
                            },
                            ai2(target) {
                                const player = get.player();
                                return get.damageEffect(target, player, player);
                            },
                        }).forResult();
                        if (result?.bool && result.cards?.length && result.targets?.length) {
                            const target = result.targets[0];
                            player.logSkill(event.name, target);
                            await player.discard(result.cards);
                            await target.damage();
                        }
                    }
                },
                init(player, skill) {
                    player.addSkill(`${skill}_record`);
                    if (_status.gameDrawed) {
                        const event = get.event(), func = lib.skill[`${skill}_record`].func;
                        if (event.isMine()) func(player, `${skill}_record`);
                        else if (player.isOnline2()) player.send(func, player, `${skill}_record`);
                    }
                },
                onremove(player, skill) {
                    delete player.storage[`${skill}_record`];
                    player.removeTip(`${skill}_record`);
                    player.removeSkill(`${skill}_record`);
                },
                subSkill: {
                    record: {
                        charlotte: true,
                        trigger: {
                            player: ['loseEnd', 'changeSkillsEnd'],
                            global: ['gameDrawEnd', 'phaseBefore', 'loseAsyncEnd', 'equipEnd', 'addJudgeEnd', 'gainEnd', 'addToExpansionEnd'],
                        },
                        filter(event, player) {
                            if (!Array.isArray(player.storage.minitongdi_record)) return true;
                            if (['lose', 'loseAsync', 'equip', 'addJudge', 'gain', 'addToExpansion'].includes(event.name)) {
                                if (!((event.getl?.(player)?.hs ?? []).length > 0 || (event.getg?.(player) ?? []).length > 0)) return false;
                            }
                            const list = [player.countCards('h', { suit: 'heart' }), player.countCards('h', { suit: 'diamond' })];
                            return [0, 1].some(index => player.storage.minitongdi_record[index] !== list[index]);
                        },
                        silent: true,
                        firstDo: true,
                        content() {
                            const func = lib.skill[event.name].func;
                            if (event.isMine()) func(player, event.name);
                            else if (player.isOnline2()) player.send(func, player, event.name);
                        },
                        func(player, name) {
                            const list = player.storage[name] = [player.countCards('h', { suit: 'heart' }), player.countCards('h', { suit: 'diamond' })];
                            player.addTip(name, `${get.translation('heart')}：${list[0]}；${get.translation('diamond')}：${list[1]}`);
                        },
                    },
                },
            },
            // 神二乔②号
            minishuangshu2: {
                audio: 'minishuangshu',
                mark: true,
                marktext: '☯',
                zhuanhuanji(player, skill) {
                    if (!player.storage.minishutu2) {
                        player.storage[skill] = !player.storage[skill];
                    }
                },
                intro: {
                    content(storage, player) {
                        return storage ? '当你使用或打出一张红桃牌后，你可以弃置一张牌，然后从牌堆或弃牌堆获得两张与此牌花色不同的牌' : '当你使用或打出一张方片牌后，你摸X张牌（X为你装备区的红色牌数）；';
                    },
                },
                trigger: { player: ['useCardAfter', 'respondAfter'] },
                filter(event, player) {
                    if (!player.storage.minishuangshu2) return get.suit(event.card) == 'diamond';
                    return get.suit(event.card) == 'heart' && player.hasCard(card => {
                        if (_status.connectMode) return true;
                        return lib.filter.cardDiscardable(card, player);
                    }, 'he');
                },
                async cost(event, trigger, player) {
                    if (!player.storage.minishuangshu2) event.result = { bool: true };
                    else event.result = await player.chooseToDiscard(get.prompt(event.skill), '弃置一张牌并获得两张与此牌花色不同的牌', 'chooseonly').set('ai', card => {
                        return 6.5 - get.value(card)
                    }).forResult();
                },
                async content(event, trigger, player) {
                    player.changeZhuanhuanji(event.name);
                    if (get.itemtype(event.cards) == 'cards') {
                        await player.discard(event.cards);
                        const suit = get.suit(event.cards[0]);
                        const list = [];
                        while (list.length < 2) {
                            const card = get.cardPile(cardx => !list.includes(cardx) && get.suit(cardx) !== suit);
                            if (card) list.push(card);
                            else break;
                        }
                        if (list.length) await player.gain(list, 'gain2');
                    }
                    else {
                        const num = player.countCards('e', { color: 'red' });
                        if (num > 0) await player.draw(num);
                    }
                },
                group: 'minishuangshu2_change',
                subSkill: {
                    change: {
                        audio: 'minishuangshu',
                        trigger: {
                            global: 'phaseBefore',
                            player: 'enterGame',
                        },
                        filter(event, player) {
                            return event.name != 'phase' || game.phaseNumber == 0;
                        },
                        prompt2(event, player) {
                            return '切换【双姝】为状态' + (player.storage.minishuangshu2 ? '阳' : '阴');
                        },
                        check: () => Math.random() > 0.5,
                        async content(event, trigger, player) {
                            player.changeZhuanhuanji('minishuangshu2');
                        },
                    }
                }
            },
            miniyizheng2: {
                audio: 'miniyizheng',
                trigger: { player: 'phaseBegin' },
                filter(event, player) {
                    return player.canMoveCard();
                },
                check(event, player) {
                    return player.canMoveCard(true) && get.effect(player, { name: 'losehp' }, player, player) > 0;
                },
                async content(event, trigger, player) {
                    await player.loseHp();
                    await player.moveCard(true);
                },
            },
            minishutu2: {
                audio: 'minishutu',
                trigger: { player: 'dying' },
                skillAnimation: true,
                animationColor: 'wood',
                limited: true,
                check(event, player) {
                    if (player.countCards('hs', card => player.canSaveCard(card, player)) >= 1 - player.hp) return false;
                    return player.maxHp > 1;
                },
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    await player.loseMaxHp();
                    await player.recoverTo(2);
                    const result = await player.chooseControl('阳', '阴').set('prompt', '殊途：请选择〖双姝〗的一个分支移除').set('ai', () => '阳').forResult();
                    if (typeof result?.control !== 'string') return;
                    player.storage.minishuangshu2 = result.control == '阳';
                },
            },
            //神貂蝉
            minimeihun: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseJieshuBegin', target: 'useCardToTargeted' },
                filter(event, player) {
                    if (event.name != 'phaseJieshu' && game.getGlobalHistory('useCard', function (evt) {
                        return evt.card.name == 'sha' && evt.targets.includes(player);
                    }).indexOf(event.getParent()) != 0) return false;
                    return game.hasPlayer(function (current) {
                        return current != player && current.countCards('he');
                    });
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt2('minimeihun'), function (card, player, target) {
                        return target != player && target.countCards('he');
                    }).set('ai', function (target) {
                        var player = _status.event.player;
                        return -Math.sign(get.attitude(player, target)) * target.countCards('he');
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        player.logSkill('minimeihun', target);
                        event.target = target;
                        player.chooseControl(lib.suit.slice(0).reverse()).set('prompt', '请声明一个花色').set('ai', function () {
                            var target = _status.event.target, cards = target.getCards('he');
                            var suits = lib.suit.slice(0);
                            suits.sort(function (a, b) {
                                var num = function (suit) {
                                    return cards.filter(function (card) {
                                        return get.suit(card) == suit;
                                    }).length;
                                };
                                return num(b) - num(a);
                            });
                            return suits[0];
                        }).set('target', target);
                    }
                    else event.finish();
                    'step 2'
                    var suit = result.control;
                    player.chat(get.translation(suit + 2));
                    game.log(player, '选择了', '#y' + get.translation(suit + 2));
                    if (target.countCards('he', { suit: suit })) player.gain(target.getCards('he', { suit: suit }), target, 'giveAuto');
                    else if (target.countCards('h')) player.gainPlayerCard(target, true, 'h', 'visible');
                },
            },
            minihuoxin: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                filter(event, player) {
                    return game.hasPlayer(function (target) {
                        return lib.skill.minihuoxin.filterTarget(null, player, target);
                    }) && player.countCards('he');
                },
                filterTarget(card, player, target) {
                    if (!ui.selected.targets.length) {
                        return game.hasPlayer(function (current) {
                            return current != target && target.canCompare(current);
                        });
                    }
                    return ui.selected.targets[0].canCompare(target);
                },
                selectTarget: 2,
                multitarget: true,
                multiline: true,
                targetprompt: ['发起人', '拼点目标'],
                filterCard: true,
                check(card) {
                    return 1 / (get.value(card) || 0.5);
                },
                position: 'he',
                usable: 1,
                content() {
                    'step 0'
                    event.list = [];
                    targets[0].chooseToCompare(targets[1]);
                    'step 1'
                    for (var target of targets) {
                        if (result.winner !== target) event.list.push(target);
                    }
                    event.list.sortBySeat();
                    var suits = lib.suit.slice(0).reverse();
                    suits.push('cancel2');
                    player.chooseControl(suits).set('prompt', get.translation(event.list) + '拼点没赢，是否声明一个花色令其进行选择？').set('ai', function () {
                        var currents = _status.event.list, cards = [];
                        for (var i of currents) cards.addArray(i.getCards('he'));
                        var suits = lib.suit.slice(0);
                        suits.sort(function (a, b) {
                            var num = function (suit) {
                                return cards.filter(function (card) {
                                    return get.suit(card) == suit;
                                }).length;
                            };
                            return num(b) - num(a);
                        });
                        return suits[0];
                    }).set('list', event.list);
                    'step 2'
                    var suit = result.control;
                    if (suit != 'cancel2') {
                        player.chat(get.translation(suit + 2));
                        game.log(player, '选择了', '#y' + get.translation(suit + 2));
                        event.suit = suit;
                    }
                    else event.finish();
                    'step 3'
                    var target = event.list.shift();
                    event.target = target;
                    player.line(target);
                    if (!target.countCards('he', { suit: event.suit })) event._result = { index: 1 };
                    else target.chooseControl().set('choiceList', [
                        '交给' + get.translation(player) + '所有的' + get.translation(event.suit) + '牌',
                        '不能使用或打出' + get.translation(event.suit) + '牌直到你的下个回合结束'
                    ]).set('ai', () => 1);
                    'step 4'
                    if (result.index == 0) player.gain(target.getCards('he', { suit: event.suit }), target, 'giveAuto');
                    else {
                        target.addTempSkill('minihuoxin_use', { player: 'phaseEnd' });
                        target.markAuto('minihuoxin_use', [event.suit]);
                    }
                    'step 5'
                    if (event.list.length) event.goto(3);
                },
                ai: {
                    order: 12,
                    result: {
                        target(player, target) {
                            return -target.countCards('h');
                        },
                    },
                },
                subSkill: {
                    use: {
                        charlotte: true,
                        onremove: true,
                        intro: { name: '魅惑', content: '不能使用或打出$花色的牌' },
                        mod: {
                            cardEnabled2(card, player) {
                                if (player.getStorage('minihuoxin_use').includes(get.suit(card))) return false;
                            },
                        },
                    },
                },
            },
            //神太
            minidulie: {
                audio: ['dulie1.mp3', 'dulie2.mp3', 'tspowei2.mp3'],
                inherit: 'dulie',
                logAudio: index => `dulie${typeof index == "number" ? index : get.rand(1, 2)}.mp3`,
                filter(event, player) {
                    return event.card.name == 'sha';
                },
                group: 'minidulie_dying',
                subSkill: {
                    dying: {
                        audio: 'tspowei2.mp3',
                        trigger: { player: 'dying' },
                        filter(event, player) {
                            if (game.getAllGlobalHistory('everything', evt => {
                                return evt.name === event.name && evt.player === event.player;
                            }).indexOf(event) !== 0) return false;
                            return game.hasPlayer(current => current.hasMark('minidulie'));
                        },
                        forced: true,
                        skillAnimation: true,
                        animationColor: 'fire',
                        content() {
                            player.recoverTo(game.countPlayer(current => current.hasMark('minidulie')));
                        },
                    },
                },
            },
            minichongwei: {
                audio: 'tspowei3.mp3',
                forced: true,
                group: ['minichongwei_init', 'minichongwei_move', 'minichongwei_use', 'minichongwei_remove'],
                subSkill: {
                    remove: {
                        audio: 'tspowei3.mp3',
                        trigger: { global: 'damageEnd' },
                        filter(event, player) {
                            return event.player && event.player.isIn() && event.player.hasMark('minidulie');
                        },
                        forced: true,
                        logTarget: 'player',
                        content() {
                            trigger.player.removeMark('minidulie', trigger.player.countMark('minidulie'));
                        },
                    },
                    use: {
                        audio: 'tspowei3.mp3',
                        trigger: { global: 'phaseBegin' },
                        filter(event, player) {
                            return event.player != player && event.player.hasMark('minidulie') && (player.countCards('h') > 0 || player.hp >= event.player.hp && event.player.countCards('h') > 0);
                        },
                        direct: true,
                        content() {
                            'step 0'
                            var list = [], target = trigger.player, choiceList = [
                                '弃置一张牌并对其造成1点伤害',
                                '获得其一张手牌',
                            ];
                            event.target = target;
                            if (player.hasCard(function (card) {
                                return lib.filter.cardDiscardable(card, player, 'minichongwei_use');
                            }, 'h')) list.push('选项一');
                            else choiceList[0] = '<span style="opacity:0.5">' + choiceList[0] + '</span>';
                            if (player.hp >= target.hp && target.countCards('h') > 0) list.push('选项二');
                            else choiceList[1] = '<span style="opacity:0.5">' + choiceList[1] + '</span>';
                            player.chooseControl(list, 'cancel2').set('prompt', get.prompt('minichongwei', target)).set('choiceList', choiceList).set('ai', function () {
                                var evt = _status.event.getParent();
                                if (evt.player.hasCard(function (card) {
                                    return lib.filter.cardDiscardable(card, evt.player, 'minichongwei_use') && get.value(card, evt.player) < 7;
                                }, 'h') && get.damageEffect(evt.target, evt.player, evt.player) > 0) return '选项一';
                                if (evt.player.hp >= evt.target.hp && evt.target.countCards('h') > 0 && get.attitude(evt.player, evt.target) <= 0 && !evt.target.hasSkillTag('noh')) return '选项二';
                                return 'cancel2';
                            });
                            'step 1'
                            if (result.control != 'cancel2') {
                                if (result.control == '选项二') {
                                    player.logSkill('minichongwei_use', target);
                                    player.gainPlayerCard(target, 'h', true);
                                    event.goto(3);
                                }
                            }
                            else event.finish();
                            'step 2'
                            player.chooseToDiscard('h', true).logSkill = ['minichongwei_use', target];
                            target.damage();
                            'step 3'
                            player.addTempSkill('tspowei_inRange');
                        },
                        ai: { expose: 0.2 },
                    },
                    init: {
                        audio: 'tspowei3.mp3',
                        trigger: { global: 'phaseBefore', player: 'enterGame' },
                        filter(event, player) {
                            if (!lib.skill.minichongwei.subSkill.init.logTarget(event, player).length) return false;
                            return event.name != 'phase' || game.phaseNumber == 0;
                        },
                        logTarget(event, player) {
                            return game.filterPlayer((current) => current != player && !current.hasMark('minidulie'));
                        },
                        forced: true,
                        content() {
                            var list = game.filterPlayer((current) => current != player && !current.hasMark('minidulie')).sortBySeat();
                            for (var i of list) i.addMark('minidulie', 1, false);
                        },
                    },
                    move: {
                        audio: 'tspowei3.mp3',
                        trigger: { player: 'phaseBegin' },
                        filter(event, player) {
                            return game.hasPlayer((current) => current != player && current.hasMark('minidulie'));
                        },
                        forced: true,
                        content() {
                            var list = game.filterPlayer((current) => current != player && current.hasMark('minidulie')).sortBySeat();
                            var map = {};
                            for (var i of list) {
                                var num = i.countMark('minidulie');
                                i.removeMark('minidulie', num);
                                map[i.playerid] = num;
                            }
                            for (var i of list) {
                                var next = i.next;
                                if (next == player) next = next.next;
                                next.addMark('minidulie', map[i.playerid]);
                            }
                        },
                    },
                },
            },
            minipowei: {
                derivation: 'minishenzhu',
                audio: 'tspowei1.mp3',
                trigger: { global: 'phaseEnd' },
                filter(event, player) {
                    return !game.hasPlayer(current => current.hasMark('minidulie'));
                },
                forced: true,
                skillAnimation: true,
                animationColor: 'metal',
                content() {
                    'step 0'
                    player.awakenSkill('minipowei');
                    player.addSkills('minishenzhu');
                    'step 1'
                    var num = 0;
                    game.countPlayer2(current => {
                        num += current.getRoundHistory('useSkill', evt => evt.skill == 'minichongwei_remove').length;
                    });
                    if (num) player.draw(num);
                },
            },
            minishenzhu: {
                audio: 'shenzhu',
                inherit: 'shenzhu',
                group: 'minishenzhu_wusheng',
                subSkill: {
                    wusheng: {
                        audio: 'shenzhu',
                        trigger: { player: 'phaseBegin' },
                        forced: true,
                        content() {
                            var card = get.cardPile(card => card.name == 'sha');
                            if (card) player.gain(card, 'gain2');
                        },
                    },
                },
            },
            //女娲
            minibutian: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    source: 'damageSource',
                    global: ['roundStart', 'phaseBefore'],
                    player: ['damageEnd', 'changeHp', 'gainMaxHpEnd', 'loseMaxHpEnd', 'enterGame'],
                },
                filter(event, player, name) {
                    var num = Math.floor(player.getDamagedHp() / 5);
                    if (name == 'damageEnd') return num > 0;
                    if (name == 'roundStart') return game.roundNumber > 1 && num > 0;
                    if (name == 'damageSource') return event.player != player && player.isDamaged() && num > 0;
                    if (name == 'phaseBefore' && game.phaseNumber > 0) return false;
                    return player.isHealthy();
                },
                forced: true,
                content() {
                    var num = Math.floor(player.getDamagedHp() / 5);
                    var name = event.triggername;
                    if (name == 'damageSource') player.recover(num);
                    else if (name == 'damageEnd' || name == 'roundStart') player.loseHp(num);
                    else {
                        player.$fullscreenpop('补天', 'fire');
                        var targets = game.filterPlayer(current => current != player).sortBySeat();
                        if (targets.length) {
                            targets.forEach(target => {
                                player.line(target);
                                target.die();
                            });
                        }
                    }
                },
            },
            minilianshi: {
                mod: { maxHandcardBase: (player, num) => 5 },
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    player: ['useCard', 'respond', 'loseAfter'],
                    global: ['loseAsyncAfter'],
                },
                filter(event, player) {
                    if (event.name.indexOf('lose') == 0) return event.type == 'discard' && event.getl(player).cards2.filter(card => get.position(card, true) == 'd' && !player.getStorage('minilianshi').includes(get.suit(card, player))).length > 0;
                    return event.cards?.some(card => !player.getStorage('minilianshi').includes(get.suit(card, player)) && lib.suit.includes(get.suit(card, player)));
                },
                forced: true,
                content() {
                    'step 0'
                    var cards;
                    if (trigger.name.indexOf('lose') == 0) cards = trigger.getl(player).cards2.filter(card => get.position(card, true) == 'd');
                    else cards = trigger.cards;
                    event.cards = cards;
                    var suits = cards.reduce((list, card) => list.add(get.suit(card, player)), []);
                    suits = suits.filter(suit => !player.getStorage('minilianshi').includes(suit));
                    player.markAuto('minilianshi', suits);
                    player.storage.minilianshi.sort((a, b) => lib.suit.indexOf(b) - lib.suit.indexOf(a));
                    player.addTip('minilianshi', get.translation('minilianshi') + player.getStorage('minilianshi').reduce((str, suit) => str + get.translation(suit), ""));
                    'step 1'
                    if (player.getStorage('minilianshi').length >= 4) {
                        player.draw();
                        if (player.isDamaged()) player.recover(get.number(cards[cards.length - 1], player));
                        player.unmarkSkill('minilianshi');
                        delete player.storage.minilianshi;
                        player.removeTip('minilianshi');
                    }
                },
                intro: {
                    onunmark: true,
                    content: '已记录花色：$',
                },
                onremove(player, skill) {
                    player.removeTip(skill);
                    delete player.storage[skill];
                },
            },
            minituantu: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('h') && event.minituantu;
                },
                onChooseToUse(event) {
                    if (!game.online && !event.minituantu) event.set('minituantu', ui.discardPile.childElementCount);
                },
                usable: 1,
                content() {
                    var names = player.getCards('h').reduce((list, card) => list.add(get.name(card)), []);
                    var cards = [];
                    names.forEach(name => {
                        var card = get.discardPile(card => !cards.includes(card) && card.name == name);
                        if (card) cards.push(card);
                    });
                    if (cards.length) player.gain(cards, 'gain2');
                    else player.chat('无牌可得？！');
                },
                ai: {
                    order(item, player) {
                        var names = player.getCards('h').reduce((list, card) => list.add(get.name(card)), []);
                        var cards = [];
                        names.forEach(name => {
                            var card = get.discardPile(card => !cards.includes(card) && card.name == name);
                            if (card) cards.push(card);
                        });
                        return cards.length;
                    },
                    result: { player: 1 },
                },
            },
            minitunxing: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    global: 'phaseBefore',
                    player: ['enterGame', 'logSkill'],
                },
                filter(event, player) {
                    if (event.name == 'logSkill' && event.skill != 'minimengli') return false;
                    return event.name != 'phase' || game.phaseNumber == 0;
                },
                forced: true,
                async content(event, trigger, player) {
                    if (player.additionalSkills.minitunxing && player.additionalSkills.minitunxing.length) await player.removeAdditionalSkills('minitunxing');
                    const list = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(name => {
                        if (!lib.character[name]) return false;
                        return lib.character[name][4] && lib.character[name][4].includes('zhu');
                    }).randomGets(3);
                    if (!list.length) return;
                    const result = await player.chooseButton(['###吞星：请选择获得一张武将牌###<div class="text center">获得此武将牌上的所有主公技和觉醒技外的技能</div>', [list, 'character']], true).set('ai', button => 1 + Math.random()).forResult();
                    if (result?.links?.length) {
                        const { links } = result;
                        const name = links[0], skills = get.character(name, 3).filter(skill => {
                            const info = get.info(skill);
                            return !info || (!info.zhuSkill && !info.juexingji);
                        });
                        if (skills.length) await player.addAdditionalSkills('minitunxing', skills);
                    }
                },
                derivation: 'minitunxing_faq',
                onremove(player) {
                    if (player.additionalSkills.minitunxing && player.additionalSkills.minitunxing.length) player.removeAdditionalSkills('minitunxing');
                },
            },
            minimengli: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'changeHp' },
                filter(event, player) {
                    return Math.sign(player.hp - 3.5) != Math.sign(player.hp - 3.5 - event.num);
                },
                forced: true,
                async content(event, trigger, player) {
                    const name = ('Mbaby_tunxingmengli' + (player.hp > 3 ? 'x' : ''));
                    player.changeSkin('minimengli', name);
                    await player.draw();
                },
            },
            //神左慈
            minihuanshu: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    global: ['roundStart', 'gainAfter', 'loseAsyncAfter'],
                    player: ['damageEnd', 'phaseUseBegin'],
                },
                filter(event, player) {
                    if (['gain', 'loseAsync'].includes(event.name)) return typeof event.HuanShuDestroy === 'number' && event.HuanShuDestroy > 0;
                    return event.name !== 'phaseUse' || player.hasCard(card => card.minihuanshu && !card.minihuanhua, 'h');
                },
                forced: true,
                getIndex: event => event.name === 'damage' ? event.num : 1,
                async content(event, trigger, player) {
                    if (['gain', 'loseAsync'].includes(trigger.name)) await player.draw(trigger.HuanShuDestroy);
                    else if (trigger.name == 'phaseUse') {
                        const cards = player.getCards('h', card => card.minihuanshu && !card.minihuanhua);
                        for (const card of cards) {
                            const card2 = lib.card.list.filter(cardx => {
                                if (card.suit == cardx[0] && card.number == cardx[1] && card.name == cardx[2] && card.nature == cardx[3]) return false;
                                return card.suit == cardx[0];
                            }).randomGet();
                            if (!card2) continue;
                            game.addVideo('skill', player, [event.name, [true, [get.cardInfo(card), card2]]]);
                            game.broadcastAll((card, card2) => {
                                card.init([card2[0], card2[1], card2[2], card2[3]]);
                            }, card, card2);
                        }
                    }
                    else await lib.skill.minihuanshu.GainContent(2, player);
                },
                async GainContent(length, player) {
                    game.addGlobalSkill('minihuanshu_gain');
                    let gains = [], count = 0;
                    const sum = Math.min(length, player.maxHp * 2 - player.countCards('h', card => card.minihuanshu));
                    if (sum > 0) {
                        while (sum - count > 0) {
                            count++;
                            const cardy = lib.card.list.randomGet();
                            if (cardy) gains.push(game.createCard2(cardy[2], cardy[0], cardy[1], cardy[3]));
                            else break;
                        }
                        if (gains.length) {
                            game.broadcastAll(cards => {
                                for (const card of cards) {
                                    card.minihuanshu = true;
                                    card.classList.add('minihuanshu-glow');
                                    const original = card.destroyed;
                                    card.destroyed = function (card, position, player, event) {
                                        let result = typeof original === 'function' ? original.apply(this, arguments) : false;
                                        if (position === 'handcard' && !player.hasSkill('minihuanshu', null, null, true)) {
                                            event.set('HuanShuDestroy', 1 + (event.HuanShuDestroy ?? 0));
                                            result = true;
                                        }
                                        return result;
                                    };
                                }
                            }, gains);
                            await player.gain(gains, 'draw');
                            game.addVideo('skill', player, ['minihuanshu', [false, get.cardsInfo(gains)]]);
                            game.log(player, '获得了', '#y' + get.cnNumber(gains.length) + '张', '#g“幻术”牌');
                        }
                    }
                    count = length - gains.length;
                    while (count > 0) {
                        count--;
                        await lib.skill.old_shenzhu.content(event, trigger, player);
                    }
                },
                video(player, info) {
                    if (info[0]) {
                        const [card, card2] = info[1];
                        player.getCards('h').forEach(cardx => {
                            if (cardx.cardid == card[4]) {
                                cardx.init([card2[0], card2[1], card2[2], card2[3]]);
                            }
                        });
                    }
                    else {
                        for (const card of info[1]) {
                            player.getCards('h').forEach(cardx => {
                                if (cardx.cardid == card[4]) {
                                    cardx.minihuanshu = true;
                                    cardx.classList.add('minihuanshu-glow');
                                    const original = cardx.destroyed;
                                    cardx.destroyed = function (card, position, player, event) {
                                        let result = typeof original === 'function' ? original.apply(this, arguments) : false;
                                        if (position === 'handcard' && !player.hasSkill('minihuanshu', null, null, true)) {
                                            event.set('HuanShuDestroy', 1 + (event.HuanShuDestroy ?? 0));
                                            result = true;
                                        }
                                        return result;
                                    };
                                }
                            });
                        }
                    }
                },
                derivation: 'minihuanshu_faq',
                subSkill: {
                    gain: {
                        charlotte: true,
                        mod: {
                            ignoredHandcard(card, player) {
                                if (card.minihuanshu) return true;
                            },
                            cardDiscardable(card, player, name) {
                                if (name == 'phaseDiscard' && card.minihuanshu) return false;
                            },
                        },
                    },
                },
            },
            minihuanhua: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'chooseToUse',
                onChooseToUse(event) {
                    if (!game.online && event.type == 'phase' && !event.minihuanhua_count) {
                        const player = event.player;
                        event.set('minihuanhua_count', [
                            player.getCards('h', card => card.minihuanshu && !card.minihuanhua),
                            player.getCards('h', card => (player.hasMark('minihuanjing_effect') || !card.minihuanshu) && !card.hasGaintag('minihuanhua_tag'))
                        ]);
                    }
                },
                filter(event, player) {
                    if (event.type !== 'phase') return false;
                    const count = event.minihuanhua_count;
                    return count[0].length > 0 && count[1].length > 0;
                },
                filterCard(card, player) {
                    return (get.event().minihuanhua_count[ui.selected.cards.length] ?? []).includes(card);
                },
                selectCard: 2,
                check(card) {
                    if (ui.selected.cards.length && ui.selected.cards[0].suit == card.suit) return 5 + get.useful(card) * get.value(card);
                    return get.useful(card) * get.value(card);
                },
                usable(skill, player) {
                    return 2 + player.countMark('minihuanjing_effect');
                },
                complexCard: true,
                position: 'h',
                lose: false,
                discard: false,
                delay: false,
                async content(event, trigger, player) {
                    const cards = event.cards, suit = cards[0].suit;
                    player.addGaintag([cards[1]], 'minihuanhua_tag');
                    game.addVideo('skill', player, ['minihuanhua', [false, get.cardInfo(cards[0])]]);
                    game.broadcastAll(cards => {
                        cards[0].minihuanhua = true;
                        cards[0].init([cards[1].suit, cards[1].number, cards[1].name, cards[1].nature]);
                        cards[0].classList.remove('minihuanshu-glow');
                        cards[0].classList.add('minihuanhua-glow');
                    }, cards);
                    if (suit == cards[1].suit) await lib.skill.minihuanshu.GainContent(1, player);
                    await game.delayx();
                },
                ai: {
                    order: 9,
                    result: { player: 1 },
                },
                subSkill: { tag: {} },
            },
            minihuanjing: {
                limited: true,
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                async content(event, trigger, player) {
                    const num = Math.max(1, player.getDamagedHp() * 2);
                    player.awakenSkill('minihuanjing');
                    await lib.skill.minihuanshu.GainContent(num, player);
                    player.addTempSkill('minihuanjing_effect');
                    player.addMark('minihuanjing_effect', num, false);
                },
                ai: {
                    order: 10,
                    result: { player: 1 },
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        marktext: '境',
                        intro: { content: '<li>本回合可额外发动#次【幻化】<br><li>本回合发动【幻化】可选择“幻术”牌为转化目标卡牌' },
                    },
                },
            },
            //神邓艾
            minixianjin: {
                audio: 'dcxianjin',
                inherit: 'dcxianjin',
                async content(event, trigger, player) {
                    let tags = ['dctuoyu_fengtian', 'dctuoyu_qingqu', 'dctuoyu_junshan'];
                    tags.removeArray(player.getStorage('dctuoyu'));
                    if (tags.length > 0) {
                        const { control } = tags.length > 1 ? await player.chooseControl(tags).set('choiceList', tags.map(tag => {
                            return `${get.translation(`${tag}_tag`)}：${{
                                dctuoyu_fengtian: '伤害/回复值+1',
                                dctuoyu_qingqu: '无次数和距离限制',
                                dctuoyu_junshan: '不可被响应',
                            }[tag]}`;
                        })).set('displayIndex', false).set('prompt', '险峻：选择激活一个副区域标签').forResult() : tags[0];
                        game.log(player, '激活了副区域', '#y' + get.translation(control));
                        player.markAuto('dctuoyu', [control]);
                        player.popup(get.translation(control + '_tag'));
                    }
                    await player.draw(player.getStorage('dctuoyu').length);
                },
            },
            //神陆逊
            minicuike: {
                audio: 'nzry_cuike',
                trigger: { player: 'phaseUseBegin' },
                async cost(event, trigger, player) {
                    let result = await player.chooseTarget(get.prompt('minicuike'), ['横置一名角色并弃置其区域内的一张牌', '对一名角色造成1点伤害'][player.countMark('nzry_junlve') % 2]).set('ai', target => {
                        const player = get.event().player;
                        if (player.countMark('nzry_junlve') % 2 == 1) return get.damageEffect(target, player, player);
                        return (target.isLinked() ? 0 : get.effect(target, { name: 'tiesuo' }, player, player)) + get.effect(target, { name: 'guohe' }, player, player);
                    }).forResult();
                    if (!result.bool && player.countMark('nzry_junlve') > game.countPlayer()) result.bool = true;
                    event.result = result;
                },
                popup: false,
                async content(event, trigger, player) {
                    let logged = true;
                    if ((event.targets || []).length) {
                        const target = event.targets[0];
                        await player.logSkill('minicuike', target);
                        if (player.countMark('nzry_junlve') % 2 == 1) await target.damage();
                        else {
                            await target.link(true);
                            await player.discardPlayerCard(target, 'hej', true);
                        }
                    }
                    else logged = false;
                    if (player.countMark('nzry_junlve') > game.countPlayer()) {
                        const result = await player.chooseTarget('摧克：是否对任意名其他角色各造成1点伤害？', lib.filter.notMe, [1, Infinity]).set('ai', target => {
                            const player = get.event().player;
                            if (player.countMark('nzry_junlve') % 2 == 1) return get.damageEffect(target, player, player);
                        }).forResult();
                        if (result.bool) {
                            const targets = result.targets.sortBySeat();
                            if (logged) player.line(targets, 'fire');
                            else await player.logSkill('minicuike', targets);
                            player.removeMark('nzry_junlve', player.countMark('nzry_junlve'));
                            for (const i of targets) await i.damage();
                        }
                    }
                },
            },
            //神庞统
            minilunce: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'roundStart' },
                filter(event, player) {
                    return game.hasPlayer(target => lib.skill.minilunce.derivation.some(i => !target.hasSkill(i)));
                },
                direct: true,
                async content(event, trigger, player) {
                    const result = await player.chooseTarget(get.prompt(event.name), (card, player, target) => {
                        return lib.skill.minilunce.derivation.some(i => !target.hasSkill(i));
                    }, '选择一名角色并为其分配一个计策').set('ai', target => 1 + Math.random()).forResult();
                    if (result.bool) {
                        const target = result.targets[0];
                        player.logSkill(event.name, target);
                        const list = lib.skill.minilunce.derivation.filter(i => !target.hasSkill(i));
                        let choice;
                        if (list.length == 1) choice = { control: list[0] };
                        else choice = await player.chooseControl(list).set('choiceList', (() => {
                            return list.map(i => '<div class="skill">【' + lib.translate[i] + '】</div><div>' + lib.translate[i + '_info'] + '</div>');
                        })()).set('prompt', '论策：为' + get.translation(target) + '分配一个计策').set('ai', () => {
                            return get.event().controls.randomGet();
                        }).set('displayIndex', false).forResult();
                        if (choice.control) {
                            const control = choice.control;
                            player.popup(control);
                            player.line(target);
                            target.storage[control] = player;
                            target.addSkill(control);
                            game.log(player, '为', target, '分配了', '#y' + get.translation(control));
                        }
                    }
                },
                derivation: ['minilunce_上策', 'minilunce_中策', 'minilunce_下策'],
                subSkill: {
                    '上策': {
                        charlotte: true,
                        onremove: true,
                        silent: true,
                        nopop: true,
                        trigger: { player: 'phaseUseBegin' },
                        async content(event, trigger, player) {
                            const skill = event.name, source = player.storage[skill], str = get.translation(source);
                            player.removeSkill(skill);
                            const result = await player.chooseToUse(function (card, player, event) {
                                if (get.name(card) != 'sha') return false;
                                return lib.filter.filterCard.apply(this, arguments);
                            }, '###上策：是否执行' + str + '的计策？###对一名角色使用一张无距离限制的【杀】').set('addCount', false).set('targetRequired', true).set('complexSelect', true).set('filterTarget', lib.filter.targetEnabled).forResult();
                            if (source.isIn()) {
                                const bool = Boolean(result.bool);
                                source.popup(bool ? '洗具' : '杯具', bool ? 'wood' : 'fire');
                                game.log(source, '的上策执行', bool ? '#g成功' : '#y失败');
                                source.getHistory('custom').push({ 'minilunce_上策': [bool, player] });
                            }
                        },
                        mark: true,
                        intro: { content: '<li>由$向你传授的上策<br><li>出牌阶段开始时，你可以对一名角色使用一张无距离限制的【杀】。' },
                    },
                    '中策': {
                        charlotte: true,
                        onremove: true,
                        silent: true,
                        nopop: true,
                        trigger: { player: ['phaseEnd', 'useCardToPlayered'] },
                        filter(event, player) {
                            return event.name == 'phase' || (event.card.name == 'sha' && player.getHistory('useCard', evt => {
                                return evt.card.name == 'sha';
                            }).indexOf(event.getParent()) == 0);
                        },
                        async content(event, trigger, player) {
                            const skill = event.name, source = player.storage[skill], str = get.translation(source);
                            player.removeSkill(skill);
                            if (source.isIn()) {
                                const bool = Boolean(trigger.name !== 'phase');
                                source.popup(bool ? '洗具' : '杯具', bool ? 'wood' : 'fire');
                                game.log(source, '的中策执行', bool ? '#g成功' : '#y失败');
                                source.getHistory('custom').push({ 'minilunce_中策': [bool, player] });
                                if (bool) {
                                    source.line(player);
                                    await source.gainPlayerCard(player, 'he', true);
                                }
                            }
                        },
                        mark: true,
                        intro: { content: `<li>由$向你传授的中策<br><li>当你于回合内首次使用【杀】指定目标后，$获得你一张牌，直到你的回合结束。` },
                    },
                    '下策': {
                        charlotte: true,
                        onremove: true,
                        silent: true,
                        nopop: true,
                        trigger: { player: 'phaseEnd' },
                        async content(event, trigger, player) {
                            const skill = event.name, source = player.storage[skill], str = get.translation(source);
                            player.removeSkill(skill);
                            if (source.isIn()) {
                                const bool = !player.hasHistory('sourceDamage', evt => evt.isPhaseUsing(player) && evt.card?.name == 'sha');
                                source.popup(bool ? '洗具' : '杯具', bool ? 'wood' : 'fire');
                                game.log(source, '的下策执行', bool ? '#g成功' : '#y失败');
                                source.getHistory('custom').push({ 'minilunce_下策': [bool, player] });
                                if (bool) {
                                    if (source != player) {
                                        const { bool } = await source.chooseToGive(player, [1, 3], 'he').forResult();
                                        if (bool) await player.recover();
                                    }
                                    else if (player.isDamaged()) {
                                        const { bool } = await player.chooseBool('是否回复1点体力').forResult();
                                        if (bool) await player.recover();
                                    }
                                }
                            }
                        },
                        mark: true,
                        intro: { content: '<li>由$向你传授的下策<br><li>回合结束时，若你本回合未于出牌阶段使用【杀】造成过伤害，则$可以交给你至多三张牌并令你回复1点体力。' },
                    },
                },
            },
            minilanhai: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'phaseEnd' },
                filter(event, player) {
                    return lib.skill.minilunce.derivation.some(effect => {
                        return player.getHistory('custom', evt => {
                            return evt[effect];
                        }).length;
                    });
                },
                forced: true,
                async content(event, trigger, player) {
                    const bool = player.hasHistory('custom', evt => {
                        return lib.skill.minilunce.derivation.some(effect => {
                            return evt[effect] && evt[effect][0];
                        });
                    });
                    const history = player.getRoundHistory('custom', evt => {
                        return lib.skill.minilunce.derivation.some(effect => {
                            return evt[effect] && evt[effect][0];
                        });
                    });
                    if (bool) {
                        await player.draw(Math.min(3, history.length));
                        const targets = game.filterPlayer(current => {
                            return lib.skill.minilunce.derivation.some(i => !current.hasSkill(i));
                        });
                        if (!targets.length) return;
                        await player.useSkill('minilunce');
                    }
                    else {
                        if (player.countMark('minilanhai') < 3) {
                            player.addMark('minilanhai', 1, false);
                            await player.gainMaxHp();
                        }
                        await player.recover();
                    }
                },
            },
            //精卫
            minitianhai: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: ['useCard', 'respond'] },
                filter(event, player) {
                    const { card, player: target } = event, number = get.number(card);
                    if (typeof number !== 'number') return false;
                    const storage = player.getStorage('minitianhai'), bool = !storage.includes(number);
                    if (player == target) return bool && player.hasHistory('lose', evt => evt.getParent() == event && evt.hs?.length);
                    if (bool) return false;
                    if (number >= 10 && !target.hasCard(card => lib.filter.cardDiscardable(card, target, 'minitianhai'), 'he')) return false;
                    return true;
                },
                forced: true,
                async content(event, trigger, player) {
                    const { card, player: target } = trigger, number = get.number(card);
                    if (player == target) player.markAuto(event.name, [number]);
                    else {
                        if (number <= 4) {
                            target.addSkill(event.name + '_damage');
                            target.addMark(event.name + '_damage', 1, false);
                            game.log(target, '下一次受到的伤害', '#g+1');
                        }
                        else if (number >= 10) {
                            const num = target.getCards('he').filter(card => lib.filter.cardDiscardable(card, target, 'minitianhai')).reduce((sum, card) => sum + get.number(card), 0);
                            if (num <= number) await target.discard(target.getCards('he'));
                            else await target.chooseToDiscard(`弃置任意张点数之和不小于${number}的牌`, 'he', true).set('selectCard', function () {
                                let num = 0;
                                for (let i = 0; i < ui.selected.cards.length; i++) {
                                    num += get.number(ui.selected.cards[i]);
                                }
                                if (num >= _status.event.num) return ui.selected.cards.length;
                                return ui.selected.cards.length + 2;
                            }).set('ai', card => {
                                return 6 - get.value(card);
                            }).set('num', number).set('complexCard', true);
                        }
                        else await player.draw();
                    }
                },
                onremove: true,
                intro: {
                    content: '已记录点数：$',
                },
                subSkill: {
                    damage: {
                        trigger: { player: 'damageBegin3' },
                        forced: true,
                        charlotte: true,
                        onremove: true,
                        content() {
                            trigger.num += player.countMark(event.name);
                            player.removeSkill(event.name);
                        },
                        intro: { content: '下次受到伤害时，此伤害+#' },
                    }
                }
            },
            minihaiku: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: ['gainAfter', 'loseAsyncAfter'] },
                filter(event, player, name, target) {
                    if (player.getStorage('minitianhai').length != 13) return false;
                    return target?.isIn();
                },
                getIndex(event, player) {
                    const evt = event.getParent('phaseDraw');
                    if (evt?.name == 'phaseDraw') return false;
                    return game.filterPlayer(current => {
                        if (evt?.player == current || player == current) return false;
                        return event.getg(current).some(card => get.owner(card) == current && lib.filter.cardDiscardable(card, current, 'minihaiku'));
                    }).sortBySeat();
                },
                logTarget: (event, player, triggername, target) => target,
                forced: true,
                async content(event, trigger, player) {
                    const target = event.targets[0];
                    let cards = trigger.getg(target).filter(card => get.owner(card) == target && lib.filter.cardDiscardable(card, target, 'minihaiku'));
                    if (cards.length) await target.discard(cards);
                    cards = cards.filterInD('d');
                    if (cards.length) await player.gain(cards, 'gain2');
                },
                ai: { combo: 'minitianhai' },
            },
            // 神鲁肃
            minitamo: {
                audio: 'tamo',
                inherit: 'tamo',
                getTargets() {
                    return game.filterPlayer(current => {
                        if (get.mode() === 'doudizhu') return current.getSeatNum() !== 3;
                        return !current.isZhu2();
                    });
                },
                filter(event, player) {
                    return (event.name != 'phase' || game.phaseNumber == 0) && get.info('minitamo').getTargets().length > 1;
                },
            },
            minidingzhou: {
                audio: 'dingzhou',
                inherit: 'dingzhou',
                filter(event, player) {
                    const num = player.countCards('he');
                    return game.hasPlayer(current => {
                        if (current == player) return false;
                        const total = current.countCards('ej');
                        return (total > 0 && num >= total) || current.countCards('h');
                    });
                },
                selectCard() {
                    const player = get.player();
                    if (ui.selected.cards.length) return [1, Math.max(...game.filterPlayer(current => current != player).map(current => current.countCards('ej')))];
                    return [0, 1];
                },
                check(card) {
                    const player = get.player();
                    const num = player.countCards('he');
                    if (game.hasPlayer(current => {
                        if (current == player || get.attitude(player, current) > 0) return false;
                        const total = current.countCards('ej');
                        return total > 0 && num >= total && total >= current.countCards('h');
                    })) return 7 - get.value(card);
                    return 0;
                },
                filterTarget(card, player, target) {
                    if (player == target) return false;
                    const num = ui.selected.cards.length;
                    if (!num) return target.countCards('h');
                    return num == target.countCards('ej');
                },
                selectTarget() {
                    if (ui.selected.cards.length) return [1, 1];
                    return [0, 1];
                },
                filterOk() {
                    const { targets } = ui.selected;
                    if (!targets.length) return false;
                    const num = ui.selected.cards.length;
                    if (!num) return targets[0].countCards('h');
                    return num == targets[0].countCards('ej');
                },
                async content(event, trigger, player) {
                    const { target, cards } = event;
                    if (cards?.length) {
                        await player.give(event.cards, target);
                        const cards = target.getGainableCards(player, 'ej');
                        if (cards.length) await player.gain(cards, 'give', target);
                    }
                    else {
                        const cards = target.getGainableCards(player, 'h');
                        if (!cards.length) return;
                        await player.gain(cards, 'give', target);
                        if (player.countCards('he')) await player.chooseToGive(target, 'he', cards.length, true).set('ai', card => {
                            const { player, target } = get.event();
                            if (player.hasSkill('zhimeng') && get.position(card) == 'e') return 10;
                            return 6 - get.value(card);
                        });
                    }
                },
                ai: {
                    order: 9,
                    result: {
                        target(player, target) {
                            let eff = 0;
                            if (ui.selected.cards.length) eff = ui.selected.cards.map(card => get.value(card)).reduce((p, c) => p + c, 0);
                            else eff = -target.getGainableCards(player, 'h').map(card => get.value(card)).reduce((p, c) => p + c, 0);
                            if (player.hasSkill('zhimeng')) eff *= 1 + get.sgnAttitude(player, target) * 0.15;
                            if (ui.selected.cards.length) {
                                const es = target.getCards('e'), js = target.getCards('j');
                                es.forEach(card => {
                                    eff -= get.value(card, target);
                                });
                                js.forEach(card => {
                                    eff -= get.effect(target, { name: card.viewAs || card.name, cards: [card] }, target, target);
                                });
                            }
                            return eff;
                        },
                    },
                },
            },
            //喵
            //核心逗猫
            minidoumao: {
                audio: 'ext:活动武将/audio/skill:1',
                trigger: { player: ['phaseBegin', 'phaseEnd'] },
                filter(event, player) {
                    return player.countCards('he');
                },
                async cost(event, trigger, player) {
                    if (event.triggername == 'phaseEnd') event.result = { bool: true };
                    else event.result = await player.chooseCardTarget({
                        prompt: get.prompt(event.skill),
                        prompt2: '弃置一张牌，失去【逗猫】并令一名其他角色获得【逗猫】，然后其摸一张牌',
                        filterTarget: lib.filter.notMe,
                        filterCard: lib.filter.cardDiscardable,
                        position: 'he',
                        ai1(card) {
                            const player = get.player();
                            let val = 7 - get.value(card);
                            if (player.hasSkill('minimiaoyuma') && get.position(card) == 'e' && ['equip3', 'equip4'].some(subtype => get.subtypes(card).includes(subtype))) val += 2;
                            return val;
                        },
                        ai2(target) {
                            const player = get.player();
                            const att = get.attitude(player, target);
                            //集智
                            if (target.hasSkill('minimiaojizhi')) return 10 * (-Math.sign(att));
                            //枪舞
                            if (player.hasSkill('minimiaoqiangwu')) {
                                player._minimiaoqiangwu_check = true;
                                const cards = player.getCards('hs', card => {
                                    return card.name == 'sha' && player.canUse(card, target);
                                });
                                if (cards.length > 1) {
                                    if (att >= 0) return 0;
                                    let sum = 0;
                                    for (const card of cards) sum += get.effect(target, card, player, player);
                                    if (sum <= 0) return 0;
                                    else {
                                        while (sum < 1 || sum > 10) {
                                            if (sum < 1) sum = sum * 10;
                                            if (sum > 10) sum = sum / 10;
                                        }
                                        return sum;
                                    }
                                }
                                return 0;
                            }
                            if (player._minimiaoqiangwu_check) delete player._minimiaoqiangwu_check;
                            //顺位传递
                            const players = game.filterPlayer(current => {
                                if (current.hasSkill('minimiaojizhi') || current.hasSkill('minimiaoqiangwu')) return false;
                                return current != player && !current.isTurnedOver() && get.attitude(player, current) > 0 && get.attitude(current, player) > 0;
                            }).sortBySeat(player);
                            if (players.length) return target == players[0] ? (att * (target.getSkills().some(skill => skill.indexOf('minimiao') == 0) ? 0.5 : 1)) : -1;
                            //普通传递
                            return Math.sign(att) + att / 114514;
                        },
                    }).forResult();
                },
                async content(event, trigger, player) {
                    if (event.triggername == 'phaseBegin') {
                        const { cards, targets: [target] } = event;
                        await player.discard(cards);
                        await player.removeSkills(event.name);
                        await target.addSkills(event.name);
                        await target.draw();
                    }
                    else if (player.countCards('he')) await player.chooseToDiscard(true, 'he');
                },
                mark: true,
                marktext: '猫',
                intro: { content: '嘿！有只猫在你身边欸！' },
            },
            //喵蔡文姬
            minimiaobeige: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'damageEnd' },
                filter(event, player) {
                    return event.card && event.card.name == 'sha' && event.source && event.source.isIn() && event.player.isIn() && player.countCards('he');
                },
                direct: true,
                preHidden: true,
                content() {
                    'step 0'
                    player.chooseToDiscard('he', get.prompt2('minimiaobeige', trigger.player)).set('ai', function (card) {
                        var player = _status.event.player;
                        var target = _status.event.list[0];
                        var source = _status.event.list[1];
                        var att1 = get.attitude(player, target);
                        var att2 = get.attitude(player, source);
                        switch (get.suit(card, player)) {
                            case 'heart': case 'diamond':
                                if (att1 > 0) return 10 - get.value(card);
                                return 0;
                                break;
                            case 'club':
                                if (att2 < 0) return (7 - get.value(card)) * (source.countCards('he') ? 1 : 0);
                                return 0;
                                break;
                            case 'spade':
                                if (att2 > 0 && source.isTurnedOver()) return 20 - get.value(card);
                                if (att2 < 0 && !source.isTurnedOver()) return 10 - get.value(card);
                                return 0;
                                break;
                        }
                    }).setHiddenSkill('minimiaobeige').set('list', [trigger.player, trigger.source]).logSkill = 'minimiaobeige';
                    'step 1'
                    if (result.bool) {
                        switch (get.suit(result.cards[0], player)) {
                            case 'heart':
                                player.line(trigger.player);
                                trigger.player.recover();
                                break;
                            case 'diamond':
                                player.line(trigger.player);
                                trigger.player.draw(2);
                                break;
                            case 'club':
                                player.line(trigger.source);
                                trigger.source.chooseToDiscard('he', 2, true);
                                break;
                            case 'spade':
                                player.line(trigger.source);
                                trigger.source.turnOver();
                                break;
                        }
                        if (player.hasSkill('minidoumao')) { event.finish(); return; }
                        player.chooseButton([
                            '悲歌：是否额外选择一个效果执行',
                            [[
                                ['heart', '令' + get.translation(trigger.player) + '回复1点体力'],
                                ['diamond', '令' + get.translation(trigger.player) + '摸两张牌'],
                                ['club', '令' + get.translation(trigger.source) + '弃置两张牌'],
                                ['spade', '令' + get.translation(trigger.source) + '将武将牌翻面']
                            ].filter(list => list[0] != get.suit(result.cards[0], player)), 'textbutton']
                        ]).set('ai', function (button) {
                            var player = _status.event.player;
                            var target = _status.event.list[0];
                            var source = _status.event.list[1];
                            var att1 = get.attitude(player, target);
                            var att2 = get.attitude(player, source);
                            switch (button.link) {
                                case 'heart':
                                    if (att1 > 0) return 3;
                                    return 0;
                                    break;
                                case 'diamond':
                                    if (att1 > 0) return 2;
                                    return 0;
                                    break;
                                case 'club':
                                    if (att2 < 0) return 1;
                                    return 0;
                                    break;
                                case 'spade':
                                    if (att2 > 0 && source.isTurnedOver()) return 5;
                                    if (att2 < 0 && !source.isTurnedOver()) return 4;
                                    return 0;
                                    break;
                            }
                        }).set('list', [trigger.player, trigger.source]);
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        if (result.links.includes('heart')) {
                            player.line(trigger.player);
                            trigger.player.recover();
                        }
                        if (result.links.includes('diamond')) {
                            player.line(trigger.player);
                            trigger.player.draw(2);
                        }
                        if (result.links.includes('club')) {
                            player.line(trigger.source);
                            trigger.source.chooseToDiscard('he', 2, true);
                        }
                        if (result.links.includes('spade')) {
                            player.line(trigger.source);
                            trigger.source.turnOver();
                        }
                    }
                },
                ai: { expose: 0.25 },
            },
            minimiaoduanchang: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'dying' },
                filter(event, player) {
                    if (player.hasSkill('minidoumao')) return false;
                    return event.getParent().name == 'damage' && event.source && event.source.countCards('he');
                },
                forced: true,
                logTarget: 'source',
                content() {
                    trigger.source.chooseToDiscard('he', true, 2);
                },
                group: 'minimiaoduanchang_duanchang',
                subSkill: {
                    duanchang: {
                        audio: 'minimiaoduanchang',
                        inherit: 'duanchang',
                    },
                },
            },
            //喵貂蝉
            minimiaolijian: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                filter(event, player) {
                    return game.countPlayer() > 1;
                },
                filterCard: true,
                selectCard() {
                    const player = get.event().player, goon = (!player.hasSkill('minidoumao'));
                    return [goon ? 1 : 2, Infinity];
                },
                position: 'he',
                filterTarget: true,
                selectTarget() {
                    const player = get.event().player, goon = (!player.hasSkill('minidoumao'));
                    return ui.selected.cards.length + (goon ? 1 : 0);
                },
                filterOk() {
                    const player = get.event().player, goon = (!player.hasSkill('minidoumao'));
                    return ui.selected.targets.length == ui.selected.cards.length + (goon ? 1 : 0);
                },
                check(card) {
                    let player = get.owner(card), targets = lib.skill.minimiaolijian.selectTargetAi(_status.event, player);
                    if (ui.selected.cards.length < targets - 1) {
                        if (player.hasSkill('sbbiyue')) return 4 * targets - get.value(card);
                        return 6 + targets - get.value(card);
                    }
                    return 0;
                },
                multiline: true,
                usable: 1,
                content() {
                    var targetx = targets.slice().sortBySeat(target)[1];
                    var card = { name: 'juedou', isCard: true };
                    if (target.canUse(card, targetx)) target.useCard(card, targetx);
                },
                ai: {
                    threaten: 3,
                    order: 7,
                    result: {
                        player(player, target) {
                            let targets = _status.event.getTempCache('minimiaolijian', 'targets');
                            if (Array.isArray(targets)) {
                                for (let arr of targets) {
                                    if (target === arr[0] && !arr[2]) return 1;
                                }
                            }
                            return 0;
                        },
                        target(player, target) {
                            let targets = _status.event.getTempCache('minimiaolijian', 'targets');
                            if (Array.isArray(targets)) {
                                for (let arr of targets) {
                                    if (target === arr[0]) {
                                        if (arr[1] * arr[2] < 0) return Math.sign(arr[2]);
                                        return arr[1];
                                    }
                                }
                            }
                            return 0;
                        },
                    },
                },
                selectTargetAi(event, player) {
                    let cache = _status.event.getTempCache('minimiaolijian', 'targets');
                    if (Array.isArray(cache)) return cache.length;
                    let targets = [], cards = [0], sbbiyue = player.hasSkill('sbbiyue') ? Math.max(0, 3 - game.countPlayer2(current => {
                        return current.getHistory('damage').length > 0;
                    })) : 0, alter = [null, 1, 1], temp;
                    for (let i of game.players) {
                        if (player === i) continue;
                        let vplayer = ui.create.player(i);
                        temp = get.effect(i, new lib.element.VCard({ name: 'juedou', isCard: true }), vplayer, i);
                        vplayer.remove();
                        if (temp) {
                            let att = get.attitude(event.player, i);
                            if (!att && sbbiyue || att * temp > 0) targets.push([i, temp, att]);
                            else if (!alter[2]) continue;
                            else if (!att || att > 0 && temp > -15 && i.hp > 2 || att < 0 && temp < 15) alter = [i, temp, att];
                        }
                    }
                    targets.sort((a, b) => {
                        if (Boolean(a[2]) !== Boolean(b[2])) return Math.abs(b[2]) - Math.abs(a[2]);
                        return Math.abs(b[1]) - Math.abs(a[1]);
                    });
                    if (targets.length < 2 && alter[0]) targets.push(alter);
                    targets = targets.slice(0, 1 + player.countCards('he', card => {
                        if (lib.filter.cardDiscardable(card, player, 'minimiaolijian')) {
                            cards.push(get.value(card));
                            return true;
                        }
                        return false;
                    }));
                    cards.sort((a, b) => a - b);
                    for (let i = 0; i < targets.length; i++) {
                        if (Math.abs(targets[i][1]) < cards[i] / (1 + sbbiyue)) {
                            targets.splice(i, targets.length - i);
                            break;
                        }
                    }
                    if (targets.length < 2) {
                        event.putTempCache('minimiaolijian', 'targets', []);
                        return 0;
                    }
                    event.putTempCache('minimiaolijian', 'targets', targets);
                    return targets.length;
                },
            },
            minimiaobiyue: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseJieshuBegin' },
                forced: true,
                content() {
                    player.draw(Math.min(5, game.countPlayer2(current => current.getHistory('damage').length) + (player.hasSkill('minidoumao') ? 1 : 2)));
                },
            },
            //喵蔡夫人
            minimiaoqieting: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'phaseEnd' },
                filter(event, player) {
                    return event.player != player;
                },
                direct: true,
                content() {
                    'step 0'
                    var list = ['摸一张牌'], target = trigger.player, str = get.translation(target);
                    event.target = target;
                    if (target.hasSkill('minidoumao') && target.countCards('h') > 0) list.push('观看' + str + '的两张手牌并获得其中一张');
                    if (!target.hasSkill('minidoumao') && target.countCards('e', function (card) {
                        return player.canEquip(card);
                    }) > 0) list.push('将' + str + '装备区内的一张牌移动至自己的装备区');
                    player.chooseControl('cancel2').set('choiceList', list).set('prompt', get.prompt('minimiaoqieting', target)).set('ai', function () {
                        var evt = _status.event.getParent();
                        var player = evt.player, target = evt.target;
                        var list = _status.event.choiceList;
                        if (get.attitude(player, target) > 0 || list.length == 1) return 0;
                        if (target.hasSkill('minidoumao')) return 1;
                        var val = (target.hasSkillTag('noe') ? 6 : 0);
                        if (target.countCards('e', function (card) {
                            return player.canEquip(card) && get.value(card, target) > val && get.effect(player, card, player, player) > 0;
                        }) > 0) return 1;
                        return 0;
                    }).set('list', list);
                    'step 1'
                    if (result.control != 'cancel2') {
                        player.logSkill('minimiaoqieting', target);
                        if (result.index == 0) {
                            player.draw();
                            event.finish();
                        }
                        else if (target.hasSkill('minidoumao')) {
                            player.choosePlayerCard(target, 'h', 2, true);
                            player.addExpose(0.2);
                            event.goto(3);
                        }
                        else {
                            player.addExpose(0.1);
                            player.choosePlayerCard(target, 'e', true).set('filterButton', function (button) {
                                return _status.event.player.canEquip(button.link);
                            }).set('ai', function (button) {
                                var player = _status.event.player;
                                return get.effect(player, button.link, player, player);
                            });
                        }
                    }
                    else event.finish();
                    'step 2'
                    if (result.bool) {
                        var card = result.cards[0];
                        target.$give(card, player, false);
                        game.delay(0.5);
                        player.equip(card);
                    }
                    event.finish();
                    'step 3'
                    if (result.bool) player.chooseButton(['选择获得一张牌', result.cards], true);
                    else event.finish();
                    'step 4'
                    if (result.bool) {
                        var card = result.links[0];
                        if (lib.filter.canBeGained(card, player, target)) player.gain(card, target, 'giveAuto', 'bySelf');
                        else game.log('但', card, '不能被', player, '获得！');
                    }
                },
            },
            minimiaoxianzhou: {
                limited: true,
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                filter(event, player) {
                    return player.countCards('he') > 0;
                },
                filterCard: true,
                selectCard: [1, Infinity],
                check(card) {
                    var player = _status.event.player;
                    if (ui.selected.cards.length >= player.hp) return 0;
                    return 7 - get.value(card);
                },
                filterTarget: lib.filter.notMe,
                discard: false,
                lose: false,
                delay: false,
                skillAnimation: true,
                animationColor: 'gray',
                content() {
                    'step 0'
                    player.addSkill('minimiaoxianzhou_restore');
                    player.awakenSkill('minimiaoxianzhou');
                    player.give(cards, target);
                    'step 1'
                    var list = game.filterPlayer(function (current) {
                        return target.inRange(current);
                    });
                    if (list.length) {
                        var max = Math.min(list.length, cards.length);
                        target.chooseTarget([1, max], '献州：对至多' + get.cnNumber(max) + '名范围内的角色各造成1点伤害，或点“取消”令' + get.translation(player) + '回复' + cards.length + '点体力', function (card, player, target) {
                            return _status.event.list.includes(target);
                        }).set('list', list).set('ai', function (target) {
                            var player = _status.event.player;
                            return get.damageEffect(target, player, player);
                        });
                    }
                    else event._result = { bool: false };
                    'step 2'
                    if (result.bool) {
                        var targets = result.targets.sortBySeat();
                        target.line(targets, 'green');
                        for (var i of targets) i.damage('nocard', target);
                    }
                    else player.recover(cards.length);
                },
                ai: {
                    order: 1,
                    result: {
                        target: 1,
                        player(player) {
                            var bool = true, players = game.filterPlayer();
                            for (var i = 0; i < players.length; i++) {
                                if (players[i] != player && get.attitude(player, players[i]) > 2 && get.attitude(players[i], player) > 2) {
                                    bool = false; break;
                                }
                            }
                            if (bool) return -10;
                            if (player.hp == 1) return 1;
                            return -10;
                        }
                    },
                },
                subSkill: {
                    restore: {
                        audio: 'minimiaoxianzhou',
                        trigger: { player: 'changeSkillsAfter' },
                        filter(event, player) {
                            return event.addSkill.includes('minidoumao');
                        },
                        forced: true,
                        locked: false,
                        content() {
                            player.restoreSkill('minimiaoxianzhou');
                            player.removeSkill('minimiaoxianzhou_restore');
                            player.popup(event.name);
                            game.log(player, '重置了技能', `#g【${get.translation(event.name)}】`);
                        },
                    },
                },
            },
            //喵张星彩
            minimiaoshenxian: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: ['loseAfter', 'loseAsyncAfter'] },
                filter(event, player) {
                    if (event.type !== 'discard' || event.getlx === false) return false;
                    return game.hasPlayer2(target => {
                        if (target === player) return false;
                        return event.getl?.(target)?.cards2?.some(card => {
                            const type = get.type2(card, target);
                            return player.hasSkill('minidoumao') ? (type === 'basic') : (type !== 'equip');
                        });
                    });
                },
                usable: 1,
                frequent: true,
                content() {
                    'step 0'
                    if (trigger.delay == false) game.delay();
                    'step 1'
                    player.draw();
                },
            },
            minimiaoqiangwu: {
                mod: {
                    targetInRange(card, player, target) {
                        if (player._minimiaoqiangwu_check) return;
                        if (card.name == 'sha' && !target.hasSkill('minidoumao')) return true;
                    },
                    cardUsableTarget(card, player, target) {
                        if (card.name == 'sha' && target.hasSkill('minidoumao')) return Infinity;
                    },
                },
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { source: 'damageSource' },
                filter(event, player) {
                    return event.card && event.card.name == 'sha' && player.hasSkill('minidoumao');
                },
                forced: true,
                locked: false,
                content() {
                    player.draw();
                },
            },
            //喵祝融
            minimiaojuxiang: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    player: 'useCard',
                    target: 'nanmanBefore',
                    source: 'damageSource',
                    global: ['useCardAfter', 'loseAfter', 'loseAsyncAfter'],
                },
                filter(event, player, name) {
                    switch (event.name) {
                        case 'nanman':
                            return true;
                        case 'useCard':
                            if (event.card.name !== 'nanman') return false;
                            if (name === 'useCard') return game.hasPlayer(current => current !== player && current.hasSkill('minidoumao'));
                            return event.player !== player && event.cards?.someInD();
                        case 'damage':
                            if (!event.card || event.card.name !== 'nanman') return false;
                            return !event.player.hasSkill('minidoumao');
                        default:
                            if (event.type != 'discard' || event.getlx === false) return false;
                            return game.hasPlayer2(target => {
                                if (target === player) return false;
                                return event.getl?.(target)?.cards2?.some(card => card.name === 'nanman' && get.position(card) === 'd');
                            });
                    }
                },
                forced: true,
                preHidden: true,
                async content(event, trigger, player) {
                    switch (trigger.name) {
                        case 'nanman':
                            trigger.cancel();
                            game.log(trigger.card, '对', player, '无效');
                            break;
                        case 'useCard':
                            if (event.triggername === 'useCard') {
                                const targets = game.filterPlayer(current => current != player && current.hasSkill('minidoumao'));
                                player.line(targets);
                                trigger.directHit.addArray(targets);
                                game.log(targets, '不可响应', trigger.card);
                            }
                            else await player.gain(trigger.cards.filterInD(), 'gain2');
                            break;
                        case 'damage':
                            await player.draw();
                            break;
                        default:
                            await player.gain(game.filterPlayer2(target => {
                                if (target === player) return false;
                                return trigger.getl?.(target)?.cards2?.some(card => card.name === 'nanman' && get.position(card) === 'd');
                            }).reduce((list, target) => {
                                list.addArray(trigger.getl(target).cards2.filter(card => card.name === 'nanman' && get.position(card) === 'd'));
                                return list;
                            }, []), 'gain2');
                            break;
                    }
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        return arg?.card && arg.card.name === 'nanman' && arg.target && arg.target !== player && arg.target.hasSkill('minidoumao');
                    },
                    effect: {
                        target(card) {
                            if (card.name == 'nanman') return [0, 1, 0, 0];
                        },
                    },
                },
            },
            minimiaolieren: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseUseBegin' },
                filter(event, player) {
                    if (!game.getGlobalHistory('everything', evt => {
                        return evt.name === 'changeSkills' && evt.player === player && evt.removeSkill.includes('minidoumao');
                    }).length) return false;
                    return game.hasPlayer(target => player.canCompare(target));
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseTarget(get.prompt('minimiaolieren'), '对一名角色发动【烈刃①】', function (card, player, target) {
                        return player.canCompare(target);
                    }).set('ai', function (target) {
                        return -get.attitude(player, target) * target.countCards('e') / target.countCards('h');
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0];
                        event.target = target;
                        player.logSkill('minimiaolieren', target);
                        player.chooseToCompare(target).clear = false;
                    }
                    else event.finish();
                    'step 2'
                    if (result) {
                        if (result.target && get.position(result.target) === 'd') player.gain(result.target, 'gain2');
                        if (result.bool && target.countGainableCards(player, 'he')) player.gainPlayerCard(target, true, 'he');
                        ui.clear();
                    }
                },
                ai: { expose: 0.25 },
                group: 'minimiaolieren_lieren',
                subSkill: {
                    lieren: {
                        audio: 'minimiaolieren',
                        inherit: 'minirelieren',
                    },
                },
            },
            minimiaochangbiao: {
                audio: 'changbiao',
                mod: {
                    targetInRange(card, player, target) {
                        if (card.minimiaochangbiao) return true;
                    },
                    selectTarget(card, player, num) {
                        if (player.hasSkill('minidoumao') && card.minimiaochangbiao && num[1] != -1) num[1]++;
                    },
                },
                enable: 'phaseUse',
                usable: 1,
                position: 'hs',
                viewAs: {
                    name: 'sha',
                    minimiaochangbiao: true,
                },
                locked: false,
                filter(event, player) {
                    return player.countCards('hs') > 0;
                },
                filterCard: true,
                selectCard: [1, Infinity],
                position: 'hs',
                check(card) {
                    var player = _status.event.player;
                    if (ui.selected.cards.length) {
                        var list = game.filterPlayer(function (current) {
                            return current != player && player.canUse('sha', current, false) && get.effect(current, { name: 'sha' }, player, player) > 0;
                        }).sort(function (a, b) {
                            return get.effect(b, { name: 'sha' }, player, player) - get.effect(a, { name: 'sha' }, player, player);
                        });
                        if (!list.length) return 0;
                        var target = list[0];
                        if (target.mayHaveShan() && !player.hasSkillTag('directHit_ai', true, {
                            target: target,
                            card: card,
                        }, true)) return 0;
                        return 6.5 - get.value(card);
                    }
                    return 6.3 - get.value(card);
                },
                onuse(result, player) {
                    player.addTempSkill('minimiaochangbiao_draw');
                },
                subSkill: {
                    draw: {
                        trigger: { player: 'phaseUseEnd' },
                        forced: true,
                        charlotte: true,
                        filter(event, player) {
                            return player.getHistory('sourceDamage', function (evxt) {
                                var evt = evxt.getParent();
                                return evt?.name == 'sha' && evt.skill == 'minimiaochangbiao' && evt.getParent('phaseUse') == event;
                            }).length > 0;
                        },
                        content() {
                            var num = 0;
                            player.getHistory('sourceDamage', function (evxt) {
                                var evt = evxt.getParent();
                                if (evt?.name == 'sha' && evt.skill == 'minimiaochangbiao' && evt.getParent('phaseUse') == trigger) num += evt.cards.length;
                            });
                            player.draw(num);
                        },
                    },
                },
                ai: {
                    order(item, player) {
                        return get.order({ name: 'sha' }, player) + 0.3 * (Math.min(player.getCardUsable('sha'), player.countCards('hs', 'sha') + player.hasCard(function (card) {
                            return card.name != 'sha' && get.value(card, player) < 6.3;
                        }, 'hs') ? 1 : 0) > 1 ? -1 : 1);
                    },
                },
            },
            //喵黄月英
            minimiaojizhi: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'useCard' },
                filter(event, player) {
                    if (get.type2(event.card) != 'trick') return false;
                    return event.player == player || (!player.hasSkill('minidoumao') && !player.hasSkill('minimiaojizhi_used'));
                },
                frequent: true,
                content() {
                    player.draw();
                    if (trigger.player != player) player.addTempSkill('minimiaojizhi_used');
                },
                subSkill: { used: { charlotte: true } },
            },
            minimiaoqicai: {
                mod: {
                    targetInRange(card, player, target, now) {
                        var type = get.type2(card);
                        if (type == 'trick' || type == 'delay') return true;
                    },
                    canBeDiscarded(card) {
                        if (get.position(card) == 'e' && get.subtype(card) == 'equip2') return false;
                    },
                },
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'changeSkillsAfter' },
                filter(event, player) {
                    return event.player !== player && event.addSkill.includes('minidoumao');
                },
                forced: true,
                content() {
                    const card = get.cardPile2(card => get.type2(card) == 'trick');
                    if (card) player.gain(card, 'gain2');
                },
            },
            minimiaoguose: {
                audio: 'ext:活动武将/audio/skill:2',
                inherit: 'sbguose',
                usable: 4,
                content() {
                    'step 0'
                    if (target.hasJudge('lebu')) target.discard(target.getJudge('lebu'));
                    else player.useCard({ name: 'lebu' }, target, cards).audio = false;
                    'step 1'
                    player.draw(target.hasSkill('minidoumao') ? 2 : 1);
                    if (target.hasSkill('minidoumao')) player.chooseToDiscard(true, 'he', '国色：请弃置一张牌');
                },
                ai: {
                    order: 9,
                    result: {
                        target(player, target) {
                            var num = (target.hasSkill('minidoumao') ? 2 : 1);
                            if (target.hasJudge('lebu')) return -get.effect(target, { name: 'lebu' }, player, target) * num;
                            return get.effect(target, { name: 'lebu' }, player, target) * num;
                        },
                    },
                },
            },
            minimiaoliuli: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { target: 'useCardToTarget' },
                filter(event, player) {
                    if (event.card.name != 'sha') return false;
                    if (!player.countCards('he')) return false;
                    return game.hasPlayer(current => {
                        return player.inRange(current) && current != event.player && current != player && lib.filter.targetEnabled(event.card, event.player, current);
                    });
                },
                preHidden: true,
                async cost(event, trigger, player) {
                    event.result = await player.chooseCardTarget({
                        position: 'he',
                        filterCard: lib.filter.cardDiscardable,
                        filterTarget(card, player, target) {
                            var trigger = _status.event;
                            if (player.inRange(target) && target != trigger.source) {
                                if (lib.filter.targetEnabled(trigger.card, trigger.source, target)) return true;
                            }
                            return false;
                        },
                        selectTarget() {
                            return get.player().hasSkill('minidoumao') ? 1 : [1, 2];
                        },
                        ai1(card) {
                            return get.unuseful(card) + 9;
                        },
                        ai2(target) {
                            const player = get.player();
                            const att = get.attitude(player, target);
                            if (player.countCards('h', 'shan')) return -att;
                            if (!ui.selected.targets.length) {
                                if (att < 5) return 6 - att;
                                if (player.hp == 1 && !player.countCards('h', 'shan')) return 10 - att;
                                if (player.hp == 2 && !player.countCards('h', 'shan')) return 8 - att;
                            }
                            return -1;
                        },
                        prompt: get.prompt2(event.skill),
                        source: trigger.player,
                        card: trigger.card,
                    }).setHiddenSkill(event.skill).forResult();
                },
                async content(event, trigger, player) {
                    const { cards, targets } = event;
                    await player.discard(cards);
                    const evt = trigger.getParent();
                    evt.triggeredTargets2.remove(player);
                    evt.targets.remove(player);
                    evt.targets.addArray(targets);
                },
                ai: {
                    effect: {
                        target(card, player, target) {
                            if (target.countCards('he') == 0) return;
                            if (card.name != 'sha') return;
                            var min = 1;
                            var friend = get.attitude(player, target) > 0;
                            var vcard = { name: 'shacopy', nature: card.nature, suit: card.suit };
                            var players = game.filterPlayer();
                            for (var i = 0; i < players.length; i++) {
                                if (player != players[i] && get.attitude(target, players[i]) < 0 && target.canUse(card, players[i])) {
                                    if (!friend) return 0;
                                    if (get.effect(players[i], vcard, player, player) > 0) {
                                        if (!player.canUse(card, players[0])) return [0, 0.1];
                                        min = 0;
                                    }
                                }
                            }
                            return min;
                        },
                    },
                },
            },
            //喵王异
            minimiaozhenlie: {
                audio: 'ext:活动武将/audio/skill:2',
                inherit: 'zhenlie',
                content() {
                    'step 0'
                    player.loseHp();
                    trigger.getParent().excluded.add(player);
                    'step 1'
                    if (trigger.player[player.hasSkill('minidoumao') ? 'countDiscardableCards' : 'countGainableCards'](player, 'he')) {
                        player[player.hasSkill('minidoumao') ? 'discardPlayerCard' : 'gainPlayerCard'](trigger.player, 'he', true);
                    }
                },
            },
            minimiaomiji: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return game.hasPlayer(function (target) {
                        if (player.hasSkill('minidoumao') && target != player) return false;
                        return target.isDamaged();
                    });
                },
                direct: true,
                frequent: true,
                content() {
                    'step 0'
                    if (player.hasSkill('minidoumao')) player.chooseBool(get.prompt2('minimiaomiji')).set('frequentSkill', 'minimiaomiji');
                    else {
                        var targets = game.filterPlayer(function (target) {
                            if (player.hasSkill('minidoumao') && target != player) return false;
                            return target.isDamaged();
                        });
                        var str = '摸' + get.cnNumber(player.getDamagedHp()) + '张牌';
                        if (!player.hasSkill('minidoumao')) str = '选择场上的一名受伤的角色，摸等同于其损失体力值的牌（至多五张）';
                        player.chooseTarget(get.prompt('minimiaomiji'), str + '，然后你可以将等量的牌交给一名其他角色', function (card, player, target) {
                            if (player.hasSkill('minidoumao') && target != player) return false;
                            return target.isDamaged();
                        }).set('ai', function (target) {
                            return target.getDamagedHp();
                        });
                    }
                    'step 1'
                    if (result.bool) {
                        var target = result.targets?.[0] ?? player;
                        player.logSkill('minimiaomiji');
                        player.line(target);
                        var num = Math.min(5, target.getDamagedHp());
                        event.num = num;
                        player.draw(num);
                    }
                    else event.finish();
                    'step 2'
                    var check = player.countCards('h') - event.num;
                    player.chooseCardTarget({
                        selectCard: event.num,
                        filterTarget: lib.filter.notMe,
                        ai1(card) {
                            var player = _status.event.player;
                            if (player.maxHp - player.hp == 1 && card.name == 'du') return 30;
                            var check = _status.event.check;
                            if (check < 1) return 0;
                            if (player.hp > 1 && check < 2) return 0;
                            return get.unuseful(card) + 9;
                        },
                        ai2(target) {
                            var att = get.attitude(_status.event.player, target);
                            if (ui.selected.cards.length == 1 && ui.selected.cards[0].name == 'du') return 1 - att;
                            return att - 2;
                        },
                        prompt: '秘计：是否将' + get.cnNumber(event.num) + '张手牌交给一名其他角色？',
                    }).set('check', check);
                    'step 3'
                    if (result.bool) {
                        player.line(result.targets);
                        player.give(result.cards, result.targets[0]);
                    }
                },
            },
            //喵春哥
            minimiaojueqing: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { source: 'damageBefore' },
                direct: true,
                content() {
                    'step 0'
                    if (!player.hasSkill('minidoumao')) {
                        player.chooseBool(get.prompt('minimiaojueqing'), '失去' + trigger.num + '点体力，令即将对其造成的伤害翻倍至' + (trigger.num * 2) + '点').set('choice', player.hp > trigger.num && trigger.player.hp > trigger.num && get.attitude(player, trigger.player) < 0);
                    }
                    else event.goto(2);
                    'step 1'
                    if (result.bool) {
                        event.logged = true;
                        player.logSkill('minimiaojueqing');
                        player.loseHp(trigger.num);
                        trigger.num *= 2;
                    }
                    'step 2'
                    if (!event.logged) player.logSkill('minimiaojueqing');
                    trigger.cancel();
                    trigger.player.loseHp(trigger.num);
                },
            },
            minimiaoshangshi: {
                group: 'minishangshi',
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'changeSkillsAfter' },
                filter(event, player) {
                    return event.addSkill.includes('minidoumao') ^ event.removeSkill.includes('minidoumao');
                },
                forced: true,
                locked: false,
                content() {
                    player[(trigger.removeSkill.includes('minidoumao') ? 'gain' : 'lose') + 'MaxHp']();
                },
            },
            //喵甄姬
            minimiaoluoshen: {
                inherit: 'miniluoshen',
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: ['phaseZhunbeiBegin', 'phaseEnd'] },
                filter(event, player) {
                    return !player.hasSkill('minidoumao') || event.name == 'phaseZhunbei';
                },
            },
            minimiaoqingguo: {
                mod: {
                    aiValue(player, card, num) {
                        if (!player.hasSkill('minidoumao')) return;
                        if (get.name(card) != 'shan' && get.color(card) != 'black') return;
                        var cards = player.getCards('hs', function (card) {
                            return get.name(card) == 'shan' || get.color(card) == 'black';
                        });
                        cards.sort(function (a, b) {
                            return (get.name(b) == 'shan' ? 1 : 2) - (get.name(a) == 'shan' ? 1 : 2);
                        });
                        var geti = function () {
                            if (cards.includes(card)) {
                                return cards.indexOf(card);
                            }
                            return cards.length;
                        };
                        if (get.name(card) == 'shan') return Math.min(num, [6, 4, 3][Math.min(geti(), 2)]) * 0.6;
                        return Math.max(num, [6.5, 4, 3][Math.min(geti(), 2)]);
                    },
                    aiUseful() {
                        return lib.skill.minimiaoqingguo.mod.aiValue.apply(this, arguments);
                    },
                },
                locked: false,
                audio: 'ext:活动武将/audio/skill:2',
                enable: ['chooseToRespond', 'chooseToUse'],
                filterCard(card) {
                    return get.color(card) == 'black';
                },
                position: 'hes',
                viewAs: { name: 'shan' },
                viewAsFilter(player) {
                    if (!player.countCards('hes', { color: 'black' })) return false;
                },
                prompt: '将一张黑色牌当闪打出',
                check: () => 1,
                ai: {
                    order: 2,
                    respondShan: true,
                    skillTagFilter(player) {
                        if (!player.countCards('hes', { color: 'black' })) return false;
                    },
                    effect: {
                        target(card, player, target, current) {
                            if (get.tag(card, 'respondShan') && current < 0) return 0.6
                        },
                    },
                },
                group: 'minimiaoqingguo_jijiu',
                subSkill: {
                    jijiu: {
                        audio: 'minimiaoqingguo',
                        mod: {
                            aiValue(player, card, num) {
                                if (player.hasSkill('minidoumao')) return;
                                if (get.name(card) != 'tao' && get.name(card) != 'shan') return;
                                var cards = player.getCards('hs', function (card) {
                                    return get.name(card) == 'tao' || get.name(card) == 'shan';
                                });
                                cards.sort(function (a, b) {
                                    return (get.name(a) == 'tao' ? 1 : 2) - (get.name(b) == 'tao' ? 1 : 2);
                                });
                                var geti = function () {
                                    if (cards.includes(card)) {
                                        return cards.indexOf(card);
                                    }
                                    return cards.length;
                                };
                                return Math.max(num, [6.5, 4, 3, 2][Math.min(geti(), 2)]);
                            },
                            aiUseful() {
                                return lib.skill.minimiaoqingguo_jijiu.mod.aiValue.apply(this, arguments);
                            },
                        },
                        locked: false,
                        enable: 'chooseToUse',
                        viewAsFilter(player) {
                            return !player.hasSkill('minidoumao') && player.countCards('hs', { name: 'shan' }) > 0;
                        },
                        filterCard: { name: 'shan' },
                        viewAs: { name: 'tao' },
                        prompt: '将一张【闪】当作【桃】使用',
                        check(card) {
                            return 15 - get.value(card);
                        },
                    },
                },
            },
            //喵孙尚香
            minimiaojieyin: {
                audio: 'ext:活动武将/audio/skill:2',
                inherit: 'minijieyi',
                content() {
                    'step 0'
                    if (get.position(cards[0]) == 'e') {
                        player.$give(cards, target);
                        target.equip(cards[0]);
                    }
                    else player.give(cards, target, true);
                    'step 1'
                    player.recover();
                    player.draw();
                    'step 2'
                    if (player.hasSkill('minidoumao')) { event.finish(); return; }
                    player.chooseBool('结姻：是否令' + get.translation(target) + '回复1点体力并摸一张牌？').set('choice', get.attitude(player, target) > 0);
                    'step 3'
                    if (result.bool) {
                        player.line(target);
                        target.recover();
                        target.draw();
                    }
                },
            },
            minimiaoxiaoji: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    player: 'loseAfter',
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                },
                filter(event, player) {
                    var evt = event.getl(player);
                    return evt?.player == player && evt.es && evt.es.length > 0;
                },
                frequent: true,
                content() {
                    'step 0'
                    event.count = trigger.getl(player).es.length;
                    'step 1'
                    event.count--;
                    player.draw(2);
                    if (player.hasSkill('minidoumao')) { event.goto(3); return; }
                    player.chooseTarget('是否弃置场上的一张牌？', function (card, player, target) {
                        return target.countDiscardableCards(player, 'ej');
                    }).set('ai', target => {
                        var player = _status.event.player;
                        var att = get.attitude(player, target);
                        if (att > 0 && (target.countCards('j') > 0 || target.countCards('e', function (card) {
                            return get.value(card, target) < 0;
                        }))) return 2;
                        if (att < 0 && target.countCards('e') > 0 && !target.hasSkillTag('noe')) return -1;
                        return 0;
                    });
                    'step 2'
                    if (result.bool) player.discardPlayerCard(result.targets[0], 'ej', true);
                    'step 3'
                    if (event.count > 0 && player.hasSkill('minimiaoxiaoji')) player.chooseBool('是否再次发动【枭姬】？').set('frequentSkill', 'minimiaoxiaoji');
                    else event.finish();
                    'step 4'
                    if (result.bool) {
                        player.logSkill('minimiaoxiaoji');
                        event.goto(1);
                    }
                },
                ai: {
                    noe: true,
                    reverseEquip: true,
                    effect: {
                        target(card, player, target, current) {
                            if (get.type(card) == 'equip' && !get.cardtag(card, 'gifts')) return [1, 3];
                        },
                    },
                },
            },
            //喵小乔
            minimiaotianxiang: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'damageBegin3' },
                filter(event, player) {
                    return player.countCards('h', { suit: 'heart' }) && event.num > 0;
                },
                direct: true,
                content() {
                    'step 0'
                    player.chooseCardTarget({
                        filterCard(card, player) {
                            return get.suit(card) == 'heart' && lib.filter.cardDiscardable(card, player);
                        },
                        filterTarget: lib.filter.notMe,
                        ai1(card) {
                            return 10 - get.value(card);
                        },
                        ai2(target) {
                            var player = _status.event.player;
                            var num = (target.hasSkill('minidoumao') ? 2 : 1);
                            var att = get.attitude(player, target);
                            return -att * num;
                        },
                        prompt: get.prompt2('minimiaotianxiang')
                    });
                    'step 1'
                    if (result.bool) {
                        var target = result.targets[0], cards = result.cards;
                        player.logSkill('minimiaotianxiang', target);
                        target.gain(cards, player, 'give');
                        player.addTempSkill('minimiaotianxiang2');
                        trigger.cancel();
                        target.damage(trigger.source ? trigger.source : 'nosource', trigger.nature, trigger.num).set('card', trigger.card).set('cards', trigger.cards).minimiaotianxiang2 = [player];
                    }
                },
                ai: {
                    maixie_defend: true,
                    effect: {
                        target(card, player, target) {
                            if (player.hasSkillTag('jueqing', false, target)) return;
                            if (get.tag(card, 'damage') && target.countCards('h') > 1) return 0.7;
                        },
                    },
                    threaten(player, target) {
                        if (!target.countCards('h')) return 2;
                    },
                },
            },
            minimiaotianxiang2: {
                charlotte: true,
                trigger: { global: ['damageAfter', 'damageCancelled', 'damageZero'] },
                filter(event, player) {
                    return event.minimiaotianxiang2 && event.minimiaotianxiang2.includes(player) && event.player.isIn();
                },
                direct: true,
                content() {
                    player.line(trigger.player);
                    if (trigger.player.hasSkill('minidoumao')) trigger.player.damage();
                    else player.discardPlayerCard(trigger.player, 'he', true);
                },
            },
            minimiaohongyan: {
                mod: {
                    suit(card, suit) {
                        if (suit == 'spade') return 'heart';
                    },
                },
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'judgeEnd' },
                filter(event, player) {
                    if (event.player.hasSkill('minidoumao')) return false;
                    return get.suit(event.result.card, event.player) == 'heart';
                },
                forced: true,
                locked: false,
                content() {
                    player.recover();
                    player.draw();
                },
            },
            //喵607
            minimiaozhuangrong: {
                audio: 'ext:活动武将/audio/skill:2',
                inherit: 'zhuangrong',
                async content(event, trigger, player) {
                    player.awakenSkill(event.name);
                    await player.loseMaxHp();
                    if (player.maxHp > player.hp) await player.recover(player.maxHp - player.hp);
                    await player.drawTo(Math.min(5, player.maxHp));
                    await player.addSkills(get.info(event.name).derivation);
                },
                derivation: ['minillqshenwei', 'miniwushuang'],
            },
            minillqshenwei: {
                audio: 'ext:活动武将/audio/skill:2',
                inherit: 'llqshenwei',
                async content(event, trigger, player) {
                    const num = player.hasSkill('minidoumao', null, null, false) ? 2 : 3;
                    trigger.num += num;
                },
                mod: {
                    maxHandcard(player, num) {
                        const numx = player.hasSkill('minidoumao', null, null, false) ? 2 : 1;
                        return num + numx;
                    },
                },
            },
            minimiaoguowu: {
                audio: 'ext:活动武将/audio/skill:2',
                inherit: 'guowu',
                async content(event, trigger, player) {
                    const hs = player.getCards('h'), num = hs.map(card => get.type2(card, player)).toUniqued().length;
                    await player.showCards(hs, get.translation(player) + '发动了【帼武】');
                    if (num >= 1) {
                        const card = get.discardPile(card => get.type(card) == 'trick');
                        if (card) await player.gain(card, 'gain2');
                    }
                    if (num >= 2) player.addTempSkill(event.name + '_effect', 'phaseUseAfter');
                    if (num >= 3) player.addTempSkill(event.name + '_buff', 'phaseUseAfter');
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        mod: { cardUsable: () => Infinity },
                    },
                    buff: {
                        charlotte: true,
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            if (event.card.name != 'sha' && get.type(event.card) != 'trick') return false;
                            return player.getHistory('useCard', evt => evt.isPhaseUsing() && (evt.card.name == 'sha' || get.type(evt.card) == 'trick')).indexOf(event) == 0;
                        },
                        prompt2: '令此牌额外结算一次',
                        async content(event, trigger, player) {
                            trigger.effectCount++;
                            game.log(trigger.card, '额外结算一次');
                        },
                    }
                }
            },
            // 喵曹婴
            minimiaolingren: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    if (!event.isFirstTarget || !event.targets.some(i => i !== player)) return false;
                    return event.card.name === 'sha' || (get.type(event.card) === 'trick' && get.tag(event.card, 'damage'));
                },
                logTarget(event, player) {
                    return event.targets.filter(i => i !== player);
                },
                check(event, player) {
                    const trigger = event.getParent('chooseToUse', true);
                    if (!trigger || trigger.player !== player) return true;
                    return !player.hasCard(card => {
                        if (!lib.filter.cardEnabled(card, player, trigger) && lib.filter.cardUsable(card, player, trigger)) return false;
                        return (card.name === 'sha' || (get.type(card) === 'trick' && get.tag(card, 'damage'))) && player.hasValueTarget(card);
                    }, 'hs');
                },
                usable: 1,
                async content(event, trigger, player) {
                    const targets = event.targets.sortBySeat();
                    let humans = targets.filter(current => current === game.me || current.isOnline());
                    let locals = [...targets].remove(...humans), map = new Map([]);
                    const send = (current, eventId) => {
                        lib.skill[event.name].chooseButton(current, player, event, eventId);
                        game.resume();
                    }, eventId = get.id();
                    let time = lib.configOL?.choose_timeout ? parseInt(lib.configOL.choose_timeout) * 1000 : 10000;
                    event._global_waiting = true;
                    for (const current of humans) current.showTimer(time);
                    if (humans.length > 0) {
                        const solve = function (resolve, reject) {
                            return function (result, player) {
                                if (result?.bool && result.links?.length) {
                                    map.set(player, result.links.sort((a, b) => a - b));
                                    resolve();
                                }
                                else reject();
                            };
                        };
                        await Promise.any(
                            humans.map(current => {
                                return new Promise(async (resolve, reject) => {
                                    if (current.isOnline()) {
                                        current.send(send, current, eventId);
                                        current.wait(solve(resolve, reject));
                                    }
                                    else {
                                        const next = lib.skill[event.name].chooseButton(current, player, event, eventId);
                                        const solver = solve(resolve, reject);
                                        if (_status.connectMode) game.me.wait(solver);
                                        const result = await next.forResult();
                                        if (_status.connectMode) game.me.unwait(result, current);
                                        else solver(result, current);
                                    }
                                });
                            })
                        ).catch(() => { });
                        game.broadcastAll('cancel', eventId);
                    }
                    if (locals.length > 0) {
                        for (const current of locals) {
                            const result = await lib.skill[event.name].chooseButton(current, player, event).forResult();
                            map.set(current, result.links.sort((a, b) => a - b));
                        }
                    }
                    delete event._global_waiting;
                    for (const current of humans) current.hideTimer();
                    for (const target of targets) {
                        const choice = map.get(target);
                        if (choice) {
                            game.log(target, '选择了', `#y${choice.map(i => `第${get.cnNumber(i + 1, true)}项`).join('、')}`);
                            for (const number of choice) {
                                switch (number) {
                                    case 0:
                                        const map = trigger.customArgs, id = target.playerid;
                                        map[id] ??= {};
                                        map[id].extraDamage ??= 0;
                                        map[id].extraDamage++;
                                        game.log(trigger.card, '对', target, '造成的伤害', '#y+1');
                                        break;
                                    case 1:
                                        await player.draw(2);
                                        break;
                                    case 2:
                                        target.addMark('minimiaofujian', 1);
                                        await player.addTempSkills(lib.skill[event.name].derivation, { player: 'phaseBegin' });
                                        break;
                                }
                            }
                        }
                    }
                },
                chooseButton(player, source, event, eventId) {
                    const trigger = event._trigger, num = (trigger.targets.length > 2 ? 1 : 2) + (player.hasSkill('minidoumao', null, null, false) ? 1 : 0);
                    const next = player.chooseButton([
                        `${get.translation(event.name)}：请选择${get.cnNumber(num)}项`,
                        [[
                            [0, `令${get.translation(trigger.card)}对你造成的伤害+1`],
                            [1, `令${get.translation(source)}摸两张牌`],
                            [2, `获得1枚“伏间”标记，令${get.translation(source)}获得${lib.skill[event.name].derivation.map(i => `【${get.translation(i)}】`).join('、')}直到其下个回合开始`],
                        ], 'textbutton'],
                    ], num, true);
                    next.set('ai', button => {
                        const { player, list: [source, trigger] } = get.event();
                        const att = get.attitude(player, source);
                        switch (button.link) {
                            case 0:
                                let hit = true, key;
                                if (get.type(trigger.card) === "trick" && player.hasCard({ name: "wuxie" }, 'h')) hit = false;
                                if (trigger.card.name == "huogong" && player.hasCard(card => {
                                    return !source.countDiscardableCards(source, 'h', i => get.suit(i) === get.suit(card));
                                }, 'h')) hit = false;
                                switch (trigger.card.name) {
                                    case "sha":
                                    case "wanjian":
                                        key = ["shan"];
                                        break;
                                    case "juedou":
                                    case "nanman":
                                    case "jiedao":
                                        key = ["sha"];
                                        break;
                                    default:
                                        key = [];
                                        break;
                                }
                                if (get.type(trigger.card) == "trick") key.push("wuxie");
                                key.push("caochuan");
                                if (!hit || !player.hasCard({ name: key }, 'hs') || get.effect(player, trigger.card, source, player) > 0 || get.damageEffect(player, source, player) > 0) {
                                    return Math.max(get.effect(player, trigger.card, source, player), get.damageEffect(player, source, player));
                                }
                                return -att * 10;
                            case 1:
                                return get.effect(source, { name: 'draw' }, player, player) * 2;
                            case 2:
                                _status.event.skillRankPlayer = source;
                                const num = lib.skill['minimiaolingren'].derivation.reduce((sum, skill) => {
                                    return sum + get.skillRank(skill, "out");
                                }, 0) * Math.sign(Math.sign(att) - 0.5);
                                delete _status.event.skillRankPlayer;
                                return num + (player.hasMark('minimiaofujian') ? 0 : get.effect(player, { name: 'guohe_copy', position: 'h' }, player, player));
                        }
                    });
                    next.set('list', [source, trigger]);
                    next.set('id', eventId);
                    next.set('_global_waiting', true);
                    return next;
                },
                derivation: ['minijianxiong', 'minimiaoxingshang'],
            },
            minimiaofujian: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseJieshuBegin' },
                filter(event, player) {
                    return game.hasPlayer(target => target !== player);
                },
                locked: true,
                async cost(event, trigger, player) {
                    event.result = await player.chooseTarget(`请选择【${get.translation(event.skill)}】的目标`, lib.translate[`${event.skill}_info`], lib.filter.notMe).set('ai', target => {
                        const player = get.player();
                        return target.hasMark('minimiaofujian') ? 0 : get.effect(target, { name: 'guohe_copy', position: 'h' }, target, player);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    event.targets[0].addMark(event.name, 1);
                    const targets = game.filterPlayer(target => target.hasMark(event.name));
                    if (targets.length) {
                        player.line(targets);
                        let lose_list = [], next;
                        for (const target of targets) {
                            const cards = target.getDiscardableCards(target, 'h');
                            if (cards.length) lose_list.push([target, cards.randomGets(1)]);
                        }
                        if (lose_list.length) {
                            if (lose_list.length === 1) {
                                next = lose_list[0][0].discard(lose_list[0][1]);
                                next.discarder = player;
                            }
                            else {
                                next = game.loseAsync({
                                    lose_list: lose_list,
                                    discarder: player,
                                }).setContent("discardMultiple");
                            }
                            await next;
                        }
                        game.countPlayer(target => target.clearMark(event.name));
                        const gains = lose_list.filter(list => list[0].hasSkill('minidoumao', null, null, false)).map(list => list[1].filterInD('d')).flat();
                        if (gains.length > 0) await player.gain(gains, 'gain2');
                    }
                },
                intro: { content: 'mark' },
            },
            minimiaoxingshang: {
                preHidden: true,
                audio: 'ext:活动武将/audio/skill:1',
                trigger: { global: 'die' },
                logTarget: 'player',
                async content(event, trigger, player) {
                    const current = trigger.player;
                    if (current.countCards('he')) await player.gain(current.getCards('he'), current, 'giveAuto');
                    await player.draw();
                    if (current.hasSkill('minidoumao', null, false, false)) {
                        const result = await player.chooseTarget('是否令一名角色获得【逗猫】？').set('ai', target => {
                            const player = get.player(), att = get.attitude(player, target);
                            //集智
                            if (target.hasSkill('minimiaojizhi')) return 10 * (-Math.sign(att));
                            //枪舞
                            if (player.hasSkill('minimiaoqiangwu')) {
                                player._minimiaoqiangwu_check = true;
                                const cards = player.getCards('hs', card => {
                                    return card.name == 'sha' && player.canUse(card, target);
                                });
                                if (cards.length > 1) {
                                    if (att >= 0) return 0;
                                    let sum = 0;
                                    for (const card of cards) sum += get.effect(target, card, player, player);
                                    if (sum <= 0) return 0;
                                    else {
                                        while (sum < 1 || sum > 10) {
                                            if (sum < 1) sum = sum * 10;
                                            if (sum > 10) sum = sum / 10;
                                        }
                                        return sum;
                                    }
                                }
                                return 0;
                            }
                            if (player._minimiaoqiangwu_check) delete player._minimiaoqiangwu_check;
                            //顺位传递
                            const players = game.filterPlayer(current => {
                                if (current.hasSkill('minimiaojizhi') || current.hasSkill('minimiaoqiangwu')) return false;
                                return current != player && !current.isTurnedOver() && get.attitude(player, current) > 0 && get.attitude(current, player) > 0;
                            }).sortBySeat(player);
                            if (players.length) return target == players[0] ? (att * (target.getSkills().some(skill => skill.indexOf('minimiao') == 0) ? 0.5 : 1)) : -1;
                            //普通传递
                            return Math.sign(att) + att / 114514;
                        }).forResult();
                        if (result?.bool && result.targets?.length) {
                            const target = result.targets[0];
                            player.line(target);
                            await target.addSkills('minidoumao');
                        }
                    }
                },
            },
            // 喵关银屏
            minimiaowuji: {
                locked: false,
                mod: {
                    cardUsable(card) {
                        if (card.storage?.minimiaowuji) return true;
                    },
                },
                audio: 'ext:活动武将/audio/skill:2',
                enable: ['chooseToUse', 'chooseToRespond'],
                viewAsFilter(player) {
                    return player.countCards('hes', (card, player) => get.color(card, player) == 'red') > 1;
                },
                viewAs: { name: 'sha', nature: 'fire', storage: { minimiaowuji: true } },
                filterCard(card, player) {
                    return get.color(card, player) == 'red';
                },
                position: 'hes',
                selectCard: 2,
                check(card) {
                    const player = get.player();
                    if (ui.selected.cards.length) return 6 + (get.suit(card, player) == get.suit(ui.selected.cards[0], player) && !player.getStorage('minimiaowuji_used').includes(get.suit(card, player))) - get.value(card);
                    return 6 - get.value(card);
                },
                prompt: '将两张红色牌当无任何次数限制的火【杀】使用或打出',
                async precontent(event, trigger, player) {
                    event.getParent().addCount = false;
                },
                group: ['minimiaowuji_damage', 'minimiaowuji_link'],
                subSkill: {
                    damage: {
                        audio: 'minimiaowuji',
                        trigger: { player: 'useCard' },
                        filter(event, player) {
                            return event.skill == 'minimiaowuji' && event.cards?.length == 2 && get.suit(event.cards[0]) == get.suit(event.cards[1]) && !player.getStorage('minimiaowuji_used').includes(get.suit(event.cards[0]));
                        },
                        forced: true,
                        locked: false,
                        async content(event, trigger, player) {
                            const skillName = 'minimiaowuji_used';
                            player.addTempSkill(skillName);
                            player.markAuto(skillName, [get.suit(trigger.cards[0])]);
                            player.addTip(skillName, get.translation(skillName) + player.getStorage(skillName).reduce((str, suit) => str + get.translation(suit), ''));
                            trigger.baseDamage++;
                        },
                    },
                    link: {
                        audio: 'minimiaowuji',
                        trigger: { player: 'shaMiss' },
                        filter(event, player) {
                            return game.hasPlayer(current => !current.isLinked());
                        },
                        async cost(event, trigger, player) {
                            event.result = await player.chooseTarget(get.prompt(event.skill), '你可以横置至多两名角色', [1, 2], (card, player, target) => {
                                return !target.isLinked();
                            }).set('ai', target => {
                                const player = get.player();
                                return get.effect(target, { name: 'tiesuo' }, player, player);
                            }).forResult();
                        },
                        async content(event, trigger, player) {
                            for (const target of event.targets.sortBySeat()) await target.link(true);
                        },
                    },
                    used: {
                        charlotte: true,
                        onremove(player, skill) {
                            delete player.storage[skill];
                            player.removeTip(skill);
                        },
                        intro: { content: '已触发花色：$' },
                    }
                }
            },
            minimiaohuxiao: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    source: 'damageSource',
                    player: 'phaseEnd'
                },
                getIndex(event, player, triggername) {
                    if (event.name == 'phase') return 1;
                    const history = player.getAllHistory('sourceDamage');
                    let num = 0;
                    for (let i = history.length - 1; i >= 0; i--) {
                        const evt = history[i];
                        if (evt.minimiaohuxiao) {
                            const historyx = player.getAllHistory('sourceDamage', () => true, evt);
                            num += historyx.reduce((numx, evtx) => numx + evtx.num, 0) % 3;
                            break;
                        }
                        num += evt.num;
                    }
                    return parseInt(num / 3);
                },
                forced: true,
                async content(event, trigger, player) {
                    if (trigger.name == 'damage') {
                        const history = player.getAllHistory('sourceDamage');
                        if (history.length) history[history.length - 1][event.name] = true;
                        await player.recover();
                        const result = await player.chooseTarget('虎啸：请选择一名角色令其获得【逗猫】', true).set('ai', target => {
                            const player = get.player();
                            const att = get.attitude(player, target);
                            //集智
                            if (target.hasSkill('minimiaojizhi')) return 10 * (-Math.sign(att));
                            //枪舞
                            const targetx = game.findPlayer(current => current.hasSkill('minimiaoqiangwu') && current.isPhaseUsing() && get.attitude(player, current) > 0);
                            if (targetx) {
                                target._minimiaoqiangwu_check = true;
                                const cards = targetx.getCards('hs', card => {
                                    return card.name == 'sha' && targetx.canUse(card, target);
                                });
                                if (cards.length > 1) {
                                    if (get.attitude(targetx, target) >= 0) return 0;
                                    let sum = 0;
                                    for (const card of cards) sum += get.effect(target, card, targetx, targetx);
                                    if (sum <= 0) return 0;
                                    else {
                                        while (sum < 1 || sum > 10) {
                                            if (sum < 1) sum = sum * 10;
                                            if (sum > 10) sum = sum / 10;
                                        }
                                        return sum;
                                    }
                                }
                                return 0;
                            }
                            if (target._minimiaoqiangwu_check) delete target._minimiaoqiangwu_check;
                            //顺位传递
                            const players = game.filterPlayer(current => {
                                if (current.hasSkill('minimiaojizhi') || current.hasSkill('minimiaoqiangwu')) return false;
                                return current != player && !current.isTurnedOver() && get.attitude(player, current) > 0 && get.attitude(current, player) > 0;
                            }).sortBySeat(player);
                            if (players.length) return target == players[0] ? (att * (target.getSkills().some(skill => skill.indexOf('minimiao') == 0) ? 0.5 : 1)) : -1;
                            //普通传递
                            if (player.hasSkill('minimiaohuxiao')) return !target.hasSkill('minidoumao') ? Math.max(1, -att) : 0;
                            return Math.sign(att) + att / 114514;
                        }).forResult();
                        if (result?.targets?.length) {
                            const [target] = result.targets;
                            player.line(target);
                            await target.addSkills('minidoumao');
                        }
                    }
                    else {
                        const num = Math.max(1, game.countPlayer(current => current.hasSkill('minidoumao')));
                        const cards = [];
                        while (cards.length < num) {
                            const card = get.cardPile2(card => !cards.includes(card) && get.color(card) == 'red');
                            if (card) cards.push(card);
                            else break;
                        }
                        if (cards.length) await player.gain(cards, 'gain2');
                    }
                },
                init(player, skill) {
                    player.addSkill(skill + '_mark');
                    let num = 0;
                    let next = 3;
                    const history = player.getAllHistory('sourceDamage');
                    for (let i = 0; i < history.length; i++) {
                        const evt = history[i];
                        num += evt.num;
                        if (num >= next) {
                            if (!evt.minimiaohuxiao) evt.minimiaohuxiao = true;
                            next = Math.floor(num / 3) * 3 + 3;
                        }
                    }
                    if (num) player.addMark(skill, num, false);
                },
                onremove(player, skill) {
                    player.removeSkill(skill + '_mark');
                    delete player.storage[skill];
                },
                intro: { content: '本局游戏已累计造成#点伤害' },
                derivation: 'minidoumao',
                subSkill: {
                    mark: {
                        charlotte: true,
                        trigger: { source: 'damageSource' },
                        firstDo: true,
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            player.addMark('minimiaohuxiao', trigger.num, false);
                        },
                    }
                }
            },
            // 喵马云騄
            minimiaoyuma: {
                audio: 'ext:活动武将/audio/skill:2',
                mod: {
                    globalFrom(from, to, distance) {
                        return distance - 1;
                    },
                    globalTo(from, to, distance) {
                        if (from.hasSkill('minidoumao')) return distance + 1;
                    },
                },
                trigger: {
                    player: 'loseAfter',
                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                },
                filter(event, player) {
                    const evt = event.getl(player);
                    return event.getl(player)?.es?.some(card => ['equip3', 'equip4'].some(subtype => get.subtypes(card).includes(subtype)));
                },
                forced: true,
                async content(event, trigger, player) {
                    await player.draw(2 * trigger.getl(player).es.filter(card => ['equip3', 'equip4'].some(subtype => get.subtypes(card).includes(subtype))).length);
                },
                derivation: 'minidoumao',
            },
            minimiaofengpo: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    if (player.getStorage('minimiaofengpo_used').includes(get.color(event.card))) return false;
                    return get.tag(event.card, 'damage') > 0.5 && event.isFirstTarget && get.info('minimiaofengpo').logTarget(event, player).length;
                },
                logTarget(event, player) {
                    return event.targets.filter(current => player != current && current.countCards('h')).sortBySeat();
                },
                check(event, player) {
                    const targets = get.info('minimiaofengpo').logTarget(event, player);
                    return targets.filter(current => get.attitude(player, current) > 0).length <= targets.filter(current => get.attitude(player, current) <= 0).length;
                },
                async content(event, trigger, player) {
                    player.addTempSkill(event.name + '_used');
                    player.markAuto(event.name + '_used', [get.color(trigger.card)]);
                    let map = new Map();
                    for (const target of event.targets.sortBySeat()) {
                        if (!target.isIn() || !target.countCards('h')) continue;
                        const result = await target.chooseCard('h', true, '凤魄：请选择一张手牌展示', `若为黑色，你随机交给${get.translation(player)}手牌，若为红色，${get.translation(trigger.card)}将对你额外生效`).set('ai', card => {
                            const player = get.player();
                            const evt = get.event().getTrigger();
                            const target = evt.player;
                            const att = get.attitude(player, target);
                            const color = get.color(card, player);
                            let val = 6 - get.value(card);
                            if (color == 'black') {
                                if (att > 0) val += 2;
                                if (get.effect(player, evt.card, target, target) < 0) val += 1;
                            }
                            return val;
                        }).forResult();
                        if (result?.cards?.length) {
                            const { cards } = result;
                            map.set(target, get.color(cards[0], target));
                            await target.showCards(cards);
                        }
                    }
                    if (!map.size) return;
                    for (const [target, color] of map) {
                        const num = target.hasSkill('minidoumao') ? Array.from(map.values()).toUniqued().length : 1;
                        if (color == 'red') {
                            player.when({ player: 'useCardAfter' }).filter(evt => evt == trigger.getParent()).step(async (event, trigger, player) => {
                                if (!player.canUse(trigger.card, target, false)) return;
                                const next = player.useCard(trigger.card, trigger.cards, target, false);
                                next.effectCount = num;
                                await next;
                            });
                        }
                        else if (color == 'black') {
                            const cards = target.getGainableCards(player, 'h');
                            if (cards.length) await target.give(cards.randomGets(num), player);
                        }
                    }
                },
                derivation: 'minidoumao',
                subSkill: {
                    used: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '已记录颜色：$' },
                    },
                }
            },
            //念
            mininianying: {
                subSkill: {
                    Mnian_zhugeliang: { audio: 'ext:活动武将/audio/skill:2' },
                    Mnian_lvbu: { audio: 'ext:活动武将/audio/skill:2' },
                    Mnian_zhouyu: { audio: 'ext:活动武将/audio/skill:2' },
                    Mnian_caopi: { audio: 'ext:活动武将/audio/skill:2' },
                },
            },
            mininianxinghan: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: ['phaseBegin', 'damageBegin4'] },
                filter(event, player) {
                    return lib.skill.mininianxinghan.filterGroup(player).length;
                },
                usable: 1,
                async content(event, trigger, player) {
                    const groups = lib.skill.mininianxinghan.filterGroup(player);
                    if (!groups.length) {
                        player.popup('杯具');
                        game.log('没有势力可进行', '#g定乱', '操作');
                        return;
                    }
                    await Promise.all(event.next);
                    event.videoId = lib.status.videoId++;
                    if (player.isUnderControl()) game.swapPlayerAuto(player);
                    //AI直接走结果
                    const switchToAuto = function () {
                        return new Promise((resolve) => {
                            game.pause();
                            game.countChoose();
                            setTimeout(() => {
                                _status.imchoosing = false;
                                if (event.dialog) event.dialog.close();
                                game.resume();
                                event._result = { successGroup: groups.randomGet() };
                                resolve(event._result);
                            }, 5000);
                        });
                    };
                    //联机时间限制修改
                    const originalTimeout = lib.configOL.choose_timeout;
                    game.broadcastAll((player, videoId) => {
                        if (_status.connectMode) lib.configOL.choose_timeout = '30';
                        if (game.me !== player) {
                            const dialog = ui.create.dialog(`${get.translation(player)}正在进行“定乱”...`);
                            dialog.videoId = videoId;
                            dialog.open();
                        }
                    }, player, event.videoId);
                    const zhugeliang_PlayChess = function (player, groups) {
                        const event = _status.event, { promise, resolve } = Promise.withResolvers();
                        //如果以自己视角进入流程后AI直接走结果
                        event.switchToAuto = function () {
                            _status.imchoosing = false;
                            event._result = { successGroup: groups.randomGet() };
                            resolve(event._result);
                            if (event.dialog) event.dialog.close();
                        };
                        //创建dialog
                        const dialog = event.dialog = ui.create.dialog('定乱：请将一个容器的棋子全部操作为同一势力', 'hidden');
                        dialog.add('<div class="text center">赤字青荒，唯记......</div>');
                        dialog.classList.add('fullheight');
                        dialog.style.borderRadius = '10px';
                        dialog.style.backgroundImage = `url(${lib.assetURL}/extension/活动武将/image/background/nanhualaoxian.png)`;
                        dialog.style.backgroundPosition = 'center';
                        dialog.style.backgroundSize = 'cover';
                        //设置dialog样式
                        dialog.style.width = '90%';
                        dialog.style.height = '85%';
                        dialog.style.left = '5%';
                        dialog.style.top = '5%';
                        dialog.style.overflow = 'auto';
                        dialog.style.display = 'flex';
                        dialog.style.flexDirection = 'column';
                        dialog.style.alignItems = 'center';
                        dialog.style.justifyContent = 'center';
                        //设置contentContainer样式
                        dialog.contentContainer = ui.create.div('.content-container', dialog);
                        dialog.contentContainer.style.display = 'flex';
                        dialog.contentContainer.style.flexDirection = 'column';
                        dialog.contentContainer.style.alignItems = 'center';
                        dialog.contentContainer.style.justifyContent = 'center';
                        dialog.contentContainer.style.width = '100%';
                        dialog.contentContainer.style.height = '100%';
                        //创建tube容器
                        const container = ui.create.div('.dingluan-tube-container', dialog.contentContainer);
                        //检测赢
                        function checkWin(tube) {
                            if (tube.childElementCount !== 4) return false;
                            const group = tube.childNodes[0].dataset.group;
                            return Array.from(tube.childNodes).every(p => p.dataset.group === group);
                        }
                        //创建棋子
                        function createPiece(group, text) {
                            const piece = ui.create.div('.dingluan-piece', text);
                            piece.dataset.group = group;
                            return piece;
                        }
                        //更新棋子位置
                        function updatePiecePositions(tube) {
                            const pieces = tube.querySelectorAll('.dingluan-piece');
                            pieces.forEach((piece, index) => piece.style.bottom = `${index * 26}px`);
                        }
                        let selectedTube = null, dingluanSuccess = null, tubes = [];
                        for (let i = 0; i < groups.length + 2; i++) {
                            const tube = ui.create.div('.dingluan-tube', container);
                            tube.dataset.index = i;
                            tube.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', () => {
                                if (dingluanSuccess !== null) return;
                                if (!selectedTube) {
                                    if (tube.childElementCount > 0) {
                                        selectedTube = tube;
                                        tube.classList.add('selected');
                                    }
                                }
                                else if (tube === selectedTube) {
                                    tube.classList.remove('selected');
                                    selectedTube = null;
                                }
                                else {
                                    if (tube.childElementCount < 4 && selectedTube.childElementCount > 0) {
                                        const piece = selectedTube.lastChild;
                                        tube.appendChild(piece);
                                        //更新两个试管的棋子位置
                                        updatePiecePositions(selectedTube);
                                        updatePiecePositions(tube);
                                        selectedTube.classList.remove('selected');
                                        selectedTube = null;
                                        if (checkWin(tube)) {
                                            _status.mininianxinghan[player.playerid] = (() => {
                                                return tubes.filter(t => t !== tube).map(t => {
                                                    return [...t.children].map(piece => ({
                                                        group: piece.dataset.group,
                                                        text: piece.innerHTML,
                                                    }));
                                                });
                                            })();
                                            event.dialog.close();
                                            game.resume();
                                            _status.imchoosing = false;
                                            event._result = { successGroup: tube.childNodes[0].dataset.group };
                                            resolve(event._result);
                                        }
                                    }
                                    else {
                                        selectedTube.classList.remove('selected');
                                        selectedTube = null;
                                    }
                                }
                            });
                            tubes.push(tube);
                        }
                        _status.mininianxinghan ??= {};
                        const savedData = _status.mininianxinghan[player.playerid];
                        if (savedData) {
                            for (let i = 0; i < savedData.length; i++) {
                                const tubeData = savedData[i];
                                tubeData.forEach(data => {
                                    if (groups.includes(data.group)) tubes[i].appendChild(createPiece(data.group, data.text));
                                });
                                updatePiecePositions(tubes[i]);
                            }
                        }
                        else {
                            let allPieces = groups.map(group => Array.from({ length: 4 }).map(() => { return { group, text: get.translation(group) } }));
                            allPieces = allPieces.flat().randomSort();
                            allPieces.forEach(piece => {
                                let eligible = tubes.filter(tube => {
                                    const num = tube.childElementCount;
                                    if (num >= 4) return false;
                                    if (num < 3) return true;
                                    return [...Array.from(tube.children).map(p => p.dataset.group), piece.group].unique().length > 1;
                                });
                                const targetTube = eligible.randomGet();
                                targetTube.appendChild(createPiece(piece.group, piece.text));
                                updatePiecePositions(targetTube);
                            });
                        }
                        //打开dialog
                        dialog.open();
                        game.pause();
                        game.countChoose();
                        return promise;
                    };
                    let next;
                    if (event.isMine()) next = zhugeliang_PlayChess(player, groups);
                    else if (event.isOnline()) {
                        const { promise, resolve } = Promise.withResolvers();
                        event.player.send(zhugeliang_PlayChess, player, groups);
                        event.player.wait(async result => {
                            if (result == 'ai') result = await switchToAuto();
                            resolve(result);
                        });
                        game.pause();
                        next = promise;
                    }
                    else next = switchToAuto();
                    const result = await next;
                    game.resume();
                    game.broadcastAll((originalTimeout, videoId) => {
                        const dialog = get.idDialog(videoId);
                        if (dialog) dialog.close();
                        if (_status.connectMode) lib.configOL.choose_timeout = originalTimeout;
                    }, originalTimeout, event.videoId);
                    const { successGroup } = result ?? {};
                    if (successGroup) {
                        player.markAuto('mininianxinghan', [successGroup]);
                        player.popup(lib.translate[`${successGroup}2`] || successGroup);
                        game.log(player, '#g定乱', '#y成功', `#g（${get.translation(successGroup)}势力）`);
                        await player.gainMaxHp();
                        await player.recover();
                        const targets = game.filterPlayer(target => target.group == successGroup);
                        if (targets.length) {
                            player.line(targets);
                            for (const t of targets) await t.changeGroup('shu');
                        }
                    }
                    else {
                        player.popup('杯具');
                        game.log(player, '#g定乱', '失败');
                    }
                },
                derivation: 'mininianxinghan_faq',
                intro: { content: '已“定乱”成功过$势力' },
                filterGroup(player) {
                    let groups = [...lib.group, ...[...game.players, ...game.dead].map(i => i.group)].unique();
                    groups.removeArray(['shu', ...player.getStorage('mininianxinghan')]);
                    return groups;
                },
                subSkill: { faq: { nopop: true } },
            },
            mininianliaoyuan: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'chooseToUse',
                filterCard: () => false,
                selectCard: -1,
                check: () => 1,
                viewAs: { name: 'huogong' },
                prompt: '出牌阶段限一次，你可以视为使用【火攻】。',
                usable: 1,
                ai: { fireAttack: true },
                mod: {
                    selectTarget(card, player, num) {
                        if (card.name == 'huogong' && num[1] != -1) num[1] = Infinity;
                    },
                },
                locked: false,
            },
            mininianying_zgl: {
                audio: 'mininianying_Mnian_zhugeliang',
                trigger: { player: 'phaseBegin', global: 'phaseEnd' },
                filter(event, player, name, indexedData) {
                    if (!Object.keys(lib.skill).some(i => get.info(i)?.nianyingSkill && get.info(i).nianyingFilter(event, player, name, indexedData))) return false;
                    if (name == 'phaseBegin') return !game.hasPlayer(target => target.group != 'shu');
                    return game.hasPlayer2(current => {
                        return current.getHistory('custom', evt => evt.name == 'changeGroup' && evt.originGroup != evt.group && [evt.originGroup, evt.group].includes('shu')).length;
                    }) || game.getGlobalHistory('everything', evt => evt.name == 'die' && evt.player.group == 'shu').length;
                },
                async cost(event, trigger, player) {
                    const skills = Object.keys(lib.skill).filter(i => get.info(i)?.nianyingSkill && get.info(i).nianyingFilter(trigger, player, event.triggername, event.indexedData)).map(i => [i, get.info(i).nianyingSkill[0], get.info(i).nianyingSkill[1]]);
                    const result = await player.chooseControl(skills.map(i => i[1]), 'cancel2')
                        .set('prompt', get.prompt('mininianying_zgl')).set('prompt2', '选择一项念影效果执行')
                        .set('displayIndex', false)
                        .set('choiceList', skills.map(i => {
                            return '<div class="skill">' + i[1] + '</div><div>' + i[2] + '</div>';
                        })).set('ai', () => get.event().controls.randomGet()).forResult();
                    event.result = { bool: (result.control != 'cancel2'), cost_data: skills.find(i => i[1] == result.control) };
                },
                async content(event, trigger, player) {
                    await player.draw(2);
                    const choice = event.cost_data;
                    player.popup(choice[1]);
                    game.log(player, '选择了', '#g' + choice[1]);
                    await lib.skill[choice[0]].nianyingContent(player);
                },
                nianyingSkill: ['奖率三军', '令场上所有与你势力相同的其他角色各摸一张牌，然后依次交给你一张锦囊牌（若其没有锦囊牌则将其本次获得的牌交给你）'],
                nianyingFilter(event, player, name) {
                    return game.hasPlayer(target => target != player && target.group == player.group);
                },
                async nianyingContent(player) {
                    const targets = game.filterPlayer(target => target != player && target.group == player.group).sortBySeat();
                    player.line(targets);
                    let map = {};
                    for (let i = 0; i < targets.length; i++) {
                        const result = await targets[i].draw((i != targets.length - 1) ? 'nodelay' : '').forResult();
                        if (Array.isArray(result)) map[targets[i].playerid] = result;
                    }
                    await game.delay();
                    for (const target of targets) {
                        const result = await target.chooseToGive(player, { type: ['trick', 'delay'] }, 'he', true).forResult();
                        if (!result.bool || !result.cards || !result.cards.length) {
                            const cards = map[target.playerid].filter(i => get.owner(i) == target);
                            if (cards.length) await target.give(cards, player);
                        }
                    }
                },
            },
            //念吕布
            mininiantazhen: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'phaseBegin' },
                forced: true,
                async content(event, trigger, player) {
                    let list = [[], [], []], items = game.filterPlayer(i => i != player).randomGets(3);
                    let jiu = 2, horse = 1;
                    while (jiu > 0 && items.length < 9) {
                        jiu--;
                        items.push('jiu');
                    }
                    while (horse > 0 && items.length < 9) {
                        horse--;
                        items.push('horse');
                    }
                    while (items.length < 9) {
                        items.push('sha');
                    }
                    items.randomSort();
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            let item = items.shift();
                            list[i].push(get.itemtype(item) == 'player' ? `${item.getSeatNum()}|${item.name}|${item.playerid}|${item.getHp()}|${parseFloat(i)}+${parseFloat(j)}` : `${item}|${parseFloat(i)}+${parseFloat(j)}`);
                        }
                    }
                    if (player.isUnderControl()) game.swapPlayerAuto(player);
                    const func = () => {
                        const event = get.event();
                        const controls = [
                            link => {
                                const evt = get.event();
                                if (evt.dialog && evt.dialog.buttons) {
                                    for (let i = 0; i < evt.dialog.buttons.length; i++) {
                                        const button = evt.dialog.buttons[i];
                                        button.classList.remove('selectable');
                                        button.classList.remove('selected');
                                        const counterNode = button.querySelector('.caption');
                                        if (counterNode) counterNode.childNodes[0].innerHTML = ``;
                                    }
                                    ui.selected.buttons.length = 0;
                                    game.check();
                                }
                                return;
                            },
                        ];
                        event.controls = [ui.create.control(controls.concat(['清除选择', 'stayleft']))];
                    };
                    if (event.isMine()) func();
                    else if (event.isOnline()) event.player.send(func);
                    const videoId = lib.status.videoId++;
                    const originalTimeout = lib.configOL.choose_timeout;
                    game.broadcastAll((player, videoId) => {
                        if (_status.connectMode) lib.configOL.choose_timeout = '30';
                        let dialog;
                        if (game.me === player) {
                            dialog = ui.create.dialog(
                                '踏阵',
                                '<div class="text center">剩余' + parseFloat(player.getHp() + 1) + '步；攻击力：0；酒：0；当前击败：无</div>',
                                [list[0], lib.skill.mininiantazhen.tazhen],
                                [list[1], lib.skill.mininiantazhen.tazhen],
                                [list[2], lib.skill.mininiantazhen.tazhen],
                            );
                            dialog.videoId = videoId;
                            dialog.classList.add('fullheight');
                        }
                        else dialog = ui.create.dialog(`${get.translation(player)}正在进行“踏阵”...`);
                        dialog.videoId = videoId;
                        dialog.open();
                    }, player, videoId);
                    const result = await player.chooseButton(get.idDialog(videoId)).set('selectButton', () => {
                        const { player, dialog } = get.event(), kill = get.info('mininiantazhen').kill(ui.selected.buttons.map(i => i.link), player);
                        if (dialog && player === game.me) {
                            const nums = Array.from({ length: 3 }).map((_, i) => i);
                            const findXY = function (item) {
                                const nums = item.split('|').reverse()[0].split('+');
                                return [parseInt(nums[0]), parseInt(nums[1])];
                            };
                            const allPosition = ui.selected.buttons.map(but => findXY(but.link)), defeatedPlayers = kill[2].map(i => i[1]);
                            dialog.content.childNodes[1].innerHTML = '<div class="text center">剩余' + parseFloat(kill[3]) + '步；攻击力：' + parseFloat(kill[0]) + '；酒：' + parseFloat(kill[1]) + '；当前击败：' + (kill[2].length ? get.translation(kill[2].map(i => i[0])) : '无') + '</div>';
                            dialog.buttons.forEach(button => {
                                const linkParts = button.link.split('|');
                                if (linkParts.length > 2) button.style.filter = defeatedPlayers.includes(linkParts[2]) ? 'grayscale(100%)' : '';
                            });
                        }
                        return [1, 1 + get.event().player.getHp() + ui.selected.buttons.filter(i => i.link.split('|')[0] == 'horse').length * 2];
                    }).set('filterButton', button => {
                        if (!get.event().list.flat().includes(button.link)) return false;
                        if (!ui.selected.buttons.length) return button.link.split('|').length <= 2;
                        const findXY = function (item) {
                            const nums = item.split('|').reverse()[0].split('+');
                            return [parseInt(nums[0]), parseInt(nums[1])];
                        };
                        const buttonPosition = findXY(button.link), itemPosition = findXY(ui.selected.buttons.slice().reverse()[0].link);
                        if (Math.abs(buttonPosition[0] - itemPosition[0]) > 1 || Math.abs(buttonPosition[1] - itemPosition[1]) > 1) return false;
                        if (buttonPosition[0] == itemPosition[0] || buttonPosition[1] == itemPosition[1]) return true;
                        const dx = buttonPosition[0] - itemPosition[0], dy = buttonPosition[1] - itemPosition[1];
                        const allPosition = ui.selected.buttons.map(but => findXY(but.link));
                        return !allPosition.some(p => p[0] == itemPosition[0] + dx && p[1] == itemPosition[1]) || !allPosition.some(p => p[0] == itemPosition[0] && p[1] == itemPosition[1] + dy);
                    }).set('list', list).set('processAI', () => {
                        const event = get.event(), { player, list } = event;
                        const findXY = function (item) {
                            const nums = item.split('|').reverse()[0].split('+');
                            return [parseInt(nums[0]), parseInt(nums[1])];
                        };
                        const canMove = function (path, next) {
                            if (!path.length) return next.split('|').length <= 2;
                            const [x1, y1] = findXY(path[path.length - 1]), [x2, y2] = findXY(next);
                            if (Math.abs(x1 - x2) > 1 || Math.abs(y1 - y2) > 1) return false;
                            if (x1 === x2 || y1 === y2) return true;
                            const dx = x2 - x1, dy = y2 - y1;
                            return !path.some(p => {
                                const [px, py] = findXY(p);
                                return (px === x1 + dx && py === y1) || (px === x1 && py === y1 + dy);
                            });
                        };
                        let allPaths = [];
                        const searchPath = function (path, used) {
                            const horses = path.filter(i => i.split('|')[0] === 'horse').length;
                            const kill = get.info('mininiantazhen').kill(path.slice(), player);
                            if (kill[2].length > 0 || path.length < player.getHp() + 1 + horses * 2) allPaths.push(path.slice());
                            for (const item of list.flat()) {
                                if (used.has(item) || !canMove(path, item)) continue;
                                if (path.length + 1 > player.getHp() + 1 + horses * 2) continue;
                                used.add(item);
                                path.push(item);
                                searchPath(path, used);
                                path.pop();
                                used.delete(item);
                            }
                        };
                        searchPath([], new Set());
                        let bestScore = 0, bestPath;
                        for (const path of allPaths) {
                            const kill = get.info('mininiantazhen').kill(path.slice(), player);
                            if (kill[2].length > 0) {
                                let score = 0;
                                const targets = kill[2].map(i => (_status.connectMode ? lib.playerOL : game.playerMap)[i[1]]);
                                const pos = path.map(findXY), nums = [0, 1, 2];
                                if (nums.some(n => !pos.some(p => p[1] === n))) {
                                    score += targets.reduce((sum, target) => sum + get.effect(target, { name: 'shunshou_copy2' }, player, player), 0);
                                }
                                if (nums.some(n => !pos.some(p => p[0] === n))) {
                                    const card = new lib.element.VCard({ name: 'sha' });
                                    score += targets.reduce((sum, target) => {
                                        if (player.canUse(card, target, false)) sum += get.effect(target, card, player, player);
                                        return sum;
                                    }, 0);
                                }
                                if (!pos.some(p => p[0] === 1 && p[1] === 1)) {
                                    const card = new lib.element.VCard({ name: 'sha' });
                                    score += targets.reduce((sum, target) => {
                                        if (target.canUse(card, player, false) && get.effect(player, card, target, target) > 0) sum -= get.effect(player, card, target, player);
                                        return sum;
                                    }, 0);
                                }
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestPath = path;
                                }
                            }
                        }
                        return { bool: Boolean(bestPath), links: bestPath };
                    }).set('custom', {
                        add: {
                            confirm(bool) {
                                if (bool != true) return;
                                const event = get.event().parent;
                                if (event.controls) event.controls.forEach(i => i.close());
                                if (ui.confirm) ui.confirm.close();
                                game.uncheck();
                            },
                            button() {
                                if (ui.selected.buttons.length) return;
                                const event = get.event();
                                if (event.dialog && event.dialog.buttons) {
                                    for (let i = 0; i < event.dialog.buttons.length; i++) {
                                        const button = event.dialog.buttons[i];
                                        const counterNode = button.querySelector('.caption');
                                        if (counterNode) counterNode.childNodes[0].innerHTML = ``;
                                    }
                                }
                                if (!ui.selected.buttons.length) {
                                    const evt = event.parent;
                                    if (evt.controls) evt.controls[0].classList.add('disabled');
                                }
                            },
                        },
                        replace: {
                            button(button) {
                                const event = get.event();
                                if (!event.isMine() || ui.selected.buttons.includes(button)) return;
                                if (!event.filterButton(button)) return;
                                if (button.classList.contains('selectable') == false) return;
                                if (ui.selected.buttons.length >= event.selectButton()) return false;
                                button.classList.add('selected');
                                ui.selected.buttons.push(button);
                                let counterNode = button.querySelector('.caption');
                                const count = ui.selected.buttons.indexOf(button) + 1;
                                if (counterNode) {
                                    counterNode = counterNode.childNodes[0];
                                    counterNode.innerHTML = `第${count}步`;
                                }
                                else {
                                    counterNode = ui.create.caption(`<span style="font-size:24px; font-family:xinwei; text-shadow:#FFF 0 0 4px, #FFF 0 0 4px, rgba(74,29,1,1) 0 0 3px;">第${count}步</span>`, button);
                                    counterNode.style.right = '5px';
                                    counterNode.style.bottom = '2px';
                                }
                                const evt = event.parent;
                                if (evt.controls) evt.controls[0].classList.remove('disabled');
                                game.check();
                            },
                        },
                    }).set('filterOk', () => {
                        return ui.selected.buttons.some(i => i.link.split('|').length > 2)
                    }).forResult();
                    game.broadcastAll((originalTimeout, videoId) => {
                        const dialog = get.idDialog(videoId);
                        if (dialog) dialog.close();
                        if (_status.connectMode) lib.configOL.choose_timeout = originalTimeout;
                    }, originalTimeout, videoId);
                    if (result?.bool && result.links?.length) {
                        const kill = get.info('mininiantazhen').kill(result.links.slice(), player);
                        if (kill[2].length > 0) {
                            const targets = kill[2].map(i => (_status.connectMode ? lib.playerOL : game.playerMap)[i[1]]).sortBySeat();
                            player.line(targets);
                            player.popup('踏阵成功', 'wood');
                            game.log(player, '踏阵', '#g成功', '击败了', targets);
                            const sha = get.cardPile('sha');
                            if (sha) await player.gain(sha, 'gain2');
                            player.addTempSkill('mininiantazhen_wushuang', { player: 'phaseBegin' });
                            await player.addAdditionalSkills('mininiantazhen_wushuang', 'miniwushuang');
                            const findXY = function (item) {
                                const nums = item.split('|').reverse()[0].split('+');
                                return [parseInt(nums[0]), parseInt(nums[1])];
                            };
                            const allPosition = result.links.map(findXY);
                            const nums = Array.from({ length: 3 }).map((_, i) => i);
                            if (nums.some(num => !allPosition.some(l => l[1] == num))) {
                                player.popup('一整列', 'wood');
                                for (const i of targets) {
                                    if (i.countCards('he')) await i.chooseToGive(player, 'he', true);
                                }
                            }
                            if (nums.some(num => !allPosition.some(l => l[0] == num))) {
                                player.popup('一整行', 'wood');
                                const card = new lib.element.VCard({ name: 'sha' });
                                const shas = targets.filter(i => player.canUse(card, i, false));
                                if (shas.length) await player.useCard(card, shas, false);
                            }
                            if (!allPosition.some(l => l[0] == 1 && l[1] == 1)) {
                                player.popup('中心格', 'wood');
                                player.addTempSkill('mininiantazhen_effect', { player: 'phaseBegin' });
                                player.markAuto('mininiantazhen_effect', targets);
                            }
                            return;
                        }
                    }
                    player.popup('踏阵失败', 'fire');
                    game.log(player, '踏阵', '#y失败');
                },
                derivation: ['miniwushuang', 'mininiantazhen_faq'],
                subSkill: {
                    wushuang: {
                        charlotte: true,
                    },
                    effect: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '$不能对你使用【杀】' },
                        mod: {
                            targetEnabled(card, player, target) {
                                if (card.name == 'sha' && target.getStorage('mininiantazhen_effect').includes(player)) return false;
                            },
                        },
                    },
                },
                kill(steps, player) {
                    // 杀的攻击力 
                    let attack = 0;
                    // 两次击败目标之间出现的酒的数量  
                    let jiuCount = 0;
                    // 两次击败目标之间是否出现过杀
                    let hasSha = false;
                    // 击败目标
                    let killed = [];
                    // 剩余行动步数
                    let rest = player.getHp() + 1 - steps.length;
                    for (const step of steps) {
                        const items = step.split('|');
                        if (items.length > 2) {
                            // 遇到击败目标时的当前攻击力
                            const jiuEffect = hasSha ? jiuCount * 2 : 0;
                            const totalAttack = attack + jiuEffect;
                            if (totalAttack >= items[3]) killed.push([items[1], items[2]]);
                            // 重置酒的计数
                            if (hasSha && jiuCount > 0) jiuCount = 0;
                            // 重置当前段的杀的出现状态
                            hasSha = false;
                        } else {
                            switch (items[0]) {
                                case 'sha':
                                    attack++;
                                    hasSha = true;
                                    break;
                                case 'horse':
                                    rest += 2;
                                    break;
                                case 'jiu':
                                    jiuCount += 1;
                                    break;

                            }
                        }
                    }
                    return [attack + (hasSha ? jiuCount * 2 : 0), jiuCount, killed, rest];
                },
                tazhen(item, type, position, noclick, node) {
                    if (item.slice().split('|').length > 2) {
                        const info = item.split('|'), _item = item, seat = parseInt(info[0]);
                        item = info[1];
                        if (node) {
                            node.classList.add('button');
                            node.classList.add('character');
                            node.style.display = '';
                        }
                        else node = ui.create.buttonPresets.character(item, 'character', position, noclick);
                        node._link = item;
                        node.link = item;
                        const func = function (node, item) {
                            const currentPlayer = game.findPlayer(current => current.getSeatNum() == seat);
                            if (currentPlayer.classList.contains('unseen_show')) node.setBackground('hidden_image', 'character');
                            else if (item != 'unknown') node.setBackground(item, 'character');
                            node.classList.add('tazhen');
                            if (node.node) {
                                node.node.name.remove();
                                // node.node.hp.remove();
                                node.node.group.remove();
                                node.node.intro.remove();
                                if (node.node.replaceButton) node.node.replaceButton.remove();
                            }
                            node.node = {
                                name: ui.create.div('.name', node),
                                group: ui.create.div('.identity', node),
                                intro: ui.create.div('.intro', node),
                            };
                            const infoitem = [currentPlayer.sex, currentPlayer.group, `${currentPlayer.hp}/${currentPlayer.maxHp}/${currentPlayer.hujia}`];
                            node.node.name.innerHTML = get.slimName(item);
                            if (lib.config.buttoncharacter_style == 'default' || lib.config.buttoncharacter_style == 'simple') {
                                if (lib.config.buttoncharacter_style == 'simple') node.node.group.style.display = 'none';
                                node.classList.add('newstyle');
                                node.node.name.dataset.nature = get.groupnature(get.bordergroup(infoitem));
                                node.node.group.dataset.nature = get.groupnature(get.bordergroup(infoitem), 'raw');
                            }
                            node.node.name.style.top = '8px';
                            if (node.node.name.querySelectorAll('br').length >= 4) {
                                node.node.name.classList.add('long');
                                if (lib.config.buttoncharacter_style == 'old') {
                                    node.addEventListener('mouseenter', ui.click.buttonnameenter);
                                    node.addEventListener('mouseleave', ui.click.buttonnameleave);
                                }
                            }
                            node.node.intro.innerHTML = lib.config.intro;
                            if (!noclick) lib.setIntro(node);
                            node.node.group.innerHTML = `<div>${get.cnNumber(seat, true)}号</div>`;
                            node.node.group.style.backgroundColor = get.translation(`${get.bordergroup(infoitem)}Color`);
                        };
                        node.refresh = func;
                        node.refresh(node, item);
                        node.link = _item;
                        node.seatNumber = seat;
                        node._customintro = uiintro => {
                            uiintro.add(`${get.translation(node._link)}`);
                        };
                        return node;
                    }
                    else {
                        const _item = item;
                        item = ['', '', 'mininiantazhen_' + item.split('|')[0]];
                        node = ui.create.card(position, 'noclick', noclick);
                        node.classList.add('button');
                        node.classList.add('tazhen');
                        node.init(item);
                        node.link = _item;
                        return node;
                    }
                },
            },
            mininiandoupo: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: ['juedouBefore', 'juedouBegin', 'useCardAfter'] },
                filter(event, player, name) {
                    if (event.name == 'juedou') {
                        const evt = event.getParent();
                        if (!evt || evt.name != 'useCard' || !(evt.targets || []).includes(event.target)) return false;
                        return (evt.targets.slice().reverse()[0] !== event.target) === (name === 'juedouBefore');
                    }
                    if (event.card.name != 'juedou' || !(event.targets || []).length) return false;
                    const juedouEvent = game.getGlobalHistory('everything', evt => evt.name === 'juedou' && evt.getParent() == event && evt.turn)[0];
                    if (!juedouEvent || juedouEvent.turn === player) return false;
                    return event.targets.some(target => target.isIn() && target.countCards('h') > 0);
                },
                direct: true,
                locked: true,
                async content(event, trigger, player) {
                    if (event.triggername == 'juedouBefore') {
                        trigger.cancel();
                        return;
                    }
                    const targets = trigger.name == 'juedou' ? trigger.getParent().targets : trigger.targets.filter(target => target.isIn() && target.countCards('h') > 0);
                    await player.logSkill('mininiandoupo', targets);
                    if (trigger.name == 'useCard') {
                        for (const target of targets) {
                            await player.gain(target.getGainableCards(player, 'h').randomGets(1), target, 'giveAuto', 'bySelf');
                        }
                    }
                    else {
                        trigger.setContent(lib.skill.mininiandoupo.juedouContent);
                    }
                },
                mod: {
                    selectTarget(card, player, range) {
                        if (card.name == "juedou" && range[1] != -1) range[1] += 2;
                    },
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        mod: {
                            cardname(card, player) {
                                const evt = _status.event, storage = player.getStorage('mininiandoupo_effect');
                                if (evt.name == 'chooseToRespond' && storage.includes(evt.getParent(2))) return 'sha';
                            },
                        },
                    },
                },
                async juedouContent(event, trigger, player) {
                    const targets = event.targets.sortBySeat(player);
                    if (event.turn == undefined) event.turn = targets[0];
                    if (typeof event.baseDamage != 'number') event.baseDamage = 1;
                    if (typeof event.extraDamage != 'number') event.extraDamage = 0;
                    if (!event.shaReq) event.shaReq = {};
                    if (typeof event.shaReq[player.playerid] != 'number') event.shaReq[player.playerid] = 1;
                    for (const target of targets) {
                        const map = event.getParent().customArgs, id = target.playerid;
                        if (map && map[id] && map[id].shaReq && map[id].shaReq[id]) {
                            event.shaReq[target.playerid] = map[id].shaReq[id];
                        }
                        else event.shaReq[target.playerid] = 1;
                        if (target != event.target) {
                            const myID = player.playerid;
                            if (map && map[id] && map[id].shaReq && map[id].shaReq[myID]) {
                                event.shaReq[player.playerid] += (map[id].shaReq[myID] - 1);
                            }
                        }
                    }
                    event.playerCards = [];
                    event.targetCards = [];
                    let stop = false;
                    const juedous = targets.slice().concat(player);
                    while (!stop) {
                        for (const target of juedous) {
                            if (stop && target == player) break;
                            event.turn = target;
                            await event.trigger('juedou');
                            event.shaRequired = event.shaReq[event.turn.playerid];
                            while (true) {
                                if (event.directHit) {
                                    event._result = { bool: false };
                                }
                                else {
                                    const next = event.turn.chooseToRespond({ name: 'sha' });
                                    if (event.shaRequired > 1) next.set('prompt2', '共需打出' + event.shaRequired + '张杀');
                                    next.set('ai', card => {
                                        let event = _status.event, player = event.splayer, target = event.starget;
                                        if (player.hasSkillTag('notricksource') || target.hasSkillTag('notrick')) return 0;
                                        if (event.shaRequired > 1 && player.countCards('h', 'sha') < event.shaRequired) return 0;
                                        if (event.player === target) {
                                            if (_status.event.tdamage >= 0 || player.hasSkill('naman')) return -1;
                                            if (get.attitude(target, player) <= 0 || event.player.hp <= 1 && _status.event.tdamage < _status.event.pdamage) {
                                                return get.order(card);
                                            }
                                            return -1;
                                        }
                                        else {
                                            if (_status.event.pdamage >= 0 || target.hasSkill('naman')) return -1;
                                            if (get.attitude(player, target) <= 0 || event.player.hp <= 1 && _status.event.tdamage > _status.event.pdamage) {
                                                return get.order(card);
                                            }
                                            return -1;
                                        }
                                    });
                                    next.set('splayer', player);
                                    next.set('starget', target);
                                    next.set('pdamage', targets.reduce((sum, i) => {
                                        return sum + get.damageEffect(player, i, event.turn);
                                    }, 0));
                                    next.set('tdamage', get.damageEffect(target, player, event.turn));
                                    next.set('shaRequired', event.shaRequired);
                                    next.autochoose = lib.filter.autoRespondSha;
                                    const result = await next.forResult();
                                    if (result.bool) {
                                        event.shaRequired--;
                                        if (event.turn !== player) {
                                            if (result.cards) event.targetCards.addArray(result.cards);
                                            if (event.shaRequired > 0) continue;
                                            else break;
                                        }
                                        else {
                                            if (result.cards) event.playerCards.addArray(result.cards);
                                            if (event.shaRequired > 0) continue;
                                            else break;
                                        }
                                    }
                                    else {
                                        stop = true;
                                        if (event.turn !== player) {
                                            await target.damage(player);
                                        }
                                        else {
                                            for (const target of targets) {
                                                await player.damage(target);
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    event._result = {};
                },
            },
            mininianying_lb: {
                audio: 'mininianying_Mnian_lvbu',
                trigger: {
                    player: 'damageEnd',
                    source: 'damageSource',
                },
                filter(event, player, name, indexedData) {
                    if (!Object.keys(lib.skill).some(i => get.info(i)?.nianyingSkill && get.info(i).nianyingFilter(event, player, name, indexedData))) return false;
                    return player.countMark('mininianying_lb') >= 2;
                },
                async cost(event, trigger, player) {
                    const skills = Object.keys(lib.skill).filter(i => get.info(i)?.nianyingSkill && get.info(i).nianyingFilter(trigger, player, event.triggername, event.indexedData)).map(i => [i, get.info(i).nianyingSkill[0], get.info(i).nianyingSkill[1]]);
                    const result = await player.chooseControl(skills.map(i => i[1]), 'cancel2')
                        .set('prompt', get.prompt('mininianying_lb')).set('prompt2', '选择一项念影效果执行')
                        .set('displayIndex', false)
                        .set('choiceList', skills.map(i => {
                            return '<div class="skill">' + i[1] + '</div><div>' + i[2] + '</div>';
                        })).set('ai', () => get.event().controls.randomGet()).forResult();
                    event.result = { bool: (result.control != 'cancel2'), cost_data: skills.find(i => i[1] == result.control) };
                },
                usable: 1,
                async content(event, trigger, player) {
                    const choice = event.cost_data;
                    player.popup(choice[1]);
                    game.log(player, '选择了', '#g' + choice[1]);
                    await lib.skill[choice[0]].nianyingContent(player);
                },
                nianyingSkill: ['斗破千军', '视为使用一张【决斗】，本次【决斗】结算中，你的所有手牌均视为【杀】'],
                nianyingFilter(event, player, name) {
                    return player.hasUseTarget(new lib.element.VCard({ name: 'juedou' }), false);
                },
                async nianyingContent(player) {
                    await player.chooseUseTarget(new lib.element.VCard({ name: 'juedou' }), true, false, '###斗破千军###<div class="text center">视为使用一张【决斗】，本次【决斗】结算中，你的所有手牌均视为【杀】</div>').set('oncard', card => {
                        const evt = _status.event;
                        evt.player.addTempSkill('mininiandoupo_effect');
                        evt.player.markAuto('mininiandoupo_effect', [evt]);
                    });
                },
                init(player, skill) {
                    const num = game.getGlobalHistory('changeHp', evt => {
                        return evt.getParent().name == 'damage' && (evt.getParent().player == player || (evt.getParent().source && evt.getParent().source == player));
                    }).concat(game.getGlobalHistory('changeHp', evt => {
                        return evt.getParent().name == 'damage' && evt.getParent().player == player && evt.getParent().source && evt.getParent().source == player;
                    })).length;
                    if (num) player.addMark(skill, num, false);
                },
                onremove: true,
                group: 'mininianying_lb_mark',
                subSkill: {
                    mark: {
                        charlotte: true,
                        trigger: {
                            global: 'phaseBefore',
                            player: 'damageEnd',
                            source: 'damageSource',
                        },
                        forced: true,
                        popup: false,
                        firstDo: true,
                        content() {
                            if (trigger.name == 'phase') delete player.storage.mininianying_lb;
                            else player.addMark('mininianying_lb', trigger.num, false);
                        },
                    },
                },
            },
            //念周瑜
            mininiansuhui: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'phaseEnd' },
                check(event, player) {
                    return get.attitude(player, event.player) > 0;
                },
                round: 1,
                logTarget: 'player',
                async content(event, trigger, player) {
                    await Promise.all(event.next);
                    event.videoId = lib.status.videoId++;
                    if (player.isUnderControl()) game.swapPlayerAuto(player);
                    const switchToAuto = function () {
                        return new Promise((resolve) => {
                            game.pause();
                            game.countChoose();
                            setTimeout(() => {
                                _status.imchoosing = false;
                                if (event.dialog) event.dialog.close();
                                if (event.control_replace) event.control_replace.close();
                                if (event.control_ok) event.control_ok.close();
                                game.resume();
                                event._result = { musicList: [0, 0, 0].concat([get.rand(0, 1)].concat([get.rand(0, 1)])) };
                                resolve(event._result);
                            }, 5000);
                        });
                    };
                    const originalTimeout = lib.configOL.choose_timeout;
                    game.broadcastAll((player, videoId) => {
                        if (_status.connectMode) lib.configOL.choose_timeout = '30';
                        if (game.me !== player) {
                            const dialog = ui.create.dialog(`${get.translation(player)}正在进行“奏乐”...`);
                            dialog.videoId = videoId;
                            dialog.open();
                        }
                    }, player, event.videoId);
                    const zhouyu_MusicPlay = function (player) {
                        const event = _status.event, { promise, resolve } = Promise.withResolvers();
                        //可以即兴/更换音符的最大次数
                        event.restNum = 5 + player.countMark('mininianchongzou_effect');
                        //定义初始五音和是否上锁的列表
                        const musicList = ['宫', '商', '角', '徵', '羽'].map(i => 'zhouyu_' + i);
                        event.musicList = [];
                        while (event.musicList.length < 5) {
                            event.musicList.push(musicList.randomGet());
                        }
                        event.musicList_Locked = [];
                        //如果以自己视角进入流程后AI直接走结果
                        event.switchToAuto = function () {
                            _status.imchoosing = false;
                            event._result = { musicList: [0, 0, 0].concat([get.rand(0, 1)].concat([get.rand(0, 1)])) };
                            resolve(event._result);
                            if (event.dialog) event.dialog.close();
                            if (event.control_replace) event.control_replace.close();
                            if (event.control_ok) event.control_ok.close();
                        };
                        //替换音符，每次替换消耗一次即兴次数
                        event.control_replace = ui.create.control('即兴', link => {
                            if (!event.restNum || event.musicList_Locked.length >= 5) return;
                            event.restNum--;
                            if (!event.restNum && event.control_replace) event.control_replace.close();
                            // 更新剩余次数显示
                            event.dialog.content.childNodes[0].innerHTML = event.dialog.content.childNodes[0].innerHTML.replace(/还可即兴\d+次/g, '还可即兴' + event.restNum + '次');
                            //更新未被锁定的音符
                            for (let i = 0; i < 5; i++) {
                                const container = event.dialog.itemContainers[1 + i];
                                if (!event.musicList_Locked.includes(container)) {
                                    event.musicList[i] = musicList.randomGet();
                                    //直接更新对应容器的内容
                                    const card = game.createCard(event.musicList[i], ' ', ' ');
                                    container.innerHTML = '';
                                    ui.create.button(card, 'card', container, true);
                                }
                            }
                            //刷新，但是现在用不上了
                            //event.musicList_Locked = [];
                        });
                        //获取结果
                        event.control_ok = ui.create.control('演奏', link => {
                            event.dialog.close();
                            event.control_replace.close();
                            event.control_ok.close();
                            game.resume();
                            _status.imchoosing = false;
                            event._result = { musicList: event.musicList };
                            resolve(event._result);
                        });
                        //点击容器事件的反馈
                        const clickItemContainer = function (container) {
                            const goon = event.musicList_Locked.includes(container);
                            event.musicList_Locked[goon ? 'remove' : 'add'](container);
                            container.classList[goon ? 'remove' : 'add']('selected');
                        };
                        //创建dialog
                        const dialog = event.dialog = ui.create.dialog('forcebutton', 'hidden');
                        dialog.addNewRow('溯洄：请进行演奏，根据最多的同名音符数执行后续效果<br><div class="text center">还可即兴' + event.restNum + '次，点击音符即可锁定，避免被即兴替换</div>');
                        dialog.addNewRow(...event.musicList.map(item => {
                            return {
                                item: [game.createCard(item, ' ', ' ')],
                                ItemNoclick: true,
                                clickItemContainer,
                            };
                        }));
                        dialog.open();
                        game.pause();
                        game.countChoose();
                        return promise;
                    };
                    let next;
                    if (event.isMine()) next = zhouyu_MusicPlay(player);
                    else if (event.isOnline()) {
                        const { promise, resolve } = Promise.withResolvers();
                        event.player.send(zhouyu_MusicPlay, player);
                        event.player.wait(async result => {
                            if (result == 'ai') result = await switchToAuto();
                            resolve(result);
                        });
                        game.pause();
                        next = promise;
                    }
                    else next = switchToAuto();
                    const result = await next;
                    game.resume();
                    game.broadcastAll((originalTimeout, videoId) => {
                        const dialog = get.idDialog(videoId);
                        if (dialog) dialog.close();
                        if (_status.connectMode) lib.configOL.choose_timeout = originalTimeout;
                    }, originalTimeout, event.videoId);
                    const target = trigger.player, musicList = result.musicList;
                    const num = Math.max(...Object.values(musicList.reduce((map, name) => {
                        if (!map[name]) map[name] = 0;
                        map[name]++;
                        return map;
                    }, {})));
                    player.chat(num + '个');
                    game.log(player, '本次', '#g演奏', '共收集', '#y' + num, '个相同音符');
                    if (num >= 3) {
                        player.popup('洗具', 'wood');
                        const level = { '3': 'phaseDiscard', '4': 'phaseUse', '5': 'phaseZhunbei' }[num.toString()], list = trigger.phaseList;
                        const index = list.find(item => item.startsWith(level));
                        if (index) {
                            target.chat('洗具', 'wood');
                            trigger.num = list.indexOf(index);
                            trigger._phaseEndTriggered = false;
                            game.log(target, '回溯至', '#g' + get.translation(level));
                        }
                        else {
                            target.chat('杯具', 'fire');
                            game.log('但是', target, '本回合没有', '#g' + get.translation(level), '！');
                        }
                    }
                    else {
                        player.chat('杯具', 'fire');
                    }
                    const cards = game.getGlobalHistory('everything', evt => {
                        return evt.name === 'cardsDiscard' || (evt.name === 'lose' && evt.position === ui.discardPile);
                    }).map(evt => evt.cards).flat().filterInD('d');
                    if (cards.length) await target.gain(cards, 'gain2');
                    target.addTempSkill('mininiansuhui_hand');
                    const musicList2 = musicList.map((item, i) => [item, i]);
                    target.addMark('mininiansuhui_hand', musicList2.filter(item => {
                        return musicList2.some(item2 => item !== item2 && item[0] === item2[0]);
                    }).length, false);
                },
                subSkill: {
                    hand: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '手牌上限+#' },
                        mod: {
                            maxHandcard(player, num) {
                                return num + player.countMark('mininiansuhui_hand');
                            },
                        },
                    },
                },
                derivation: 'mininiansuhui_faq',
            },
            mininianchongzou: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: ['useCard', 'respond'] },
                filter(event, player) {
                    if (!game.getGlobalHistory('everything', evt => {
                        if (evt === event) return false;
                        return evt.player === event.player && ['useCard', 'respond'].includes(evt.name) && evt.card.name === event.card.name;
                    }).length) return false;
                    return !game.getGlobalHistory('everything', evt => {
                        return evt.player === event.player && evt.name === 'mininianchongzou' && get.type2(event.card) === get.type2(evt._trigger.card);
                    }).length;
                },
                forced: true,
                async content(event, trigger, player) {
                    const card = get.cardPile(card => get.type2(card) !== get.type2(trigger.card));
                    if (card) await player.gain(card, 'gain2');
                    if (!player.storage.mininianchongzou_gain) {
                        player.when({ global: 'roundStart' }, false)
                            .then(() => {
                                const num = player.countMark('mininianchongzou_gain');
                                delete player.storage.mininianchongzou_gain;
                                player.addTempSkill('mininianchongzou_effect', 'roundStart');
                                player.addMark('mininianchongzou_effect', num, false);
                            })
                            .finish();
                    }
                    player.addMark('mininianchongzou_gain', 1, false);
                },
                ai: { combo: 'mininiansuhui' },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '即兴次数+#' },
                    },
                },
            },
            mininianying_zy: {
                audio: 'mininianying_Mnian_zhouyu',
                trigger: { global: 'phaseEnd' },
                filter(event, player, name, indexedData) {
                    if (!Object.keys(lib.skill).some(i => get.info(i)?.nianyingSkill && get.info(i).nianyingFilter(event, player, name, indexedData))) return false;
                    const history = game.getGlobalHistory('everything', evt => evt.player === event.player && ['useCard', 'respond'].includes(evt.name));
                    const map = history.reduce((map, evt) => {
                        const { name } = evt.card;
                        if (!map[name]) map[name] = 0;
                        map[name]++;
                        return map;
                    }, {});
                    return Object.keys(map).reduce((sum, item) => sum + Math.floor(map[item] / 2), 0) >= 2;
                },
                async cost(event, trigger, player) {
                    const skills = Object.keys(lib.skill).filter(i => get.info(i)?.nianyingSkill && get.info(i).nianyingFilter(trigger, player, event.triggername, event.indexedData)).map(i => [i, get.info(i).nianyingSkill[0], get.info(i).nianyingSkill[1]]);
                    const result = await player.chooseControl(skills.map(i => i[1]), 'cancel2')
                        .set('prompt', get.prompt('mininianying_zy')).set('prompt2', '选择一项念影效果执行')
                        .set('displayIndex', false)
                        .set('choiceList', skills.map(i => {
                            return '<div class="skill">' + i[1] + '</div><div>' + i[2] + '</div>';
                        })).set('ai', () => get.event().controls.randomGet()).forResult();
                    event.result = { bool: (result.control != 'cancel2'), cost_data: skills.find(i => i[1] == result.control) };
                },
                async content(event, trigger, player) {
                    const choice = event.cost_data;
                    player.popup(choice[1]);
                    game.log(player, '选择了', '#g' + choice[1]);
                    await lib.skill[choice[0]].nianyingContent(player);
                },
                nianyingSkill: ['江东双壁', '令至多两名角色各获得1点护甲（至多为5）'],
                nianyingFilter: () => true,
                async nianyingContent(player) {
                    const result = await player.chooseTarget(...get.info('mininianying_zy').nianyingSkill, [1, 2]).set('ai', target => {
                        const player = get.player();
                        return get.attitude(player, target) / Math.sqrt(Math.min(1, target.hp + target.hujia));
                    }).forResult();
                    if (result?.bool && result.targets?.length) {
                        const targets = result.targets.sortBySeat();
                        player.line(targets);
                        for (const target of targets) await target.changeHujia(1, null, true);
                    }
                },
            },
            mininiandengji: {
                /**
                 * 创建念曹丕的登阶游戏喵
                 * 
                 * 重要的事情说三遍，可乐喵万岁！可乐喵万岁！可乐喵万岁！
                 * 
                 * @author iceCola
                 * @param {Player} player 
                 * @param {unknown} [lastGameData=null] 上一次的游戏数据
                 */
                startDengjieGame(player, lastGameData = null) {
                    // 在小游戏上面显示的武将图片来源于哪些武将ID喵
                    const NAMES = [
                        'caopi', // 曹丕
                        'caoang', // 曹昂
                        'caochong', // 曹冲
                        'caozhang', // 曹彰
                        'caozhi', // 曹植
                        'liuxie', // 刘协
                    ];
                    // 游戏地图数据喵
                    const MAPS = [
                        'brrrbb(2,3)rrbb;brrbrrbrbr(3,4);(1,5)rb(0,3)brr(5,-12)rrr;brrbrrbrbrr;bbbrrbbrb(4,6)r',
                        'rbbrb(0,2)bbrbr;rrbbrrrb(2,5)bb;br(3,4)rbrbrrbr;bbrr(4,8)r(1,7)rbrr;rbbbr(5,-16)rbrbb',
                        'brb(2,3)rrrrbr(5,-10);rrrr(1,5)bbrrbr;brbbbrbb(3,4)bb;r(4,6)brrbbrrbr;rrrrbr(0,3)rrrb',
                        'brbbrbbrbbb;(1,9)rbrbbbr(0,2)rb;rrbr(4,2)r(3,3)rbrr;br(5,-20)brbrbrr(2,4);rbbrbrbrbbr',
                    ];
                    // 游戏相邻格
                    const NEIGHBORS = [
                        ['left', -1, 0],
                        ['up', 0, -1],
                        ['right', 1, 0],
                        ['down', 0, 1],
                    ];

                    // 解析地图函数
                    function parseMap(map, names, mapString) {
                        let slot = 0;
                        for (let i = 0; i < mapString.length; i++) {
                            const ch = mapString[i];
                            switch (ch) {
                                case 'b':
                                    map[slot] = 1;
                                    break;
                                case 'r':
                                    map[slot] = -1;
                                    break;
                                case '(':
                                    const j = mapString.indexOf(')', i);
                                    const [nameIndex, score] = mapString.slice(i + 1, j).split(',').map(x => parseInt(x));
                                    map[slot] = [nameIndex, score];
                                    names[NAMES[nameIndex]] = slot;
                                    i = j;
                                    break;
                                case ';':
                                    continue;
                                default:
                                    throw new Error(`无效的地图数据: ${ch}`);
                            }
                            slot++;
                        }
                    }

                    // 游戏数据保存对象
                    class GameData {
                        map = [];
                        names = {};
                        width = 11;
                        height = 5;
                        x = -1;
                        y = -1;
                        score = 0;
                        steps = 0;
                        time = 0;
                        walkedReds = [];

                        constructor(mapString) {
                            if (mapString.constructor.name === 'GameData') {
                                this.map = mapString.map.slice();
                                this.names = Object.assign({}, mapString.names);
                                this.width = mapString.width;
                                this.height = mapString.height;
                                this.x = mapString.x;
                                this.y = mapString.y;
                                this.score = mapString.score;
                                this.steps = mapString.steps;
                                this.time = mapString.time;
                                this.walkedReds = mapString.walkedReds.slice();
                                return;
                            }

                            parseMap(this.map, this.names, mapString);
                        }

                        initPlayer() {
                            if (this.x < 0 && this.y < 0) {
                                const nameCaopi = NAMES[0];
                                const slotCaopi = this.names[nameCaopi];
                                const { x, y } = this.getPosFromSlot(slotCaopi);
                                this.x = x;
                                this.y = y;
                                this.score = this.map[slotCaopi][1];
                                this.map[slotCaopi] = 0;
                            } else {
                                const slotCaopi = this.getSlotFromPos(this.x, this.y);
                                this.map[slotCaopi] = 0;
                            }
                        }

                        getPosFromSlot(slot) {
                            return {
                                x: slot % this.width,
                                y: Math.floor(slot / this.width)
                            };
                        }

                        getSlotFromPos(x, y) {
                            return x + y * this.width;
                        }
                    }

                    // 构造UI喵
                    /** @type {GameData} */
                    const gameData = lastGameData || new GameData(MAPS.randomGet());
                    const videoId = lib.status.videoId++;

                    function createUI(videoId, gameWidth, gameHeight, gameMap, NAMES) {
                        const dialog = ui.create.dialog('曹丕登阶Demo', 'forcebutton');
                        dialog.videoId = videoId;
                        dialog.addText('等待开始...');
                        dialog.classList.add('dengjie-game');

                        const gameContainer = ui.create.div(dialog.content);
                        const table = document.createElement('table');
                        table.classList.add('dengjie-game');
                        gameContainer.appendChild(table);

                        const tips = dialog.content.children[1].firstElementChild;
                        tips.id = 'dengjie-tips';

                        function remoteGetSlotFromPos(x, y, width) {
                            return x + y * width;
                        }

                        function createCharacter(name, score) {
                            const button = ui.create.button(get.info('mininiandengji').namesMap.get(name), 'character');

                            for (const element of [...button.children]) {
                                element.remove();
                            }
                            button.classList.add('noclick');

                            if (name !== NAMES[0]) {
                                const scoreDiv = ui.create.div('.score');
                                scoreDiv.innerHTML = Math.abs(score);

                                if (score > 0) {
                                    scoreDiv.classList.add('gain');
                                } else {
                                    scoreDiv.classList.add('lose');
                                }

                                button.appendChild(scoreDiv);
                            }

                            return button;
                        }

                        function buildNodes() {
                            for (let y = 0; y < gameHeight; y++) {
                                const tr = document.createElement('tr');
                                table.appendChild(tr);

                                for (let x = 0; x < gameWidth; x++) {
                                    const td = document.createElement('td');
                                    td.classList.add('dengjie-game');
                                    td.id = `dengjie-cell-${x}-${y}`;
                                    tr.appendChild(td);

                                    const slot = remoteGetSlotFromPos(x, y, gameWidth);
                                    const data = gameMap[slot];

                                    if (Array.isArray(data)) {
                                        const button = createCharacter(NAMES[data[0]], data[1]);
                                        td.appendChild(button);
                                    }
                                }
                            }
                        }

                        buildNodes();
                        dialog.open();

                        const width = dialog.clientWidth + 1;
                        dialog.style.width = width + 'px';
                        dialog.style.left = `calc(50% - ${width / 2}px)`;
                        dialog.style.height = 'auto';
                        dialog.style.minHeight = 'max-content';
                    }

                    let isAI = false;

                    if (player.isOnline()) {
                        player.send(createUI, videoId, gameData.width, gameData.height, gameData.map, NAMES);
                    } else if (player.isMine()) {
                        createUI(videoId, gameData.width, gameData.height, gameData.map, NAMES);
                    } else {
                        isAI = true;
                    }

                    const originalTimeout = lib.configOL.choose_timeout;

                    game.broadcastAll(function (player, videoId) {
                        if (_status.connectMode) {
                            lib.configOL.choose_timeout = '30';
                        }
                        if (game.me !== player) {
                            const dialog = ui.create.dialog(`${get.translation(player)}正在进行登阶...`);
                            dialog.videoId = videoId;
                            dialog.open();
                        }
                    }, player, videoId);

                    // 游戏主逻辑
                    const initialData = new GameData(gameData); // 备份当前的数据以便失败时回滚喵

                    function checkPosition(x, y) {
                        if (y < 0 || y >= gameData.height) {
                            throw new Error('y out of range');
                        }
                        if (x < 0 || x >= gameData.width) {
                            throw new Error('x out of range');
                        }
                    }

                    function getTableCell(x, y) {
                        return document.getElementById(`dengjie-cell-${x}-${y}`);
                    }

                    function* walkNearCells(x, y) {
                        checkPosition(x, y);

                        for (const [dir, ox, oy] of NEIGHBORS) {
                            const nx = x + ox;
                            const ny = y + oy;

                            if (nx < 0 || nx >= gameData.width || ny < 0 || ny >= gameData.height) {
                                continue;
                            }

                            yield [dir, x + ox, y + oy];
                        }
                    }

                    function getCellScore(x, y) {
                        checkPosition(x, y);

                        const data = gameData.map[gameData.getSlotFromPos(x, y)];

                        if (typeof data == 'number') {
                            return data;
                        } else if (Array.isArray(data)) {
                            return data[1];
                        } else {
                            return 0;
                        }
                    }

                    // 啊本来是准备做箭头的喵，但是后面感觉直接放收益更好哦喵
                    function buildArrow(x, y, score) {
                        const container = ui.create.div('.arrow-container');
                        const arrow = ui.create.div('.arrow');
                        const extraClass = score == 0 ? 'old' : (score > 0 ? 'new-gain' : 'new-lose');
                        arrow.innerHTML = (score != 0 ? (score > 0 ? '+' : '-') : '') + Math.abs(score);
                        container.appendChild(arrow);
                        container.classList.add(extraClass);
                        return container;
                    }

                    function buildArrowRemote(x, y) {
                        const score = getCellScore(x, y);

                        if (player.isMine()) {
                            const cell = getTableCell(x, y);
                            const container = buildArrow(x, y, score);
                            cell.appendChild(container);
                            cell.classList.add('selectable');
                        } else if (player.isOnline()) {
                            player.send(function (x, y, score, buildArrow, getTableCell) {
                                const container = buildArrow(x, y, score);
                                const cell = getTableCell(x, y);
                                cell.appendChild(container);
                                cell.classList.add('selectable');
                            }, x, y, score, buildArrow, getTableCell);
                        }
                    }

                    function clearArrow(cell) {
                        cell.querySelector('.arrow-container')?.remove();
                    }

                    function clearArrowRemote([x, y]) {
                        if (player.isMine()) {
                            const cell = getTableCell(x, y);
                            clearArrow(cell);
                            cell.classList.remove('selectable');
                        } else if (player.isOnline()) {
                            player.send(function (x, y, clearArrow, getTableCell) {
                                const cell = getTableCell(x, y);
                                clearArrow(cell);
                                cell.classList.remove('selectable');
                            }, x, y, clearArrow, getTableCell);
                        }
                    }

                    function markWalked(x, y) {
                        checkPosition(x, y);

                        const slot = gameData.getSlotFromPos(x, y);
                        const data = gameData.map[slot];

                        if (Array.isArray(data)) {
                            const name = NAMES[data[0]];
                            delete gameData.names[name];

                            if (player.isMine()) {
                                const cell = getTableCell(x, y);
                                cell.querySelector('.button')?.remove();
                            } else if (player.isOnline()) {
                                player.send(function (x, y, getTableCell) {
                                    const cell = getTableCell(x, y);
                                    cell.querySelector('.button')?.remove();
                                }, x, y, getTableCell);
                            }
                        }

                        gameData.map[slot] = 0;
                    }

                    function waitCellClick(locations) {
                        function waitCellClickCore(cells) {
                            const eventName = lib.config.touchscreen ? 'touchend' : 'click';
                            const { promise, resolve } = Promise.withResolvers();

                            function clearHandler() {
                                cells.forEach(cell => cell.removeEventListener(eventName, clickHandler));
                            }

                            function clickHandler(event) {
                                const cell = event.currentTarget;
                                resolve(cells.indexOf(cell));
                                clearHandler();
                            }

                            cells.forEach(cell => cell.addEventListener(eventName, clickHandler));

                            game.countChoose();
                            _status.noclearcountdown = 'direct';
                            return promise;
                        }

                        function send(player, locations, id, waitCellClickCore, getTableCell) {
                            const cells = [];

                            for (const [x, y] of locations) {
                                const cell = getTableCell(x, y);
                                cells.push(cell);
                            }

                            const dialog = get.idDialog(id);

                            player.chooseButton(dialog)
                                .set('noconfirm', true)
                                .setContent(async (event, trigger, player) => {
                                    const promise = new Promise(resolve => {
                                        event.switchToAuto = function () {
                                            resolve('ai');
                                        };
                                    });

                                    event.result = await Promise.race([promise, waitCellClickCore(cells)]);

                                    if (event.result !== 'ai') {
                                        event.result = { index: event.result, _noHidingTimer: true };
                                    }
                                });

                            game.resume();
                        }

                        if (player.isOnline()) {
                            player.send(send, player, locations, videoId, waitCellClickCore, getTableCell);

                            const { promise, resolve, reject } = Promise.withResolvers();

                            player.wait(result => {
                                if (result === 'ai') {
                                    reject('switchauto');
                                    return;
                                }

                                resolve(result.index);
                            });
                            _status.noclearcountdown = 'direct';

                            return promise;
                        } else if (player.isMine()) {
                            return waitCellClickCore(locations.map(([x, y]) => getTableCell(x, y)));
                        }
                    }

                    function setTips(text) {
                        if (player.isOnline()) {
                            player.send(text => {
                                const tips = document.getElementById('dengjie-tips');

                                if (tips) {
                                    tips.innerHTML = text;
                                }
                            }, text);
                        } else if (player.isMine()) {
                            const tips = document.getElementById('dengjie-tips');

                            if (tips) {
                                tips.innerHTML = text;
                            }
                        }
                    }

                    async function waitNextStep() {
                        const px = gameData.x, py = gameData.y;
                        const nextCells = [];

                        for (const [_, x, y] of walkNearCells(px, py)) {
                            buildArrowRemote(x, y);
                            nextCells.push([x, y]);
                        }

                        setTips(`请选择下一步方向 (分数: ${gameData.score})`);

                        const now = new Date();
                        const index = await waitCellClick(nextCells);
                        gameData.time += new Date() - now;
                        gameData.steps++;
                        nextCells.forEach(item => {
                            clearArrowRemote(item);
                        });
                        return nextCells[index];
                    }

                    function finishStep(x, y) {
                        checkPosition(x, y);

                        const curScore = gameData.score;
                        const slot = gameData.getSlotFromPos(x, y);
                        const data = gameData.map[slot];
                        const nextScore = getCellScore(x, y);
                        let keepRed = false;
                        let win = '';

                        if (Array.isArray(data)) {
                            if (curScore <= Math.abs(nextScore)) {
                                return [false, 'character'];
                            }

                            win = NAMES[data[0]];
                        } else if (curScore <= -nextScore) {
                            return [false, 'zeroscore'];
                        } else if (nextScore < 0) {
                            keepRed = true;
                        }

                        gameData.score += +nextScore;

                        if (!keepRed) {
                            markWalked(x, y);
                        } else {
                            gameData.walkedReds.push(slot);
                        }

                        return [true, win];
                    }

                    async function movePlayer(x, y) {
                        const px = gameData.x;
                        const py = gameData.y;

                        gameData.x = x;
                        gameData.y = y;

                        function movePlayerCore(x, y, px, py, getTableCell) {
                            function asyncAnimate(element, keyframes, options) {
                                return new Promise(function (resolve, reject) {
                                    const animation = element.animate(keyframes, options);
                                    animation.onfinish = resolve;
                                });
                            }

                            const targetChess = getTableCell(px, py).querySelector(".button");
                            const targetCell = getTableCell(x, y);

                            (async () => {
                                await asyncAnimate(targetChess, [
                                    { transform: 'scale(1)' },
                                    { transform: 'scale(1.25)' },
                                ], {
                                    duration: 100,
                                    fill: 'forwards',
                                });
                                await game.$elementGoto(targetChess, targetCell, 'first', 300, 'ease-in-out');
                                await asyncAnimate(targetChess, [
                                    { transform: 'scale(1.25)' },
                                    { transform: 'scale(1)' },
                                ], {
                                    duration: 100,
                                    fill: 'forwards',
                                });
                            })();
                        }

                        if (player.isMine()) {
                            movePlayerCore(x, y, px, py, getTableCell);
                        } else if (player.isOnline()) {
                            player.send(movePlayerCore, x, y, px, py, getTableCell);
                        }

                        // 等待500ms后动画过去哦
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }

                    async function rollbackPlayer() {
                        const px = gameData.x;
                        const py = gameData.y;

                        function rollbackPlayerCore(x, y, px, py, getTableCell) {
                            function asyncAnimate(element, keyframes, options) {
                                return new Promise(function (resolve, reject) {
                                    const animation = element.animate(keyframes, options);
                                    animation.onfinish = resolve;
                                });
                            }

                            const targetChess = getTableCell(px, py).querySelector('.button');
                            const targetCell = getTableCell(x, y);

                            const promise = (async () => {
                                await asyncAnimate(targetChess, [
                                    { transform: 'scale(1)' },
                                    { transform: 'scale(0)' },
                                ], {
                                    duration: 100,
                                    fill: 'forwards',
                                });
                                await new Promise(resolve => setTimeout(resolve, 100));

                                const first = targetCell.firstChild;
                                if (first) {
                                    targetCell.insertBefore(targetChess, targetCell.firstChild);
                                } else {
                                    targetCell.appendChild(targetChess);
                                }

                                await asyncAnimate(targetChess, [
                                    { transform: 'scale(0)' },
                                    { transform: 'scale(1)' },
                                ], {
                                    duration: 100,
                                    fill: 'forwards',
                                });
                            })();
                        }

                        if (player.isMine()) {
                            rollbackPlayerCore(initialData.x, initialData.y, px, py, getTableCell);
                        } else if (player.isOnline()) {
                            player.send(rollbackPlayerCore, initialData.x, initialData.y, px, py, getTableCell);
                        }

                        // 等待300ms后动画过去哦
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }

                    const {
                        promise: gamePromise,
                        resolve: gameResolve,
                    } = Promise.withResolvers();

                    function onGameWin(name) {
                        setTips('本次登阶成功!');

                        // 清空走过的红色块
                        for (const slot of gameData.walkedReds) {
                            gameData.map[slot] = 0;
                        }
                        gameData.walkedReds.length = 0;

                        // 重新放置曹丕
                        const px = gameData.x;
                        const py = gameData.y;
                        const slot = gameData.getSlotFromPos(px, py);
                        gameData.map[slot] = [0, 0];

                        get.event().result = {
                            bool: true,
                            name: name,
                            nextData: gameData,
                            curData: gameData,
                        }

                        onGameOver();
                    }

                    function onGameFailed(reason) {
                        setTips('本次登阶失败...');

                        // 重新放置曹丕
                        const px = initialData.x;
                        const py = initialData.y;
                        const slot = initialData.getSlotFromPos(px, py);
                        initialData.map[slot] = [0, 0];

                        get.event().result = {
                            bool: false,
                            reason: reason,
                            nextData: initialData,
                            curData: gameData,
                        };

                        onGameOver();
                    }

                    function onGameOver() {
                        game.broadcastAll(function (id, timeout) {
                            get.idDialog(id)?.close();
                            if (_status.connectMode) {
                                lib.configOL.choose_timeout = timeout;
                            }
                        }, videoId, originalTimeout);

                        if (player.isMine()) {
                            game.stopCountChoose();
                            delete _status.imchoosing;
                            delete _status.noclearcountdown;
                        } else if (player.isOnline()) {
                            player.send(function () {
                                game.stopCountChoose();
                                delete _status.imchoosing;
                                delete _status.noclearcountdown;
                            });
                        }

                        player.hideTimer();
                        delete _status.noclearcountdown;
                        gameResolve();
                    }

                    const event = game.createEvent('dengjieGame', false);
                    event.set('noconfirm', true);
                    event.setContent(async function (event) {
                        event.switchToAuto = function () {
                            // 喜欢偷懒让AI帮你玩是吧喵，看AI怎么摆烂制裁你哦喵
                            // 孩子不行，AI也是有能力玩的
                            const startX = gameData.x;
                            const startY = gameData.y;

                            let pathFound = null;
                            let targetName = null;

                            // 深度优先搜索函数
                            function dfs(x, y, curScore, walkedReds, mapState, path) {
                                // 检查当前位置是否越界
                                if (x < 0 || x >= gameData.width || y < 0 || y >= gameData.height) return false;

                                const slot = x + y * gameData.width;
                                const cell = mapState[slot];

                                // 角色格子
                                if (Array.isArray(cell) && cell[0] !== 0) {
                                    pathFound = path.concat([[x, y]]);
                                    targetName = NAMES[cell[0]];
                                    return true;
                                }

                                // 计算当前格子分数
                                let scoreDelta = 0;
                                let newWalkedReds = walkedReds.slice();
                                let newMapState = mapState.slice();

                                if (typeof cell === 'number') {
                                    scoreDelta = cell;
                                    if (cell !== 0) {
                                        newMapState[slot] = 0;
                                        if (cell < 0) newWalkedReds.push(slot);
                                    }
                                }

                                const newScore = curScore + scoreDelta;
                                if (newScore < 0) return false; // 分数不够走负格

                                // 遍历方向，优先 +1，再 0，最后 -1
                                const dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];
                                dirs.sort(([dx1, dy1], [dx2, dy2]) => {
                                    const s1 = mapState[(x + dx1) + (y + dy1) * gameData.width];
                                    const s2 = mapState[(x + dx2) + (y + dy2) * gameData.width];
                                    const v = val => (typeof val === 'number' ? val : val[1]);
                                    return (v(s2) || 0) - (v(s1) || 0); // 大分数先走
                                });

                                for (const [dx, dy] of dirs) {
                                    const nx = x + dx;
                                    const ny = y + dy;

                                    // 防止无限循环，允许回头
                                    const key = nx + ',' + ny + ',' + newScore + ',' + newWalkedReds.join(',');
                                    if (!dfs.visited) dfs.visited = new Set();
                                    if (dfs.visited.has(key)) continue;
                                    dfs.visited.add(key);

                                    if (dfs(nx, ny, newScore, newWalkedReds, newMapState, path.concat([[x, y]]))) {
                                        return true;
                                    }
                                }

                                return false;
                            }

                            // 执行 DFS
                            dfs.visited = new Set();
                            const success = dfs(startX, startY, gameData.score, gameData.walkedReds.slice(), gameData.map.slice(), []);
                            if (!success) {
                                onGameFailed('switchauto');
                                return;
                            }

                            // 同步执行路径，更新 gameData
                            for (const [x, y] of pathFound) {
                                const slot = gameData.getSlotFromPos(x, y);
                                const cell = gameData.map[slot];

                                if (Array.isArray(cell) && cell[0] !== 0) {
                                    targetName = NAMES[cell[0]];
                                    gameData.map[slot] = 0;
                                } else if (typeof cell === 'number') {
                                    gameData.score += cell;
                                    if (cell !== 0) {
                                        gameData.map[slot] = 0;
                                        if (cell < 0) gameData.walkedReds.push(slot);
                                    }
                                }

                                gameData.x = x;
                                gameData.y = y;
                            }

                            event.result = {
                                bool: true,
                                name: targetName,
                                curData: gameData,
                                nextData: gameData,
                            };
                        };

                        // 游戏的主循环喵，主体逻辑都在这里喵
                        async function gameLoop() {
                            let win = '';
                            let failedReason;

                            gameData.initPlayer();
                            initialData.initPlayer();

                            try {
                                while (true) {
                                    const [x, y] = await waitNextStep();
                                    const [ok, reason] = finishStep(x, y);

                                    if (ok) {
                                        await movePlayer(x, y);

                                        if (reason) {
                                            win = reason; // 这里其实是武将名称喵
                                            break;
                                        }
                                    } else {
                                        await rollbackPlayer();
                                        failedReason = reason;
                                        break;
                                    }
                                }
                            } catch (e) {
                                if (typeof e === 'string') {
                                    failedReason = e;
                                } else {
                                    throw e;
                                }
                            }

                            if (win) {
                                onGameWin(win);
                            } else {
                                onGameFailed(failedReason);
                            }
                        }

                        if (isAI) {
                            event.switchToAuto();
                        } else {
                            gameLoop();
                        }

                        await gamePromise;
                    });

                    // 创建事件并弹出对话框喵
                    // 使用范例:
                    // const result = await startDengjieGame(player).forResult(); // 首次玩游戏不需要传游戏数据或传null
                    // if (result.bool) { // 如果本次登阶成功
                    //     if (result.name === "liuxie") { // 如果本次登阶的目标是刘协
                    //         // ...
                    //     } else {
                    //         // ...
                    //     }
                    // } else { // 如果本次登阶失败
                    //     // ...
                    // }
                    // const nextData = result.nextData; // 获取下一次登阶的游戏数据喵
                    // // ...
                    // const result2 = await startDengjieGame(player, nextData).forResult(); // 第二次玩必须传数据哦，不然就变成首次了喵
                    // // ...
                    return event;
                },
                init(player, skill) {
                    const effect = `${skill}_effect`;
                    const storage = player.getStorage(effect);
                    if (storage.length) {
                        player.storage[effect].sort((a, b) => lib.suit.indexOf(b) - lib.suit.indexOf(a));
                        player.addTip(effect, get.translation(effect) + player.getStorage(effect).reduce((str, suit) => str + get.translation(suit), ''));
                    }
                },
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    global: 'phaseBefore',
                    player: ['enterGame', 'damageEnd'],
                },
                filter(event, player) {
                    if (Array.from(get.info('mininiandengji').namesMap.keys()).remove('caopi').every(name => player.hasAllHistory('custom', evt => evt[`mininiandengji_${name}`]))) return false;
                    if (event.name == 'damage') return !player.hasMark('mininiandengji_used');
                    return event.name != 'phase' || game.phaseNumber == 0;
                },
                async content(event, trigger, player) {
                    if (trigger.name == 'damage') {
                        player.addTempSkill(event.name + '_used');
                        player.addMark(event.name + '_used', 1, false);
                    }
                    if (player.isUnderControl()) game.swapPlayerAuto(player);
                    const { startDengjieGame } = get.info(event.name);
                    let result;
                    if (_status.startDengjieGame?.[player.playerid]) result = await startDengjieGame(player, _status.startDengjieGame[player.playerid]).forResult();
                    else result = await startDengjieGame(player).forResult();
                    game.broadcastAll((result, player) => {
                        _status.startDengjieGame ??= {};
                        _status.startDengjieGame[player.playerid] = result?.nextData;
                    }, result, player);
                    if (result?.bool && result.name) {
                        player.getHistory('custom').push({ [`${event.name}_${result.name}`]: true });
                        player.markAuto(event.name, result.name);
                        const { characterEffectMap } = get.info(event.name);
                        if (characterEffectMap.has(result.name)) {
                            const effect = `${event.name}_effect`;
                            const suit = characterEffectMap.get(result.name)[1];
                            player.addSkill(effect);
                            player.markAuto(effect, suit);
                            get.info(event.name).init(player, event.name);
                            await player.addAdditionalSkills(event.name, characterEffectMap.get(result.name)[0]);
                        }
                        else if (result.name == 'liuxie') {
                            player.storage.mininianchengming = true;
                            await player.gainMaxHp();
                            await player.recover();
                        }
                    }
                },
                namesMap: new Map([
                    ['caopi', 'Mnian_caopi'],
                    ['liuxie', 'Mbaby_liuxie'],
                    ['caoang', 'Mbaby_caoang'],
                    ['caozhi', 'Mbaby_caozhi'],
                    ['caozhang', 'Mbaby_caozhang'],
                    ['caochong', 'Mbaby_caochong'],
                ]),
                characterEffectMap: new Map([
                    ['caoang', ['minikangkai', 'spade']],
                    ['caozhi', ['miniluoying', 'club']],
                    ['caozhang', ['minijiangchi', 'diamond']],
                    ['caochong', ['minichengxiang', 'heart']],
                ]),
                derivation: ['mininiandengji_faq', 'minikangkai', 'miniluoying', 'minijiangchi', 'minichengxiang'],
                subSkill: {
                    used: {
                        charlotte: true,
                        onremove: true,
                    },
                    effect: {
                        charlotte: true,
                        onremove(player, skill) {
                            player.removeTip(skill);
                        },
                        intro: { content: '已解锁花色：$' },
                    },
                },
                intro: {
                    markcount: 'expansion',
                    mark(dialog, storage = []) {
                        if (!storage.length) return '未曾“登阶”成功';
                        dialog.addText('已击败角色');
                        dialog.addSmall([storage.map(i => get.info('mininiandengji').namesMap.get(i)), 'character']);
                    },
                },
            },
            mininiandengji_faq: { nopop: true },
            mininianchengming: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { target: 'useCardToTargeted' },
                enable: 'phaseUse',
                filter(event, player) {
                    if (!player.hasCard(card => get.info('mininianchengming').filterCard(card, player), 'he')) return false;
                    return event.name == 'chooseToUse' || (event.card?.name === 'sha' && player.storage.mininianchengming);
                },
                filterCard(card, player) {
                    const suit = get.suit(card, player);
                    if (!player.getStorage('mininiandengji_effect').includes(suit)) return false;
                    if (ui.selected.cards.length && get.suit(ui.selected.cards[0], player) != suit) return false;
                    const cards = player.getCards('he', cardx => player.canRecast(cardx));
                    return cards.includes(card) && cards.filter(cardx => get.suit(cardx, player) == suit).length >= player.countMark('mininianchengming_used') + 1;
                },
                selectCard() {
                    const player = get.player();
                    return player.countMark('mininianchengming_used') + 1;
                },
                check(card) {
                    const player = get.player();
                    return 7 - get.value(card);
                },
                complexCard: true,
                discard: false,
                lose: false,
                delay: false,
                position: 'he',
                async cost(event, trigger, player) {
                    const info = get.info(event.skill);
                    const next = player.chooseCard(get.prompt2(event.skill));
                    for (const item of ['filterCard', 'selectCard', 'complexCard']) {
                        next.set(item, info[item]);
                    }
                    next.set('ai', card => {
                        const player = get.player();
                        return 7 - get.value(card);
                    });
                    event.result = await next.forResult();
                },
                async content(event, trigger, player) {
                    const { cards } = event;
                    player.addTempSkill(event.name + '_used');
                    player.addMark(event.name + '_used', 1, false);
                    await player.recast(cards);
                    const list = player.getStorage('mininiandengji_effect');
                    if (!list.length) return;
                    const result = list.length == 1 ? { bool: true, links: [['', '', `lukai_${list[0]}`]] } : await player.chooseButton(['选择一种花色，从牌堆或弃牌堆中获得一张此花色的牌', [list.map(i => ['', '', `lukai_${i}`]), 'vcard']], true).forResult();
                    if (result?.bool && result.links?.length) {
                        const suit = result.links[0][2].slice(6);
                        player.popup(suit);
                        game.log(player, '声明了', '#g' + get.translation(suit));
                        const card = get.cardPile(cardx => get.suit(cardx) == suit);
                        if (card) await player.gain(card, 'gain2');
                    }
                },
                ai: {
                    combo: 'mininiandengji',
                    order(item, player) {
                        const num = player.countMark('mininianchengming_used') + 1;
                        let cards = player.getCards('he', card => get.info('mininianchengming').filterCard(card, player));
                        cards = cards.filter(card => cards.filter(i => get.suit(card, player) == get.suit(i, player)).length >= num);
                        if (!cards.length) return 1;
                        return num < 4 ? 10 : 3;
                    },
                    result: { player: 1 },
                },
                subSkill: {
                    used: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '本回合已发动过#次〖承命〗' },
                    },
                },
            },
            mininianying_cp: {
                audio: 'mininianying_Mnian_caopi',
                trigger: {
                    player: 'gainAfter',
                    global: 'loseAsyncAfter',
                },
                filter(event, player, name, indexedData) {
                    if (!Object.keys(lib.skill).some(i => get.info(i)?.nianyingSkill && get.info(i).nianyingFilter(event, player, name, indexedData))) return false;
                    const evt = event.getParent('phaseDraw');
                    if (evt?.name == 'phaseDraw') return false;
                    return event.getg?.(player)?.length;
                },
                usable: 1,
                nianyingSkill: ['恣意而为', '选择一名其他角色和一种花色，随机获得其一张此花色的手牌'],
                nianyingFilter(event, player, name, indexedData) {
                    return game.hasPlayer(current => current != player && current.countCards('h'));
                },
                async cost(event, trigger, player) {
                    const skills = Object.keys(lib.skill).filter(i => get.info(i)?.nianyingSkill && get.info(i).nianyingFilter(trigger, player, event.triggername, event.indexedData)).map(i => [i, get.info(i).nianyingSkill[0], get.info(i).nianyingSkill[1]]);
                    const result = await player.chooseControl(skills.map(i => i[1]), 'cancel2')
                        .set('prompt', get.prompt('mininianying_zy')).set('prompt2', '选择一项念影效果执行')
                        .set('displayIndex', false)
                        .set('choiceList', skills.map(i => {
                            return '<div class="skill">' + i[1] + '</div><div>' + i[2] + '</div>';
                        })).set('ai', () => get.event().controls.randomGet()).forResult();
                    event.result = { bool: (result.control != 'cancel2'), cost_data: skills.find(i => i[1] == result.control) };
                },
                async content(event, trigger, player) {
                    const choice = event.cost_data;
                    player.popup(choice[1]);
                    game.log(player, '选择了', '#g' + choice[1]);
                    await lib.skill[choice[0]].nianyingContent(player);
                },
                async nianyingContent(player) {
                    if (!game.hasPlayer(current => current != player && current.countCards('h'))) return;
                    const result = await player.chooseButtonTarget({
                        createDialog: ['###恣意而为###<div class="text center">选择一名其他角色和一种花色，随机获得其一张此花色的手牌</div>', [lib.suit.map(i => ['', '', `lukai_${i}`]), 'vcard']],
                        forced: true,
                        complexSelect: true,
                        filterTarget(card, player, target) {
                            return target != player && target.countCards('h');
                        },
                        ai1(button) {
                            const player = get.player();
                            const link = button.link[2].slice(6);
                            if (player.getStorage('mininiandengji_effect').includes(link)) return 10;
                            if (link == 'diamond') return 0.9;
                            return Math.random();
                        },
                        ai2(target) {
                            const player = get.player(), att = get.attitude(player, target);
                            if (att > 0) return 0;
                            return -att * target.countCards('h');
                        },
                    }).forResult();
                    if (result?.bool && result.links?.length && result.targets?.length) {
                        const [target] = result.targets;
                        const suit = result.links[0][2].slice(6);
                        player.popup(suit);
                        game.log(player, '声明了', '#g' + get.translation(suit));
                        player.line(target);
                        const cards = target.getCards('h', card => {
                            return lib.filter.canBeGained(card, target, player) && get.suit(card, target) == suit;
                        });
                        if (cards.length) await player.gain(cards.randomGet(), target, 'giveAuto');
                    }
                },
            },
            mininiansongwei: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'judgeEnd' },
                filter(event, player) {
                    if (event.player == player || event.player.group != 'wei') return false;
                    return player.hasZhuSkill('mininiansongwei', event.player);
                },
                async cost(event, trigger, player) {
                    event.result = await trigger.player.chooseBool(`是否发动【颂威】，令${get.translation(player)}摸一张牌？`).set('choice', get.attitude(trigger.player, player) > 0).forResult();
                },
                zhuSkill: true,
                async content(event, trigger, player) {
                    trigger.player.line(player, 'green');
                    await player.draw();
                },
            },
            chengxiang_Mnian_caopi: { audio: 'ext:活动武将/audio/skill:true' },
            //战
            // 战黄忠
            minifightdingjun: {
                init(player) {
                    if (!ui._minifightdingjun) {
                        game.broadcastAll(() => {
                            if (!_status._minifightdingjun) _status._minifightdingjun = 0;
                            _status._minifightdingjun = Math.max(0, _status._minifightdingjun);
                            if (get.is.phoneLayout()) ui._minifightdingjun = ui.create.div('.touchinfo.left', ui.window);
                            else ui._minifightdingjun = ui.create.div(ui.gameinfo);
                            ui._minifightdingjun.innerHTML = '当前士气：' + _status._minifightdingjun;
                        });
                    }
                },
                audio: 'ext:活动武将/audio/skill:2',
                placeSkill: true,
                categories: () => ['战场技'],
                async updateShiQi(player = _status.event.player, num = 1) {
                    if (num) {
                        const next = game.createEvent('minifight_UpdateShiQi');
                        next.num = num;
                        next.player = player;
                        next.setContent(async function (event, trigger, player) {
                            const num = event.num;
                            game.broadcastAll(num => {
                                _status._minifightdingjun += num;
                                _status._minifightdingjun = Math.max(0, _status._minifightdingjun);
                                ui._minifightdingjun.innerHTML = '当前士气：' + _status._minifightdingjun;
                            }, num);
                            game.log('#y士气', '#g' + (num > 0 ? '增加了' : '下降了') + Math.abs(num) + '点');
                        });
                        await next;
                    }
                },
                trigger: { global: ['damageSource', 'minifight_UpdateShiQiAfter'] },
                filter(event, player) {
                    return (event.name !== 'damage' || (event.source?.isIn() && event.card?.name === 'sha')) && event.num > 0;
                },
                forced: true,
                content() {
                    if (trigger.name === 'damage') get.info(event.name).updateShiQi(player, trigger.num);
                    else player.draw(trigger.num);
                },
                video(player, info) {
                    if (info[0]) _status.tempBackground = info[1];
                    else delete _status.tempBackground;
                    game.updateBackground();
                },
                derivation: 'minifightreliegong',
                global: 'minifightdingjun_ai',
                group: ['minifightdingjun_change', 'minifightdingjun_effect'],
                subSkill: {
                    change: {
                        audio: 'minifightdingjun',
                        trigger: { global: ['minifight_UpdateShiQiEnd', 'phaseEnd'] },
                        filter(event, player) {
                            if (event.name === 'phase') return _status._minifightdingjun === 0 && ui._minifightdingjun_dingjunshan;
                            return !ui._minifightdingjun_dingjunshan && _status._minifightdingjun >= game.players.length + game.dead.length;
                        },
                        forced: true,
                        locked: false,
                        content() {
                            if (!ui._minifightdingjun_dingjunshan) {
                                player.$fullscreenpop('定军山战场', 'fire');
                                const background = 'ext:活动武将/image/background/battlefield_dingjun.jpg';
                                game.broadcastAll(bg => {
                                    if (get.is.phoneLayout()) ui._minifightdingjun_dingjunshan = ui.create.div('.touchinfo.left', ui.window);
                                    else ui._minifightdingjun_dingjunshan = ui.create.div(ui.gameinfo);
                                    ui._minifightdingjun_dingjunshan.innerHTML = '<br>定军山战场';
                                    _status.tempBackground = bg;
                                    game.updateBackground();
                                }, background);
                                game.addVideo('skill', player, ['minifightdingjun', [true, background]]);
                            }
                            else {
                                game.broadcastAll(() => {
                                    ui._minifightdingjun_dingjunshan.remove();
                                    delete ui._minifightdingjun_dingjunshan;
                                    delete _status.tempBackground;
                                    game.updateBackground();
                                });
                                game.addVideo('skill', player, ['minifightdingjun', [false]]);
                            }
                        },
                    },
                    effect: {
                        audio: 'minifightdingjun',
                        trigger: { global: 'useCard' },
                        filter(event, player) {
                            if (!ui._minifightdingjun_dingjunshan || event.player.hasSkill('minireliegong', null, null, false)) return false;
                            return _status._minifightdingjun >= 2 && event.card.name === 'sha';
                        },
                        prompt2(event, player) {
                            return '是否消耗2层士气，令' + get.translation(event.player) + '于' + get.translation(event.card) + '结算中视为拥有【烈弓】？';
                        },
                        check(event, player) {
                            return event.targets.reduce((sum, target) => sum + get.effect(target, event.card, event.player, player), 0) > 0;
                        },
                        logTarget: 'player',
                        async content(event, trigger, player) {
                            await get.info('minifightdingjun').updateShiQi(player, -2);
                            await trigger.player.addTempSkills('minifightreliegong');
                            trigger.player.when('useCardAfter').filter(evt => evt === trigger).then(() => player.removeSkills('minifightreliegong'));
                        },
                    },
                    ai: {
                        ai: {
                            directHit_ai: true,
                            skillTagFilter(player, tag, arg) {
                                const targets = game.filterPlayer(target => target.hasSkill('minifightdingjun'));
                                if (!targets.length || _status._minifightdingjun_aiCheck || !_status._minifightdingjun || _status._minifightdingjun < 2) return false;
                                if (!ui._minifightdingjun_dingjunshan || !arg?.card || !arg?.target || arg.card.name !== 'sha') return false;
                                const filter = card => !ui.selected.cards.includes(card) && !card.cards?.includes(card);
                                if (!(arg.target.getHp() >= player.getHp() || arg.target.countCards('h', filter) >= player.countCards('h', filter))) return false;
                                _status._minifightdingjun_aiCheck = true;
                                const bool = (() => {
                                    if (get.effect(arg.target, arg.card, player, player) <= 0) return false;
                                    if (get.damageEffect(arg.target, player, player) < 0 && targets.some(i => get.attitude(player, i) < 0)) return true;
                                    if (get.damageEffect(arg.target, player, player) > 0 && targets.some(i => get.attitude(player, i) > 0)) return true;
                                    return false;
                                })();
                                delete _status._minifightdingjun_aiCheck;
                                return bool;
                            },
                        },
                    },
                },
            },
            minifightliegong: {
                audio: 'liegong',
                trigger: { player: 'useCardToTargeted' },
                filter(event, player) {
                    if (event.card.name !== 'sha') return false;
                    return event.target.getHp() >= player.getHp() || event.target.countCards('h') >= player.countCards('h');
                },
                forced: true,
                logTarget: 'target',
                content() {
                    const goon1 = trigger.target.getHp() >= player.getHp(), goon2 = trigger.target.countCards('h') >= player.countCards('h');
                    trigger.getParent().directHit.push(trigger.target);
                    game.log(trigger.target, '不能响应', trigger.card);
                    if (goon1 && goon2) {
                        const id = trigger.target.playerid;
                        const map = trigger.getParent().customArgs;
                        if (!map[id]) map[id] = {};
                        if (typeof map[id].extraDamage !== 'number') map[id].extraDamage = 0;
                        map[id].extraDamage++;
                        game.log(trigger.card, '对', trigger.target, '造成的伤害', '#y+1');
                    }
                },
                ai: {
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (!arg?.card || !arg?.target || arg.card.name !== 'sha') return false;
                        const filter = card => !ui.selected.cards.includes(card) && !card.cards?.includes(card);
                        return arg.target.getHp() >= player.getHp() || arg.target.countCards('h', filter) >= player.countCards('h', filter);
                    },
                },
            },
            minifightreliegong: {
                inherit: 'xinliegong',
                mod: {
                    targetInRange(card, player, target) {
                        if (card.name == 'sha') return true;
                    },
                },
            },
            minifightlizhan: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                filter(event, player) {
                    if (player.hasSkill('minifightlizhan_blocker')) return false;
                    return player.hasSha('respond') && player.hasUseTarget(new lib.element.VCard({ name: 'sha' }));
                },
                async content(event, trigger, player) {
                    let num = 0;
                    while (player.hasSha('respond')) {
                        const result = await player.chooseToRespond('###力斩：请打出任意张【杀】###当前已经打出' + num + '张【杀】', (card, player) => {
                            return get.name(card) === 'sha';
                        }).set('ai', () => 1).forResult();
                        if (result?.bool) num++;
                        else break;
                    }
                    if (!num) {
                        player.addTempSkill('minifightlizhan_blocker', { player: ['useCard1', 'useSkillBegin', 'phaseUseEnd'] });
                        return event.finish();
                    }
                    player.addTempSkill('minifightlizhan_effect');
                    const sha = new lib.element.VCard({ name: 'sha', storage: { minifightlizhan: num } });
                    const next = player.chooseUseTarget(sha, true, '###力斩###<div class="text center">请选择【杀】的目标（需要' + num + '张【闪】响应，伤害基数为' + num + '）</div>');
                    await next;
                    if (player.hasHistory('sourceDamage', evt => evt.getParent('chooseUseTarget') === next)) {
                        const targets = game.filterPlayer(target => {
                            if (player.hasHistory('useCard', evt => evt.getParent() === next && evt.targets?.includes(target))) return false;
                            return get.inpileVCardList().some(info => {
                                if (['delay', 'equip'].includes(info[0])) return false;
                                const card = new lib.element.VCard({ name: info[2], nature: info[3] });
                                return get.tag(card, 'damage') && player.canUse(card, target, false);
                            });
                        });
                        if (targets.length) {
                            const result = await player.chooseTarget('力斩：是否再选择另一名角色？', '视为对其使用一张无距离和次数限制的伤害类卡牌', (card, player, target) => {
                                return get.event().targets.includes(target);
                            }).set('targets', targets).set('ai', target => {
                                const player = get.player();
                                return Math.max(...get.inpileVCardList().filter(info => {
                                    if (['delay', 'equip'].includes(info[0])) return false;
                                    const card = new lib.element.VCard({ name: info[2], nature: info[3] });
                                    return get.tag(card, 'damage') && player.canUse(card, target, false);
                                }).map(name => get.effect(target, new lib.element.VCard({ name: name[2], nature: name[3] }), player, player)));
                            }).set('animate', false).forResult();
                            if (result?.bool && result.targets?.length) {
                                const [target] = result.targets;
                                const { links } = await player.chooseButton([
                                    '###力斩###<div class="text center">视为' + get.translation(target) + '对使用一张无距离和次数限制的伤害类卡牌</div>',
                                    [get.inpileVCardList().filter(info => {
                                        if (['delay', 'equip'].includes(info[0])) return false;
                                        const card = new lib.element.VCard({ name: info[2], nature: info[3] });
                                        return get.tag(card, 'damage') && player.canUse(card, target, false);
                                    }), 'vcard'],
                                ], true).set('ai', button => {
                                    const { player, target } = get.event(), name = button.link;
                                    return get.effect(target, new lib.element.VCard({ name: name[2], nature: name[3] }), player, player);
                                }).set('target', target).forResult();
                                if (links?.length) await player.useCard(new lib.element.VCard({ name: links[0][2], nature: links[0][3] }), target, false);
                            }
                        }
                    }
                },
                ai: {
                    order(item, player) {
                        return get.order({ name: 'sha' }, player) + 0.5;
                    },
                    result: {
                        player(player) {
                            return player.hasValueTarget(new lib.element.VCard({ name: 'sha' })) ? 1 : 0;
                        },
                    },
                },
                subSkill: {
                    blocker: { charlotte: true },
                    effect: {
                        charlotte: true,
                        trigger: {
                            player: 'useCard1',
                            global: 'useCard',
                        },
                        filter(event, player, name) {
                            if (name === 'useCard1') {
                                return event.card.storage?.minifightlizhan && typeof event.card.storage.minifightlizhan === 'number';
                            }
                            return Array.isArray(event.respondTo) && event.respondTo[0] === player && event.respondTo[1].storage?.minifightlizhan && typeof event.respondTo[1].storage.minifightlizhan === 'number';
                        },
                        forced: true,
                        popup: false,
                        content() {
                            if (event.triggername === 'useCard1') {
                                trigger.baseDamage += (trigger.card.storage.minifightlizhan - 1);
                                for (const target of game.filterPlayer(null, null, true)) {
                                    const id = target.playerid, map = trigger.customArgs;
                                    if (!map[id]) map[id] = {};
                                    map[id].shanRequired = trigger.card.storage.minifightlizhan;
                                }
                            }
                            else {
                                trigger.getParent(2).baseDamage--;
                            }
                        },
                    },
                },
            },
            // 战张辽
            minifightbiaoxi: {
                audio: 'ext:活动武将/audio/skill:2',
                init(player, skill) {
                    game.addGlobalSkill(skill + '_record');
                },
                placeSkill: true,
                categories: () => ['战场技'],
                trigger: { global: ['loseAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'] },
                filter(event, player) {
                    if (ui._minifightbiaoxi_hefei) return false;
                    return event.minifightbiaoxi;
                },
                prompt2: '进入合淝战场？',
                async content(event, trigger, player) {
                    player.$fullscreenpop('合淝战场', 'fire');
                    const background = 'ext:活动武将/image/background/battlefield_hefei.jpg';
                    game.broadcastAll(bg => {
                        if (get.is.phoneLayout()) ui._minifightbiaoxi_hefei = ui.create.div('.touchinfo.left', ui.window);
                        else ui._minifightbiaoxi_hefei = ui.create.div(ui.gameinfo);
                        ui._minifightbiaoxi_hefei.innerHTML = '<br>合淝战场';
                        _status.tempBackground = bg;
                        game.updateBackground();
                    }, background);
                    game.addVideo('skill', player, [event.name, [true, background]]);
                },
                video(player, info) {
                    if (info[0]) _status.tempBackground = info[1];
                    else delete _status.tempBackground;
                    game.updateBackground();
                },
                derivation: 'new_retuxi',
                group: ['minifightbiaoxi_effect', 'minizhengbing_mark'],
                subSkill: {
                    effect: {
                        trigger: { global: 'useCardAfter' },
                        filter(event, player) {
                            if (!ui._minifightbiaoxi_hefei || event.card?.name != 'sha') return false;
                            return [player].concat(event.targets).some(current => game.hasPlayer(currentx => currentx != current && currentx.countGainableCards(current, 'h')));
                        },
                        async cost(event, trigger, player) {
                            event.result = await player.chooseTarget(get.prompt(event.skill), `令其中一名角色发动〖突袭〗`, (card, player, target) => {
                                return (player == target || get.event().getTrigger().targets.includes(target)) && game.hasPlayer(current => current != target && current.countGainableCards(target, 'h'));
                            }).set('ai', target => {
                                const player = get.player();
                                return get.attitude(player, target);
                            }).forResult();
                        },
                        async content(event, trigger, player) {
                            const { targets: [target] } = event;
                            const targets = game.filterPlayer(current => current != target && current.countGainableCards(target, 'h'));
                            if (!targets.length) return;
                            const result = await target.chooseTarget(`突袭：获得至多两名其他角色的手牌`, (card, player, target) => {
                                return get.event().targetsx.includes(target);
                            }, true, [1, 2]).set('ai', target => {
                                const player = get.player();
                                return get.effect(target, { name: 'guohe_copy2', position: 'h' }, player, player);
                            }).set('targetsx', targets).forResult();
                            if (result?.bool && result?.targets?.length) {
                                result.targets.sortBySeat();
                                await target.logSkill('new_retuxi', result.targets);
                                await target.gainMultiple(result.targets);
                                if (target.isMaxHandcard(true) && ui._minifightbiaoxi_hefei) game.broadcastAll(() => {
                                    ui._minifightbiaoxi_hefei.remove();
                                    delete ui._minifightbiaoxi_hefei;
                                    delete _status.tempBackground;
                                    game.updateBackground();
                                });
                                game.addVideo('skill', player, ['minifightbiaoxi', [false]]);
                            }
                        },
                    },
                    record: {
                        charlotte: true,
                        trigger: {
                            player: 'loseAfter',
                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                        },
                        filter(event, player) {
                            if (player.hasSkill('minifightbiaoxi_losed', null, null, false)) return false;
                            const evt = event.getParent('phaseUse', true);
                            if (!evt) return false;
                            if (evt.player != player) return false;
                            return event.getl?.(player)?.cards2?.some(card => get.type(card) == 'basic') && player.getHistory('lose', evt => evt.getParent('phaseUse', true)).reduce((num, evt) => num + evt.cards2.filter(card => get.type(card) == 'basic').length, 0) > 1;
                        },
                        forced: true,
                        popup: false,
                        silent: true,
                        firstDo: true,
                        async content(event, trigger, player) {
                            player.addTempSkill('minifightbiaoxi_losed', 'phaseUseAfter');
                            trigger.minifightbiaoxi = true;
                        },
                    },
                    losed: { charlotte: true },
                }
            },
            minifightpozhen: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: {
                    player: 'gainAfter',
                    global: 'loseAsyncAfter',
                },
                filter(event, player) {
                    const cards = event.getg?.(player);
                    if (!cards?.length) return false;
                    return game.hasPlayer(current => {
                        if (current == player) return false;
                        return event.getl?.(current)?.cards2.some(card => cards.includes(card));
                    }) && player.hasCard(lib.filter.cardRecastable, 'he');
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseCard(get.prompt2(event.skill), lib.filter.cardRecastable, [1, trigger.getg(player).length], 'he').set('ai', card => {
                        const player = get.player();
                        if (player.isPhaseUsing()) {
                            if (player.hasValueTarget({ name: 'sha' }) && get.name(card) != 'sha' && get.type(card) == 'basic') return 10;
                            return 7 - get.value(card);
                        }
                        if (player.countMark('minifightpozhen_draw') < 5 && get.type(card) != 'basic') return 10;
                        return 7 - get.value(card);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const { cards } = event;
                    await player.recast(cards);
                    if (cards.some(card => get.type(card) == 'basic')) {
                        player.addTempSkill(event.name + '_effect');
                        player.addMark(event.name + '_effect', 1, false);

                    }
                    if (cards.some(card => get.type(card) != 'basic') && player.countMark(event.name + '_draw') < 5) {
                        player.addSkill(event.name + '_draw');
                        player.addMark(event.name + '_draw', 1, false);
                    }
                },
                subSkill: {
                    effect: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '使用【杀】的次数上限+#' },
                        mod: {
                            cardUsable(card, player, num) {
                                if (card.name == 'sha') return num + player.countMark('minifightpozhen_effect');
                            },
                        },
                    },
                    draw: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '下个摸牌阶段摸牌数+#' },
                        trigger: { player: 'phaseDrawBegin2' },
                        filter(event, player) {
                            return !event.numFixed;
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            const num = player.countMark(event.name);
                            player.removeSkill(event.name);
                            trigger.num += num;
                        },
                    }
                }
            },
            // 战陆逊
            minifightxurui: {
                audio: 'ext:活动武将/audio/skill:2',
                placeSkill: true,
                categories: () => ['战场技'],
                trigger: { global: ['loseAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter', 'damageSource'] },
                filter(event, player) {
                    if (event.name == 'damage') {
                        if (!ui._minifightxurui_yiling) return false;
                        return event.hasNature('fire') && game.filterPlayer2(current => current.hasHistory('damage', evt => evt.hasNature('fire'))).flatMap(current => current.getHistory('damage', evt => evt.hasNature('fire'))).reduce((num, evt) => num + evt.num, 0) > 2;
                    }
                    return !ui._minifightxurui_yiling && game.hasPlayer(current => {
                        if (current.countCards('h')) return false;
                        return event.getl?.(current)?.hs?.length;
                    });
                },
                locked: false,
                forced: true,
                async content(event, trigger, player) {
                    if (ui._minifightxurui_yiling) {
                        game.broadcastAll(() => {
                            ui._minifightxurui_yiling.remove();
                            delete ui._minifightxurui_yiling;
                            delete _status.tempBackground;
                            game.updateBackground();
                        });
                        game.addVideo('skill', player, [event.name, [false]]);
                    }
                    else {
                        player.$fullscreenpop('夷陵战场', 'fire');
                        const background = 'ext:活动武将/image/background/battlefield_yiling.jpg';
                        game.broadcastAll(bg => {
                            if (get.is.phoneLayout()) ui._minifightxurui_yiling = ui.create.div('.touchinfo.left', ui.window);
                            else ui._minifightxurui_yiling = ui.create.div(ui.gameinfo);
                            ui._minifightxurui_yiling.innerHTML = '<br>夷陵战场';
                            _status.tempBackground = bg;
                            game.updateBackground();
                        }, background);
                        game.addVideo('skill', player, [event.name, [true, background]]);
                    }
                },
                video(player, info) {
                    if (info[0]) _status.tempBackground = info[1];
                    else delete _status.tempBackground;
                    game.updateBackground();
                },
                group: 'minifightxurui_effect',
                subSkill: {
                    effect: {
                        trigger: { global: 'useCardToPlayer' },
                        filter(event, player) {
                            if (!ui._minifightxurui_yiling || event.player !== _status.currentPhase || !player.isMinHandcard()) return false;
                            return event.targets?.length === 1 && event.targets[0] !== event.player;
                        },
                        async cost(event, trigger, player) {
                            const { targets: [target], card } = trigger;
                            const result = await player.chooseButton([
                                '蓄锐：你可以选择一项',
                                [
                                    [
                                        ['previous', `${get.translation(card)}结算结束后对${get.translation(target)}的上家（${get.translation(target.getPrevious())}）造成1点火焰伤害`],
                                        ['next', `${get.translation(card)}结算结束后对${get.translation(target)}的下家（${get.translation(target.getNext())}）造成1点火焰伤害`],
                                        ['damage', `${get.translation(card)}造成的伤害+1且改为火属性`],
                                    ],
                                    'textbutton',
                                ],
                            ]).set('ai', button => {
                                const { link } = button;
                                const { player, target } = get.event();
                                const next = target.getNext(), previous = target.getPrevious(), { currentPhase } = _status;
                                const { card } = get.event().getTrigger();
                                const att = get.attitude(player, target);
                                let eff1 = 0, eff2 = 0;
                                if (next?.isIn()) eff1 += get.damageEffect(next, player, player, 'fire');
                                if (previous?.isIn()) eff2 += get.damageEffect(previous, player, player, 'fire');
                                if (eff1 > 0 || eff2 > 0) {
                                    if (link == 'next' && eff1 > 0 && eff1 >= eff2) return 1;
                                    if (link == 'previous' && eff2 > 0 && eff2 >= eff1) return 1;
                                }
                                if (link == 'damage') return 1;
                                return 0;
                            }).set('target', target).forResult();
                            event.result = {
                                bool: result?.bool,
                                cost_data: result?.links,
                            }
                        },
                        async content(event, trigger, player) {
                            const { cost_data: [link] } = event;
                            const { targets: [target], card } = trigger;
                            if (link == 'damage') {
                                const evt = trigger.getParent();
                                if (typeof evt.baseDamage != 'number') evt.baseDamage = 1;
                                evt.baseDamage++;
                                target.addTempSkill('minifightxurui_damage');
                                target.markAuto('minifightxurui_damage', [card]);
                            }
                            else {
                                const target = trigger.targets[0][`get${link[0].toUpperCase()}${link.slice(1)}`]();
                                player.when({ global: 'useCardAfter' }).filter(evt => evt == trigger.getParent()).step(async () => {
                                    if (target?.isIn()) await target.damage('fire');
                                })
                            }
                            await player.draw(2);
                            if (!player.countCards('h') || !game.hasPlayer(current => player != current)) return;
                            const result = await player.chooseCardTarget({
                                prompt: get.prompt('minifightxurui'),
                                prompt2: '请选择要交给的牌并指定一名其他角色',
                                filterCard: true,
                                filterTarget: lib.filter.notMe,
                                ai1(card) {
                                    return 6 - get.value(card);
                                },
                                ai2(target) {
                                    const player = get.player();
                                    return get.attitude(player, target);
                                },
                            }).forResult();
                            if (result?.cards?.length && result.targets?.length) await player.give(result.cards, result.targets[0]);
                        },
                    },
                    damage: {
                        charlotte: true,
                        onremove: true,
                        trigger: { player: 'damageBegin3' },
                        filter(event, player) {
                            return event.card && player.getStorage('minifightxurui_damage').includes(event.card);
                        },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            player.unmarkAuto(event.name, [trigger.card]);
                            if (!player.getStorage(event.name).length) player.removeSkill(event.name);
                            game.setNature(trigger, 'fire');
                        },
                    }
                }
            },
            minifightshijie: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'roundStart' },
                filter(event, player) {
                    return !player.hasSkill('minifightshijie_gain') && player.countCards('h') && !player.countExpansions('minifightshijie');
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseCard(get.prompt2(event.skill), 'h', [1, Infinity], 'allowChooseAll').set('ai', card => {
                        const player = get.player();
                        if (player.countCards('h') < 5 && !ui._minifightxurui_yiling) return 1;
                        return 6 - get.value(card);
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const next = player.addToExpansion(event.cards, 'giveAuto', player);
                    next.gaintag.add(event.name + '_gain');
                    await next;
                    player.addTempSkill(event.name + '_gain', { player: 'die' });
                    player.storage[event.name + '_gain'] = player.countExpansions(event.name + '_gain');
                },
                subSkill: {
                    gain: {
                        charlotte: true,
                        onremove: true,
                        trigger: { global: 'phaseEnd' },
                        forced: true,
                        popup: false,
                        async content(event, trigger, player) {
                            player.storage[event.name]--;
                            let num = player.storage[event.name];
                            if (num == 0) {
                                const cards = player.getExpansions(event.name);
                                if (cards.length) {
                                    await player.gain(cards, 'draw');
                                    await player.draw(cards.length);
                                }
                                player.removeSkill(event.name);
                            }
                            else {
                                game.log(player, '剩余', '#g' + num + '回合');
                                player.markSkill(event.name);
                            }
                        },
                        intro: {
                            mark(dialog, storage, player) {
                                const cards = player.getExpansions('minifightshijie_gain');
                                if (typeof storage == 'number') dialog.addText(`剩余${storage}回合`);
                                if (player.isUnderControl(true)) dialog.addAuto(cards);
                                else return '共有' + get.cnNumber(cards.length) + '张牌';
                            },
                            content: 'expansion',
                            markcount: 'expansion',
                        },
                    }
                }
            },
            // 战典韦 
            _minifightchuanglie_mark: {
                charlotte: true,
                trigger: { target: 'useCardToPlayer' },
                firstDo: true,
                silent: true,
                content(event, trigger, player) {
                    const target = trigger.player;
                    player.addTempSkill('minifightchuanglie_mark');
                    player.storage.minifightchuanglie_mark ??= {};
                    if (typeof player.storage.minifightchuanglie_mark[target.playerid] != 'number') player.storage.minifightchuanglie_mark[target.playerid] = 0;
                    player.storage.minifightchuanglie_mark[target.playerid]++;
                }
            },
            minifightchuanglie: {
                audio: 'ext:活动武将/audio/skill:2',
                placeSkill: true,
                categories: () => ['战场技'],
                trigger: {
                    global: 'useCardToPlayer',
                    player: 'dying',
                },
                filter(event, player) {
                    if (event.name == 'useCardToPlayer') {
                        const storage = event.target.storage.minifightchuanglie_mark;
                        if (!storage) return false;
                        const { playerid } = event.player;
                        return storage[playerid] == 3 && !Object.keys(storage).some(id => storage[id] > 2 && id != playerid) && !ui._minifightchuanglie_wancheng;
                    }
                    return ui._minifightchuanglie_wancheng;
                },
                forced: true,
                locked: false,
                async content(event, trigger, player) {
                    if (trigger.name == 'useCardToPlayer') {
                        player.$fullscreenpop('宛城战场', 'fire');
                        const background = 'ext:活动武将/image/background/battlefield_wancheng.jpg';
                        game.broadcastAll(bg => {
                            ui._minifightchuanglie_wancheng?.remove();
                            delete ui._minifightchuanglie_wancheng;
                            if (get.is.phoneLayout()) ui._minifightchuanglie_wancheng = ui.create.div('.touchinfo.left', ui.window);
                            else ui._minifightchuanglie_wancheng = ui.create.div(ui.gameinfo);
                            ui._minifightchuanglie_wancheng.innerHTML = '<br>宛城战场';
                            _status.tempBackground = bg;
                            game.updateBackground();
                        }, background);
                        game.addVideo('skill', player, [event.name, [true, background]]);
                    }
                    else {
                        game.broadcastAll(() => {
                            ui._minifightchuanglie_wancheng?.remove();
                            delete ui._minifightchuanglie_wancheng;
                            delete _status.tempBackground;
                            game.updateBackground();
                        });
                        game.addVideo('skill', player, [event.name, [false]]);
                        await player.recover(2);
                    }
                },
                video(player, info) {
                    if (info[0]) _status.tempBackground = info[1];
                    else delete _status.tempBackground;
                    game.updateBackground();
                },
                group: 'minifightchuanglie_effect',
                subSkill: {
                    effect: {
                        audio: 'minifightchuanglie',
                        trigger: { global: ['useCardToTarget', 'useCardAfter'] },
                        filter(event, player) {
                            if (!ui._minifightchuanglie_wancheng || event.card?.name !== 'sha') return false;
                            if (event.name == 'useCard') {
                                if (game.hasPlayer2(current => current.hasHistory('damage', evt => evt.card == event.card))) return false;
                                return [event.player].addArray(event.targets).some(current => current.isIn());
                            }
                            return event.player != player && !event.targets.includes(player) && event.targets.length == 1;
                        },
                        async cost(event, trigger, player) {
                            if (trigger.name == 'useCard') {
                                event.result = await player.chooseTarget(get.prompt(event.skill), '选择一名角色对其发动〖强袭〗', (card, player, target) => {
                                    return get.event().targetsx?.includes(target);
                                }).set('ai', target => {
                                    const player = get.player();
                                    return get.damageEffect(target, player, player);
                                }).set('targetsx', [trigger.player].addArray(trigger.targets).filter(current => current.isIn())).forResult();
                            }
                            else {
                                const { target } = trigger;
                                event.result = await player.chooseBool(get.prompt(event.skill, target), `将${get.translation(trigger.card)}转移给自己`).set('choice', get.effect(target, trigger.card, trigger.player, player) < 0).forResult();
                                event.result.targets = [target];
                            }
                        },
                        async content(event, trigger, player) {
                            if (trigger.name == 'useCard') {
                                const [target] = event.targets;
                                await player.loseHp();
                                await player.draw();
                                player.addTempSkill('minifightchuanglie_damage');
                                await target.damage();
                            }
                            else {
                                const { target } = trigger;
                                const user = trigger.player;
                                player.line(target);
                                const evt = trigger.getParent();
                                evt.triggeredTargets2.remove(target);
                                evt.targets.remove(target);
                                // 神秘结算
                                const num = target.storage.minifightchuanglie_mark?.[user.playerid]
                                if (typeof num == 'number' && num > 0) target.storage.minifightchuanglie_mark[user.playerid]--;
                                evt.targets.push(player);
                                player.addTempSkill('minifightchuanglie_mark');
                                player.storage.minifightchuanglie_mark ??= {};
                                if (typeof player.storage.minifightchuanglie_mark[user.playerid] != 'number') player.storage.minifightchuanglie_mark[user.playerid] = 0;
                                player.storage.minifightchuanglie_mark[user.playerid]++;
                                await game.delayx();
                            }
                        },
                    },
                    damage: {
                        audio: 'qiangxi',
                        trigger: { source: 'damageBegin1' },
                        filter(event, player) {
                            return player.countCards('he', { type: 'equip' }) && event.getParent().name == 'minifightchuanglie_effect';
                        },
                        async cost(event, trigger, player) {
                            const target = trigger.player;
                            event.result = await player.chooseToDiscard('he', get.prompt(event.skill, target), '弃置一张装备牌令此伤害+1', card => {
                                return get.type(card) == 'equip';
                            }, 'chooseonly').set('goon', get.damageEffect(target, player, player) > 0).set('ai', card => {
                                return get.event().goon ? 12 - get.value(card) : 0;
                            }).forResult();
                        },
                        logTarget: 'player',
                        async content(event, trigger, player) {
                            await player.discard(event.cards);
                            trigger.num++;
                        },
                    },
                    mark: {
                        charlotte: true,
                        onremove: true,
                    }
                }
            },
            minifightkuangji: {
                audio: 'ext:活动武将/audio/skill:2',
                locked: false,
                mod: {
                    cardUsable(card, player) {
                        if (card?.storage?.minifightkuangji) return Infinity;
                    },
                },
                enable: 'chooseToUse',
                usable: 1,
                filter(event, player) {
                    if (['sha', 'shan'].every(name => !event.filterCard(get.autoViewAs({ name, storage: { minifightkuangji: true } }, 'unsure'), player, event))) return false;
                    return player.hasCard(card => get.subtypes(card).includes('equip1'), 'hes');
                },
                chooseButton: {
                    dialog(event, player) {
                        const list = ['sha', 'shan'].filter(name => event.filterCard(get.autoViewAs({ name, storage: { minifightkuangji: true } }, 'unsure'), player, event)).map(name => ['基本', '', name]);
                        const dialog = ui.create.dialog('狂戟', [list, 'vcard']);
                        dialog.direct = true;
                        return dialog;
                    },
                    check(button) {
                        const player = get.player();
                        return get.event().getParent().type == 'phase' ? player.getUseValue({ name: button.link[2] }) : 1;
                    },
                    backup(links, player) {
                        return {
                            audio: 'minifightkuangji',
                            filterCard(card, player) {
                                return get.subtypes(card).includes('equip1') && lib.filter.cardRespondable(card, player);
                            },
                            popname: true,
                            viewAs: {
                                name: links[0][2],
                                storage: { minifightkuangji: true },
                                suit: 'none',
                                number: null,
                                isCard: true,
                            },
                            position: 'hes',
                            ignoreMod: true,
                            ai1(card) {
                                return 12 - get.value(card);
                            },
                            log: false,
                            async precontent(event, trigger, player) {
                                await player.respond(event.result.cards, 'minifightkuangji', 'highlight');
                                event.getParent().addCount = false;
                                event.result.card = {
                                    name: event.result.card.name,
                                    storage: { minifightkuangji: true },
                                    suit: 'none',
                                    number: null,
                                    isCard: true,
                                };
                                let num = 1;
                                const info = get.info(event.result.cards[0], false);
                                if (typeof info.distance?.attackFrom == 'number') {
                                    num -= info.distance.attackFrom;
                                }
                                num = Math.ceil(num / 2);
                                if (num > 0) event.result._apply_args = { effectCount: num };
                                player.when('useCard').filter(evt => evt.skill == 'minifightkuangji_backup' && evt.card.name == 'shan' && evt.getParent() == event.getParent()).step(async () => {
                                    await player.draw(num);
                                });
                                event.result.cards = [];
                            },
                        };
                    },
                    prompt(links) {
                        return `将一张武器牌当做【${get.translation(links[0][2])}】使用`;
                    },
                },
                ai: {
                    respondSha: true,
                    respondShan: true,
                    skillTagFilter(player, tag, arg) {
                        if (arg == 'respond') return false;
                        if (!player.hasCard(card => get.subtypes(card).includes('equip1'), 'hes')) return false;
                    },
                    order: 6,
                    result: { player: 1 },
                },
                group: 'minifightkuangji_equip',
                subSkill: {
                    equip: {
                        audio: 'minifightkuangji',
                        trigger: {
                            global: 'phaseBefore',
                            player: 'enterGame',
                        },
                        filter(event, player) {
                            if (!player.countCards('h')) return false;
                            return event.name != 'phase' || game.phaseNumber == 0;
                        },
                        async cost(event, trigger, player) {
                            event.result = await player.chooseCard(get.prompt(event.skill), '将至多两张手牌替换为武器牌', [1, 2]).set('ai', card => {
                                return 6 - get.value(card);
                            }).forResult();
                        },
                        async content(event, trigger, player) {
                            const { cards } = event;
                            await player.lose(cards, ui.cardPile);
                            const gains = [];
                            while (gains.length < cards.length) {
                                const card = get.cardPile2(card => get.subtypes(card).includes('equip1') && !gains.includes(card));
                                if (card) gains.push(card);
                                else break;
                            }
                            if (gains.length) await player.gain(gains, 'draw');
                        },
                    }
                }
            },
            // 战马超
            minifightdangfeng: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { global: 'phaseEnd' },
                filter(event, player) {
                    return !game.hasPlayer2(current => current.hasHistory('damage')) || !game.hasPlayer2(current => current.hasHistory('useCard', evt => evt.card?.name == 'sha'));
                },
                forced: true,
                locked: false,
                async content(event, trigger, player) {
                    if (!game.hasPlayer2(current => current.hasHistory('damage'))) {
                        const card = get.cardPile(card => card.name == 'sha');
                        if (card) await player.gain(card, 'gain2');
                        else {
                            player.chat('断杀术…');
                            game.log('但是哪里都找不到没有符合条件的牌！');
                        }
                    }
                    if (!game.hasPlayer2(current => current.hasHistory('useCard', evt => evt.card?.name == 'sha'))) {
                        await player.chooseToUse('荡锋：你可以使用一张【杀】', function (card, player, event) {
                            if (get.name(card) != 'sha' && get.number(card) != 'unsure') {
                                return false;
                            }
                            return lib.filter.cardEnabled.apply(this, arguments);
                        }).set('addCount', false);
                    }
                },
            },
            minifighthaiji: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: 'useCardToPlayered' },
                filter(event, player) {
                    return event.card?.name == 'sha' && event.target.isIn();
                },
                forced: true,
                logTarget: 'target',
                check(event, player) {
                    return get.attitude(player, event.target) < 0;
                },
                async content(event, trigger, player) {
                    const { target, targets } = trigger;
                    player.addTempSkill(event.name + '_distance', 'roundStart');
                    player.addMark(event.name + '_distance', 1, false);
                    if (targets.every(current => get.distance(player, current) <= 1)) await player.draw();
                    if (game.filterPlayer(current => current != player).every(current => get.distance(player, current) <= 1)) {
                        target.addTempSkill('fengyin');
                        const result = await player.judge(card => {
                            if (get.color(card) == 'red') return 2;
                            return -1;
                        }).set('judge2', result => result.bool).forResult();
                        if (result?.bool) trigger.getParent().directHit.add(target);
                        else await player.draw(2);
                    }
                },
                ai: {
                    ignoreSkill: true,
                    directHit_ai: true,
                    skillTagFilter(player, tag, arg) {
                        if (!arg?.isLink || !arg?.card?.name != 'sha') {
                            return false;
                        }
                        if (tag == 'directHit_ai') {
                            return true;
                        }
                        if (game.filterPlayer(current => current != player).some(current => get.distance(player, current) > 1)) {
                            return false;
                        }
                        if (!arg.skill || !lib.skill[arg.skill] || lib.skill[arg.skill].charlotte || lib.skill[arg.skill].persevereSkill || get.is.locked(arg.skill) || !arg.target.getSkills(true, false).includes(arg.skill)) {
                            return false;
                        }
                    },
                },
                group: 'minifighthaiji_effect',
                subSkill: {
                    effect: {
                        audio: 'minifighthaiji',
                        trigger: { player: 'useCard2' },
                        filter(event, player) {
                            if (event.card?.name != 'sha') return false;
                            return game.hasPlayer(target => {
                                return !event.targets.includes(target) && lib.filter.targetEnabled2(event.card, player, target) && lib.filter.targetInRange(event.card, player, target);
                            }) && player.getHistory('useCard', evt => evt.card?.name == 'sha').indexOf(event) == 0;
                        },
                        locked: true,
                        async cost(event, trigger, player) {
                            event.result = await player.chooseTarget(get.prompt(event.skill), `为${get.translation(trigger.card)}额外指定一个目标`, (card, player, target) => {
                                const evt = _status.event.getTrigger();
                                return !evt.targets.includes(target) && lib.filter.targetEnabled2(evt.card, player, target) && lib.filter.targetInRange(evt.card, player, target);
                            }).set('ai', target => get.effect(target, get.event().getTrigger().card, get.player(), get.player())).forResult();
                        },
                        async content(event, trigger, player) {
                            trigger.targets.addArray(event.targets);
                        },
                    },
                    distance: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '本轮计算与其他角色的距离-#' },
                        mod: {
                            globalFrom(from, to, current) {
                                return current - from.countMark('minifighthaiji_distance');
                            },
                        },
                    },
                }
            },
            // 战姜维
            minifightyilve: {
                audio: 'ext:活动武将/audio/skill:2',
                enable: 'phaseUse',
                usable(skill, player) {
                    return 1 + player.countMark(skill + '_add');
                },
                chooseButton: {
                    dialog(event, player) {
                        const dialog = ui.create.dialog(
                            `毅略：请选择一项`,
                            [
                                [
                                    ['tiaoxin', `令一名角色对你选择的一名其他角色发动${get.poptip('minitiaoxin')}`],
                                    ['gain', '展示牌堆顶五张牌并选择至多等量名角色，这些角色依次获得其中一张牌'],
                                ],
                                'textbutton',
                            ],
                            'hidden'
                        );
                        return dialog;
                    },
                    filter(button, player) {
                        return button.link !== 'tiaoxin' || game.hasPlayer(current => {
                            return game.hasPlayer(currentx => currentx.countDiscardableCards(current, 'h') && currentx != player)
                        });
                    },
                    check(button) {
                        const player = get.player();
                        const { link } = button;
                        if (link == 'gain') return game.countPlayer(current => get.attitude(player, current) > 0) >= 2 ? 2.5 : 1.1;
                        if (link == 'tiaoxin' && game.hasPlayer(current => {
                            return game.hasPlayer(currentx => currentx.countDiscardableCards(current, 'h') && currentx != player && currentx != current && get.effect(currentx, { name: 'guohe_copy', position: 'h' }, current, current) > 0);
                        })) return 2;
                        return 1;
                    },
                    backup(links, player) {
                        const backup = get.copy(lib.skill['minifightyilve_' + links[0]]);
                        return backup;
                    },
                    prompt(links, player) {
                        return `###毅略###${links[0] == 'tiaoxin' ? `令一名角色对你选择的一名其他角色发动${get.poptip('minitiaoxin')}` : '展示牌堆顶五张牌并选择至多等量名角色，这些角色依次获得其中一张牌，若其因此获得了【杀】，其可以使用之'}。若有角色因此使用或弃置了【杀】，你失去1点体力。`;
                    },
                },
                ai: {
                    order(item, player) {
                        if (game.countPlayer(current => get.attitude(player, current) > 0) >= 2) {
                            return 10;
                        }
                        if (game.hasPlayer(current => {
                            return game.hasPlayer(currentx => currentx.countDiscardableCards(current, 'h') && currentx != player && currentx != current && get.effect(currentx, { name: 'guohe_copy', position: 'h' }, current, current) > 0);
                        })) {
                            return 10;
                        }
                        return 7;
                    },
                    result: { player: 1 },
                },
                derivation: 'minitiaoxin',
                subSkill: {
                    backup: {},
                    add: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: `本回合${get.poptip('minifightyilve')}发动次数+#` },
                    },
                    tiaoxin: {
                        audio: 'minifightyilve',
                        filterCard: () => false,
                        selectCard: -1,
                        selectTarget: 2,
                        filterTarget(card, player, target) {
                            if (!ui.selected.targets.length) return true;
                            return player != target && target.countDiscardableCards(ui.selected.targets[0], 'h');
                        },
                        multitarget: true,
                        targetprompt: ['挑衅者', '被挑衅者'],
                        async content(event, trigger, player) {
                            const [user, target] = event.targets;
                            game.broadcastAll(player => player.tempname?.add('Mfight_jiangwei'), user);
                            const next = user.useSkill('minitiaoxin', [target]);
                            await next;
                            game.broadcastAll(player => player.tempname?.remove('Mfight_jiangwei'), user);
                            if (game.getGlobalHistory('everything', evt => evt.getParent() == next && evt.minitiaoxin).length) await player.loseHp();
                        },
                        ai: {
                            result: {
                                target(player, target) {
                                    if (!ui.selected.targets.length) return 1;
                                    return get.effect(target, { name: 'guohe_copy', position: 'h' }, ui.selected.targets[0], target);
                                }
                            }
                        }
                    },
                    gain: {
                        audio: 'minifightyilve',
                        filterCard: () => false,
                        selectCard: -1,
                        prompt(event) {
                            return '###毅略###展示牌堆顶五张牌并选择至多等量名角色，这些角色依次获得其中一张牌，若其因此获得了【杀】，其可以使用之，然后将剩余牌放回牌堆顶。若有角色因此使用或弃置了【杀】，你失去1点体力。';
                        },
                        selectTarget: [1, 5],
                        filterTarget: true,
                        multitarget: true,
                        async content(event, trigger, player) {
                            const targets = event.targets.slice().sortBySeat();
                            const { cards } = await game.cardsGotoOrdering(get.cards(5));
                            await player.showCards(cards).setContent(() => { });
                            const dialog = ui.create.dialog(`###毅略###<div class='text center'>获得其中一张牌，若你因此获得了【杀】，你可以使用之</div>`, cards, true);
                            _status.dieClose.push(dialog);
                            dialog.videoId = lib.status.videoId++;
                            game.addVideo('cardDialog', null, ['毅略', get.cardsInfo(cards), dialog.videoId]);
                            game.broadcast((cards, id) => {
                                const dialog = ui.create.dialog(`###毅略###<div class='text center'>获得其中一张牌，若你因此获得了【杀】，你可以使用之</div>`, cards, true);
                                _status.dieClose.push(dialog);
                                dialog.videoId = id;
                            }, cards, dialog.videoId);
                            await game.delay();
                            let used = false;
                            while (targets.length && cards.length) {
                                const current = targets.shift();
                                let result;
                                if (cards.length == 1) {
                                    result = { bool: true, links: cards };
                                }
                                else {
                                    const next = current.chooseButton(true);
                                    next.set('ai', button => {
                                        const player = get.player();
                                        const { link } = button;
                                        if (player.hasSkill('minifightqizhi') && link.name == 'sha' && player.getUseValue(link) > 0) return 10;
                                        return get.value(link);
                                    });
                                    next.set('dialog', dialog.videoId);
                                    next.set('closeDialog', false);
                                    next.set('dialogdisplay', true);
                                    next.set('cardsx', cards.slice(0));
                                    next.set('filterButton', button => {
                                        return get.event().cardsx.includes(button.link);
                                    });
                                    result = await next.forResult();
                                }
                                if (!result?.bool || !result.links?.length) {
                                    continue;
                                }
                                const { links } = result;
                                cards.removeArray(links);
                                await current.gain(links, 'gain2');
                                const capt = get.translation(current) + '选择了' + get.translation(links);
                                game.broadcastAll((card, id, name, capt) => {
                                    const dialog = get.idDialog(id);
                                    if (dialog) {
                                        dialog.content.firstChild.innerHTML = capt;
                                        for (var i = 0; i < dialog.buttons.length; i++) {
                                            if (dialog.buttons[i].link == card) {
                                                game.createButtonCardsetion(name, dialog.buttons[i]);
                                                break;
                                            }
                                        }
                                        game.addVideo('dialogCapt', null, [dialog.videoId, dialog.content.firstChild.innerHTML]);
                                    }
                                }, links[0], dialog.videoId, current.getName(true), capt);
                                if (current.getCards('h').includes(links[0]) && get.name(links[0], current) == 'sha') {
                                    const result = await current.chooseToUse({
                                        filterCard(card) {
                                            if (get.name(card) != 'sha' || !get.event().cardsx?.includes(card)) return false;
                                            return lib.filter.filterCard.apply(this, arguments);
                                        },
                                        prompt: '毅略：是否使用其中一张牌？',
                                    }).set('cardsx', links).set('addCount', false).forResult();
                                    if (result?.bool) used = true;
                                }
                            }
                            game.broadcastAll('closeDialog', dialog.videoId);
                            game.broadcastAll(dialog => {
                                _status.dieClose.remove(dialog);
                            }, dialog);
                            if (cards.length) {
                                await game.cardsGotoPile(cards.reverse(), 'insert');
                            }
                            if (used) await player.loseHp();
                        },
                        ai: { result: { target: 1 } },
                    },
                }
            },
            minifightqizhi: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: ['changeHp', 'recoverEnd'] },
                filter(event, player) {
                    if (event.name == 'recover') return player.isPhaseUsing() && player.countMark('minifightqizhi_used') < 5 && player.countCards('he');
                    return event.num < 0 && player.isDamaged();
                },
                locked: true,
                async cost(event, trigger, player) {
                    if (trigger.name == 'recover') {
                        event.result = await player.chooseToDiscard('he', get.prompt(event.skill), `你可以弃置一张牌令${get.poptip('minifightyilve')}本回合发动次数+1`, 'chooseonly').set('ai', card => {
                            const player = get.player();
                            if (!player.hasSkill('minifightyilve')) return 0;
                            return 7 - get.value(card);
                        }).forResult();
                    }
                    else event.result = { bool: true };
                },
                async content(event, trigger, player) {
                    if (trigger.name == 'recover') {
                        await player.discard(event.cards);
                        player.addTempSkill(event.name + '_used', { player: ['phaseUseEnd', 'phaseChange'] });
                        player.addMark(event.name + '_used', 1, false);
                        player.addTempSkill('minifightyilve_add');
                        player.addMark('minifightyilve_add', 1, false);
                    }
                    else await player.draw(player.getDamagedHp());
                },
                subSkill: {
                    used: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: `本阶段${get.poptip('minifightqizhi')}已发动次数：#` },
                    }
                }
            },
            // 隐系列
            // 徐庶
            miniyinyinxing: {
                mod: {
                    cardEnabled(card, player) {
                        const evt = get.event();
                        if (evt.name !== 'chooseToUse') return;
                        const color = get.color(card);
                        if (color == 'unsure' || evt.skill) return true;
                        return !card.cards?.length;
                    },
                    cardRespondable(card, player) {
                        const evt = get.event();
                        if (evt.name !== 'chooseToRespond') return;
                        const color = get.color(card);
                        if (color == 'unsure' || evt.skill) return true;
                        return !card.cards?.length;
                    },
                    cardSavable(card, player) {
                        return lib.skill.miniyinyinxing.mod.cardEnabled.apply(this, arguments);
                    },
                    cardRecastable: (card, player, source) => false,
                    cardGiftable: (card, player, target) => false,
                },
                getType(cards, player) {
                    const nums = cards.map(card => {
                        const num = get.number(card, player);
                        if (num <= 2) return num + 13;
                        return num;
                    }).sort((a, b) => a - b);
                    const len = nums.length;
                    if (len == 2) {
                        return nums[1] == nums[0] ? '对子' : null;
                    }
                    const map = {};
                    nums.forEach(num => {
                        if (typeof map[num] != 'number') map[num] = 0;
                        map[num]++;
                    });
                    if (len == 3) {
                        if (Object.keys(map).length == 1) {
                            return '三条';
                        }
                        if (Object.keys(map).length == 3) {
                            // 234和A23
                            if ([[15, 3, 4], [14, 15, 3]].some(list => list.every(num => nums.includes(num)))) {
                                return '三顺';
                            }
                            if (nums.includes(15)) {
                                return null;
                            }
                            for (let i = 0; i < 2; i++) {
                                if (nums[i + 1] - nums[i] != 1) {
                                    return null;
                                }
                                // if (nums[i + 1] == 15) {
                                //     return null;
                                // }
                            }
                            return '三顺';
                        }
                        return null;
                    }
                    if (len > 3) {
                        if (Object.keys(map).length == 1) {
                            return '炸弹';
                        }
                        return null;
                    }
                    return null;
                },
                getList(event, player) {
                    return get.inpileVCardList(info => {
                        if (!['basic', 'trick'].includes(info[0])) return false;
                        if (!event.filterCard(get.autoViewAs({ name: info[2], nature: info[3] }, 'unsure'), player, event)) return false;
                        return info[0] == 'basic' || !player.getStorage('miniyinyinxing_used').includes(info[2]);
                    });
                },
                audio: 'ext:活动武将/audio/skill:2',
                hiddenCard(player, name) {
                    return lib.inpile.includes(name) && (get.type(name) == 'basic' || ((get.type(name) == 'trick' && !player.getStorage('miniyinyinxing_used').includes(name))));
                },
                onChooseToUse(event) {
                    if (!game.online && !event.miniyinyinxing) {
                        event.set('miniyinyinxingList', get.info('miniyinyinxing').getList(event, event.player));
                    }
                },
                onChooseToRespond(event) {
                    if (!game.online && !event.miniyinyinxing) {
                        event.set('miniyinyinxingList', get.info('miniyinyinxing').getList(event, event.player));
                    }
                },
                enable: ['chooseToUse', 'chooseToRespond'],
                filter(event, player) {
                    if (event.miniyinyinxing) return false;
                    if (event.type === 'phase') return true;
                    return event.miniyinyinxingList?.length;
                },
                filterCard: true,
                selectCard: [2, Infinity],
                filterOk() {
                    const event = get.event(), player = event.player, cards = ui.selected.cards;
                    const type = get.info('miniyinyinxing').getType(cards, get.player());
                    if (typeof type !== 'string' || !['三条', '炸弹', '对子', '三顺'].includes(type)) return false;
                    if (['三条', '炸弹'].includes(type)) {
                        if (event.type !== 'phase') return false;
                        return !cards.some(card => get.position(card) == 's' || !lib.filter.cardDiscardable(card, player, 'miniyinyinxing'));
                    }
                    return event.miniyinyinxingList?.some(info => {
                        if (info[0] !== { '对子': 'basic', '三顺': 'trick' }[type]) return false;
                        return event.filterCard(get.autoViewAs({ name: info[2], nature: info[3] }, cards), player, event);
                    });
                },
                position: 'hs',
                discard: false,
                lose: false,
                delay: false,
                check(card) {
                    const player = get.player(), event = get.event(), cards = player.getCards('hs');
                    const map = { '炸弹': [], '三条': [], '对子': [], '三顺': [] };
                    const combinations = function (cards, num) {
                        let result = [];
                        const helper = function (start, combo) {
                            if (combo.length === num) {
                                result.push(combo.slice());
                                return;
                            }
                            for (let i = start; i < cards.length; i++) {
                                combo.push(cards[i]);
                                helper(i + 1, combo);
                                combo.pop();
                            }
                        }
                        helper(0, []);
                        return result;
                    };
                    if (cards.length >= 2) {
                        const pairs = combinations(cards, 2);
                        for (const list of pairs) {
                            const type = lib.skill.miniyinyinxing.getType(list, player);
                            if (type === '对子') map['对子'].push(list);
                        }
                    }
                    if (cards.length >= 3) {
                        const triples = combinations(cards, 3);
                        for (const list of triples) {
                            const type = lib.skill.miniyinyinxing.getType(list, player);
                            if (event.type === 'phase' && type === '三条') map['三条'].push(list);
                            if (type === '三顺') map['三顺'].push(list);
                        }
                    }
                    if (event.type === 'phase' && cards.length >= 4) {
                        const quads = combinations(cards, 4);
                        for (const list of quads) {
                            const type = lib.skill.miniyinyinxing.getType(list, player);
                            if (type === '炸弹') map['炸弹'].push(list);
                        }
                    }
                    let map2 = new Map([]);
                    for (const item in map) {
                        for (const list of map[item]) {
                            if (item === '炸弹' || item === '三条') {
                                if (list.some(cardx => get.position(cardx) == 's' || !lib.filter.cardDiscardable(cardx, player, 'miniyinyinxing'))) continue;
                                if (item === '炸弹') map2.set(list, 9.1 * game.countPlayer(target => target === player ? 0 : get.damageEffect(target, player, player)));
                                else {
                                    const cards2 = [...Array.from(ui.cardPile.childNodes), ...Array.from(ui.discardPile.childNodes)].filter(card => {
                                        const type = get.type(card);
                                        if (type === 'equip') return game.hasPlayer(target => target.canEquip(card));
                                        if (type === 'delay') return game.hasPlayer(target => target.canAddJudge(card));
                                        return false;
                                    });
                                    map2.set(list, (() => {
                                        if (!cards2.length) return 0;
                                        return Math.max(...cards2.map(cardx => {
                                            const type = get.type(cardx);
                                            return game.filterPlayer(target => {
                                                return type === 'equip' ? target.canEquip(cardx) : target.canAddJudge(cardx);
                                            }).map(target => get.effect(target, cardx, player, player));
                                        }).flat());
                                    })());
                                }
                            }
                            else {
                                if (event.name !== 'chooseToUse' || event.type !== 'phase') map2.set(list, 1 + Math.random());
                                else {
                                    const vcards = event.miniyinyinxingList.filter(info => {
                                        if (info[0] !== { '对子': 'basic', '三顺': 'trick' }[item]) return false;
                                        return event.filterCard(get.autoViewAs({ name: info[2], nature: info[3] }, list), player, event);
                                    });
                                    map2.set(list, (() => {
                                        if (!vcards.length) return 0;
                                        return Math.max(...vcards.map(info => {
                                            return player.getUseValue(get.autoViewAs({ name: info[2], nature: info[3] }, list), true, true);
                                        }));
                                    })());
                                }
                            }
                        }
                    }
                    let selected = [], score = 0;
                    for (const [list, num] of Array.from(map2.entries())) {
                        if (num > score) {
                            score = num;
                            selected = list;
                        }
                    }
                    return (score > 0 && selected.includes(card)) ? 1 : -1;
                },
                async content(event, trigger, player) {
                    const evt = event.getParent(2);
                    const { cards } = event;
                    const type = get.info('miniyinyinxing').getType(cards, player);
                    switch (type) {
                        case '对子': {
                            evt.set('miniyinyinxing', true);
                            player.popup(type);
                            const list = get.inpileVCardList(info => {
                                if (!['basic'].includes(info[0])) return false;
                                return evt.filterCard({ name: info[2], nature: info[3] }, evt.player, evt)
                            });
                            if (list.length) {
                                const result = list.length == 1 ? { bool: true, links: [list[0]] } : await player.chooseButton([`隐姓：请选择要${evt.name == 'chooseToUse' ? '使用' : '打出'}的基本牌`, [list, 'vcard']], true).forResult();
                                if (result?.links?.length) {
                                    const { links } = result;
                                    if (evt.name == 'chooseToUse') {
                                        game.broadcastAll(
                                            (cards, links) => {
                                                lib.skill.miniyinyinxing_backup.links = cards;
                                                lib.skill.miniyinyinxing_backup.viewAs = { name: links[0][2], nature: links[0][3] };
                                                lib.skill.miniyinyinxing_backup.filterCard = (card, player) => {
                                                    return lib.skill.miniyinyinxing_backup.links.includes(card);
                                                };
                                            },
                                            cards,
                                            links
                                        );
                                        evt.set('_backupevent', 'miniyinyinxing_backup');
                                        evt.set('openskilldialog', `请选择${get.translation(links[0][3])}【${get.translation(links[0][2])}】的目标`);
                                        evt.backup('miniyinyinxing_backup');
                                    } else {
                                        delete evt.result.used;
                                        delete evt.result.skill;
                                        evt.result.card = get.autoViewAs({ name: links[0][2], nature: links[0][3] });
                                        evt.result.cards = cards;
                                        evt.redo();
                                        return;
                                    }
                                    evt.goto(0);
                                }
                            }
                        }
                            break;
                        case '三顺': {
                            evt.set('miniyinyinxing', true);
                            player.popup(type);
                            let key;
                            switch (evt.name) {
                                case '_wuxie':
                                    key = 'wuxieresult2';
                                    break;
                                default:
                                    key = 'result';
                            }
                            const list = get.inpileVCardList(info => {
                                if (!['trick'].includes(info[0])) return false;
                                if (player.getStorage('miniyinyinxing_used').includes(info[2])) return false;
                                return evt.name == '_wuxie' ? info[2] == 'wuxie' : evt.filterCard({ name: info[2], nature: info[3] }, evt.player, evt);
                            });
                            if (list.length) {
                                const result = list.length == 1 ? { bool: true, links: [list[0]] } : await player.chooseButton([`隐姓：请选择要${evt.name == 'chooseToUse' ? '使用' : '打出'}的锦囊牌`, [list, 'vcard']], true).forResult();
                                if (result?.links?.length) {
                                    const { links } = result;
                                    if (evt.name == 'chooseToUse') {
                                        game.broadcastAll(
                                            (cards, links) => {
                                                lib.skill.miniyinyinxing_backup.links = cards;
                                                lib.skill.miniyinyinxing_backup.viewAs = { name: links[0][2], nature: links[0][3] };
                                                lib.skill.miniyinyinxing_backup.filterCard = (card, player) => {
                                                    return lib.skill.miniyinyinxing_backup.links.includes(card);
                                                };
                                            },
                                            cards,
                                            links
                                        );
                                        evt.set('_backupevent', 'miniyinyinxing_backup');
                                        evt.set('openskilldialog', `请选择${get.translation(links[0][3])}【${get.translation(links[0][2])}】的目标`);
                                        evt.backup('miniyinyinxing_backup');
                                    } else {
                                        player.addTempSkill('miniyinyinxing_used');
                                        player.markAuto('miniyinyinxing_used', [links[0][2]]);
                                        delete evt[key].used;
                                        delete evt[key].skill;
                                        evt[key].card = get.autoViewAs({ name: links[0][2], nature: links[0][3] });
                                        evt[key].cards = cards;
                                        evt.redo();
                                        return;
                                    }
                                    evt.goto(0);
                                }
                            }
                        }
                            break;
                        case '三条': {
                            player.popup(type);
                            await player.discard(cards);
                            let num = cards.map(card => get.suit(card)).toUniqued().length == 1 ? 2 : 1;
                            while (num--) {
                                const targets = game.filterPlayer(current => {
                                    return Array.from({ length: 5 }).map((_, index) => index + 1).some(i => current.hasEnabledSlot(i)) || !current.isDisabledJudge();
                                });
                                if (!targets.length) return;
                                const list = Array.from({ length: 5 }).map((_, i) => [i + 1, get.translation(`equip${i + 1}`)]).concat([['judge', '判定区']]);
                                const result = await player.chooseButtonTarget({
                                    createDialog: [
                                        '隐姓：请选择你要置入牌的角色和区域',
                                        [list, 'tdnodes'],
                                    ],
                                    forced: true,
                                    filterTarget(card, player, target) {
                                        const { link } = ui.selected.buttons[0];
                                        if (link == 'judge') return !target.isDisabledJudge();
                                        return target.hasEnabledSlot(link);
                                    },
                                    ai1(button) {
                                        const player = get.player();
                                        const { link } = button;
                                        if (link == 'judge') return game.hasPlayer(current => !current.isDisabledJudge() && get.attitude(player, target) < 0);
                                        return game.hasPlayer(current => current.hasEnabledSlot(link) && get.attitude(player, target) > 0);
                                    },
                                    ai2(target) {
                                        const player = get.player(), att = get.attitude(player, target);
                                        const { link } = ui.selected.buttons[0];
                                        if (link == 'judge') return -att;
                                        return att;
                                    },
                                }).forResult();
                                if (result?.targets?.length && result.links?.length) {
                                    const [target] = result.targets;
                                    const [link] = result.links;
                                    const bool = typeof link == 'number';
                                    player.line(target);
                                    const card = get.cardPile(cardx => {
                                        if (bool) return get.subtype(cardx, false) == `equip${link}` && target.canEquip(cardx, true);
                                        return get.type(cardx, false) == 'delay' && target.canAddJudge(cardx);
                                    });
                                    if (card) {
                                        target.$gain2(card);
                                        await game.delayx();
                                        await target[bool ? 'equip' : 'addJudge'](card);
                                    }
                                }
                            }
                        }
                            break;
                        case '炸弹': {
                            player.popup(type);
                            await player.discard(cards);
                            let num = cards.map(card => get.suit(card)).toUniqued().length == 1 ? 2 : 1;
                            while (num--) {
                                for (const target of game.filterPlayer(current => current != player).sortBySeat()) {
                                    player.line(target, 'fire');
                                    await target.damage(cards.length - 3);
                                }
                            }
                        }
                            break;
                    }
                },
                ai: {
                    sortCardByNum: true,
                    respondSha: true,
                    respondShan: true,
                    save: true,
                    order(item, player) {
                        if (_status.event.type === 'phase') return 9.1;
                        return 4;
                    },
                    result: {
                        player(player) {
                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                            return 1;
                        },
                    },
                },
                init(player, skill) {
                    player.addSkill(`${skill}_plugin`);
                },
                onremove(player, skill) {
                    player.removeSkill(`${skill}_plugin`);
                },
                group: ['miniyinyinxing_draw'],
                subSkill: {
                    draw: {
                        audio: 'miniyinyinxing',
                        trigger: {
                            player: 'loseAfter',
                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                        },
                        filter(event, player) {
                            return event.getl(player)?.hs?.length && player.countCards('h') < 5;
                        },
                        forced: true,
                        async content(event, trigger, player) {
                            await player.drawTo(5);
                        },
                    },
                    backup: {
                        selectCard: -1,
                        popname: true,
                        log: false,
                        ignoreMod: true,
                        async precontent(event, trigger, player) {
                            event.result._apply_args = { addSkillCount: false };
                            if (get.type(event.result.card.name) == 'trick') {
                                player.addTempSkill('miniyinyinxing_used');
                                player.markAuto('miniyinyinxing_used', [event.result.card.name]);
                            }
                            if (event.result.cards.map(card => get.suit(card)).toUniqued().length == 1) {
                                event.result._apply_args = { effectCount: 2 };
                            }
                        },
                    },
                    used: {
                        charlotte: true,
                        onremove: true,
                        intro: { content: '本回合已使用过：$' },
                    },
                    use: {
                        audio: 'miniyinyinxing',
                        filterCard: true,
                        selectCard: [2, Infinity],
                        filterOk() {
                            const type = get.info('miniyinyinxing').getType(ui.selected.cards, get.player());
                            if (typeof type != 'string') return false;
                            if (get.type(get.info('miniyinyinxing_backup').viewAs.name) == 'basic') return type == '对子';
                            return type == '三顺';
                        },
                        position: 'hs',
                        popname: true,
                        log: false,
                        ai1(card) {
                            const player = get.player();
                            return 8 - get.value(card);
                        },
                        async precontent(event, trigger, player) {
                            if (get.type(event.result.card.name) == 'trick') {
                                player.addTempSkill('miniyinyinxing_used');
                                player.markAuto('miniyinyinxing_used', [event.result.card.name]);
                            }
                            if (event.result.cards.map(card => get.suit(card)).toUniqued().length == 1) {
                                event.result._apply_args = { effectCount: 2 };
                            }
                        },
                    },
                    plugin: {
                        charlotte: true,
                        trigger: { player: 'drawBefore' },
                        silent: true,
                        firstDo: true,
                        async content(event, trigger, player) {
                            trigger.setContent(lib.skill[event.name].draw);
                        },
                        draw() {
                            if (typeof event.minnum === 'number' && num < event.minnum) num = event.minnum;
                            if (event.drawDeck) {
                                if (event.drawDeck > num) event.drawDeck = num;
                                num -= event.drawDeck;
                            }
                            let logList;
                            if (event.log != false) {
                                logList = [player];
                                if (num > 0) logList.add(`${event.bottom ? '从牌堆底' : ''}摸了${get.cnNumber(num)}张牌`);
                                if (event.drawDeck) logList.add(`从牌库中获得了${get.cnNumber(event.drawDeck)}张牌`);
                            }
                            let cards = [];
                            if (num > 0) {
                                if (event.otherGetCards) cards.addArray(event.otherGetCards(num));//从专属牌堆摸牌，没有再看其他的
                                else if (event.bottom) cards.addArray(get.bottomCards(num, true));
                                else if (player.getTopCards) {
                                    let add = [];
                                    if (player.storage.doudizhu_cardPile?.length) {
                                        add = player.storage.doudizhu_cardPile.randomRemove(num);
                                        player[player.storage.doudizhu_cardPile.length > 0 ? 'markSkill' : 'unmarkSkill']('doudizhu_cardPile');
                                    }
                                    if (add.length < num) add.addArray(get.cards(num - add.length, true));
                                    else game.updateRoundNumber();
                                    cards.addArray(add);
                                }
                                else cards.addArray(get.cards(num, true));
                            }
                            else cards = [];
                            if (cards.length > 0) {
                                /*
                                let cards3 = cards.filter(card => (card._knowers ?? []).length > 0 || player.storage.doudizhu_cardPile?.includes(card));
                                let cards2 = lib.skill['miniyinyinxing_plugin'].getBestCards([...player.getCards('hs'), ...cards3], cards.length - cards3.length, player);
                                if (cards2.length > 0) {
                                    let cards4 = [];
                                    for (let i = 0; i < cards.length; i++) {
                                        cards4.push((cards[i]._knowers ?? []).length > 0 ? cards[i] : cards2.shift());
                                    }
                                    cards = cards4;
                                }
                                */
                                let replaceFlags = cards.map(card => !((card._knowers ?? []).length > 0 || player.storage.doudizhu_cardPile?.includes(card)));
                                let need = replaceFlags.filter(Boolean).length;
                                let cards2 = lib.skill['miniyinyinxing_plugin'].getBestCards([...player.getCards('hs'), ...cards.filter((_, i) => !replaceFlags[i])], need, player);
                                if (cards2.length >= need) {
                                    let idx = 0;
                                    cards = cards.map((card, i) => replaceFlags[i] ? cards2[idx++] : card);
                                }
                            }
                            if (event.drawDeck) cards = cards.concat(player.getDeckCards(event.drawDeck));
                            if (get.itemtype(cards) === 'cards') {
                                let next;
                                if (event.animate != false) {
                                    if (event.visible) {
                                        next = player.gain(cards, 'gain2').set('log', false);
                                        logList.addArray(['（', cards, '）']);
                                    }
                                    else next = player.gain(cards, 'draw');
                                }
                                else {
                                    next = player.gain(cards);
                                    if (event.$draw) player.$draw(cards.length);
                                }
                                if (logList?.length) game.log(...logList);
                                next.gaintag.addArray(event.gaintag);
                            }
                            event.result = cards;
                        },
                        getBestCards(cards, num, player) {
                            const getNum = card => {
                                let number = get.number(card, player);
                                return number <= 2 ? number + 13 : number;
                            };
                            const haveMap = {}, pileMap = {};
                            cards.forEach(card => {
                                const number = getNum(card);
                                haveMap[number] ??= 0;
                                haveMap[number]++;
                            });
                            const pile = Array.from(ui.cardPile.childNodes).filter(card => !(card._knowers ?? []).length);
                            pile.forEach(card => {
                                const number = getNum(card);
                                pileMap[number] ??= [];
                                pileMap[number].push(card);
                            });
                            const buildCandidates = function (type) {
                                const result = [];
                                if (type === '炸弹') {
                                    for (const n in pileMap) {
                                        const have = haveMap[n] || 0;
                                        const need = 4 - have;
                                        if (need <= 0) continue;//炸弹需要处理手里已有完整炸弹，否则search+hasTypeSubset会引发指数爆炸导致卡死
                                        if (need <= num && pileMap[n].length >= need) result.push(...pileMap[n].slice(0, need));
                                    }
                                    return result;
                                }
                                if (type === '对子') {
                                    for (const n in pileMap) {
                                        const have = haveMap[n] || 0;
                                        const need = 2 - have;
                                        if (need > 0 && need <= num && pileMap[n].length >= need) result.push(...pileMap[n].slice(0, need));
                                    }
                                    return result;
                                }
                                if (type === '三顺') {
                                    const nums = Object.keys({ ...haveMap, ...pileMap }).map(Number).sort((a, b) => a - b);
                                    for (let i = 0; i < nums.length - 2; i++) {
                                        const seq = [nums[i], nums[i] + 1, nums[i] + 2];
                                        if (!seq.every(n => pileMap[n] || haveMap[n])) continue;
                                        for (const n of seq) {
                                            if (!(haveMap[n] > 0) && pileMap[n]?.length) result.push(pileMap[n][0]);
                                        }
                                    }
                                    return result;
                                }
                                return result;
                            };
                            const hasTypeSubset = function (allCards, needLen, type) {
                                const len = allCards.length, max = 1 << len;
                                for (let i = 1; i < max; i++) {
                                    let pick = 0;
                                    const subset = [];
                                    for (let k = 0; k < len; k++) {
                                        if (i & (1 << k)) {
                                            pick++;
                                            if (pick > needLen) break;
                                            subset.push(allCards[k]);
                                        }
                                    }
                                    if (pick === needLen) {
                                        if (lib.skill.miniyinyinxing.getType(subset) === type) return true;
                                    }
                                }
                                return false;
                            };
                            const search = function (candidates, type) {
                                const len = candidates.length, max = 1 << len;
                                const needLen = type === '对子' ? 2 : type === '三顺' ? 3 : 4;
                                for (let i = 1; i < max; i++) {
                                    let pick = 0;
                                    const gain = [];
                                    for (let k = 0; k < len; k++) {
                                        if (i & (1 << k)) {
                                            pick++;
                                            if (pick > num) break;
                                            gain.push(candidates[k]);
                                        }
                                    }
                                    if (pick === 0 || pick > num) continue;
                                    if (hasTypeSubset([...cards, ...gain], needLen, type)) return gain;
                                }
                                return null;
                            };
                            for (const type of (() => {
                                let list = ['炸弹', '三顺', '对子'];
                                if (_status.currentPhase !== player) list.reverse();
                                return list;
                            })()) {
                                const candidates = buildCandidates(type);
                                if (!candidates.length) continue;
                                const result = search(candidates, type);
                                if (result) return result;
                            }
                            return [];
                        },
                    },
                },
            },
            miniyinjujian: {
                audio: 'ext:活动武将/audio/skill:2',
                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                filter(event, player) {
                    return player.countCards('h');
                },
                async cost(event, trigger, player) {
                    event.result = await player.chooseCardTarget({
                        prompt: get.prompt2(event.skill),
                        filterCard: lib.filter.cardDiscardable,
                        position: 'h',
                        filterTarget: true,
                        ai1(card) {
                            return 6.5 - get.value(card) + ([2, 12].includes(get.number(card)) ? 2 : 0);
                        },
                        ai2(target) {
                            const player = get.player();
                            return get.attitude(player, target);
                        },
                    }).forResult();
                },
                async content(event, trigger, player) {
                    const { cards, targets: [target] } = event;
                    await player.discard(cards);
                    const number = get.number(cards[0]);
                    const bool1 = number <= 1;
                    const bool2 = number >= 13;
                    const result = (!bool1 && !bool2) ? await target.chooseControl().set('choiceList', [`获得两张点数大于${number}的牌`, `获得两张点数小于${number}的牌`]).set("ai", () => {
                        const { player, numberx } = get.event();
                        if (numberx == 2) return 1;
                        if (numberx == 12) return 0;
                        return [0, 1].randomGet();
                    }).set('numberx', number).forResult() : { index: bool1 ? 0 : 1 };
                    if ([0, 1].includes(result?.index)) {
                        const { index } = result;
                        const list = [];
                        while (list.length < 2) {
                            const card = get.cardPile(cardx => {
                                const numberx = get.number(cardx);
                                return (index == 0 ? numberx > number : numberx < number) && !list.includes(cardx);
                            });
                            if (card) list.push(card);
                            else break;
                        }
                        if (list.length) await target.gain(list, 'gain2');
                    }
                },
            },
        },
        dynamicTranslate: {
            minizhongjian(player) {
                return '出牌阶段限' + (player.hasSkill('recaishi2') ? '两' : '一') + '次，你可以选择一名本回合内未选择过的角色。你令其获得一项效果：①其下次造成伤害后弃置两张牌，然后你摸一张牌。②其下次受到伤害后摸两张牌，然后你摸一张牌。';
            },
            minijiaozhao(player) {
                return [lib.translate.minijiaozhao_info, lib.translate.minijiaozhao_1_info, lib.translate.minijiaozhao_2_info][player.countMark('minidanxin')];
            },
            minipingting(player) {
                return '出牌阶段开始时，你可以选择以下选项中的至多' + get.cnNumber(2 + player.countMark('minishuangshu_pingting')) + '项：⒈本阶段使用的第一张牌无距离限制。⒉本阶段使用第二张牌指定目标后获得此牌对应的所有实体牌。⒊本阶段使用的第三张牌结算完毕后摸两张牌。⒋本阶段使用的第四张牌额外结算一次。';
            },
            miniyizheng(player) {
                return '出牌阶段结束时，你可以移动场上至多' + get.cnNumber(1 + player.countMark('minishuangshu_yizheng')) + '张装备牌（只能移动武器、防具和坐骑牌，且一次技能结算中每种副类别的装备限移动一次），然后若你于本次技能结算中移动了：一张装备牌，你回复1点体力；两张装备牌，直到你的下回合开始，当你失去一张牌时，摸一张牌。';
            },
            minimanwang(player) {
                var num = 4 - player.countMark('spmanwang');
                var str = '出牌阶段，你可以弃置任意张牌。然后你依次执行以下选项中的前X项：';
                var list = [
                    '⒈获得〖叛侵〗。',
                    '⒉摸一张牌。',
                    '⒊回复1点体力。',
                    '⒋摸两张牌并失去〖叛侵〗。',
                ];
                for (var i = 0; i < 4; i++) {
                    if (i == num) {
                        str += '<span style="text-decoration: line-through;">';
                    }
                    str += list[i];
                }
                if (num < 4) str += '</span>';
                return str + '然后你获得〖祸首〗直到你的下个回合开始。';
            },
            miniguixiu(player) {
                return lib.translate[(player.storage.miniguixiu ? 'miniguixiux' : 'miniguixiu') + '_info'];
            },
            miniyanzhu(player) {
                var bool = player.storage.miniyanzhu;
                var str = '出牌阶段限一次，你可以令一名其他角色';
                if (bool) str += '<span style="text-decoration:line-through;">';
                str += '选择一项：';
                if (bool) str += '</span>';
                str += '弃置一张牌并令下一次受到的伤害+1直到其下回合开始';
                if (bool) str += '<span style="text-decoration:line-through;">';
                str += '，或将装备区里的所有牌交给你并令你发动〖宴诛〗无法选择此项';
                if (bool) str += '</span>';
                return str + '。';
            },
            miniyoulong(player) {
                var storage = player.storage.miniyoulong;
                var str = '转换技';
                if (!player.storage.miniyou_luanfeng) str += '，每回合每项各限一次';
                str += '。';
                if (!storage) str += '<span class="bluetext">';
                str += '阴，你可以废除你的一个装备栏，视为使用一张未以此法使用过的普通锦囊牌；';
                if (!storage) str += '</span>';
                if (storage) str += '<span class="bluetext">';
                str += '阳，你可以弃置一张非基本牌，视为使用一张未以此法使用过的基本牌。';
                if (storage) str += '</span>';
                return str;
            },
            minikeji(player) {
                let str = '弃牌阶段开始时，';
                if (player.hasSkill('minisbduojing_keji', null, false, false)) str += '<span style="text-decoration:line-through;">';
                str += '若你于本回合的出牌阶段内没有过使用或打出过【杀】，则';
                if (player.hasSkill('minisbduojing_keji', null, false, false)) str += '</span>';
                str += '你可以跳过此阶段并摸一张牌。';
                return str;
            },
            miniliuma(player) {
                if (!player.storage.miniliuma_give) return lib.translate.miniliuma_info;
                return '①出牌阶段结束时，你可以将至多X张手牌置入“流马”区（X为你的体力值，“流马”区至多存在五张牌）。②你可以使用或打出“流马”区的牌。';
            },
            minisbqicai(player) {
                let storage = player.storage.dcsbyingmou, str = '转换技，①游戏开始时，你可以转换此技能状态。②';
                if (!storage) str += '<span class="bluetext">';
                str += '阳：每回合限两次，当你使用锦囊牌时，你可以为此牌增加或减少一个目标；';
                if (!storage) str += '</span>';
                if (storage) str += '<span class="bluetext">';
                str += '阴：每回合限两次，出牌阶段，你可以弃置一张基本牌，然后从牌堆中获得一张锦囊牌。';
                if (storage) str += '</span>';
                return str;
            },
            minidunshi(player) {
                var info = player.storage.minidunshi;
                var str = '每回合限一次，你可以视为使用或打出一张';
                var list = ['sha', 'shan', 'tao', 'jiu'];
                for (var i of list) {
                    var strx = '【' + get.translation(i) + '】';
                    if (!info?.includes(i)) strx = ('<span style="text-decoration:line-through;">' + strx + '</span>');
                    str += strx;
                    if (i != 'jiu') str += '/';
                }
                str += '，然后当前回合角色于本回合内下一次造成伤害时，你选择两项：⒈防止此伤害。系统从技能名中包含“仁/义/礼/智/信”字样的技能中随机选择三个其未拥有的技能，然后你令当前回合角色获得其中一个技能。⒉从〖遁世〗中删除你本次使用或打出的牌名。⒊减1点体力上限并摸X张牌（X为〖遁世〗的剩余牌名数）。';
                return str;
            },
            minizhenliang(player) {
                let storage = player.storage.minizhenliang, str = '转换技。';
                if (!storage) str += '<span class="bluetext">';
                str += '阳：出牌阶段限一次，你可以弃置一张与“任”颜色相同的牌并对攻击范围内的一名角色造成1点伤害。';
                if (!storage) str += '</span>';
                if (storage) str += '<span class="bluetext">';
                str += '阴：你的回合外，一名角色使用或打出牌结算完成后，若此牌与“任”颜色相同，则你可以令一名角色摸两张牌。';
                if (storage) str += '</span>';
                return str;
            },
            minirehuxiao(player, skill) {
                return lib.translate[player.storage[skill] ? 'minirehuxiao_rewrite_info' : 'minirehuxiao_info'];
            },
            minisbxianmou(player) {
                const storage = player.storage.minisbxianmou;
                let str = '转换技，①游戏开始时，你可以转换此技能状态；②你不因使用装备牌而失去过牌的回合结束时，你可以：';
                if (!storage) str += '<span class="bluetext">';
                str += '阳，观看牌堆顶五张牌并获得至多X张牌，若未获得X张牌则获得〖遗计〗直到再发动此项；';
                if (!storage) str += '</span>';
                if (storage) str += '<span class="bluetext">';
                str += '阴，观看一名角色手牌并弃置其中至多X张牌，若弃置X张牌则你进行一次【闪电】判定。';
                if (storage) str += '</span>';
                return str + '（X为你本回合不因使用装备牌而失去的牌数）';
            },
            minixiafeng(player, skill) {
                let str = '每回合限一次。当你使用【杀】后，你可以对场上体力值最大的角色造成1点伤害或令场上体力值最小的角色回复1点体力。';
                const storage = player.getStorage(skill);
                if (storage.length) str = str.replace(/【杀】/, `【杀】/${storage.map(str => `【${get.translation(str)}】`).join('/')}`);
                return str;
            },
            mininianchengming(player) {
                let str = lib.translate[`mininianchengming_info`];
                if (player.storage.mininianchengming) str = str.replace(/出牌阶段/, '出牌阶段或当你成为【杀】的目标时');
                return str;
            },
            minishuangshu2(player) {
                const bool1 = player.storage.minishuangshu2;
                const bool2 = player.storage.minishutu2;
                let yang = '当你使用或打出一张方片牌后，你摸X张牌（X为你装备区的红色牌数）', yin = '当你使用或打出一张红桃牌后，你可以弃置一张牌，然后从牌堆或弃牌堆获得两张与此牌花色不同的牌';
                if (bool1) {
                    yin = `<span class='bluetext'>${yin}</span>`;
                    if (bool2) yang = `<span style="text-decoration: line-through;">${yang}</span>`;
                }
                else {
                    yang = `<span class='firetext'>${yang}</span>`;
                    if (bool2) yin = `<span style="text-decoration: line-through;">${yin}</span>`;
                };
                let start = '转换技。①游戏开始时，你可以转换此技能状态；', end = '。';
                return `${start}阳：${yang}；阴：${yin}${end}`;
            },
            minishuangshu1(player, skill) {
                if (typeof player.hp2 === 'number') return lib.translate[`${skill}_info`];
                return '锁定技。回合开始时，你执行一个额外的摸牌阶段。';
            },
            minishutu(player, skill) {
                if (typeof player.hp2 === 'number') return lib.translate[`${skill}_info`];
                return '当你回复体力后，你可以从牌堆或弃牌堆获得两张指定花色的红色牌。';
            },
            minitongdi(player, skill) {
                if (typeof player.hp2 === 'number') return lib.translate[`${skill}_info`];
                return '当你使用红色牌令一名角色的体力值变化后，若你手牌中的红桃牌和方片牌的数量相同，则你可以弃置一张红色牌，对一名角色造成1点伤害。';
            },
        },
        translate: {
            MiNi_wei: '欢乐三国杀·魏国',
            MiNi_shu: '欢乐三国杀·蜀国',
            MiNi_wu: '欢乐三国杀·吴国',
            MiNi_qun: '欢乐三国杀·群雄',
            MiNi_shen: '欢乐三国杀·神将',
            MiNi_change: '一样？不一样？',
            MiNi_refresh: '欢乐三国杀·界限突破',
            MiNi_sp: '欢乐三国杀·SP武将',
            MiNi_sbCharacter: '欢乐三国杀·谋攻篇',
            MiNi_starCharacter: '欢乐三国杀·星河篇',
            MiNi_miaoKill: '欢乐三国杀·喵系列',
            MiNi_nianKill: '欢乐三国杀·念系列',
            MiNi_fightKill: '欢乐三国杀·战系列',
            MiNi_yinKill: '欢乐三国杀·隐系列',
            MiNi_shengzhiyifa: '欢乐三国杀·限时地主',
            //牌
            miniyanxiao_card: '言笑',
            miniyanxiao_card_info: '判定阶段开始时，获得此牌和判定区内的所有牌。',
            minilingren_basic: ' ',
            minilingren_trick: ' ',
            minilingren_equip: ' ',
            junling: '军令',
            minijieyue_junling1: '军令一',
            minijieyue_junling1_info: '执行者对发起者指定的一名角色造成1点伤害。',
            minijieyue_junling2: '军令二',
            minijieyue_junling2_info: '执行者随机弃置一张手牌区和装备区的牌。',
            minijieyue_junling3: '军令三',
            minijieyue_junling3_info: '执行者本回合不能回复体力。',
            minijieyue_junling4: '军令四',
            minijieyue_junling4_info: '执行者本回合不能使用或打出手牌，且本回合非锁定技失效。',
            //魏
            Mbaby_caoang: '欢杀曹昂',
            Mbaby_caopi: '欢杀曹丕',
            Mbaby_zhenji: '欢杀甄宓',
            Mbaby_re_zhenji: '欢杀界甄宓',
            Mbaby_old_caoren: '欢杀曹仁',
            Mbaby_caoren: '欢杀界曹仁',
            Mbaby_dianwei: '欢杀典韦',
            Mbaby_re_dianwei: '欢杀界典韦',
            Mbaby_guohuai: '欢杀郭淮',
            Mbaby_re_guohuai: '欢杀界郭淮',
            Mbaby_zhangchunhua: '欢杀张春华',
            Mbaby_re_zhangchunhua: '欢杀界张春华',
            Mbaby_xiahoudun: '欢杀夏侯惇',
            Mbaby_re_xiahoudun: '欢杀界夏侯惇',
            Mbaby_re_xuzhu: '欢杀界许诸',
            Mbaby_re_zhangliao: '欢杀界张辽',
            Mbaby_zhanghe: '欢杀张郃',
            Mbaby_yujin: '欢杀于禁',
            Mbaby_xuhuang: '欢杀徐晃',
            Mbaby_xunyu: '欢杀荀彧',
            Mbaby_dengai: '欢杀邓艾',
            Mbaby_caozhi: '欢杀曹植',
            Mbaby_sp_caiwenji: 'SP欢杀蔡琰',
            Mbaby_caoying: '欢杀曹婴',
            Mbaby_caorui: '欢杀曹叡',
            Mbaby_re_caorui: '欢杀界曹叡',
            Mbaby_xiahouyuan: '欢杀夏侯渊',
            Mbaby_ol_xiahouyuan: '欢杀界夏侯渊',
            Mbaby_haozhao: '欢杀郝昭',
            Mbaby_xizhicai: '欢杀戏志才',
            Mbaby_xinxianying: '欢杀辛宪英',
            Mbaby_guohuanghou: '欢杀郭皇后',
            Mbaby_caozhen: '欢杀曹真',
            Mbaby_zhongyao: '欢杀钟繇',
            Mbaby_lidian: '欢杀李典',
            Mbaby_xunyou: '欢杀荀攸',
            Mbaby_caoxiu: '欢杀曹休',
            Mbaby_sp_jiangwei: 'SP欢杀姜维',
            Mbaby_zhonghui: '欢杀钟会',
            Mbaby_zhangchangpu: '欢杀张昌蒲',
            Mbaby_yangxiu: '欢杀杨修',
            Mbaby_re_simayi: '欢杀界司马懿',
            Mbaby_dufuren: '欢杀杜夫人',
            Mbaby_caozhang: '欢杀曹彰',
            Mbaby_caocao: '欢杀曹操',
            Mbaby_re_caocao: '欢杀界曹操',
            Mbaby_sp_pangde: 'SP欢杀庞德',
            Mbaby_wenyang: '欢杀文鸯',
            Mbaby_xiahoulingnv: '欢杀夏侯令女',
            Mbaby_chenqun: '欢杀陈群',
            Mbaby_wangji: '欢杀界王基',
            Mbaby_jsp_guanyu: 'SP欢杀关羽',
            Mbaby_kuailiangkuaiyue: '欢杀蒯良蒯越',
            Mbaby_sp_jiaxu: 'SP欢杀贾诩',
            Mbaby_yinfuren: '欢杀尹夫人',
            Mbaby_sp_caoren: 'SP欢杀曹仁',
            Mbaby_re_guojia: '欢杀界郭嘉',
            Mbaby_caohong: '欢杀曹洪',
            Mbaby_sb_caocao: '欢杀谋曹操',
            Mbaby_zhugedan: '欢杀诸葛诞',
            Mbaby_bianfuren: '欢杀卞夫人',
            Mbaby_sb_yujin: '欢杀谋于禁',
            Mbaby_yuejin: '欢杀乐进',
            Mbaby_jianggan: '欢杀蒋干',
            Mbaby_chengyu: '欢杀程昱',
            Mbaby_sb_xuhuang: '欢杀谋徐晃',
            Mbaby_ruanyu: '欢杀阮瑀',
            Mbaby_dc_yanghu: '欢杀羊祜',
            Mbaby_yanrou: '欢杀阎柔',
            Mbaby_wangshuang: '欢杀王双',
            Mbaby_chenlin: '欢杀陈琳',
            Mbaby_dc_liuye: '欢杀刘晔',
            Mbaby_wenqin: 'OL文钦',
            Mbaby_wenqin_prefix: 'OL',
            Mbaby_guanqiujian: '欢杀毌丘俭',
            Mbaby_guanlu: '欢杀管辂',
            Mbaby_zhenghun: '欢杀郑浑',
            Mbaby_chentai: '欢杀陈泰',
            Mbaby_hanhaoshihuan: '欢杀韩浩史涣',
            Mbaby_sb_zhenji: '欢杀谋甄宓',
            Mbaby_simalang: '欢杀司马朗',
            Mbaby_zhanggong: '欢杀张恭',
            Mbaby_zhaoang: '欢杀赵昂',
            Mbaby_caoanmin: '欢杀曹安民',
            Mbaby_bianyue: '欢杀卞玥',
            Mbaby_sb_guojia: '欢杀谋郭嘉',
            Mbaby_caimaozhangyun: '欢杀蔡瑁张允',
            Mbaby_xinpi: '欢杀辛毗',
            Mbaby_dukui: '欢杀杜夔',
            Mbaby_zhugeruoxue: '欢杀诸葛若雪',
            Mbaby_star_xunyu: '欢杀星荀彧',
            Mbaby_dc_jiachong: '欢杀贾充',
            Mbaby_ol_xunyu: '欢杀界荀彧',
            Mbaby_dc_sb_chengyu: '欢杀谋程昱',
            Mbaby_caochong: '欢杀曹冲',
            Mbaby_caochun: '欢杀曹纯',
            miniluoshen: '洛神',
            miniluoshen_info: '准备阶段，你可以进行一次判定并获得判定牌，若判定结果为黑色，你可重复此流程。',
            minireluoshen: '洛神',
            minireluoshen_info: '①准备阶段，你可以进行一次判定并获得判定牌，若判定结果为黑色，你可重复此流程。②当你于每轮首次失去〖洛神①〗获得的红色牌后，你可以发动〖洛神①〗。',
            miniqiaobian: '巧变',
            miniqiaobian_info: '①你可以弃置一张手牌并跳过自己的一个阶段（准备阶段和结束阶段除外）。若你以此法跳过了摸牌阶段，则你可以获得至多两名其他角色的各一张手牌；若你以此法跳过了出牌阶段，则你可以移动场上的一张牌。②结束阶段，若你本回合至少跳过了三个阶段，则你摸两张牌。',
            minikangkai: '慷忾',
            minikangkai_info: '锁定技，每回合限两次。当一名角色成为【杀】的目标后，若你至该角色的距离为1，你摸一张牌。然后你可以交给其一张牌并展示之，若此牌为装备牌，该角色可以使用此牌。',
            minishangshi: '伤逝',
            minishangshi_info: '当你的手牌数小于X时，你可以将手牌摸至X张（X为你已损失的体力值且至少为1）。',
            minijueqing: '绝情',
            minijueqing_info: '当你即将造成伤害时，你依次执行：①你可以失去1点体力，令此伤害+1；②你可以防止此伤害，改为令受伤角色失去等同于伤害值的体力。',
            minireshangshi: '伤逝',
            minireshangshi_info: '①当你的手牌数小于X时，你可以将手牌摸至X张（X为你已损失的体力值且至少为1）。②每回合限一次，当你发动〖伤逝①〗后，你可以弃置任意张手牌，若你以此法弃置了所有手牌，你于下个回合的摸牌阶段额外摸一张牌。',
            minifangzhu: '放逐',
            minifangzhu_info: '当你受到伤害后，你可以令一名其他角色将武将牌翻面，然后该角色摸一张牌。',
            miniqiangxi: '强袭',
            miniqiangxi_info: '当你于回合内首次造成伤害时，你可以弃置一张武器牌令此伤害+1。',
            minireqiangxi: '强袭',
            minireqiangxi_info: '出牌阶段对每名其他角色限一次，你可以失去1点体力并摸一张牌，对你攻击范围内的一名其他角色造成1点伤害；其他角色受到伤害时，你可以弃置一张装备牌并令伤害值+1。',
            miniyizhong: '毅重',
            miniyizhong_info: '锁定技，当你的防具栏没有牌且未被废除时，梅花【杀】对你无效。',
            minijiezi: '截辎',
            minijiezi_info: '锁定技，每轮限两次，其他角色跳过摸牌阶段后，你摸两张牌。',
            minijushou: '据守',
            minijushou_info: '结束阶段，你可以翻面并摸四张牌，然后你可以使用一张装备牌。',
            minichenqing: '陈情',
            minichenqing_info: '每回合限一次，当一名角色进入濒死状态时，你可以令另一名角色摸五张牌，然后其弃置四张牌。若其以此法弃置的四张牌花色各不相同，则视为该角色对濒死的角色使用一张【桃】。',
            minituntian: '屯田',
            minituntian_info: '当你于回合外失去牌后，你可以进行判定。若判定结果不为♥，则你将此牌置于你的武将牌上，称之为【田】。结束阶段，你可以弃置一张牌并进行〖屯田〗判定。锁定技，你计算与其他角色的距离时-X（X为你武将牌上【田】的数目）。',
            minijiushi: '酒诗',
            minijiushi1: '酒诗',
            minijiushi3: '酒诗',
            minijiushi_info: '当你需要使用【酒】时，若你的武将牌正面向上，你可以翻面并视为使用一张【酒】。当你受到伤害后，若你的武将牌背面向上，你可以翻面。当你翻面时，你可以获得牌堆中的一张随机锦囊牌。',
            miniluoying: '落英',
            miniluoying_discard: '落英',
            miniluoying_judge: '落英',
            miniluoying_info: '当其他角色的梅花牌因弃置或判定而进入弃牌堆时，你可以获得之。你的梅花牌不计入手牌上限。',
            miniquhu: '驱虎',
            miniquhu_info: '出牌阶段限一次，你可以：①弃置两张牌，对一名其他角色造成1点伤害；②对自己造成1点伤害，然后摸一张牌。',
            minijieming: '节命',
            minijieming_info: '当你受到1点伤害后，你可令一名角色将手牌摸至X张（X为其体力上限且至多为4）。',
            minimingjian: '明鉴',
            minimingjian_info: '出牌阶段限一次，你可以将任意张手牌交给一名其他角色，该角色于其下个回合的手牌上限+1，使用【杀】的次数上限+1。',
            minixingshuai: '兴衰',
            minixingshuai_info: '主公技，限定技，当你进入濒死状态时，其他魏势力角色可依次令你回复1点体力，然后这些角色依次受到1点伤害并摸一张牌。',
            minihuituo: '恢拓',
            minihuituo_info: '当你受到伤害后，你可以令一名角色判定。若结果为：红色，其回复1点体力；黑色，该角色摸X+1张牌（X为伤害值）。',
            miniremingjian: '明鉴',
            miniremingjian_info: '①出牌阶段限一次，你可以将任意张手牌交给一名其他角色，该角色于其下个回合的手牌上限+1，使用【杀】的次数上限+1。②每轮限一次，当你或〖明鉴〗角色造成伤害后，你可以发动〖恢拓〗。',
            minirexingshuai: '兴衰',
            minirexingshuai_info: '主公技，限定技，当你进入濒死状态时，其他魏势力角色可依次令你回复1点体力，然后这些角色依次受到1点伤害并摸一张牌。魏势力角色死亡后，你重置此技能。',
            minixingshang: '行殇',
            minixingshang_info: '一名角色死亡时，你可以获得该角色的所有牌并摸一张牌。',
            minilingren: '凌人',
            minilingren_info: '每回合限一次，当你于出牌阶段使用带有「伤害」这一标签的基本牌或普通锦囊牌指定目标后，你可以猜测其中的一个目标的手牌中是否有基本牌，锦囊牌或装备牌。若你至少猜对了：一项，此牌对该角色的伤害+1；两项，你摸两张牌；三项，你获得〖奸雄〗和〖行殇〗直到下回合开始。',
            minifujian: '伏间',
            minifujian_info: '锁定技，准备阶段和结束阶段，你随机观看一名其他角色的手牌。',
            minihuchi: '虎痴',
            minihuchi_info: '结束阶段，若你的手牌数小于2，则你将手牌数补至两张；当你使用的【杀】被抵消后，你获得1枚“痴”；出牌阶段限一次，你可以移去所有“痴”，然后摸等量的牌。',
            minijingce: '精策',
            minijingce_info: '锁定技，结束阶段，你摸X张牌（X为你本回合使用牌的花色数+1且至多为3）。',
            tiandu_xizhicai: '天妒',
            minichouce: '筹策',
            minichouce_info: '当你受到1点伤害后，你可以判定，若结果为：黑色，你获得一名角色区域里的一张牌；红色，你选择一名角色，其摸一张牌，若其是〖先辅〗选择的角色，则改为摸两张牌。',
            minishensu: '神速',
            minishensu_info: '你可以选择一至三项：1.跳过判定阶段和摸牌阶段；2.跳过出牌阶段；3.跳过弃牌阶段并将武将牌翻面。你每选择一项，视为你对一名其他角色使用一张无距离限制的雷【杀】。',
            minishebian: '设变',
            minishebian_info: '当你翻面时，你可以移动场上的一张装备牌，然后回复1点体力。',
            minizhongjian: '忠鉴',
            minizhongjian_info: '出牌阶段限一次，你可以选择一名本回合内未选择过的角色。你令其获得一项效果：①其下次造成伤害后弃置两张牌，然后你摸一张牌。②其下次受到伤害后摸两张牌，然后你摸一张牌。',
            minicaishi: '才识',
            minicaishi_info: '摸牌阶段结束时，若你此阶段摸的牌：花色相同，本回合你将〖忠鉴〗中『出牌阶段限一次』修改为『出牌阶段限两次』；花色不同，你可以弃置一张牌，然后回复1点体力。',
            minijiaozhao: '矫诏',
            minijiaozhao2: '矫诏',
            minijiaozhao_info: '出牌阶段限一次，你可以展示一张手牌并声明一个基本牌或普通锦囊牌，本阶段你可以将此牌当作你声明的牌使用（你不是此牌的合法目标）。',
            minijiaozhao_1: '矫诏·2级',
            minijiaozhao_1_info: '出牌阶段限两次，你可以展示一张手牌并声明一个基本牌或普通锦囊牌，本阶段你可以将此牌当作你声明的牌使用（每种类型限一次，且你不是此牌的合法目标）。',
            minijiaozhao_2: '矫诏·3级',
            minijiaozhao_2_info: '出牌阶段限三次，你可以展示一张手牌并声明一个基本牌或普通锦囊牌，本阶段你可以将此牌当作你声明的牌使用（每种牌名限一次）。',
            minidanxin: '殚心',
            minidanxin_info: '当你受到伤害后，你可以摸一张牌并升级〖矫诏〗。',
            miniqingjian: '清俭',
            miniqingjian_info: '每回合限一次，当你于摸牌阶段外获得牌时，你可以展示任意张牌并交给一名其他角色，然后你摸一张牌。',
            minisidi: '司敌',
            minisidi_info: '结束阶段，你可以将至多两张非基本牌置于武将牌上，称为“司”。其他角色的出牌阶段开始时，你可以移去一张“司”。若如此做，其本阶段内不能使用或打出与“司”颜色相同的牌。此阶段结束时，若其于此阶段内未使用过：【杀】，你视为对其使用一张【杀】。锦囊牌，你摸两张牌。',
            minihomo: '活墨',
            minihomo_info: '每回合限两次，当你需要使用一张基本牌时，你可以将一张黑色非基本牌置于牌堆顶，然后视为使用此基本牌。',
            minizuoding: '佐定',
            minizuoding_info: '一名角色于其回合内使用黑桃牌指定目标后，若本回合内没有角色受到过伤害，则你可以令其中一名目标角色摸一张牌。',
            minixunxun: '恂恂',
            minixunxun_info: '摸牌阶段，你可以观看牌堆顶的四张牌，然后将其中的两张牌置于牌堆顶，并将其余的牌以任意顺序置于牌堆底。结束阶段，你获得牌堆底的两张牌。',
            minizhengbing: '整兵',
            minizhengbing_info: '你通过〖突袭〗获得的牌不计入手牌上限；出牌阶段，你可以重铸你通过〖突袭〗获得的牌，若你以此法重铸的牌为你手牌中的最后一张通过〖突袭〗获得的牌，你额外摸一张牌。',
            miniqice: '奇策',
            miniqice_info: '出牌阶段限一次，你可以将任意张手牌当作任意一张普通锦囊牌使用。',
            minizhiyu: '智愚',
            minizhiyu_info: '当你受到伤害后，你可以摸两张牌并弃置一张牌，然后展示所有手牌，然后若你的手牌的颜色均相同且伤害来源的手牌数大于你的手牌数，你可以令伤害来源将手牌数弃置至与你一致。',
            miniqingxi: '倾袭',
            miniqingxi_info: '当你使用【杀】或【决斗】指定目标后，你可以令其选择一项：①弃置X张手牌（X为你攻击范围内的角色数，且当你装备区内有武器牌/没有武器牌时至多为4/2），若如此做，其弃置你的此武器牌；②令此牌的伤害值+1且你进行判定，若结果为红色，则其不能响应此牌；若结果为黑色，你摸两张牌。',
            minikunfen: '困奋',
            minikunfen_info: '结束阶段，你可以失去1点体力。若如此做，你摸两张牌，然后可以视为使用一张【火攻】。',
            minifengliang: '逢亮',
            minifengliang_info: '觉醒技，当你进入濒死状态时，你减1点体力上限，将体力值回复至3点，然后获得〖挑衅〗。',
            miniquanji: '权计',
            miniquanji_info: '当你受到1点伤害后，你可以摸两张牌。出牌阶段，你可以将任意张手牌置于武将牌上，称为“权”。你的手牌上限+X（X为武将牌上“权”的数量且X至多为5）。',
            minijilei: '鸡肋',
            minijilei_info: '当你受到有来源的伤害后，你可以声明一种牌的类别。若如此做，你从牌堆中获得一张此类型的牌，且伤害来源不能使用、打出或弃置此类别的手牌直到其下个回合开始。',
            miniyanjiao: '严教',
            miniyanjiao_info: '出牌阶段限一次，你可以选择一名角色。该角色从牌堆顶亮出三张牌，选择并获得点数之和不大于总点数一半（至少为1）的牌，然后你获得剩余的牌（若你选的角色是自己，则弃置剩余的牌）。',
            minifankui: '反馈',
            minifankui_info: '当你受到1点伤害后，你可以进行一次判定，若判定结果为红桃，你获得一名角色的一张牌，否则你获得伤害来源的一张牌。',
            miniguicai: '鬼才',
            miniguicai_info: '当一名角色的判定牌生效前，你可以打出一张牌代替之，然后若此牌的花色为：红桃，你回复1点体力；梅花，你摸两张牌。',
            miniyise: '异色',
            miniyise_info: '其他角色得到你的牌后，若这些牌中：有红色牌，你可摸一张牌或令其回复1点体力；有黑色牌，你可令其下次受到【杀】造成的伤害时，此伤害+1。',
            minishunshi: '顺世',
            minishunshi_info: '准备阶段，或当你受到伤害后，你可将一张牌交给一名其他角色并获得如下效果直到你的回合结束：下个摸牌阶段的额定摸牌数+1，下个出牌阶段使用【杀】的次数上限+1且无视防具，下个弃牌阶段手牌上限+1。',
            minijiangchi: '将驰',
            minijiangchi_info: '出牌阶段开始时，你可以选择一项：①摸一张牌，直到你的下个回合开始，受到伤害后摸一张牌。②摸三张牌，然后本回合内不能使用或打出【杀】且手牌上限+2。③本回合使用【杀】无距离限制且可以多使用一张【杀】。',
            minijianxiong: '奸雄',
            minijianxiong_info: '当你受到1点伤害后，你可以选择一项：①摸两张牌；②获得对你造成伤害的牌并摸一张牌。',
            minihujia: '护驾',
            minihujia_info: '主公技，当你需要使用或打出一张【闪】时，你可以令其他魏势力角色选择是否打出一张【闪】。若有角色响应，则你视为使用或打出了一张【闪】，且该角色可以令你摸一张牌。',
            minijuesi: '决死',
            minijuesi_info: '出牌阶段，你可以弃置一张【杀】并选择攻击范围内的一名有牌的其他角色，该角色弃置一张牌，然后若其弃置的牌不是【杀】且你的体力值不大于该角色，你摸两张牌；若其弃置的牌是【杀】，则视为对其使用【决斗】。',
            minichoujue: '仇决',
            minichoujue_info: '觉醒技，一名角色的回合结束时，若你的手牌数和体力值相差3或更多，你减1点体力上限并获得〖背水〗，然后将〖膂力〗改为“在自己的回合时每回合限两次”。',
            minibeishui: '背水',
            minibeishui_info: '觉醒技，准备阶段，若你的手牌数或体力值不大于2，你减1点体力上限并获得〖清剿〗，然后将〖膂力〗改为受到伤害后也可以发动。',
            miniqingjiao: '清剿',
            miniqingjiao_info: '出牌阶段开始时，你可以弃置所有手牌，然后从牌堆或弃牌堆中随机获得八张牌名各不相同且副类别不同的牌。若如此做，结束阶段，你弃置所有手牌。',
            miniweilie: '炜烈',
            miniweilie_info: '每局游戏限X次。出牌阶段，你可以弃置一张牌并令一名角色回复1点体力并摸一张牌（X为你〖浮萍①〗中的记录数+1）。',
            minifaen: '法恩',
            minifaen_info: '①当一名角色翻面或者横置后，你可以令其摸一张牌。②当一名横置的角色受到伤害时，你可以弃置一张牌并防止此伤害。',
            miniqizhi: '奇制',
            miniqizhi_info: '当你于回合内使用基本牌或锦囊牌指定目标后，你可以弃置不是此牌目标的一名角色的一张牌。若弃置的牌与使用的牌类型相同，你摸一张牌；类型不同，其摸一张牌。',
            minijinqu: '进趋',
            minijinqu_info: '你可以跳过弃牌阶段并摸两张牌。若如此做，你将手牌弃置至X张。（X为你于此回合发动过〖奇制〗的次数+1）',
            minijinghong: '惊鸿',
            minijinghong_info: '准备阶段，你可以选择至多X名其他角色（X为场上存活人数-1，且X至多为4），然后你依次随机展示这些角色的各一张牌，其若展示的牌为：黑色，你获得此牌，且此牌不计入你的手牌上限；红色，其弃置此牌。',
            minispluoshen: '洛神',
            minispluoshen_info: '你可以将一张黑色牌当作【闪】使用或打出。若如此做，每轮限一次，你可以于此牌结算完成后进行一次判定并获得判定牌，若判定结果为黑色，你可以重复此流程。',
            minispwusheng: '武圣',
            minispwusheng_info: '①回合开始时，你从牌堆或弃牌堆中获得一张红色牌。②你可以将一张红色牌当作【杀】使用或打出。③你使用的非转化红色【杀】造成的伤害+1，你使用方片【杀】无距离限制。',
            minidanji: '单骑',
            minidanji_info: '觉醒技，当你本局游戏使用或打出的牌数不小于5时，或当本局游戏造成不少于6点伤害后，你将体力值回复至上限，然后获得〖驭马〗和〖怒斩〗。',
            mininuzhan: '怒斩',
            mininuzhan_info: '锁定技，你使用非锦囊牌转化的【杀】不计入次数限制，你使用锦囊牌转化的【杀】造成的伤害+1。',
            minishenshi: '审时',
            minishenshi_info: '①出牌阶段限一次，你可以将一张牌交给一名其他角色，然后对其造成1点伤害，若该角色因此死亡，则你可以令一名角色将手牌摸至四张。②其他角色对你造成伤害后，你可以观看该角色的手牌，然后交给其一张牌，其失去此牌后，你将手牌摸至四张。',
            minijianshu: '间书',
            minijianshu_info: '出牌阶段限一次，你可以将一张手牌交给一名其他角色，并选择另一名其他角色，你令前者与后者拼点。赢的角色随机交给你一张牌，没赢的角色失去1点体力。若有角色因此死亡，你令你〖间书〗于此阶段发动的次数上限+1。',
            miniyongdi: '拥嫡',
            miniyongdi_info: '限定技，出牌阶段，你可以选择一名角色，若其：体力上限最少，其加1点体力上限；体力值最少，其回复1点体力；手牌数最少，其摸X张牌（X为其体力上限且至多为5）。',
            miniyongbi: '拥嬖',
            miniyongbi_info: '限定技。出牌阶段，你可以将任意手牌交给一名其他角色，然后将〖媵予〗的发动时机改为“准备阶段和结束阶段”。若这些牌中包含的花色数：大于1，则你与其本局游戏的手牌上限+2；大于2，则当你或其于本局游戏内受到大于1的伤害时，此伤害-1。',
            miniweikui: '伪溃',
            miniweikui_info: '出牌阶段限一次，你可以失去1点体力并选择一名有手牌的其他角色，你观看其手牌：若其手牌中没有【闪】，则视为你对其使用【杀】，且本回合你计算与其的距离视为1；若其手牌中有【闪】，你获得其中一张牌并回复1点体力。',
            minilizhan: '励战',
            minilizhan_info: '结束阶段，你可以令任意名已受伤的角色摸一张牌，然后你摸X张牌（X为手牌数等于体力值的目标角色数）。',
            minishenglun: '胜论',
            minishenglun_info: '出牌阶段限一次，你可以选择至多两名其他角色，然后你依次与目标角色依次比较你与其的：体力、手牌数、已装备武器牌数、已装备防具牌数、已装备坐骑牌数（你对应的数值比其大则获得1枚“胜”标记，否则获得1枚“负”标记）。当你的“胜”/“负”标记数达到10后，你回复1点体力/对一名角色造成1点伤害，然后发动〖遗计〗并失去所有的“胜”/“负”标记。',
            miniyuanhu: '援护',
            miniyuanhu_info: '①出牌阶段限两次，你可将一张装备牌置入一名角色的装备区内并摸一张牌，若此牌为：武器牌，你弃置与其距离为1的另一名角色区域的一张牌；防具牌，其摸一张牌；坐骑牌，其回复1点体力。②回合结束时，若你本回合未发动过〖援护①〗，则你从牌堆中获得一张装备牌。',
            minijuezhu: '决助',
            minijuezhu_info: '限定技，出牌阶段，你可以选择一名角色并废除一个坐骑栏，令该角色获得〖飞影〗并废除判定区。若如此做，该角色死亡后，你恢复以此法废除的装备栏。',
            minisbjianxiong: '奸雄',
            minisbjianxiong_info: '游戏开始时，你可获得至多2枚“治世”标记。当你受到伤害后，你可获得伤害牌，摸2-X张牌（X为你的“治世”标记数），然后你可获得或失去1枚“治世”标记。',
            minisbqingzheng: '清正',
            minisbqingzheng_backup: '清正',
            minisbqingzheng_info: '出牌阶段限一次，你可以弃置3-X种花色的所有手牌（X为你的“治世”标记数）并观看一名有手牌的其他角色的手牌，你弃置其中一种花色的所有牌。若其被弃置的牌数小于你以此法弃置的牌数，你对其造成1点伤害，然后你可获得或失去1枚“治世”标记。',
            minigongao: '功獒',
            minigongao_info: '锁定技，一名其他角色进入濒死状态时，你增加1点体力上限，然后回复1点体力。',
            minijuyi: '举义',
            minijuyi_info: '限定技，准备阶段，若你的体力上限大于场上的存活角色数，你将手牌数摸至体力上限，然后获得〖崩坏〗和〖威重〗。',
            miniwanwei: '挽危',
            miniwanwei_info: '每轮限一次，一名其他角色进入濒死状态时，你可以交给其至多五张牌。若如此做，若其脱离濒死状态，你摸等量的牌并回复1点体力。',
            miniyuejian: '约俭',
            miniyuejian_info: '你的手牌上限+X（X为你的体力上限）。当你需要使用基本牌时，若你本回合未使用过基本牌，则你可以视为使用之。',
            minixiayuan: '狭援',
            minixiayuan_info: '每轮限一次，一名其他角色进入濒死状态时，你可以弃置至多两张牌并令其回复等量的体力。',
            minijieyue: '节钺',
            minijieyue_info: '准备阶段，你可以令一名其他角色摸一张牌，然后选择一个军令令其选择是否执行。若其执行，你摸一张牌；若其不执行，你摸三张牌，且其本回合受到的伤害+1。',
            minixiaoguo: '骁果',
            minixiaoguo_info: '其他角色的结束阶段，你可以弃置一张牌，令其选择一项：①弃置一张装备牌，令你摸一张牌，直到其下个结束阶段，你对其造成伤害时摸一张牌；②受到你对其造成的1点伤害，直到其下个结束阶段，你对其使用【杀】造成的伤害+1。',
            miniweicheng: '伪诚',
            miniweicheng_info: '当牌从你的手牌区移动至其他角色的手牌区后，若你的手牌数小于等于体力值，你可以摸一张牌。',
            minidaoshu: '盗书',
            minidaoshu_info: '出牌阶段限一次，你可以选择一个花色并获得一名其他角色的一张手牌。若此牌花色与你选择的相同，则你对其造成1点伤害且你〖盗书〗于此阶段内可使用的次数上限+1，否则你须交给一名其他角色一张手牌。',
            minishefu: '设伏',
            minishefu_info: '结束阶段或当你受到伤害后，你可以记录一个当前「伏兵」未记录的基本牌或锦囊牌的名称并将一张牌移出游戏，称为「伏兵」。你的回合外，当有其他角色使用与你记录的「伏兵」牌名相同的手牌时，你可以取消此牌的所有目标，然后移去该「伏兵」，若此时处于使用者的回合内，则其本回合所有技能失效。',
            minibenyu: '贲育',
            minibenyu_info: '当你受到有来源造成的伤害后，你可以选择一项：①将手牌摸至与伤害来源相同（至多摸至五张）；②弃置一张手牌，然后对伤害来源造成1点伤害。',
            minisbduanliang: '断粮',
            minisbduanliang_tag: 'invisible',
            minisbduanliang_info: '出牌阶段限两次，你可以摸一张牌并与一名其他角色进行谋弈。若你赢，且你选择的选项为：“围城断粮”，若其判定区没有【兵粮寸断】，你将此牌当作【兵粮寸断】对其使用，否则你获得其一张牌；“擂鼓进军”，你视为对其使用一张【决斗】。',
            minixingzuo: '兴作',
            minixingzuo_info: '出牌阶段开始时，你可观看牌堆底的三张牌并用任意张手牌替换其中等量的牌。若如此做，结束阶段，你可令一名有手牌的角色用所有手牌替换牌堆底的三张牌。',
            minideshao: '德劭',
            minideshao_info: '每回合限两次，当你成为一名角色使用的黑色牌的目标后，你可以摸一张牌，然后若其手牌数大于你，则你可以弃置其一张牌。',
            minixiangshu: '襄戍',
            minixiangshu_info: '限定技，结束阶段，若你本回合内造成过伤害，则你可以令一名已受伤的角色回复X点体力并摸X张牌（X为你本局游戏内造成的伤害值总和且至多为5）。',
            minizhuilie: '追猎',
            minizhuilie_info: '锁定技，你使用【杀】无距离限制；当你使用【杀】指定目标后，若其不在你的攻击范围内，此【杀】不计入使用次数限制且你判定。若判定结果为：武器牌或坐骑牌，此【杀】的伤害基数改为X（X为其体力值）；锦囊牌，你获得此牌；基本牌，你失去1点体力。',
            minisongci: '颂词',
            minisongci_info: '①每名角色限一次，出牌阶段，你可以选择一名角色。若其手牌数：大于其体力值，其弃置两张牌；不大于其体力值，其摸两张牌。②弃牌阶段结束时，你摸一张牌。',
            minipoyuan: '破垣',
            minipoyuan_info: '游戏开始时或准备阶段，若你的装备区内：没有【霹雳车】，则你可以将一张【霹雳车】置入装备区；有【霹雳车】，则你可以弃置一名其他角色至多两张牌。',
            minipiliche: '霹雳投石车',
            minipiliche_info: '锁定技。①你计算与其他角色的距离-1，当此牌离开你的装备区时，销毁之。②你于回合内使用基本牌无距离限制，且当你于回合内使用基本牌时，你令此牌的牌面数值+1。③当你于回合外使用或打出基本牌时，你摸一张牌。',
            minihuiqi: '彗启',
            minihuiqi_info: '觉醒技。一名角色回合结束后，若你与其他两名角色于此回合成为过牌的目标，你回复1点体力并获得〖偕举〗。',
            minixieju: '偕举',
            minixieju_info: '出牌阶段限一次。你可以令任意名本回合成为过牌的目标的角色可以依次将一张黑色牌当作【杀】使用。',
            minizhenrong: '征荣',
            minizhenrong_info: '当你对其他角色造成伤害后，你可以将其一张牌置于你的武将牌上，称为“荣”。',
            minihongju: '鸿举',
            minihongju_info: '觉醒技，准备阶段，若你武将牌上的“荣”数不小于3且场上有角色死亡，则你可以用任意张手牌替换等量的“荣”，然后获得〖清侧〗。',
            minibusuan: '卜算',
            minibusuan_info: '出牌阶段限一次，你可以选择一名角色，然后选择至多两张不同的卡牌名称（限基本牌或锦囊牌）。该角色下次摸牌阶段摸牌时，改为从牌堆或弃牌堆中获得你选择的牌。',
            minimingjie: '命戒',
            minimingjie_info: '结束阶段，你可以摸一张牌，若此牌为红色，你可以重复此流程直到摸到黑色牌或摸到第三张牌。然后若你以此法均获得红色牌，则你回复1点体力。',
            miniqiangzhi: '强峙',
            miniqiangzhi_info: '出牌阶段限一次，你可以依次弃置你和一名其他角色的共计三张牌。然后若你与其之中有角色未因此失去牌，则另一名角色对该角色造成1点伤害。',
            minijiuxian: '救陷',
            minijiuxian_info: '出牌阶段限一次，你可以重铸至多一半手牌（向上取整），然后视为使用一张【决斗】。当此牌对目标角色造成伤害后，你可以令其攻击范围内的一名其他角色回复1点体力。',
            miniyonglve: '勇略',
            miniyonglve_info: '判定区有牌的其他角色的判定阶段开始时，你可以弃置其判定区的一张牌或弃置自己一张牌，然后若其在你的攻击范围内，则你摸一张牌；若其不在你的攻击范围内，则你视为对其使用一张无距离限制的【杀】。',
            minisbluoshen: '洛神',
            minisbluoshen_info: '当你失去最后的红色手牌后，你可展示牌堆顶的一张牌，然后若此牌为：黑色，你重复此流程且可使用此牌；红色，你获得此牌。',
            minisbqingguo: '倾国',
            minisbqingguo_info: '①出牌阶段限两次，你可以将一张红色手牌交给一名其他角色，然后令其交给你一张黑色牌。②当你成为其他角色【杀】或普通锦囊牌的目标时，你可以弃置一张黑色牌，令此牌对你无效。',
            miniquji: '去疾',
            miniquji_info: '出牌阶段限一次，你可以重铸X张牌（X为你已损失的体力值+1）并令至多X名角色回复1点体力，然后仍处于受伤状态的目标角色摸一张牌。',
            miniqianxin: '遣信',
            miniqianxin_info: '出牌阶段限两次，你可将一张手牌交给一名其他角色，称为「信」。这些角色的准备阶段，若其手牌中有「信」，则其选择一项：令你摸两张牌，本回合手牌上限-2。',
            minisushou: '夙守',
            minisushou_info: '一名角色的出牌阶段开始时，若其手牌数为全场唯一最多，则你可以失去1点体力并摸X张牌。然后若该角色不是你，则你可以观看其一半的手牌（向上取整），且用至多X张手牌替换其中等量的牌。（X为你已损失的体力值）',
            minixianwei: '险卫',
            minixianwei_info: '锁定技，准备阶段，你废除一个装备栏并摸X张牌（X为你未废除的装备栏数+1），然后你令一名其他角色对其自己使用一张牌堆中的一张与此装备栏副类别相同的装备牌（没有可使用的牌则改为摸一张牌）。当你废除所有装备栏后，你加2点体力上限，然后你与所有其他角色视为在彼此的攻击范围内。',
            miniwuxie: '无胁',
            miniwuxie_info: '出牌阶段结束时，你可以选择一名其他角色，与其将手牌中所有伤害牌置入牌堆底，然后你可令你与其中的一名角色回复1点体力。',
            minisbxianmou: '先谋',
            minisbxianmou_info: '转换技。①游戏开始时，你可以转换此技能状态；②你不因使用装备牌而失去过牌的回合结束时，你可以：阳，观看牌堆顶五张牌并获得至多X张牌，若未获得X张牌则获得〖遗计〗直到再发动此项；阴，观看一名角色手牌并弃置其中至多X张牌，若弃置X张牌则你进行一次【闪电】判定。（X为你本回合不因使用装备牌而失去的牌数）',
            minisbyiji: '遗计',
            minisbyiji_info: '当你受到1点伤害后或当你每轮首次进入濒死状态时，你可以摸两张牌，然后可以将至多两张手牌交给其他角色。',
            minilianzhou: '连舟',
            minilianzhou_info: '锁定技。准备阶段，你横置你与任意名体力值大于等于你的其他角色。',
            minijilang: '惊澜',
            minijilang_info: '锁定技。当你造成伤害后，若你的手牌数：大于体力值，你弃置三张手牌；等于体力值，你弃置一张牌并回复1点体力；小于体力值，你受到1点火焰伤害并摸五张牌。',
            minichijie: '持节',
            minichijie_info: '每回合每项各限两次。①其他角色使用的牌对你结算结束后，你可以令此牌对所有后续目标无效。②其他角色使用的牌结算完成时，若你是此牌的目标之一且此牌未造成过伤害，则你可以获得此牌对应的所有实体牌。',
            minifanyin: '泛音',
            minifanyin_info: '出牌阶段限一次。你可以亮出牌堆中点数最小的一张牌。然后你选择一项，并可以亮出一张点数为此牌两倍的牌且重复此流程：⒈使用此牌（无距离和次数限制）；⒉你于本回合内使用的下一张基本牌或普通锦囊牌选择目标后，可以增加一个目标。',
            minipeiqi: '配器',
            minipeiqi_info: '当你受到伤害后，你可以移动场上至多两张牌。然后你摸一张牌。',
            miniqiongying: '琼英',
            miniqiongying_info: '出牌阶段限一次。你可以移动场上的一张牌。',
            minianshu: '安庶',
            minianshu_info: '①每轮开始时，你可以将弃牌堆中不同牌名的基本牌各一张置于牌堆顶（没有则跳过），视为使用一张由你指定起点结算的【五谷丰登】；②一名角色的回合结束时，若有角色本回合失去了本轮因〖安庶〗获得的牌，你可令其将手牌调整至体力上限（至多摸五张）。',
            minibeini: '悖逆',
            minibeini_info: '出牌阶段限一次，你可以将手牌调整至体力上限+1，然后令一名角色视为对另一名角色使用一张【杀】，且这些角色的非锁定技失效直到回合结束。',
            minishizong: '恃纵',
            minishizong_info: '当你需要使用一张基本牌时，你可以交给一名其他角色X张牌，然后其可以将一张牌置于牌堆底，视为你使用之（X为你本回合发动〖恃纵〗的次数）。',
            minirequhu: '驱虎',
            minirequhu_info: '出牌阶段限一次，你可以与一名角色拼点，若你赢，则该角色对一名由你指定的角色造成1点伤害。若你没赢，你与其各摸一张。',
            minirejieming: '节命',
            minirejieming_info: '当你受到1点伤害后或死亡时，你可令一名角色摸X张牌。然后若其手牌数大于X，则其将手牌弃置至X张，然后你获得其因此弃置的牌中位于弃牌堆且点数最大的一张（X为其体力上限且至多为5）。',
            minigaojian: '告谏',
            minigaojian_info: '当你于出牌阶段使用的锦囊牌结算完成进入弃牌堆后，你可以选择一名角色。其依次展示牌堆顶的牌直到出现锦囊牌（至多展示五张），然后选择一项：1.若其不为你，使用此牌，2.用任意张手牌与等量展示牌交换。',
            minichengxiang: '称象',
            minichengxiang_info: '锁定技，当你受到伤害后，你亮出牌堆顶的四张牌，然后获得其中任意张点数和不大于13的牌。',
            minishanjia: '缮甲',
            minishanjia_info: '出牌阶段开始时，你可以摸三张牌，然后弃置三张牌（本局游戏你每失去过一张装备牌则少弃置一张）。若你没有以此法弃置：基本牌，此阶段你使用【杀】的次数上限+1；锦囊牌，此阶段你使用牌无距离限制；基本牌和锦囊牌，你可以视为使用一张【杀】。',
            //蜀
            Mbaby_guanyu: '欢杀关羽',
            Mbaby_re_guanyu: '欢杀界关羽',
            Mbaby_zhugeliang: '欢杀诸葛亮',
            Mbaby_re_zhugeliang: '欢杀界诸葛亮',
            Mbaby_liubei: '欢杀刘备',
            Mbaby_re_liubei: '欢杀界刘备',
            Mbaby_old_liubei: `${get.poptip('rule_mamba')}刘备`,
            Mbaby_machao: '欢杀马超',
            Mbaby_re_machao: '欢杀界马超',
            Mbaby_zhurong: '欢杀祝融',
            Mbaby_ol_zhurong: '欢杀界祝融',
            Mbaby_zhangfei: '欢杀张飞',
            Mbaby_re_zhangfei: '欢杀界张飞',
            Mbaby_zhaoyun: '欢杀赵云',
            Mbaby_re_zhaoyun: '欢杀界赵云',
            Mbaby_huangzhong: '欢杀黄忠',
            Mbaby_re_huangzhong: '欢杀界黄忠',
            Mbaby_weiyan: '欢杀魏延',
            Mbaby_re_weiyan: '欢杀界魏延',
            Mbaby_liaohua: '欢杀廖化',
            Mbaby_re_liaohua: '欢杀界廖化',
            Mbaby_pangtong: '欢杀庞统',
            Mbaby_ol_pangtong: '欢杀界庞统',
            Mbaby_menghuo: '欢杀孟获',
            Mbaby_re_menghuo: '欢杀界孟获',
            Mbaby_ol_jiangwei: '欢杀姜维',
            Mbaby_liushan: '欢杀刘禅',
            Mbaby_ol_liushan: '欢杀界刘禅',
            Mbaby_xin_fazheng: '欢杀法正',
            Mbaby_re_fazheng: '欢杀界法正',
            Mbaby_madai: '欢杀马岱',
            Mbaby_guanping: '欢杀关平',
            Mbaby_liufeng: '欢杀刘封',
            Mbaby_guanyinping: '欢杀关银屏',
            Mbaby_mb_guanyinping: '欢杀界关银屏',
            Mbaby_zhangxingcai: '欢杀张星彩',
            Mbaby_dongyun: '欢杀董允',
            Mbaby_sp_sunshangxiang: 'SP欢杀孙尚香',
            Mbaby_xushu: '欢杀徐庶',
            Mbaby_xin_masu: '欢杀马谡',
            Mbaby_re_masu: '欢杀界马谡',
            Mbaby_qinmi: '欢杀秦宓',
            Mbaby_zhugezhan: '欢杀诸葛瞻',
            Mbaby_wuxian: '欢杀吴苋',
            Mbaby_shamoke: '欢杀沙摩柯',
            Mbaby_xiahoushi: '欢杀夏侯氏',
            Mbaby_guansuo: '欢杀关索',
            Mbaby_mayunlu: '欢杀马云騄',
            Mbaby_wangping: '欢杀王平',
            Mbaby_jianyong: '欢杀简雍',
            Mbaby_zhugeguo: '欢杀诸葛果',
            Mbaby_sp_zhugeliang: '欢杀卧龙',
            Mbaby_baosanniang: '欢杀鲍三娘',
            Mbaby_huaman: '欢杀花鬘',
            Mbaby_zhaoxiang: '欢杀赵襄',
            Mbaby_xiahouba: '欢杀夏侯霸',
            Mbaby_yanyan: '欢杀严颜',
            Mbaby_chendao: '欢杀陈到',
            Mbaby_liyan: '欢杀李严',
            Mbaby_liuchen: '欢杀刘谌',
            Mbaby_yangwan: '欢杀杨婉',
            Mbaby_re_huangyueying: '欢杀界黄月英',
            Mbaby_zhoucang: '欢杀周仓',
            Mbaby_lvkai: '欢杀吕凯',
            Mbaby_sunqian: '欢杀界孙乾',
            Mbaby_ganfuren: '欢杀甘夫人',
            Mbaby_liuyong: '欢杀刘永',
            Mbaby_mizhu: '欢杀糜竺',
            Mbaby_mifuren: '欢杀糜夫人',
            Mbaby_wangyue: '欢杀王悦',
            Mbaby_xf_yiji: '欢杀伊籍',
            Mbabysp_zhangfei: 'SP欢杀张飞',
            Mbaby_wangtao: '欢杀王桃',
            Mbaby_wolongfengchu: '欢杀卧龙凤雏',
            Mbaby_guanzhang: '欢杀关兴张苞',
            Mbaby_sb_liubei: '欢杀谋刘备',
            Mbaby_sb_machao: '欢杀谋马超',
            Mbaby_sb_huangzhong: '欢杀谋黄忠',
            Mbaby_sb_zhaoyun: '欢杀谋赵云',
            Mbaby_zhangyi: '欢杀张嶷',
            Mbaby_jiangfei: '欢杀蒋琬费祎',
            Mbaby_sb_sunshangxiang: '欢杀谋孙尚香',
            Mbaby_sb_xiahoushi: 'SP欢杀夏侯氏',
            Mbaby_dc_hujinding: '欢杀胡金定',
            Mbaby_re_dengzhi: '欢杀邓芝',
            Mbaby_re_mazhong: '欢杀马忠',
            Mbaby_ol_sb_guanyu: '欢杀谋关羽',
            Mbaby_zongyu: '欢杀宗预',
            Mbaby_sb_huangyueying: '欢杀谋黄月英',
            Mbaby_ol_sb_jiangwei: '欢杀谋姜维',
            Mbaby_leitong: '欢杀雷铜',
            Mbaby_wulan: '欢杀吴兰',
            Mbaby_zhaotongzhaoguang: '欢杀赵统赵广',
            Mbaby_ganfurenmifuren: '欢杀甘夫人糜夫人',
            Mbaby_huanghao: '欢杀黄皓',
            Mbaby_xianglang: '欢杀向朗',
            Mbaby_guanyue: '欢杀关樾',
            Mbaby_mifangfushiren: '欢杀糜芳傅士仁',
            Mbaby_dc_wuban: '欢杀吴班',
            miniwusheng: '武圣',
            miniwusheng_info: '锁定技。①你使用红色【杀】造成的伤害+1。②回合开始时，你从牌堆或弃牌堆中获得一张红色【杀】。',
            miniguanxing: '观星',
            miniguanxing_info: '准备阶段，你可以观看牌堆顶的X张牌（场上人数不大于2时X为3，否则X为5）并可以调整这些牌于牌堆顶或牌堆底。若你将所有牌置于牌堆底，则你可以于结束阶段再次发动〖观星〗。',
            minireguanxing: '观星',
            minireguanxing_zhuge: '诸葛连弩',
            minireguanxing_info: '①准备阶段和结束阶段，你可以观看牌堆顶的X张牌并可以调整这些牌于牌堆顶或牌堆底，若你的“星”小于X张，你可以将其中一张牌称为“星”置于你的武将牌上。②出牌阶段，你可以获得你武将牌上的所有“星”，若这些牌不小于X张，则你本回合视为装备【诸葛连弩】。（X为5，场上人数不大于2时X为3）',
            minikongcheng: '空城',
            minikongcheng_info: '锁定技，若你没有手牌，你不能成为【杀】、【决斗】和【顺手牵羊】的目标。',
            minirende: '仁德',
            minirende_info: '出牌阶段结束时，你可以令至多两名角色各摸一张牌。',
            minirerende: '仁德',
            minirerende_info: '出牌阶段，你可以将至少一张手牌交给其他角色，然后你于此阶段内不能再以此法交给该角色牌，且该角色使用红色【杀】不能指定你为目标直到你的下个回合开始；若你于此阶段内给出的牌首次达到两张，你可以视为使用一张基本牌或普通锦囊牌。',
            minijijiang: '激将',
            minijijiang_info: '主公技。当你需要使用或打出【杀】时，蜀势力角色可以代替你进行此操作，若如此做，你与响应【激将】的角色各摸一张牌。',
            minirejijiang: '激将',
            minirejijiang_info: '主公技。①当你需要使用或打出【杀】时，蜀势力角色可以代替你进行此操作，若如此做，你与响应【激将】的角色各摸一张牌。②每回合限一次，你的回合外，一名其他蜀势力角色使用或打出【杀】时，其可以令你摸一张牌。',
            miniyuma: '驭马',
            miniyuma_info: '锁定技，你计算与其他角色的距离-1；当你失去装备区中的坐骑牌时，你摸两张牌。',
            minitieji: '铁骑',
            minitieji_info: '当你使用【杀】指定目标后，你可以进行一次判定，若判定结果为：红色，其不能响应此【杀】；黑色，你摸一张牌。',
            miniretieji: '铁骑',
            miniretieji_info: '当你使用【杀】指定目标后，你可以令目标角色本回合非锁定技失效，然后你进行一次判定，若判定结果为：红色，其不能响应此【杀】；黑色，你摸两张牌。',
            minijuxiang: '巨象',
            minijuxiang_info: '锁定技。①【南蛮入侵】对你无效。②其他角色弃置【南蛮入侵】后，你获得之。③其他角色使用【南蛮入侵】结算完毕后，你获得此牌对应的所有实体牌，若此牌造成伤害，你摸一张牌。',
            minilieren: '烈刃',
            minilieren_info: '锁定技，每回合限两次，当你使用【杀】对目标角色造成伤害后，你弃置目标角色一张手牌，若此牌点数小于【杀】的点数，你获得此牌。',
            minirelieren: '烈刃',
            minirelieren_info: '当你使用【杀】指定目标后，你可以和目标角色进行拼点，然后你获得其的拼点牌。若你赢，你获得其一张牌。',
            minitishen: '替身',
            minitishen_info: '你的回合外，当目标角色含有你的【杀】结算完毕后，若你未受到此牌造成的伤害，则你获得此牌。',
            miniretishen: '替身',
            miniretishen_info: '你的回合外，当目标角色含有你的【杀】结算完毕后，若你未受到此牌造成的伤害，则你获得此牌。当你使用的【杀】被【闪】抵消后，你本阶段使用的下一张【杀】不可被响应且造成的伤害+1。',
            miniyajiao: '涯角',
            miniyajiao_info: '锁定技，每轮限一次，当你于回合外使用或打出【杀】或【闪】时，你摸一张牌。',
            minireyajiao: '涯角',
            minireyajiao_info: '当你于回合外使用或打出一张手牌时，你可以亮出牌堆顶的一张牌，并可以将之交给任意一名角色。结束阶段，若你本回合发动过〖龙胆〗，你摸一张牌。',
            miniliegong: '烈弓',
            miniliegong_info: '当你使用【杀】指定目标后，若目标角色的手牌数或体力值不小于你，则该角色不能响应此【杀】。',
            minireliegong: '烈弓',
            minireliegong_info: '你的攻击范围无限。当你使用【杀】指定目标后，若目标角色的手牌数不大于你，则该角色不能响应此【杀】；若目标角色的体力值不小于你，此【杀】伤害+1。',
            minikuanggu: '狂骨',
            minikuanggu_info: '当你对一名角色造成1点伤害后，你可以回复1点体力或摸一张牌。',
            miniqimou: '奇谋',
            miniqimou_info: '限定技，出牌阶段，你可以失去任意点体力并摸一张牌，本回合你计算与其他角色的距离-X且你可以多使用X张【杀】（X为你失去的体力值）。',
            minidangxian: '当先',
            minidangxian_info: '回合开始时，你进行一个额外的出牌阶段并从牌堆中获得一张【杀】。',
            minifuli: '伏枥',
            minifuli_info: '限定技，当你处于濒死状态时，你可以将体力回复至X点并将手牌数摸至X张，然后若X大于3，你翻面（X为全场势力数）。',
            minilianhuan: '连环',
            minilianhuan_info: '出牌阶段开始时，你可以选择至多两名角色，这些角色重置或横置其武将牌，然后若你也是【连环】的目标角色，则你摸一张牌。',
            minirelianhuan: '连环',
            minirelianhuan_info: '①出牌阶段开始时，你可以视为使用【铁索连环】。②你使用【铁索连环】可以额外指定任意名目标，若以此法指定的目标包含你，则你摸一张牌。③当你使用【铁索连环】指定未横置的其他角色后，你随机弃置其一张手牌。',
            mininiepan: '涅槃',
            mininiepan_info: '限定技，当你处于濒死状态时，你可以弃置你区域内的所有牌并复原你的武将牌，然后摸三张牌并将体力回复至3点。然后你选择一项：①获得〖八阵〗；②获得〖火计〗和〖看破〗。',
            minihuoshou: '祸首',
            minihuoshou_info: '锁定技，【南蛮入侵】对你无效；当其他角色使用【南蛮入侵】时，你代替其成为此牌的伤害来源并摸一张牌。',
            minirehuoshou: '祸首',
            minirehuoshou_info: '锁定技。①【南蛮入侵】对你无效。②当其他角色使用【南蛮入侵】时，你代替其成为此牌的伤害来源并摸一张牌。③出牌阶段开始时，你随机获得弃牌堆中的一张【南蛮入侵】。④出牌阶段，若你于此阶段使用过【南蛮入侵】，你不能使用【南蛮入侵】。',
            minizaiqi: '再起',
            minizaiqi_info: '摸牌阶段，若你已受伤，则你可以改为亮出牌堆顶的X张牌（X为你已损失的体力值），然后你回复X点体力（X为其中♥牌的数目）并获得其中的非♥牌。',
            minirezaiqi: '再起',
            minirezaiqi_info: '①摸牌阶段，若你已受伤，则你可以改为亮出牌堆顶的X张牌（X为你已损失的体力值），并回复X点体力（X为其中♥牌的数目）。然后你将这些♥牌置入弃牌堆，并获得其余的牌。②结束阶段，你可以发动一次X为你本回合造成的伤害值的〖再起①〗。',
            minitiaoxin: '挑衅',
            minitiaoxin_info: '出牌阶段开始时，你可以弃置一名其他角色至多两张手牌，然后若弃置的牌中含有【杀】，你弃置一张牌。',
            minizhiji: '志继',
            minizhiji_info: '觉醒技，准备阶段，若你没有手牌，你须回复1点体力或摸两张牌，然后减1点体力上限，并获得〖观星〗。',
            minifangquan: '放权',
            minifangquan_info: '你可以跳过你的出牌阶段，然后于此回合结束时选择一名其他角色，其进行一个额外回合。',
            miniruoyu: '若愚',
            miniruoyu_info: '主公技，觉醒技。准备阶段，若你的体力值为全场最少，你增加1点体力上限并回复1点体力，然后获得〖激将〗。',
            minixiangle: '享乐',
            minixiangle_info: '锁定技。①当你成为一名角色使用【杀】的目标后，除非该角色弃置一张牌，否则此【杀】对你无效。②每轮结束时，若你本轮未使用过牌，你可以弃置X张牌并翻面，然后发动〖放权〗（X为你座次的一半，向下取整）。',
            minirefangquan: '放权',
            minirefangquan_info: '你可以跳过你的出牌阶段，然后于弃牌阶段开始时选择一名其他角色，你可以交给其任意张牌并令其于本回合结束后进行一个额外回合。',
            minireruoyu: '若愚',
            minireruoyu_info: '主公技，觉醒技。准备阶段，若你的体力值为全场最少，你增加1点体力上限并回复1点体力，然后获得〖激将〗和〖思蜀〗。',
            minienyuan: '恩怨',
            minienyuan_info: '当你获得一名其他角色的牌后，你可以令其摸一张牌；其他角色获得你的牌后，你摸一张牌。',
            minixuanhuo: '眩惑',
            minixuanhuo_info: '摸牌阶段，你可以选择一名其他角色，除非该角色对你选择的另一名角色使用一张【杀】，否则你获得其一张牌。',
            minireenyuan: '恩怨',
            minireenyuan_info: '①当你获得一名其他角色的牌后，你可以令其摸一张牌；其他角色获得你的牌后，你可以摸一张牌。②当你受到1点伤害后，你可以令伤害来源选择一项：1.交给你一张红色手牌，然后若此牌不为红桃牌，你摸一张牌；2.失去1点体力。',
            minirexuanhuo: '眩惑',
            minirexuanhuo_info: '摸牌阶段结束时，你可以交给一名其他角色至多两张手牌，然后其选择一项：1.视为对你选择的另一名其他角色使用任意一张【杀】或【决斗】；2.你观看并获得其任意张手牌。',
            miniqianxi: '潜袭',
            miniqianxi2: '潜袭',
            miniqianxi_info: '准备阶段，你可以摸两张牌并弃置其中的一张，然后你令一名与你距离为1的角色于本回合无法使用或打出与你弃置的牌颜色相同的手牌。',
            minilongyin: '龙吟',
            minilongyin_info: '当一名角色于其出牌阶段使用【杀】时，你可弃置一张牌令此【杀】不计入出牌阶段使用次数。若此【杀】为红色，则你摸一张牌；若你以此法弃置的牌与此【杀】的花色相同，则你重置〖竭忠〗。',
            minixiansi: '陷嗣',
            minixiansi_info: '准备阶段，你可以弃置至多两名其他角色的各一张牌。若你弃置的是装备区里的牌且你在目标角色的攻击范围内，其视为对你使用一张【杀】。结算完成后，若〖陷嗣〗只选择了一名角色，则你摸一张牌。',
            minibingzheng: '秉正',
            minibingzheng_info: '出牌阶段结束时，你可以令一名角色弃置一张手牌或摸一张牌。然后若其手牌数等于体力值，你摸一张牌，且你可以交给该角色一张牌。',
            miniliangzhu: '良助',
            miniliangzhu_info: '当一名角色于其出牌阶段内回复体力时，你可以选择一项：1、摸一张牌；2、令该角色摸两张牌；3、获得该角色装备区里的武器牌。',
            minifanxiang: '返乡',
            minifanxiang_info: '觉醒技，准备阶段，若你已发动过〖良助〗，你加1点体力上限并回复1点体力，失去〖良助〗并获得〖枭姬〗和〖舞剑〗。',
            miniwujian: '舞剑',
            miniwujian_info: '出牌阶段，你可以将装备区中的牌当作【杀】使用（每个装备栏每回合限一次，且该【杀】不计入次数限制）。',
            minijujian: '举荐',
            minijujian_info: '准备阶段和结束阶段，你可以弃置一张非基本牌并选择一名角色，令其选择一项：1.摸两张牌；2.回复1点体力；3.将其武将牌翻转至正面朝上并重置之。',
            minihuxiao: '虎啸',
            minihuxiao_info: '锁定技。当你对一名角色造成火属性伤害后，你本回合内对其使用牌没有次数限制。',
            miniwuji: '武继',
            miniwuji_info: '觉醒技，结束阶段，若你于此回合内造成过3点或更多伤害，则你加1点体力上限并回复1点体力，然后从场上、牌堆或弃牌堆中获得【青龙偃月刀】。',
            minixueji: '雪恨',
            minixueji_info: '出牌阶段限一次，你可以弃置一张红色牌，然后选择至多X名角色，横置这些角色并对其中一名角色造成1点火焰伤害（X为你已损失的体力值+1）。',
            minirehuxiao: '虎啸',
            minirehuxiao_info: '锁定技。当你对一名角色造成火属性伤害后，你摸一张牌且本回合内对其使用牌没有次数限制。',
            minirehuxiao_rewrite: '虎啸·改',
            minirehuxiao_rewrite_info: '锁定技。①回合开始时，你获得一张红色【杀】；②当你对一名角色造成火属性伤害后，你摸一张牌且本回合内对其使用牌没有次数限制。',
            minirewuji: '武继',
            minirewuji_info: '觉醒技，结束阶段，若你于此回合内造成过3点或更多伤害，则你加1点体力上限并回复1点体力，然后从场上、牌堆或弃牌堆中获得【青龙偃月刀】并修改〖虎啸〗。',
            miniresanyao: '散谣',
            miniresanyao_info: '出牌阶段限一次，你可以弃置至多四张牌并对等量的其他角色各造成1点伤害。',
            minisanyao: '散谣',
            minisanyao_info: '锁定技，每回合限一次，当你使用牌指定其他角色为目标后，若其为场上除你以外体力值最大的角色，你对其造成1点伤害。',
            minizhiman: '制蛮',
            minizhiman_info: '当你对一名其他角色造成伤害时，你可以防止此伤害，然后获得其装备区或判定区的一张牌。',
            minizhuandui: '专对',
            minizhuandui_info: '当你使用【杀】指定目标/成为【杀】的目标后，你可以与目标角色/此【杀】使用者拼点，若你赢，此杀不能被【闪】响应/对你无效。当你拼点胜利后，你摸一张牌。',
            minizuilun: '罪论',
            minizuilun_info: '结束阶段，你可以观看牌堆顶的四张牌，你每满足以下一项便保留一张，然后以任意顺序放回其余的牌：1.你于此回合内造成过伤害；2.你于此回合内未弃置过牌；3.手牌数为全场最少。若均不满足，你选择一名其他角色，与其各失去1点体力。',
            miniqiangwu: '枪舞',
            miniqiangwu_info: '出牌阶段，你可以进行判定并获得判定牌。然后直到回合结束，你使用点数小于判定结果的【杀】时不受距离限制，且你使用点数大于判定结果的【杀】时无使用次数限制。',
            minixiantu: '献图',
            minixiantu_info: '一名其他角色的出牌阶段开始时，你可以摸两张牌，然后交给其两张牌。若如此做，此阶段结束时，若该角色本阶段未造成过伤害，你失去1点体力。',
            minifumian: '福绵',
            minifumian_info: '准备阶段，你可以选择一项：1.摸牌阶段多摸一张牌；2.使用红色牌可以多选择一个目标。若与你上回合选择的选项不同，则该选项数值+1并复原此技能。',
            minidaiyan: '怠宴',
            minidaiyan_info: '结束阶段，你可以令一名角色从牌堆中获得一张红桃基本牌，然后若其于上回合未成为过此技能的目标，则你摸一张牌。',
            minijili: '蒺藜',
            minijili_info: '当你于一回合内使用或打出第X张牌时，你可以摸X张牌（X为你的攻击范围）。结束阶段，你可以弃置一张牌并摸一张牌。',
            miniqiaoshi: '樵拾',
            miniqiaoshi_info: '其他角色的结束阶段，若其手牌数不小于你，你可以与其各摸一张牌。',
            miniyanyu: '燕语',
            miniyanyu_info: '出牌阶段，你可以重铸【杀】。回合结束时，若你本回合因〖燕语〗重铸过【杀】，则你可以令一名角色摸一张牌（若该角色不为你则改为摸两张牌）。',
            minizhengnan: '征南',
            minizhengnan_info: '当一名角色进入濒死状态时，若你未因其发动过〖征南〗，则你回复[1]点体力并摸[1]张牌，然后获得下列技能中的任意一个：〖武圣〗、〖当先〗和〖制蛮〗（若技能全部拥有则改为摸[3]张牌，若你因自己发动〖征南〗，则本次技能结算中所有[ ]中的数值+1）。',
            minixiefang: '撷芳',
            minixiefang_info: '锁定技，你计算与其他角色的距离时-X，你的手牌上限+X（X为女性角色数且X至少为1）。',
            minifengpo: '凤魄',
            minifengpo_info: '当你于回合内第一次使用【杀】或【决斗】指定一个目标后，你可以选择一项：1.摸X张牌；2.令此牌的伤害值基数+X。（X为其手牌中红色牌的数量且X至多为4）',
            minifeijun: '飞军',
            minifeijun_info: '出牌阶段限一次，你可以弃置一张牌，然后选择一项：⒈令一名其他角色交给你一张牌；⒉令一名其他角色弃置一张装备区的牌。',
            minibinglve: '兵略',
            minibinglve_info: '锁定技，当你发动〖飞军〗时，你摸一张牌，若目标角色与你之前指定的目标均不相同，则你再摸X张牌（X为成为过你发动〖飞军〗目标的存活角色数）。',
            miniqiaoshui: '巧说',
            miniqiaoshui_info: '①你的锦囊牌不计入手牌上限。②出牌阶段，你可与一名其他角色拼点。若你赢，你使用的下一张基本牌或普通锦囊牌可以增加或减少一个目标；若你没赢，你本回合不能再发动〖巧说②〗。',
            miniqirang: '祈禳',
            miniqirang_info: '①当你使用装备牌，你可获得牌堆中的一张锦囊牌。②当你使用锦囊牌指定唯一目标时，你可以为此牌额外指定一个目标。',
            miniyuhua: '羽化',
            miniyuhua_info: '锁定技。①你的非基本牌不计入手牌上限。②结束阶段，你观看牌堆顶的两张牌，将其中一张牌置于牌堆顶或牌堆底，然后获得另一张牌。',
            minibazhen: '八阵',
            minibazhen_info: '锁定技。①若你的装备区没有防具牌，你视为装备【八卦阵】。②当你的【八卦阵】判定失效时，你摸一张牌。',
            minihuoji: '火计',
            minihuoji_info: '①你可以将一张红色牌当作【火攻】使用。②当你使用【火攻】需要弃牌时，你可以观看牌堆顶的四张牌，选择其中一张符合要求的牌作为需要弃置的牌，然后将其余的牌放回牌堆顶。',
            minixushen: '许身',
            minixushen2: '许身',
            minixushen_info: '限定技，当你进入濒死状态后，你可以回复1点体力并获得〖镇南〗，然后若你脱离濒死状态且“欢杀关索”不在场，你可令一名其他角色选择是否用“欢杀关索”代替其武将并令其摸三张牌。',
            minisouying: '薮影',
            minisouying_info: '每回合限一次，当你对其他角色（或其他角色对你）使用【杀】或普通锦囊牌指定唯一目标后，你可以弃置一张牌。若如此做，你获得此牌对应的所有实体牌（或令此牌对你无效）。',
            minizhanyuan: '战缘',
            minizhanyuan_info: '觉醒技，你的回合内，当你因〖蛮嗣〗累计获得超过7张牌后，你可以选择一名其他角色。若如此做，你与其获得〖系力〗，然后你失去〖蛮嗣〗。',
            minifuhan: '扶汉',
            minifuhan_info: '限定技，回合开始时，你可以移去所有"梅影"标记并摸等量的牌，然后从欢杀将池中的随机X张存在于武将牌堆的蜀势力武将牌中选择并获得至多两个技能（限定技、觉醒技、隐匿技、使命技、主公技除外）。若此时你是体力值最低的角色，你回复1点体力（X为场上角色数，且X至少为4）。',
            minibaobian: '豹变',
            minibaobian_info: '锁定技，当你受到伤害后，你获得以下未获得的第一个技能：〖挑衅〗、〖咆哮〗、〖神速〗。',
            minijuzhan: '拒战',
            minijuzhan_info: '当你成为其他角色【杀】的目标后，你可以与其各摸一张牌，然后其本回合内不能再对你使用牌。当你使用【杀】指定一名角色为目标后，你可以获得其一张牌，然后你本回合内不能再对其使用红色【杀】。',
            miniwanglie: '往烈',
            miniwanglie2: '往烈',
            miniwanglie_info: '出牌阶段，你使用牌无距离限制。当你于出牌阶段内使用牌时，你可以令此牌不能被响应，且本回合结束时，你摸等同于此牌造成的伤害数的牌，然后你本回合不能再使用牌。',
            miniduliang: '督粮',
            miniduliang2: '督粮',
            miniduliang_info: '出牌阶段限一次，你可以获得一名其他角色的一张手牌，然后选择一项：1.令其观看牌堆顶的两张牌，然后获得其中的基本牌和装备牌；2.令其于下个摸牌阶段额外摸一张牌，然后交给你一张牌。',
            minizhanjue: '战绝',
            minizhanjue_info: '出牌阶段，若你本阶段内因〖战绝〗获得过的牌数小于3，则你可以将所有手牌当做【决斗】使用。此【决斗】使用结算结束后，你摸一张牌，然后所有因此【决斗】受到过伤害的角色也各摸一张牌。若你因此【决斗】受到过伤害，则你可以弃置伤害来源的一张牌。',
            miniqinwang: '勤王',
            miniqinwang_info: '主公技。出牌阶段限一次，你可以令所有其他蜀势力角色依次选择是否交给你一张基本牌，然后你可以令选择是的角色摸一张牌（以此法获得的牌本回合不计算在〖战绝〗使用的牌中）。',
            miniyouyan: '诱言',
            miniyouyan_info: '①出牌阶段限一次，你可以弃置任意张牌。②出牌阶段/弃牌阶段各限一次，当你的牌因弃置进入弃牌堆后，你可以从牌堆中获得本次弃牌中没有的花色的牌各一张。',
            minijizhi: '集智',
            minijizhi_info: '当你使用锦囊牌时，你可以摸一张牌。若此牌为：基本牌，你本回合手牌上限+1；锦囊牌，你本回合使用【杀】的额定次数+1；装备牌，你可以将此牌置入一名其他角色的装备区。',
            miniqicai: '奇才',
            miniqicai_info: '锁定技，你使用锦囊牌无距离限制，你装备区内的武器牌和防具牌不能被其他角色弃置。',
            minizhongyong: '忠勇',
            minizhongyong_info: '当你使用的【杀】结算完毕后，你可以将此【杀】或目标角色使用的【闪】交给一名目标角色以外的其他角色，若其中包含：红色牌，获得牌的角色可以对你攻击范围内的角色使用一张【杀】；黑色牌，你与获得牌的角色各摸一张牌。',
            minidaopu: '刀仆',
            minidaopu_info: '锁定技，若你的你的武器栏未被废除且装备区中没有武器牌，则你视为装备【青龙偃月刀】；若你的装备区中有【青龙偃月刀】，则你使用红色【杀】造成的伤害+1。',
            minitunan: '图南',
            minitunan_info: '出牌阶段限一次，你可以选择至多两名角色，这些角色依次亮出牌堆顶的一张牌并选择一项：使用此牌（无距离限制）；将此牌当作普通【杀】使用。',
            miniqianya: '谦雅',
            miniqianya_info: '当你成为锦囊牌的目标后，你可以将任意张手牌交给一名其他角色，然后你从牌堆中获得一张非装备牌。',
            minishushen: '淑慎',
            minishushen_info: '①一名角色受到伤害时，你可以失去1点体力并防止此伤害，然后你与其各摸一张牌。②当你回复1点体力后，你可以令一名其他角色摸一张牌。',
            minihuangsi: '皇思',
            minihuangsi_info: '限定技，当你处于濒死状态时，你可以将体力值回复至1并弃置所有手牌，然后你可以令一名角色摸X+2张牌（X为你以此法弃置的手牌数）。',
            minifengxiang: '封乡',
            minifengxiang_info: '锁定技，当你受到伤害后，你摸一张牌，然后若场上存在手牌中“隙”唯一最多的角色，则其回复1点体力。',
            miniziyuan: '资援',
            miniziyuan_info: '出牌阶段限一次，你可以将任意张手牌交给一名其他角色，若这些牌的点数之和：不小于13，该角色回复1点体力；不大于13，你摸一张牌。',
            minijugu: '巨贾',
            minijugu_info: '锁定技。①你的手牌上限+X。②回合开始时，你可以视为对至多X名角色使用【五谷丰登】。（X为你的体力上限）',
            miniguixiu: '闺秀',
            miniguixiu_info: '锁定技，每回合限一次，结束阶段，若你的体力值为：奇数，你摸一张牌；偶数，你回复1点体力。',
            miniguixiux: '闺秀·改',
            miniguixiux_info: '锁定技，每回合限一次，结束阶段或当你进入濒死状态时，若你的体力值为：奇数，你摸一张牌；偶数，你回复1点体力。',
            minicunsi: '存嗣',
            minicunsi_info: '限定技，出牌阶段，你可以令一名其他角色获得〖勇决〗，然后修改技能〖闺秀〗，最后你失去所有体力并令其摸X张牌（X为你失去的体力数+1）。',
            miniyongjue: '勇决',
            miniyongjue_info: '①其他角色出牌阶段使用的第一张【杀】结算完毕后，你可以获得之。②当你受到有点数的【杀】造成的伤害时，你可以弃置一张点数大于等于此【杀】点数的牌并防止此伤害。',
            minihuguan: '护关',
            minihuguan_info: '一名角色于其出牌阶段使用第一张红色牌时，你可以选择一个花色并选择一项：①令其本回合此花色的牌不计入手牌上限；②令其本回合不能弃置此花色的手牌。',
            minimingluan: '鸣鸾',
            minimingluan_info: '其他角色的结束阶段，若本回合有角色回复过体力，你可以摸等同于当前回合角色手牌数的牌，然后将手牌弃至五张。',
            minijijie: '机捷',
            minijijie_info: '①出牌阶段限一次，你可以观看牌堆底的一张牌，然后将其交给任意一名角色。②每轮限一次，一名角色于其出牌阶段内一次性得到超过一张牌时，你可以发动〖机捷①〗。',
            minijiyuan: '急援',
            minijiyuan_info: '①当你交给一名其他角色牌时，你可令该角色摸一张牌。②当一名角色进入濒死时，你可令其摸X张牌并清空〖机捷①〗的发动计数（X为你发动〖机捷①〗的次数）。',
            minipaoxiao: '咆哮',
            minipaoxiao_info: '锁定技。①你使用【杀】无距离和次数限制。②你使用本回合第一次之后的【杀】造成的伤害+1，使用本回合第二次之后的【杀】无视防具且不可被响应。',
            minixuhe: '虚吓',
            minixuhe_info: '锁定技，当你使用【杀】被【闪】抵消后，或你使用或打出【闪】时，你与对方各摸一张牌。',
            minirewusheng: '武圣',
            minirewusheng_info: '①回合开始时，你从牌堆或弃牌堆中获得一张红色牌。②你可以将一张红色牌当作【杀】使用或打出。③你使用的红色【杀】造成的伤害+1。',
            minituodao: '拖刀',
            minituodao_info: '锁定技，当你使用或打出【闪】时，你令你使用的下一张【杀】的伤害基数+1。',
            miniyaopei: '摇佩',
            miniyaopei_info: '其他角色的弃牌阶段结束时，若其本阶段弃置过牌，则你可以弃置一张牌。若此牌与其本阶段弃置的任意牌的花色相同，你回复1点体力并摸两张牌；否则你选择一项：①其摸两张牌，你回复1点体力。②其回复1点体力，你摸两张牌。',
            miniyoulong: '游龙',
            miniyoulong_info: '转换技，每回合每项各限一次。阴，你可以废除你的一个装备栏，视为使用一张未以此法使用过的普通锦囊牌；阳，你可以弃置一张非基本牌，视为使用一张未以此法使用过的基本牌。',
            miniluanfeng: '鸾凤',
            miniluanfeng_info: '限定技，一名角色进入濒死状态时，若其体力上限不小于你，你可令其回复至3点体力，恢复你与其被废除的装备栏，令其手牌补至6张，取消〖游龙〗的回合限制并重置〖游龙〗使用过的牌名。',
            minifuhun: '父魂',
            minifuhun_info: '①你可以将两张手牌当做【杀】使用或打出。②当你于出牌阶段因〖父魂①〗使用的【杀】造成伤害后，你获得〖武圣〗和〖咆哮〗直到回合结束。③当你于一回合内不为首次使用使用的【杀】造成伤害后，你获得〖武圣〗和〖咆哮〗。',
            minisbrende: '仁德',
            minisbrende_info: '①出牌阶段每名角色限一次，你可以将任意张牌交给一名其他角色，然后你获得等量“仁望”标记（至多为10）。②每回合限一次，你可以移去2/3枚“仁望”，视为使用或打出一张基本牌/普通锦囊牌。③出牌阶段开始时，你获得3枚“仁望”。',
            minisbzhangwu: '章武',
            minisbzhangwu_info: '限定技，出牌阶段，你可以令所有于本局游戏成为过〖仁德①〗目标的其他角色依次交给你X张牌，然后你回复3点体力，本回合〖仁德〗失效（X为游戏轮数-1，且至多为3）。',
            minisbjijiang: '激将',
            minisbjijiang_info: '主公技，出牌阶段结束时，你可以选择一名其他蜀势力角色A和一名在A攻击范围内的角色B。A选择一项：1.视为对B使用一张【杀】；2.下一个出牌阶段开始前，跳过此阶段。',
            minisbtieji: '铁骑',
            minisbtieji_info: '①当你使用【杀】指定其他角色为目标后，你可以令目标角色不能响应此【杀】，且其所有非锁定技失效直到回合结束。然后你与其进行谋弈。若你赢，且你选择的选项为：“直取敌营”，则你获得其一张牌；“扰阵疲敌”，你摸两张牌。②当你谋弈成功后，你本回合使用【杀】的次数上限+1，然后你可以弃置一张牌并从牌堆或弃牌堆获得一张【杀】。',
            minisbliegong: '烈弓',
            minisbliegong_info: '若你的装备区内没有武器牌，则你手牌区内所有【杀】的属性视为无属性。当你使用牌时或成为其他角色使用牌的目标后，若此牌有花色且你未记录此牌的花色，你记录此牌的花色。当你使用【杀】指定唯一目标后，若〖烈弓〗存在记录花色，则你可亮出并获得牌堆顶的X张牌（X为〖烈弓〗记录过的花色数-1），令此【杀】的伤害值基数+Y（Y为亮出牌中被〖烈弓〗记录过花色的牌的数量），且目标角色不能使用〖烈弓〗记录过花色的牌响应此【杀】。此【杀】使用结算结束后，你清除〖烈弓〗记录的的花色。',
            minisblongdan: '龙胆',
            minisblongdan_info: '蓄力技（1/3）。①你可以消耗1点蓄力值，将一张基本牌当作任意基本牌使用或打出，然后你摸一张牌。②一名角色的回合结束时，你获得1点蓄力值。',
            minisbshilve: '识略',
            minisbshilve_info: '当你发动〖龙胆〗使用或打出【杀】或【闪】时，你可以和对方进行谋弈。若你赢，且你选择的选项为：“偃旗息鼓”，从牌堆或弃牌堆获得一张非基本牌；“胆壮心雄”，你获得1点蓄力值。',
            minishizhi: '矢志',
            minishizhi_info: '锁定技，若当前回合角色为你，则你的【闪】视为【杀】，且当你使用对应的实体牌为一张【闪】的非转化普通杀造成伤害后，你回复1点体力。',
            minishoucheng: '守成',
            minishoucheng_info: '每回合限一次，一名角色于回合外失去手牌后，若其手牌数小于其体力值，则你可以令其摸两张牌。',
            minisbxiaoji: '枭姬',
            minisbxiaoji_info: '当你失去装备区里的一张牌后，你摸两张牌，然后可以弃置场上的一张牌。',
            minisbjieyin: '结姻',
            minisbjieyin_info: '①游戏开始时，你可以选择一名其他角色，你与其各获得1枚“姻”标记，然后令其获得〖结姻〗，最后你将势力变更至与其相同。②出牌阶段限一次，你可以将一张手牌交给一名有“姻”的其他角色或将一张装备牌置入一名有“姻”的其他角色的对应空置装备栏，然后你回复1点体力并摸一张牌。③拥有“姻”标记的角色死亡时，你获得其区域内所有的牌。',
            minisbfanxiang: '返乡',
            minisbfanxiang_info: '限定技，出牌阶段，你可以获得场上所有有“姻”标记的其他角色的装备区的牌，然后移去场上的所有“姻”标记并令所有角色失去〖结姻〗，最后你获得〖舞剑〗，将势力更换为吴。',
            minispyanyu: '燕语',
            minispyanyu_info: '一名角色的出牌阶段开始时，你可以弃置一张牌。若如此做，则此回合出牌阶段内限两次，当一张与你弃置的牌类别相同的其他牌进入弃牌堆后，你可令任意一名角色获得此牌。',
            miniwuyuan: '武缘',
            miniwuyuan_info: '出牌阶段限一次。你可将一张【杀】交给一名其他角色，然后你回复1点体力，你与其各摸一张牌。若此【杀】为：红色【杀】，其回复1点体力：黑色，其下回合使用【杀】的次数上限+1；属性【杀】，其改为摸两张牌。',
            miniweimeng: '危盟',
            miniweimeng_info: '出牌阶段限一次，你可以获得一名其他角色的至多X张手牌，然后交给其等量的牌（X为你的体力值）。若你给出的牌点数之和：大于得到的牌，则你摸一张牌；小于得到的牌，弃置该角色区域内的一张牌；等于得到的牌，你下一次发动〖危盟〗时的X改为“你的体力值+1”。',
            minifuman: '抚蛮',
            minifuman_info: '出牌阶段每名角色限一次。你可以弃置一张牌，令一名其他角色从牌堆中获得一张【杀】。然后其失去此【杀】后，你与其各摸一张牌。此【杀】结算完成后，若此【杀】造成过伤害，你摸一张牌。',
            miniweilin: '威临',
            miniweilin_info: '①每回合限一次，你可以将一张牌当作任意【杀】/【酒】/【忠】/【义】使用，且目标角色本回合与此牌颜色相同的手牌均视为【杀】。②当你使用或打出牌后，若此牌为你本局使用或打出的7的倍数张，则你可以获得一张【水淹七军】。',
            mini_zhong: '忠',
            mini_zhong_info: '当其他角色受到伤害时，使用此牌，将此伤害转移给自己。',
            mini_yi: '义',
            mini_yi_info: '出牌阶段，对一名有手牌的其他角色使用，令其交给你一张牌，然后其获得此【义】对应的实体牌。',
            miniduoshou: '夺首',
            miniduoshou_info: '锁定技。①你每回合使用的第一张红色牌无距离限制。②你每回合使用的第一张基本牌不计入使用次数。③你每回合使用的第一张【杀】指定目标后摸两张牌。④你每回合第一次造成伤害后，你获得受伤角色的一张牌。',
            minichengshang: '承赏',
            minichengshang_info: '出牌阶段限一次，当你于使用牌后，你可以从牌堆中获得所有与此牌花色点数相同的牌（你以此法获得的牌本回合不计入手牌上限）。若你未以此法获得牌，此技能视为未发动过。',
            miniliuma: '流马',
            miniliuma_info: '①出牌阶段结束时，你可以将至多X张手牌置入“流马”区（X为你的体力值，“流马”区至多存在五张牌）。②每轮开始时，若场上仅你拥有【流马】，则你可以令一名其他角色获得不能发动此项的【流马】。③你可以使用或打出“流马”区的牌。',
            minisbjizhi: '集智',
            minisbjizhi_info: '锁定技。①当你使用非转化锦囊牌时，你摸一张牌。②你使用锦囊牌无距离限制。',
            minisbqicai: '奇才',
            minisbqicai_info: '转换技，①游戏开始时，你可以转换此技能状态。②阳：每回合限两次，当你使用普通锦囊牌时，你可以为此牌增加或减少一个目标；阴：每回合限两次，出牌阶段，你可以弃置一张基本牌，然后从牌堆中获得一张锦囊牌。',
            miniranji: '燃己',
            miniranji_info: '限定技，结束阶段。若你本回合使用过牌的阶段数大于等于/小于等于体力值，你可以获得〖困奋〗/〖诈降〗（同时满足则都获得）。若如此做，你将手牌数调整至手牌上限并将体力值回复至体力上限，然后你不能回复体力直到你杀死角色。',
            minikuiji: '溃击',
            minikuiji_info: '出牌阶段限一次，你可以将一张黑色基本牌当做【兵粮寸断】置于你的判定区，摸两张牌，然后你可以对体力值最多的一名其他角色造成2点伤害。该角色因此进入濒死状态时，你可令一名角色回复1点体力。',
            minicuorui: '挫锐',
            minicuorui_info: '出牌阶段开始时，你可以弃置一名你至其的距离不大于1的角色区域里的一张牌，然后你选择一项：1.弃置另一名其他角色装备区里至多两张与此牌颜色相同的牌；2.弃置另一名其他角色的至多两张手牌，然后获得其中与此牌颜色相同的牌。',
            miniqingren: '青刃',
            miniqingren_info: '一名角色的结束阶段，你可以摸X张牌（X为你本回合使用或打出的非虚拟基本牌数）。',
            minixunbie: '殉别',
            minixunbie_info: '限定技。当你进入濒死状态时，你可以将此武将牌替换为“甘夫人”或“糜夫人”（不能选择已在场上的武将）。然后回复至1点体力并防止所有伤害直到本回合结束。',
            miniqinqing: '寝情',
            miniqinqing_info: '结束阶段，你可以弃置任意名攻击范围内包含一号位的其他角色各一张牌，然后你摸等量张牌。',
            minicunwei: '存畏',
            minicunwei_info: '锁定技。当你成为锦囊牌的目标后，你摸一张牌，然后若你不是唯一目标，你弃置一张牌。',
            miniqianzheng: '愆正',
            miniqianzheng_info: '每回合限两次。当你使用【杀】或成为其他角色使用【杀】或普通锦囊牌的目标后，你可以重铸两张牌。若你以此法重铸的牌中没有与指定你为目标的牌类别相同的牌，你于此牌对应的实体牌进入弃牌堆后获得此牌对应的所有实体牌。',
            minifenhui: '奋恚',
            minifenhui_info: `限定技。出牌阶段，你可以令一名角色获得X枚“恨”标记，你摸等量的牌（X为本局游戏你使用牌指定其为目标的次数，至多为5）。你获得如下效果：⒈当其受到伤害时，你移去其1枚“恨”，令此伤害+1；⒉当其死亡时，你减1点体力上限，修改${get.poptip('dcshouzhi')}并获得${get.poptip('dcxingmen')}。`,
            minifengshi: '锋势',
            minifengshi_info: '当你使用牌指定第一个目标后，你可弃置你与其中一名手牌数小于你的目标角色的各一张牌，并令此牌对其造成的伤害+1；当你成为其他角色使用牌的目标后，若你的手牌数小于其，则你可以弃置其一张牌，并令此牌对你造成的伤害+1。',
            miniyouzhan: '诱战',
            miniyouzhan_info: '锁定技，其他角色于你的回合内失去一张牌后，你摸一张牌（不计入本回合的手牌上限），且其获得如下效果：1.其于此回合下一次受到的伤害+1；2.结束阶段，若其于此回合未受到过伤害，其摸一张牌。',
            //吴
            Mbaby_bulianshi: '欢杀步练师',
            Mbaby_chengpu: '欢杀程普',
            Mbaby_daqiao: '欢杀大乔',
            Mbaby_re_daqiao: '欢杀界大乔',
            Mbaby_ganning: '欢杀甘宁',
            Mbaby_re_ganning: '欢杀界甘宁',
            Mbaby_huanggai: '欢杀黄盖',
            Mbaby_re_huanggai: '欢杀界黄盖',
            Mbaby_lusu: '欢杀鲁肃',
            Mbaby_ol_lusu: '欢杀界鲁肃',
            Mbaby_luxun: '欢杀陆逊',
            Mbaby_re_luxun: '欢杀界陆逊',
            Mbaby_lvmeng: '欢杀吕蒙',
            Mbaby_re_lvmeng: '欢杀界吕蒙',
            Mbaby_sunce: '欢杀孙策',
            Mbaby_re_sunce: '欢杀界孙策',
            Mbaby_sunluban: '欢杀孙鲁班',
            Mbaby_sunluyu: '欢杀孙鲁育',
            Mbaby_sunquan: '欢杀孙权',
            Mbaby_re_sunquan: '欢杀界孙权',
            Mbaby_old_sunquan: `${get.poptip('rule_mamba')}孙权`,
            Mbaby_sunshangxiang: '欢杀孙尚香',
            Mbaby_re_sunshangxiang: '欢杀界孙尚香',
            Mbaby_taishici: '欢杀太史慈',
            Mbaby_re_taishici: '欢杀界太史慈',
            Mbaby_wuguotai: '欢杀吴国太',
            Mbaby_ol_wuguotai: '欢杀界吴国太',
            Mbaby_xiaoqiao: '欢杀小乔',
            Mbaby_ol_xiaoqiao: '欢杀界小乔',
            Mbaby_xusheng: '欢杀徐盛',
            Mbaby_re_xusheng: '欢杀界徐盛',
            Mbaby_xin_xusheng: '欢杀界徐盛',
            Mbaby_xin_xusheng_ab: '界界界徐盛',
            Mbaby_xin_xusheng_prefix: '界|界|界',
            Mbaby_old_zhoutai: '欢杀周泰',
            Mbaby_zhoutai: '欢杀界周泰',
            Mbaby_zhouyu: '欢杀周瑜',
            Mbaby_re_zhouyu: '欢杀界周瑜',
            Mbaby_zhugejin: '欢杀诸葛瑾',
            Mbaby_zumao: '欢杀祖茂',
            Mbabysp_xiaoqiao: 'SP欢杀小乔',
            Mbaby_zhuzhi: '欢杀朱治',
            Mbaby_sunjian: '欢杀孙坚',
            Mbaby_ol_sunjian: '欢杀界孙坚',
            Mbaby_sunliang: '欢杀孙亮',
            Mbaby_zhangzhang: '欢杀张昭张紘',
            Mbaby_zhoufei: '欢杀周妃',
            Mbaby_zhugeke: '欢杀诸葛恪',
            Mbaby_xushi: '欢杀徐氏',
            Mbaby_buzhi: '欢杀步骘',
            Mbaby_lukang: '欢杀陆抗',
            Mbabysp_daqiao: 'SP欢杀大乔',
            Mbaby_sunhao: '欢杀孙皓',
            Mbaby_re_jsp_pangtong: 'SP欢杀庞统',
            Mbaby_luyusheng: '欢杀陆郁生',
            Mbaby_zhuhuan: '欢杀朱桓',
            Mbaby_yanjun: '欢杀严畯',
            Mbaby_re_sunyi: '欢杀孙翊',
            Mbaby_zhangxuan: '欢杀张嫙',
            Mbaby_zhoufang: '欢杀周鲂',
            Mbaby_luji: '欢杀陆绩',
            Mbaby_re_sundeng: '欢杀界孙登',
            Mbaby_panjun: '欢杀潘濬',
            Mbaby_dingfeng: '欢杀界丁奉',
            Mbaby_xuezong: '欢杀薛综',
            Mbaby_sb_huanggai: '欢杀谋黄盖',
            Mbaby_zhangfen: '欢杀张奋',
            Mbaby_sunxiu: '欢杀孙休',
            Mbaby_dc_sunru: '欢杀孙茹',
            Mbaby_yufan: '欢杀虞翻',
            Mbaby_quancong: '欢杀全琮',
            Mbaby_re_guyong: '欢杀顾雍',
            Mbaby_sb_lvmeng: '欢杀谋吕蒙',
            Mbaby_quanhuijie: '欢杀全惠解',
            Mbaby_jiangqing: '欢杀蒋钦',
            Mbaby_lvdai: '欢杀吕岱',
            Mbaby_heqi: '欢杀贺齐',
            Mbaby_dc_sunhanhua: '欢杀孙寒华',
            Mbaby_zhangwen: '欢杀张温',
            Mbaby_weiwenzhugezhi: '欢杀卫温诸葛直',
            Mbaby_re_panzhangmazhong: '欢杀潘璋马忠',
            Mbaby_kanze: '欢杀阚泽',
            Mbaby_sb_ganning: '欢杀谋甘宁',
            Mbaby_chendong: '欢杀陈武董袭',
            Mbaby_xugong: '欢杀许贡',
            Mbaby_zhupeilan: '欢杀朱佩兰',
            Mbaby_sb_sunquan: '欢杀谋孙权',
            Mbaby_xielingyu: '欢杀谢灵毓',
            Mbaby_lvfan: '欢杀吕范',
            Mbaby_gexuan: '欢杀葛玄',
            Mbaby_sunhuan: '欢杀孙桓',
            minizhiheng: '制衡',
            minizhiheng_info: '出牌阶段结束时，你可以弃置任意张手牌并将手牌数补至四张。',
            minirezhiheng: '制衡',
            minirezhiheng_info: '出牌阶段限一次，你可以弃置任意张牌并摸等量张牌。若你以此法弃置了全部手牌，则你额外摸一张牌。若本阶段你第一次发动〖制衡〗获得的牌未包含延时锦囊牌，则本阶段你可以额外发动一次〖制衡〗。若本阶段你第二次发动〖制衡〗获得的牌均为基本牌，则本阶段你可以额外发动一次〖制衡〗。',
            minijiuyuan: '救援',
            minijiuyuan_info: '主公技。①当你处于濒死状态时，其他吴势力角色对你使用的【桃】的回复值+1。②其他吴势力角色使用【桃】对自己生效时，可以改为令你回复1点体力，然后其摸一张牌。',
            minirejiuyuan: '救援',
            minirejiuyuan_info: '主公技。①其他吴势力角色对你使用的【桃】的回复值+1。②其他吴势力角色于其回合内回复体力时，可以改为令你回复1点体力，然后其摸一张牌。',
            miniqixi: '奇袭',
            miniqixi_info: '出牌阶段开始时，你可以弃置一名其他角色区域里的一张牌。',
            minireqixi: '奇袭',
            minireqixi_info: '你可以将一张黑色牌当作【过河拆桥】使用。出牌阶段开始时，你可以弃置一名角色区域里的一张牌。',
            minifenwei: '奋威',
            minifenwei_info: '限定技，当一名角色使用的锦囊牌指定了至少两名角色为目标时，你可以令此牌对其中任意名角色无效，然后你摸一张牌。当你失去最后的手牌后，你重置〖奋威〗。',
            miniguose: '国色',
            miniguose_info: '当你失去方片牌时，摸一张牌。',
            miniwanrong: '婉容',
            miniwanrong_info: '出牌阶段限一次，你可以将一张方片花色牌当作【乐不思蜀】使用，或弃置一张方片花色牌并弃置场上的一张【乐不思蜀】。',
            minikurou: '苦肉',
            minikurou_info: '准备阶段，你可以失去1点体力并摸两张牌。',
            minizhaxiang: '诈降',
            minizhaxiang_info: '锁定技，你使用红色【杀】无距离限制且不能被响应，你使用【杀】的次数上限+1。',
            minifanjian: '反间',
            minifanjian_info: '出牌阶段开始时，你可以令一名其他角色摸一张牌，然后你对其造成1点伤害。',
            minireyingzi: '英姿',
            minireyingzi_info: '锁定技，摸牌阶段，你额外摸X张牌；你的手牌上限+X。（X为以下条件中你满足的项数：手牌数不小于2、体力值不小于2、装备区里的牌数不小于1）',
            minirefanjian: '反间',
            minirefanjian_info: '出牌阶段限一次，你可以声明一个手牌中有的花色并选择一名其他角色，其选择一个花色，若你与其选择的花色：相同，你令其摸一张牌并对其造成1点伤害；不相同，你对一名角色造成1点伤害。',
            miniqianxun: '谦逊',
            miniqianxun_info: '锁定技，当你成为锦囊牌的唯一目标时，你摸一张牌，然后可以交给一名其他角色一张手牌。',
            minireqianxun: '谦逊',
            minireqianxun2: '谦逊',
            minireqianxun_info: '当一张锦囊牌对你生效时，你可以将至多X张手牌置于武将牌上（X为你的体力值）。回合结束时，你获得这些牌。',
            minilianying: '连营',
            minilianying_info: '当你失去最后的手牌时，你可以摸两张牌，然后可以交给一名其他角色一张手牌。',
            minitianyi: '天义',
            minitianyi_info: '出牌阶段开始时，你可以选择一项：①本回合使用【杀】的次数上限+1，且使用【杀】造成伤害后回复1点体力；②摸一张牌，本回合使用【杀】无距离限制且无视目标角色的防具。',
            miniretianyi: '天义',
            miniretianyi_info: '①出牌阶段开始时，你可以选择两项：①本回合使用【杀】的次数上限+1；②本回合使用【杀】造成伤害后回复1点体力；③摸一张牌；④本回合使用【杀】无距离限制且无视目标角色的防具。②当你使用【杀】指定目标时，你可以与目标角色拼点，若你赢，你可以为此【杀】额外指定一个目标。',
            minihanzhan: '酣战',
            minihanzhan_info: '①当你发起拼点时，或成为拼点的目标时，你可以令对方选择拼点牌的方式改为随机选择一张手牌。②当你拼点结束后，你可以获得其中的【杀】。',
            minihaoshi: '好施',
            minihaoshi_info: '摸牌阶段，你可以多摸两张牌，然后若你的手牌数大于5，你须弃置X张手牌或将X张手牌交给一名手牌数最少的其他角色（X为你手牌数的一半，向下取整）。',
            miniolhaoshi: '好施',
            miniolhaoshi_info: '①摸牌阶段开始时，你多摸两张牌。②摸牌阶段结束时，若你的手牌数大于5，则你可以将一半手牌（向下取整）交给一名其他角色并获得如下效果直到你下回合开始：当你成为【杀】或普通锦囊牌的目标后，其可以交给你一张手牌。',
            minidimeng: '缔盟',
            minidimeng_info: '①出牌阶段限一次，若你没有“盟”标记，你可令两名角色交换手牌并获得X枚“盟”标记（X为这两名角色手牌数之差的绝对值）。②摸牌阶段结束时或回合结束时，你可以弃置任意张牌并移去等量的“盟”标记。',
            miniganlu: '甘露',
            miniganlu_info: '锁定技，出牌阶段开始时，你选择一项：①移动场上的一张装备牌；②交换场上装备区中的两张副类别相同的装备牌的位置；③摸一张牌。',
            minibuyi: '补益',
            minibuyi_info: '每回合限三次，一名角色进入濒死状态时，你可以展示其一张手牌，若此牌为基本牌，该角色弃置此牌并回复1点体力。',
            minireganlu: '甘露',
            minireganlu_info: '锁定技，出牌阶段开始时，你选择一项：①摸两张牌，然后你可以移动场上的一张装备牌或交换场上装备区中的两张副类别相同的装备牌的位置；②交换两名角色装备区内的牌，然后弃置一张牌。',
            minirebuyi: '补益',
            minirebuyi_info: '每回合限三次，一名角色进入濒死状态时，你可以观看并展示其任意张手牌（若其没有手牌则改为你令其摸一张牌并展示之），然后你弃置以此法展示的牌并令其回复X点体力（X为其中基本牌的数量）。',
            minipojun: '破军',
            minipojun2: '破军',
            minipojun_info: '当你使用【杀】指定目标时，你可以将其至多X张牌移出游戏直至回合结束（X为其体力值），然后若其中有：装备牌，你弃置其中的一张；【闪】，你摸一张牌。',
            minirepojun: '破军',
            minirepojun_info: '①当你使用【杀】指定目标后，你可以将其至多X张牌移出游戏直至回合结束（X为其体力值），然后若其中有：装备牌，你弃置其中的一张；【闪】，你摸一张牌。②你使用【杀】对手牌数和装备区牌数均不大于你的角色造成的伤害+1。',
            minidcpojun: '破军',
            minidcpojun_info: '当你使用【杀】指定目标或成为【杀】的目标后，你可以将对方的至多X张牌置于其武将牌上（X为你的体力上限），然后其于当前回合结束时获得这些牌。',
            miniyicheng: '疑城',
            miniyicheng_info: '锁定技，一名角色的武将牌的牌数变化后，若其武将牌上的类别数：为1，其本回合非锁定技失效且不能使用或打出手牌；为2，其本回合受到的伤害+1；为3，你摸三张牌。',
            minianxu: '安恤',
            minianxu_info: '出牌阶段开始和结束时，你可以获得一名手牌数最多的其他角色的一张手牌，然后若此牌的花色为黑桃，该角色摸一张牌。',
            minilihuo: '疠火',
            minilihuo_info: '当你声明使用普通【杀】时，你可以将此【杀】改为火【杀】。若以此法使用的【杀】造成的伤害大于1，则此【杀】结算后你失去1点体力；你使用火【杀】选择目标后，可以额外指定一个目标。当你于回合内第一次因火【杀】造成伤害后，你摸一张牌。',
            minichunlao: '醇醪',
            minichunlao2: '醇醪',
            minichunlao_info: '结束阶段，若你没有“醇”，你可以将至少一张【杀】置于你的武将牌上，称为“醇”。当一名角色处于濒死状态时，你可以移去一张“醇”，视为该角色使用一张【酒】，然后若此“醇”的颜色为：红色，你回复1点体力；黑色，你摸两张牌。',
            minizenhui: '谮毁',
            minizenhui_info: '出牌阶段限一次，当你使用【杀】或普通锦囊牌指定唯一目标时，你可以令其选择一项：①交给你一张牌；②失去1点体力。',
            minijiaojin: '骄矜',
            minijiaojin_info: '当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以弃置一张手牌并令此牌对你无效。',
            minihongyuan: '弘援',
            minihongyuan_info: '摸牌阶段，你可以令至多两名角色各摸一张牌。',
            minixingwu: '星舞',
            minixingwu_info: '出牌阶段限一次，你可以翻面并弃置一张手牌，然后弃置一名角色装备区里的一张牌并对其造成2点伤害（若该角色为女性角色则改为1点）。',
            miniluoyan: '落雁',
            miniluoyan_info: '锁定技，当你发动〖星舞〗后，你获得〖天香〗和〖红颜〗直至你的下个出牌阶段开始。',
            minihuimou: '回眸',
            minihuimou_info: '当你于回合外使用或打出红桃牌时，或发动〖天香〗弃置红桃牌后，你可以令一名背面朝上的角色翻至正面。',
            miniyinbing: '引兵',
            miniyinbing_info: '弃牌阶段开始前，你可以将至少一张非基本牌称作「引兵」牌置于武将牌上。每当你受到【杀】的伤害后，你移去一张「引兵」牌并摸一张牌。',
            minijuedi: '绝地',
            minijuedi_info: '锁定技，准备阶段，若你的武将牌上有「引兵」牌，你选择一项：1.移去「引兵」牌，将手牌补至体力上限+1；2.将「引兵」牌交给一名体力值不大于你的其他角色，其回复1点体力并摸等量的牌。',
            minimeibu: '魅步',
            minimeibu_info: '其他角色的出牌阶段开始时，你可以弃置一张牌，令该角色于本阶段内拥有〖止息〗，且你获得其因〖止息〗弃置的牌。',
            minijieyin: '结姻',
            minijieyin_info: '出牌阶段限一次，你可以选择一名其他角色，交给其一张手牌或将一张装备牌置于其装备区，然后你回复1点体力。',
            minijieyi: '结谊',
            minijieyi_info: '出牌阶段限一次，你可以选择一名其他角色，交给其一张手牌或将一张装备牌置于其装备区，然后你回复1点体力并摸一张牌。若其体力值小于你，你可以令其回复1点体力；若其体力值大于等于你，你可以令其摸一张牌。',
            minibuqu: '不屈',
            minibuqu_info: '锁定技。①当你处于濒死状态时，若你的“创”标记数小于4，则你获得1枚“创”并将体力值回复至1点。②你的手牌上限+X（X为你的“创”标记数）。',
            minirebuqu: '不屈',
            minirebuqu_info: '锁定技。①当你受到伤害或失去体力时，若你的“创”标记数小于4，则你获得1枚“创”并取消之。②你的手牌上限+X（X为你的“创”标记数）。',
            miniqingchuang: '清创',
            miniqingchuang_info: '出牌阶段限一次，你可以弃置一张【桃】或【酒】，然后移去1枚“创”并摸一张牌。',
            minijiang: '激昂',
            minijiang_info: '当你使用【杀】或【决斗】时指定目标后，或成为其他角色使用【杀】或【决斗】时指定目标后，你可以摸一张牌。',
            miniolhunzi: '魂姿',
            miniolhunzi_info: '觉醒技，游戏开始时或当你的体力值发生变化时，若你的体力值为1，你减1点体力上限，然后获得〖英姿〗和〖英魂〗。',
            minihunzi: '魂姿',
            minihunzi_info: '觉醒技，准备阶段，若你的体力值为1，你减1点体力上限，然后获得〖英姿〗和〖英魂〗。',
            minizhiba: '制霸',
            minizhiba_info: '主公技，其他吴势力角色的出牌阶段限一次，其可以交给你一张【决斗】。',
            miniolzhiba: '制霸',
            miniolzhiba_info: '主公技，其他吴势力角色的出牌阶段限一次，其可以交给你一张【杀】或【决斗】。',
            minikeji: '克己',
            minikeji_info: '弃牌阶段开始时，若你于本回合的出牌阶段内没有过使用或打出过【杀】，则你可以跳过此阶段并摸一张牌。',
            miniqinxue: '勤学',
            miniqinxue_info: '觉醒技，结束阶段，若你的手牌数不小于你的体力值的三倍，则你调整体力上限与体力值一致，失去〖克己〗并获得〖攻心〗。',
            minisbduojing: '夺荆',
            minisbduojing_info: '出牌阶段限两次，你可以与一名其他角色谋弈。若你赢，且你选择的选项为：“休养生息”，获得其一张牌，回复1点体力，然后若X大于0，你摸X张牌并弃置等量的牌（X为你已损失的体力值）；“白衣渡江”，视为对其使用一张不计次数且无视距离和防具的【杀】，且本回合可额外使用一张【杀】，且本回合无视〖克己〗发动条件。',
            minitianxiang: '天香',
            minitianxiang_info: '当你即将受到伤害时，你可以弃置一张红桃手牌并将伤害转移给一名其他角色，然后其摸一张牌。',
            miniretianxiang: '天香',
            miniretianxiang_info: '当你即将受到伤害时，你可以弃置一张红桃手牌并将伤害转移给一名其他角色，然后你选择一项：①令其摸一张牌：②令其摸X张牌（X为其损失的体力值且至多为5）。',
            minianguo: '安国',
            minianguo_info: '出牌阶段限一次，你可以选择一名角色，若其手牌数为全场最少，其摸一张牌；体力值为全场最低，回复1点体力；装备区内牌数为全场最少，随机使用一张装备牌。然后若该角色有未执行的效果且你满足条件，你执行之。',
            miniyinghun: '英魂',
            miniyinghun_info: '准备阶段，你可令一名其他角色摸一张牌，然后弃置X张牌（X为你已损失的体力值）。',
            minireyinghun: '英魂',
            minireyinghun_info: '准备阶段，你可令一名其他角色执行一项：1.摸X张牌；2.摸一张牌，然后弃置X张牌（X为你已损失的体力值）。',
            miniwulie: '武烈',
            miniwulie_info: '限定技，回合开始时，你可以失去任意点体力并获得Y枚「烈」，然后你可以指定至多Y名其他角色，令这些角色各获得1枚「烈」（Y为你以此法失去的体力值）。有「烈」的角色受到伤害时，其可以移去1枚「烈」，然后防止此伤害。',
            miniwulie2: '武烈',
            miniwulie2_info: '移去1枚「烈」，然后防止此伤害',
            minikuizhu: '溃诛',
            minikuizhu_info: '弃牌阶段结束后，你可以选择一项：①令至多X名角色各摸一张牌。②对任意名体力值之和不大于X的角色各造成1点伤害。（X为你此阶段弃置的牌数）',
            minichezheng: '掣政',
            minichezheng_info: '锁定技，你的出牌阶段内，攻击范围内不包含你的其他角色不能成为你使用【杀】的目标。出牌阶段结束时，你摸X张牌（X为攻击范围内不包含你的其他角色数且X至少为2）。',
            minilijun: '立军',
            minilijun_info: '主公技，每个出牌阶段限一次，其他吴势力角色使用【杀】结算后，你摸一张牌，然后你可以令其摸一张牌。',
            miniguzheng: '固政',
            miniguzheng_info: '其他角色的弃牌阶段结束时，你可以令其获得本阶段内进入弃牌堆的牌中的一张，然后你获得剩余的牌（若没有剩余的牌则改为摸一张牌）。',
            miniliangyin: '良姻',
            miniliangyin_info: '当有牌移至游戏外时，你可以令一名角色摸一张牌；当有牌从游戏外加入任意角色的手牌时，你可以令一名角色弃置一张牌。',
            miniaocai: '傲才',
            miniaocai_info: '当你于回合外需要使用或打出一张基本牌时，你可以观看牌堆顶的三张牌（若你没有手牌则改为四张）。若你观看的牌中有此牌，你可以使用打出之。',
            miniduwu: '黩武',
            miniduwu_info: '出牌阶段，你可以弃置X张牌对你攻击范围内的一名其他角色造成1点伤害（X为该角色的体力值）。若该角色因此法进入濒死状态且存活，则你于濒死状态结算后摸一张牌，且本回合不能再发动〖黩武〗。',
            miniwengua: '问卦',
            miniwengua2: '问卦',
            miniwengua_info: '{其他角色}/{你}的出牌阶段限一次，{其可以交给你一张牌并展示}/{你可以展示一张牌}，若此牌为锦囊牌，则你加1点体力上限（体力上限至多加至5点）并回复1点体力，你可以将此牌置于牌堆顶或牌堆底，然后{你与其}/{你}从另一端摸一张牌。',
            minifuzhu: '伏诛',
            minifuzhu_info: '其他角色的结束阶段，若牌堆剩余牌数不大于你体力上限的十倍，则你可以依次对其使用牌堆中所有的【杀】（不能超过游戏人数），然后洗牌。',
            minihongde: '弘德',
            minihongde_info: '当你一次性获得至少两张牌后，你可以令一名其他角色摸一张牌。每回合限两次，当你失去牌后，你可以摸一张牌。',
            minidingpan: '定叛',
            minidingpan_info: '出牌阶段限X次，你可以令一名装备区里有牌的角色摸一张牌，然后其选择一项：1.令你弃置其装备区里的一张牌；2.获得其装备区里的所有牌，若如此做，你对其造成1点伤害。（X为场上的存活势力数）',
            minijueyan: '决堰',
            minijueyan_info: '出牌阶段限一次，你可以废除一个装备栏，然后根据选择执行对应的效果：①武器栏，本回合内你可以多使用三张【杀】；②防具栏，摸三张牌，本回合手牌上限+3；③2个坐骑栏，回复1点体力，本回合获得〖集智〗，且本回合你使用的牌无距离限制。',
            minihuairou: '怀柔',
            minihuairou_info: '出牌阶段，你可以将一张你已废除装备栏对应副类别的装备牌置入弃牌堆，然后选择一个基本牌或锦囊牌的牌名从牌堆中或弃牌堆获得之（每种牌名每回合限一次）。',
            miniyanxiao: '言笑',
            miniyanxiao_info: '出牌阶段，你可以将一张方片称为“言笑”牌置于一名角色的判定区内。判定区内有“言笑”牌的角色下个判定阶段开始时，其获得判定区里的所有牌，然后其进行一次判定，若判定结果为：红色，其摸一张牌；黑色，其本回合使用【杀】的次数上限+1。',
            minianxian: '安娴',
            minianxian_info: '当你不因〖安娴〗使用【杀】指定目标时，你可以令其弃置一张手牌；当你成为【杀】的目标时，你可以弃置一张手牌，令此【杀】对你无效，然后使用者摸一张牌，若你弃置了方片牌，则你视为对此【杀】的使用者使用一张【杀】。',
            minicanshi: '残蚀',
            minicanshi2: '残蚀',
            minicanshi_info: '摸牌阶段开始时，你可以多摸X张牌（X为已受伤的角色数）。若如此做，当你于此回合内使用【杀】时，你弃置一张牌。',
            minichouhai: '仇海',
            minichouhai_info: '锁定技，当你受到【杀】造成的伤害时，若你没有牌，则此伤害+1。',
            miniguolun: '过论',
            miniguolun_info: '出牌阶段限一次，你可以展示一名其他角色的手牌，然后你可以选择你的一张牌，你与其交换这两张牌。然后若你展示的牌的点数比其展示的牌的点数小，你摸两张牌；若其展示的牌的点数比你展示的牌的点数小，其摸一张牌，你回复1点体力。',
            minisongsang: '送丧',
            minisongsang_info: '锁定技，其他角色死亡后，你增加1点体力上限，然后回复1点体力。',
            minizhente: '贞特',
            minizhente_info: '当你成为其他角色使用基本牌或普通锦囊牌的目标后，你可令使用者选择一项：1.本回合不能再使用与此牌颜色相同的牌；2.此牌对你无效。',
            minizhiwei: '至微',
            minizhiwei2: '至微',
            minizhiwei_info: '游戏开始时/你的回合开始时，若场上没有因此法被选择过的角色存活，则你选择一名其他角色。该角色造成伤害后，你摸一张牌，该角色受到伤害后，你可以交给其一张手牌。你弃牌阶段弃置的牌可以交给该角色。',
            minifenli: '奋励',
            minifenli_info: '若你的手牌数/体力值/装备区的牌数为全场最多，你可以跳过判定和摸牌阶段/出牌阶段/弃牌阶段。',
            minipingkou: '平寇',
            minipingkou_info: '回合结束时，你可以对至多X名其他角色各造成1点伤害（X为你本回合跳过的阶段数）。若你选择的角色数小于你本回合跳过的阶段数，则你选择其中一名装备区有牌的目标角色，获得其装备区中的一张牌。',
            miniguanchao: '观潮',
            miniguanchao_info: '出牌阶段开始时，你可以选择获得一项效果直到回合结束：1.本回合你使用【杀】的额定次数+1，当你使用牌时，若你本回合使用过的所有牌的点数为严格递增，你摸一张牌；2.本回合你计算与其他角色距离-1，当你使用牌时，若你本回合使用过的所有牌的点数为严格递减，你摸一张牌。',
            minixunxian: '逊贤',
            minixunxian_info: '每名角色的回合限一次，当你使用或打出的牌进入弃牌堆后，你可以将这些牌交给一名其他角色。',
            minisyxiongyi: '凶疑',
            minisyxiongyi_info: '限定技。当你处于濒死状态时，若剩余武将牌堆中：有“欢杀徐氏”，则你可以将体力值回复至3点，并将此武将牌替换为“欢杀徐氏”；没有“欢杀徐氏”，则你可以将体力值回复至1点并获得〖魂姿〗。',
            minishezang: '奢葬',
            minishezang_info: '每回合限一次。当你或你回合内的其他角色进入濒死状态时，你可以从牌堆中获得每种花色的牌各一张。',
            miniyoudi: '诱敌',
            miniyoudi_info: '结束阶段，你可以令一名其他角色弃置你一张手牌。若弃置的牌：不是【杀】，则你获得其一张牌并摸一张牌；不是黑色牌且你的体力上限小于5，则你增加1点体力上限。',
            minizhenglun: '整论',
            minizhenglun_info: '摸牌阶段，若你没有“橘”，你可以少摸一张牌并获得一个“橘”。',
            minikuangbi: '匡弼',
            minikuangbi_info: '①出牌阶段限一次，你可以令一名其他角色将至多三张牌置于你的武将牌上，然后你可以令其摸等量张牌。②回合开始时，你获得武将牌上所有的“匡弼”牌。③当你失去手牌中最后一张因〖匡弼②〗获得的牌时，你摸一张牌并回复1点体力。',
            miniguanwei: '观微',
            miniguanwei_info: '每回合限一次，一名角色的出牌阶段结束时，若其本阶段使用过重复花色的牌，则你可以弃置一张牌，令该角色摸两张牌并进行一个额外的出牌阶段。',
            minigongqing: '公清',
            minigongqing_info: '锁定技，当你受到伤害时，若伤害来源的攻击范围：小于3，此伤害减至1点；大于等于3，你摸一张牌。',
            miniduanbing: '短兵',
            miniduanbing_info: '①你使用【杀】可以额外选择一名距离为1的角色为目标。②当你于一回合首次使用【杀】指定与你距离不小于1的角色后，你令其需额外使用一张【闪】响应此【杀】。',
            minifenxun: '奋迅',
            minifenxun_info: '①出牌阶段限一次，你可以选择一名其他角色，本回合你计算与其的距离视为1。②回合结束时，你摸X张牌（X为本回合距离你1以内的角色受到过伤害数之和）。',
            minifunan: '复难',
            minifunan_info: '其他角色使用或打出牌响应你使用的牌时，你可获得其使用或打出的牌。',
            minijiexun: '诫训',
            minijiexun_info: '结束阶段，你可以选择一种花色，然后令一名角色摸等同于场上此花色牌数张牌，然后其弃置X张牌（X为此前〖诫训〗的发动次数）。若其因此法弃置了所有牌，则清空〖诫训〗的发动次数。',
            minisbkurou: '苦肉',
            minisbkurou_info: '出牌阶段，你可以失去1点体力，然后你的手牌上限和体力上限+1直到你的下个回合开始，然后当你回复体力后，你重置此技能。',
            minisbzhaxiang: '诈降',
            minisbzhaxiang_info: '锁定技。①当你失去1点体力后，你摸三张牌。②回合结束时，你摸X张牌。③你于每回合使用的前X张【杀】无距离限制、不计入次数限制且不可被响应。（X为你已损失体力值的一半，向上取整）',
            miniwanglu: '望橹',
            miniwanglu_info: '锁定技。准备阶段，若你的装备区内：有【大攻车】，则你获得一个额外的出牌阶段；没有【大攻车】，则你将一张【大攻车】置入装备区。',
            miniwanglu_faq: '关于大攻车',
            miniwanglu_faq_info: '<br><li>花色：♠<br><li>点数：9<br><li>类别：武器<br><li>攻击范围：2<br><li>装备效果：出牌阶段开始时，你可以视为使用一张【杀】，且当此【杀】对目标角色造成伤害后，你弃置其一张牌。若此【大攻车】未被强化，则其他角色无法弃置你装备区内的【大攻车】。当此牌离开你的装备区后，销毁之。',
            minixianzhu: '陷筑',
            minixianzhu_info: '①出牌阶段限一次，你可以弃置一张手牌中的武器牌，然后视为对一名角色使用一张无距离且不计入次数的【杀】。②当你使用【杀】造成伤害后，你可以强化你装备区内的【大攻车】（每张【大攻车】最多被强化五次）。',
            minixianzhu_faq: '关于强化大攻车',
            minixianzhu_faq_info: '<br>从以下选项中任选一项：<br><li>⒈通过【大攻车】使用【杀】无视距离和防具；<br><li>⒉通过【大攻车】使用的【杀】可以额外选择1个目标（可叠加）；<br><li>⒊通过【大攻车】使用的【杀】造成伤害后的弃置牌数+1（可叠加）。',
            minichaixie: '拆械',
            minichaixie_info: '锁定技。当你的【大攻车】被销毁后，你摸X张牌（X为此【大攻车】被强化过的次数）。',
            minidagongche: '大攻车',
            minidagongche_skill: '大攻车',
            minidagongche_info: '出牌阶段开始时，你可以视为使用一张【杀】，且当此【杀】对目标角色造成伤害后，你弃置其一张牌。若此【大攻车】未被强化，则其他角色无法弃置你装备区内的【大攻车】。当此牌离开你的装备区后，销毁之。',
            miniyanzhu: '宴诛',
            miniyanzhu_info: '出牌阶段限一次，你可以令一名其他角色选择一项：弃置一张牌并令下一次受到的伤害+1直到其下回合开始，或将装备区里的所有牌交给你并令你发动〖宴诛〗无法选择此项。',
            minixingxue: '兴学',
            minixingxue_info: '结束阶段，你可以令至多X名角色依次摸一张牌并将一张牌置于牌堆顶或交给一名其他目标角色（X为你的体力上限）。',
            minizhaofu: '诏缚',
            minizhaofu_info: '主公技，出牌阶段限一次，你可选择至多两名其他角色，这些角色本轮视为在所有吴势力角色的攻击范围内。',
            minixiecui: '撷翠',
            minixiecui_info: '一名角色于其回合内第一次使用牌造成伤害时，你可以令此伤害+1。然后若其手牌数大于其体力值，则该角色获得伤害牌且其本回合的手牌上限+1。',
            minizongxuan: '纵玄',
            minizongxuan_info: '当你的牌因弃置而进入弃牌堆后，你可以令一名其他角色获得其中的一张，然后你摸一张牌。然后你可将其中的任意张剩余牌置于牌堆顶。',
            minizhiyan: '直言',
            minizhiyan_info: '结束阶段，你可令一名角色正面朝上摸一张牌。若此牌不为装备牌，则你摸一张牌。若此牌为装备牌，则其使用此装备牌，然后回复1点体力。',
            miniyaoming: '邀名',
            miniyaoming_info: '①每回合每项限两次。当你造成或受到伤害时，你可以：⒈令一名角色摸一张牌；⒉弃置一名其他角色的一张手牌；⒊令一名角色摸两张牌，然后弃置两张牌。②回合结束时，若你本回合未发动过〖邀名①〗，则你可以发动〖邀名①〗。',
            minishenxing: '慎行',
            minishenxing_info: '出牌阶段限20次，你可以摸一张牌，然后弃置X张牌（X为你本阶段此前发动此技能的次数，且X至多为2）。然后若你没有可弃置的牌，则本阶段此技能失效。',
            miniligong: '离宫',
            miniligong_info: '觉醒技，准备阶段，若〖慧淑〗的中括号内有不小于5的数字，则你加1点体力上限，回复1点体力并失去〖易数〗。系统随机检索四张存在于欢杀将池中的吴势力女性武将牌，然后你选择一项：⒈摸三张牌。⒉失去〖慧淑〗，然后获得这些武将牌上的任意两个技能。',
            minijianyi: '俭衣',
            minijianyi_info: '锁定技，其他角色的回合结束时，若弃牌堆中有于本回合内因弃置而进入弃牌堆的武器牌或防具牌，则你获得其中一张。',
            minishangyi: '尚义',
            minishangyi_info: '出牌阶段限一次，你可以弃置一张牌并选择一名有手牌的其他角色，你令其观看你的手牌，然后你观看其手牌并选择一项：1.获得其中一张牌；2.与其交换一张手牌。若你以此法获得了其的黑色牌，或你与其交换的两张牌均为红色，你摸一张牌。',
            miniqinguo: '勤国',
            miniqinguo_info: '①当你使用的装备牌结算完毕时，你可以视为使用一张【杀】，若此【杀】造成伤害，则你摸一张牌。②当你因使用或失去装备牌导致装备区内牌的数量发生变化后，若你装备区内牌的数量大于等于你的体力值，则你可以回复1点体力。',
            miniqizhou: '绮冑',
            miniqizhou_info: '锁定技。你根据装备区里牌的花色数获得以下技能：≥1，〖英姿〗；≥2，〖奇袭〗；≥3，〖旋风〗；≥4：〖短兵〗。',
            minishanxi: '闪袭',
            minishanxi_info: '出牌阶段限一次。你可以选择一名攻击范围内不包含你的其他角色，展示你与其的至多X张手牌（X为你的空装备栏数+1）。若这些牌中有【闪】，则你弃置这些【闪】，然后获得对方的一张未展示的牌。',
            minihuiling: '汇灵',
            minihuiling_info: '锁定技。当你使用牌时或因弃置而失去牌后，若此牌颜色为弃牌堆中数量较少的颜色，你获得1枚“灵”标记。若弃牌堆中：红色牌数大于黑色牌数，你回复1点体力；黑色牌数大于红色牌数，你可以弃置一名其他角色区域内的一张牌。',
            minichongxu: '冲虚',
            minichongxu_info: '限定技。出牌阶段，若“灵”数不小于4，你可以失去〖汇灵〗，增加等同于“灵”数的体力上限（至多增加场上人数的体力上限），然后获得〖踏寂〗和〖清荒〗。',
            minisongshu: '颂蜀',
            minisongshu_info: '出牌阶段限一次，你可以和其他角色拼点。若你没赢，你可以与其各摸两张牌；否则此技能视为未发动过。',
            minisibian: '思辩',
            minisibian_info: '摸牌阶段，你可以放弃摸牌，改为亮出牌堆顶的四张牌，然后获得其中所有点数最大与点数最小的牌，且可以将剩余的牌交给手牌数最少或最多的角色。',
            minifuhai: '浮海',
            minifuhai_info: '出牌阶段限一次。你可以令所有有手牌的其他角色同时展示一张手牌，然后你选择一个方向并摸X张牌（X为该方向上的角色展示的点数连续严格递增或严格递减的牌数，至少为2）。',
            miniduodao: '夺刀',
            miniduodao_info: '当你成为【杀】的目标后，你可以弃置一张牌。然后你获得此【杀】使用者装备区里的武器牌（若此【杀】为红色，则改为你获得其区域内一张牌）。',
            minianjian: '暗箭',
            minianjian_info: '锁定技，当你使用【杀】指定目标后，若你不在其攻击范围内，则此【杀】无视防具且你选择一项：1. 令其无法响应此【杀】；2. 其受到此【杀】造成的伤害+1。若其因执行此【杀】的效果受到伤害而进入濒死状态，则其不能使用【桃】直到此濒死事件结算结束。',
            minikuanshi: '宽释',
            minikuanshi_info: '结束阶段，你可以选择一名角色。直到你的下回合开始，该角色每受到两次伤害后，其回复1点体力。',
            minisbqixi: '奇袭',
            minisbqixi_info: '出牌阶段限一次。你可以声明一种花色并令一名其他角色猜测你声明的花色。若其猜错，你令其从其此次未选择过的花色中再次猜测。然后你弃置其区域内的X张牌（X为其于本次〖奇袭〗中猜错的次数+1）。',
            minisbfenwei: '奋威',
            minisbfenwei_info: '①出牌阶段限一次，你可以将至多三张牌称为“威”分别置于等量名角色的武将牌上，然后你摸等量牌。②当一名有“威”的角色成为锦囊牌的目标时，你须选择一项：1.令其获得其“威”；2.令其移去“威”，并取消此目标；3.令其移去“威”，其不可响应此牌；4.令其移去“威”，你摸一张牌。',
            miniduanxie: '断绁',
            miniduanxie_info: '出牌阶段限一次，你可以令一名其他角色横置（若场上无处于横置状态的角色则改为至多两名），然后你横置。',
            minifenming: '奋命',
            minifenming_info: '结束阶段，你可以弃置所有处于横置状态的角色的各一张牌，然后你摸等量张牌。',
            minibiaozhao: '表召',
            minibiaozhao_info: '每轮开始时，你可以选择两名角色A和B。直到本轮结束或你死亡后，A对B使用牌无次数和距离限制，且B对你使用的牌造成的伤害+1。',
            miniyechou: '业仇',
            miniyechou_info: '当你死亡时，你可以令一名其他角色获得如下效果：①直到其下个回合开始前，每个回合结束时，其失去1点体力。②当其受到伤害值不小于其体力值的伤害时，其令此伤害翻倍。',
            minicilv: '辞虑',
            minicilv_info: '当你成为普通锦囊牌的目标后，你可以摸X张牌（X为剩余选项数且至少为1），然后若你的手牌数大于你的体力上限，则你选择执行并移去一项：①令此牌对你无效；②防止此牌对你造成的伤害；③于此牌结算完毕后获得此牌对应的所有实体牌。',
            minitongye: '统业',
            minitongye_info: '锁定技。若牌堆未洗牌，则你视为拥有〖英姿〗和〖固政〗。',
            miniyuandi: '元嫡',
            miniyuandi_info: '当其他角色于其出牌阶段使用首张仅指定其为目标的牌时，你可以选择一项：1.弃置其一张手牌；2.你与其各摸一张牌。',
            minidiaodu: '调度',
            minidiaodu_info: '出牌阶段开始时，你可以获得一名距离不大于1的一名角色A装备区里的一张牌，然后你将此牌交给另一名角色B，然后B选择是否使用此牌，若B使用/不使用，则你/B摸一张牌。',
            minidiancai: '典财',
            minidiancai_info: '一名角色的出牌阶段结束时，若你于此阶段失去了至少X张牌，则你可以将手牌摸至体力上限（X为你的体力值且X至多为5）。然后你可以发动一次〖调度〗。',
            minilianhua: '炼化',
            minilianhua_info: '①你的回合外，其他角色受到伤害后，你获得1枚“丹血”标记（该角色与你阵营一致时为红色，不一致为黑色，此颜色对所有玩家均不可见）。②准备阶段，你失去所有“丹血”标记，根据你失去的“丹血”标记的数量和颜色，从牌堆/弃牌堆中获得相应的牌以及相应技能直到回合结束：3枚或以下，〖英姿〗和【桃】；红色“丹血”较多，〖观星〗和【无中生有】；黑色“丹血”较多，〖直言〗和【顺手牵羊】；红色和黑色一样多，〖攻心〗和【杀】【决斗】。',
            mininiji: '逆击',
            mininiji_info: '①当你成为基本牌或锦囊牌的目标后，你可以摸一张牌，称为“逆击”。②一名角色的结束阶段，你可以使用一张手牌，然后弃置所有“逆击”牌。',
            //群
            Mbaby_zuoci: '欢杀左慈',
            Mbaby_gaoshun: '欢杀高顺',
            Mbaby_xin_gaoshun: '欢杀界高顺',
            Mbaby_caifuren: '欢杀蔡夫人',
            Mbaby_re_caifuren: '欢杀界蔡夫人',
            Mbaby_lijue: '欢杀李傕',
            Mbaby_xuyou: '欢杀许攸',
            Mbaby_re_gongsunzan: '欢杀界公孙瓒',
            Mbaby_pangde: '欢杀庞德',
            Mbaby_re_pangde: '欢杀界庞德',
            Mbaby_yj_jushou: '欢杀沮授',
            Mbaby_liru: '欢杀李儒',
            Mbaby_dongzhuo: '欢杀董卓',
            Mbaby_ol_dongzhuo: '欢杀界董卓',
            Mbaby_sp_zhangjiao: '欢杀张角',
            Mbaby_re_zhangjiao: '欢杀界张角',
            Mbaby_huatuo: '欢杀华佗',
            Mbaby_re_huatuo: '欢杀界华佗',
            Mbaby_lvbu: '欢杀吕布',
            Mbaby_re_lvbu: '欢杀界吕布',
            Mbaby_diaochan: `${get.poptip('rule_mamba')}貂蝉`,
            Mbaby_sp_diaochan: 'SP欢杀貂蝉',
            Mbaby_re_diaochan: '欢杀界貂蝉',
            Mbaby_huaxiong: '欢杀华雄',
            Mbaby_sb_huaxiong: '欢杀界华雄',
            Mbaby_yuji: '欢杀于吉',
            Mbaby_zhangliang: '欢杀张梁',
            Mbaby_zhangbao: '欢杀张宝',
            Mbaby_ol_yanwen: '欢杀界颜良文丑',
            Mbaby_ol_caiwenji: '欢杀界蔡琰',
            Mbaby_liubiao: '欢杀刘表',
            Mbaby_re_liubiao: '欢杀界刘表',
            Mbaby_yuanshao: '欢杀袁绍',
            Mbaby_xin_yuanshao: '欢杀界袁绍',
            Mbaby_yuanshu: '欢杀袁术',
            Mbaby_yl_yuanshu: '欢杀界袁术',
            Mbaby_chengong: '欢杀陈宫',
            Mbaby_re_chengong: '欢杀界陈宫',
            Mbaby_jiaxu: '欢杀贾诩',
            Mbaby_re_jiaxu: '欢杀界贾诩',
            Mbaby_liuzhang: '欢杀刘璋',
            Mbaby_panfeng: '欢杀潘凤',
            Mbaby_sp_machao: 'SP欢杀马超',
            Mbaby_jsp_huangyueying: 'SP欢杀黄月英',
            Mbaby_quyi: '欢杀麴义',
            Mbaby_liuxie: '欢杀刘协',
            Mbaby_fuhuanghou: '欢杀伏寿',
            Mbaby_zhangqiying: `${get.poptip('rule_mamba')}张琪瑛`,
            Mbaby_chunyuqiong: '欢杀淳于琼',
            Mbaby_beimihu: '欢杀卑弥呼',
            Mbaby_dongbai: '欢杀董白',
            Mbaby_zhangji: '欢杀张济',
            Mbaby_sp_taishici: 'SP欢杀太史慈',
            Mbaby_xushao: '欢杀许劭',
            Mbaby_hetaihou: '欢杀何太后',
            Mbaby_wangrong: '欢杀王荣',
            Mbaby_sp_menghuo: 'SP欢杀孟获',
            Mbaby_caoxing: '欢杀曹性',
            Mbabysp_zhenji: 'SP欢杀甄宓',
            Mbaby_liangxing: '欢杀梁兴',
            Mbaby_caojie: '欢杀曹节',
            Mbaby_tangji: '欢杀唐姬',
            Mbaby_libai: '李白',
            Mbaby_guotufengji: '欢杀郭图逢纪',
            Mbaby_re_nanhualaoxian: '欢杀南华老仙',
            Mbaby_yanfuren: '欢杀严夫人',
            Mbaby_gongsunyuan: '欢杀公孙渊',
            Mbaby_re_gongsunyuan: '欢杀界公孙渊',
            Mbaby_sp_zhangliao: 'SP欢杀张辽',
            Mbaby_sp_ol_zhanghe: 'SP欢杀张郃',
            Mbaby_zhujun: '欢杀朱儁',
            Mbaby_sp_kongrong: '欢杀孔融',
            Mbaby_laiyinger: '欢杀来莺儿',
            Mbaby_sb_yuanshao: '欢杀谋袁绍',
            Mbaby_tw_mateng: '欢杀马腾',
            Mbaby_dc_huangchengyan: '欢杀黄承彦',
            Mbaby_simahui: '欢杀司马徽',
            Mbaby_zoushi: '欢杀邹氏',
            Mbaby_wangyun: '欢杀王允',
            Mbaby_xiaoshan: '欢杀小闪',
            Mbaby_zhanglu: '欢杀张鲁',
            Mbaby_zhangning: '欢杀张宁',
            Mbaby_ol_dingyuan: '欢杀丁原',
            Mbaby_liubian: '欢杀刘辩',
            Mbaby_re_pangdegong: '欢杀庞德公',
            Mbaby_licaiwei: '欢杀李采薇',
            Mbaby_dc_huangzu: '欢杀黄祖',
            Mbaby_yanbaihu: '欢杀严虎',
            Mbaby_guosi: '欢杀郭汜',
            Mbaby_fanchou: '欢杀樊稠',
            Mbaby_huangfusong: '欢杀皇甫嵩',
            Mbaby_wutugu: '欢杀兀突骨',
            Mbaby_fuwan: '欢杀伏完',
            Mbaby_dongxie: '欢杀董翓',
            Mbaby_guanning: '欢杀管宁',
            Mbaby_re_hansui: '欢杀韩遂',
            Mbaby_tadun: '欢杀蹋顿',
            Mbaby_re_tadun: '欢杀界蹋顿',
            Mbaby_dc_gaolan: '欢杀高览',
            Mbaby_yl_luzhi: '欢杀卢植',
            Mbaby_mengjie: '欢杀孟节',
            Mbaby_caiyong: '欢杀蔡邕',
            Mbaby_re_chendeng: '欢杀陈登',
            Mbaby_duanwei: '欢杀段煨',
            Mbabysp_xuhuang: 'SP欢杀徐晃',
            Mbaby_zhangrang: '欢杀张让',
            Mbabysp_liubei: 'SP欢杀刘备',
            Mbaby_ol_sb_huaxiong: '欢杀谋华雄',
            Mbaby_jiling: '欢杀纪灵',
            Mbaby_star_yuanshu: '欢杀星袁术',
            Mbabysp_sunjian: 'SP欢杀孙坚',
            Mbaby_hejin: '欢杀何进',
            Mbaby_re_taoqian: '欢杀陶谦',
            Mbaby_xurong: '欢杀徐荣',
            miniweidi: '伪帝',
            miniweidi_info: '弃牌阶段结束时，你可以将其中一张弃置的牌交给一名其他角色。',
            minimingce: '明策',
            minimingce_info: '出牌阶段开始时，你可以令一名其他角色视为对其攻击范围内另一名角色使用一张【杀】。',
            miniremingce: '明策',
            miniremingce_info: '出牌阶段开始时，你可以选择一项：1.令一名角色视为对其攻击范围内另一名你指定的角色使用一张【杀】，此【杀】结算后，若此【杀】造成过伤害，你摸两张牌；2.选择一名其他角色，与其各摸一张牌，且其下回合使用【杀】的次数上限+1。',
            minizhichi: '智迟',
            minizhichi_info: '锁定技。当你于回合外受到伤害后，直到此回合结束，防止你受到的伤害且所有普通锦囊牌对你无效。',
            minichenglve: '成略',
            minichenglve_info: '出牌阶段限一次，你可以摸一张牌，然后弃置一张手牌。若如此做，直到本回合结束，你使用与弃置牌花色相同的牌无距离和次数限制。',
            miniguhuo: '蛊惑',
            miniguhuo_info: '锁定技。①你使用【杀】或伤害性锦囊牌结算完毕后，若此牌未造成伤害，你将此牌移出游戏并摸一张牌，然后于当前回合结束获得此牌。②每回合限一次，你使用【杀】或伤害性锦囊牌结算完毕后，若此牌造成伤害，你摸一张牌。',
            minijijun: '集军',
            minijijun_info: '锁定技，当你使用【杀】或普通锦囊牌指定唯一目标时，或成为【杀】的目标时，你进行一次判定，若结果为黑色，你将此牌置于武将牌上，称为“兵”。',
            minifangtong: '方统',
            minifangtong_info: '结束阶段，你可以选择一项：①弃置一张“兵”，摸一张牌；②弃置两张“兵”，回复1点体力；③弃置三张“兵”，对一名角色造成两点雷属性伤害。',
            minizhoufu: '咒缚',
            minizhoufu2: '咒缚',
            minizhoufu_info: '出牌阶段限一次，你可以用一张牌对一名其他角色施“咒”或移去一名其他角色的“咒”。当有“咒”的角色判定时，将“咒”作为判定牌；一名角色的回合结束时，你令本回合移除过“咒”的角色各失去1点体力。',
            miniyingbing: '影兵',
            miniyingbing_info: '锁定技，有“咒”的角色使用与“咒”颜色相同的牌时，你摸一张牌；若这是你第二次因该“咒”摸牌，其移去该“咒”。',
            miniqieting: '窃听',
            miniqieting_info: '锁定技，其他角色的结束阶段，若其手牌数大于你，则你摸一张牌。',
            minireqieting: '窃听',
            minireqieting_info: '其他角色的回合结束时，若其手牌数大于你，则你摸一张牌，然后若其本回合内未对其他角色造成过伤害，则你可选择一项：①摸一张牌。②观看其两张手牌并获得其中的一张。③将其装备区内的一张牌移动至你的装备区。',
            minixianzhou: '献州',
            minixianzhou_info: '限定技，出牌阶段，你可将所有手牌交给一名其他角色，然后其可以对其攻击范围内的至多X名角色各造成1点伤害（X为你以此法给出的牌数）。',
            minirexianzhou: '献州',
            minirexianzhou_info: '限定技，出牌阶段，你可将任意张牌交给一名其他角色，然后你回复X点体力并对其攻击范围内的至多X名角色各造成1点伤害（X为你以此法给出的牌数）。',
            minipianyi: '翩仪',
            minipianyi_info: '结束阶段，你可以摸一张牌，若你的武将牌已翻面，则改为摸三张牌。',
            minijianchu: '鞬出',
            minijianchu_info: '当你使用【杀】指定一名角色为目标后，你可以弃置其一张牌，然后其获得此【杀】对应的实体牌。',
            minirejianchu: '鞬出',
            minirejianchu_info: '当你使用【杀】指定一名角色为目标后，你可以弃置其一张牌，然后若此牌类型：不为基本牌，你摸一张牌且其不可响应此【杀】；为基本牌，你令此【杀】不计入次数限制。',
            miniyaowu: '耀武',
            miniyaowu_info: '锁定技，当你受到【杀】造成的伤害时，若此【杀】为红色/黑色，其摸一张牌/你摸一张牌。',
            minireyaowu: '耀武',
            minireyaowu_info: '锁定技，当你受到【杀】造成的伤害时，若此【杀】为红色/黑色，其摸一张牌/你摸一张牌。然后你获得此【杀】对应的所有实体牌。',
            miniyangwei: '扬威',
            miniyangwei_info: '当你于出牌阶段使用有颜色的【杀】结算完毕后，你可以于本阶段使用一张与此牌颜色不同的【杀】（无次数限制且不计入次数）。出牌阶段结束后，若你本回合使用【杀】的次数大于2，你回复1点体力。',
            miniqiaomeng: '趫猛',
            miniqiaomeng_info: '当你使用【杀】对一名角色造成伤害时，你可以获得该角色区域内的一张牌。若此牌是坐骑牌，此伤害+1。',
            miniyicong: '义从',
            miniyicong_info: '锁定技，你计算与其他角色的距离时-X，其他角色计算与你的距离时+Y。（X为你的体力值，Y为你的已损失体力值）',
            minishendao: '神道',
            minishendao_info: '你的判定牌生效前，你可以将判定结果改为任意花色。',
            minixinsheng: '新生',
            minixinsheng_info: '当你受到伤害后，你可以亮出牌堆顶的三张牌，然后获得其中每种花色的牌各一张。',
            minixianzhen: '陷阵',
            minixianzhen_info: '锁定技。你于回合内首次使用【杀】造成伤害时，此伤害+1；你于回合内使用的第一张【杀】被闪避后，你摸一张牌。',
            minijinjiu: '禁酒',
            minijinjiu_info: '锁定技。①你的【酒】均视为【杀】且不计入出牌阶段的使用次数。②其他角色使用的【酒】进入弃牌堆后，你获得之。③你的回合内，其他角色不能使用【酒】。',
            minirexianzhen: '陷阵',
            minirexianzhen_info: '①出牌阶段限一次，你可以与一名角色拼点。若你赢，你可以使用你的拼点牌且本回合你无视该角色的防具且对其使用牌没有次数和距离限制；若你没赢，你获得拼点牌中的【杀】且本回合你不能使用【杀】且你的【杀】不计入手牌上限。②你于回合内首次造成伤害时，此伤害+1。③你使用的【杀】被【闪】抵消后，你摸一张牌。',
            minirejinjiu: '禁酒',
            minirejinjiu_info: '锁定技。①你的【酒】均视为点数为K的【杀】且不计入出牌阶段的使用次数。②其他角色使用的【酒】进入弃牌堆后，你获得之。③你的回合内，其他角色不能使用【酒】。',
            miniluanji: '乱击',
            miniluanji_info: '出牌阶段开始时，你可以将两张手牌当【万箭齐发】使用。',
            minireluanji: '乱击',
            minireluanji_info: '你可以将两张与你本回合以此法转化的花色均不相同的手牌当【万箭齐发】使用。若你以此法使用的【万箭齐发】未造成伤害，则你可以在此牌结算完成后摸X张牌。（X为此牌的目标数）',
            minixueyi: '血裔',
            minixueyi_info: '主公技，锁定技，游戏开始时，你获得X个“裔”标记（X为场上群势力角色的数目）。出牌阶段/当你处于濒死状态时，你可以移去1枚“裔”标记，然后回复1点体力并摸一张牌。你的手牌上限+Y（Y为你拥有的“裔”标记数的两倍）。',
            minijiuchi: '酒池',
            minijiuchi_info: '你可以将一张黑色手牌当作【酒】使用。',
            minibenghuai: '崩坏',
            minibenghuai_info: '锁定技，结束阶段，若你的体力不为全场最少，你须减1点体力或体力上限，然后摸一张牌。',
            miniwansha: '完杀',
            miniwansha_info: '锁定技，你的回合内，只有你可以使用【桃】。',
            minirewansha: '完杀',
            minirewansha_info: '锁定技，你的回合内，只有你可以使用【桃】；出牌阶段开始时，你可令一名体力值大于1的其他角色失去1点体力，本阶段结束时，其回复1点体力。',
            minimieji: '灭计',
            minimieji_info: '出牌阶段限一次，你可以将一张黑色牌置于牌堆顶，然后令有一名手牌的其他角色弃置一张锦囊或弃置两张非锦囊牌。',
            minishibei: '矢北',
            minishibei_info: '锁定技，当你受到伤害后，若此伤害是你本回合第一次受到的伤害，则你回复1点体力并摸一张牌，否则你失去1点体力。',
            minijijiu: '急救',
            minijijiu_info: '你的回合外，你可以将一张红色牌当作【桃】使用，然后你可以弃置一名其他角色的一张手牌。',
            minireqingnang: '青囊',
            minireqingnang_info: '出牌阶段限一次，你可以令任意名角色各加1点体力上限并回复1点体力，然后你弃置X张牌（X为目标角色数-1）。若如此做，你的下个回合开始时，这些角色减1点体力上限。',
            miniqingnang: '青囊',
            miniqingnang_info: '出牌阶段限一次，你可以令一名角色回复1点体力。',
            minileiji: '雷击',
            minileiji_info: '①当你使用或打出一张【闪】或【闪电】时，你可令一名其他角色进行一次判定：若结果为梅花，其受到1点雷属性伤害，然后你回复1点体力；若结果为黑桃，其受到2点雷属性伤害。②你的手牌上限+2。',
            minihuangtian: '黄天',
            minihuangtian_info: '主公技。①其他群势力角色的出牌阶段限一次，其可以交给你一张【闪】或【闪电】。②每回合限一次，你可以获得其他群势力角色使用或打出的【闪】。',
            minixinhuangtian: '黄天',
            minixinhuangtian_info: '主公技。①其他群势力角色的出牌阶段限一次，其可以交给你一张【闪】或【闪电】或黑桃手牌。②每回合限一次，你可以获得其他群势力角色使用或打出的【闪】。',
            minishuangxiong: '双雄',
            minishuangxiong_info: '摸牌阶段，你可以放弃摸牌，亮出牌堆顶的三张牌并选择获得其中一种颜色的所有牌，本回合你可以将与这些牌颜色不同的一张手牌当作【决斗】使用。当你受到【决斗】造成的伤害后，你可以获得对方于此牌结算过程中打出的所有【杀】。',
            miniyinlang: '引狼',
            miniyinlang_info: '出牌阶段结束时，你可以选择场上的一个势力。若如此做，你与场上与你选择势力相同的角色各获得1枚“生”标记。有“生”标记的角色使用牌无法指定没有“生”的角色为目标。',
            minixiusheng: '休生',
            minixiusheng_info: '锁定技，准备阶段，你移去场上所有的“生”标记，然后你摸等量的牌。',
            minihuaibi: '怀璧',
            minihuaibi_info: '主公技，锁定技，你的手牌上限+X（X场上的“生”标记数）；有“生”标记的角色对你造成伤害后，你摸一张牌。',
            minikuangfu: '狂斧',
            minikuangfu_info: '出牌阶段限一次，你可以弃置场上的一张装备牌，然后视为使用一张无对应实体牌的【杀】（无视距离且不计入次数限制）。若此【杀】造成了伤害，你摸两张牌。',
            minilihun: '离魂',
            minilihun_info: '出牌阶段限一次，你可以选择一名其他角色，你将武将牌翻面并获得其所有手牌。出牌阶段结束时，你交给其X张牌。（X为该角色的体力值）',
            minizhuiji: '追击',
            minizhuiji_info: '锁定技，你计算体力值小于等于你的角色的距离视为1，体力值大于等于你的角色无法响应你对其使用的【杀】。',
            minishichou: '誓仇',
            minishichou2: '誓仇',
            minishichou4: '誓仇',
            minishichou_info: '①当你使用【杀】指定目标后，你可以选择X+1名角色成为此【杀】的额外目标（X为你已损失的体力值）。②你使用【杀】结算完成后，若此牌未造成伤害，则你从牌堆中获得一张【杀】。③每回合限三次，当你使用【杀】造成1点伤害后，你摸一张牌。',
            minilijian: '离间',
            minilijian_info: '每回合限一次，你使用的【杀】或【决斗】可以额外指定一名男性角色为目标。',
            minijiqiao: '机巧',
            minijiqiao_info: '出牌阶段开始时，你可以弃置任意张非锦囊牌，然后你亮出牌堆顶两倍数量的牌并获得其中的锦囊牌，若其中没有锦囊牌，则你从牌堆或弃牌堆中获得一张锦囊牌。',
            minilinglong: '玲珑',
            minilinglong_info: '锁定技，若你的装备区没有防具牌，你视为装备【八卦阵】；若你的装备区没有坐骑牌，你的手牌上限+1；若你的装备区没有牌，你视为拥有〖集智〗和〖奇才〗。',
            minilinglong_jizhi: '集智',
            minilinglong_jizhi_info: '当你使用锦囊牌时，你可以摸一张牌。若此牌为：基本牌，你本回合手牌上限+1；锦囊牌，你本回合使用【杀】的额定次数+1；装备牌，你可以将此牌置入一名其他角色的装备区。',
            minifuqi: '伏骑',
            minifuqi_info: '锁定技，当你使用牌时，你令所有与你距离不大于2的其他角色不能使用或打出牌响应此牌；当你对其他角色造成伤害后，你令其本回合非锁定技失效。',
            minijiaozi: '骄恣',
            minijiaozi_info: '锁定技，当你造成伤害时，若你的手牌数为全场最多，则此伤害+1。',
            minitianming: '天命',
            minitianming_info: '当你成为【杀】的目标时，你可以弃置两张牌（不足则全弃，无牌则不弃），然后摸两张牌。然后你可以选择一名角色，令其弃置两张牌（不足则全弃，无牌则不弃），然后摸两张牌。',
            minimizhao: '密诏',
            minimizhao_info: '出牌阶段限一次，你可以将任意张手牌交给一名其他角色。若如此做，你令该角色与你指定的另一名有手牌的角色拼点，视为拼点赢的角色对没赢的角色使用一张【杀】。',
            minibeige: '悲歌',
            minibeige_info: '当一名角色受到【杀】造成的伤害后，你可以弃置一张牌，然后若此牌为：①红色，其回复1点体力并摸两张牌；②梅花，伤害来源弃置两张牌；③黑桃，伤害来源将武将牌翻面。',
            minizhuikong: '惴恐',
            minizhuikong_info: '其他角色的准备阶段，你可以与该角色拼点。若你赢，该角色本回合使用的牌不能指定除该角色外的角色为目标。若你没赢，其本回合至你的距离视为1。',
            miniqiuyuan: '求援',
            miniqiuyuan_info: '当你成为【杀】的目标时，你可以令至多三名不为此【杀】的使用者的其他角色选择一项：①交给你一张【闪】；②成为此【杀】的额外目标并弃置一张牌。',
            minidianhua: '点化',
            minidianhua_info: '准备阶段或结束阶段，你可以观看牌堆顶的X张牌（X为你的「紫薇」「后土」「玉清」「勾陈」标记数的总和+1），然后你将这些牌以任意顺序放回牌堆顶。',
            minicangchu: '仓储',
            minicangchu2: '仓储',
            minicangchu3: '仓储',
            minicangchu_info: '锁定技。①游戏开始时，你获得3个“粮”。你的手牌上限+X（X为“粮”数）。②每回合限一次，当你于回合外获得牌时/回复体力后，你获得一个“粮”。③你的“粮”数不能超过存活角色数。',
            miniliangying: '粮营',
            miniliangying_info: '弃牌阶段开始时，你可以摸至多X张牌，然后交给等量的角色各一张牌。（X为你的“粮”数）',
            minishishou: '失守',
            minishishou_info: '锁定技，当你使用【酒】时或受到火焰伤害后，你移去一个“粮”。',
            minizongkui: '纵傀',
            minizongkui_info: '回合开始时，你可以指定一名未拥有“傀”标记的其他角色，令其获得一枚“傀”标记。游戏开始时，你指定一名体力值最少且没有“傀”标记的其他角色，令其获得一枚“傀”标记。',
            miniguju: '骨疽',
            minilianzhu: '连诛',
            minilianzhu_info: '出牌阶段限一次，你可将一张牌交给一名其他角色。若此牌为红色，你摸两张牌或回复1点体力。若此牌为黑色，目标角色选择一项：①弃置两张牌；②令你摸两张牌。',
            minixiahui: '黠慧',
            minixiahui_info: '锁定技，①你的黑色牌不计入手牌上限。②当有其他角色获得你的黑色牌后，其于下次扣减体力前不能使用，打出，弃置这些牌。③一名其他角色的回合结束时，若其本回合失去过“黠慧”牌，则其失去1点体力。',
            minilveming: '掠命',
            minilveming_info: '出牌阶段限一次，你可以选择一名装备区牌数不大于你的的角色，令其选择一个点数，然后你进行判定：若点数相同，你对其造成2点伤害；若点数不同，则你随机获得其区域内的一张牌。',
            minitunjun: '屯军',
            minitunjun_info: '限定技。出牌阶段，你可以选择一名角色，令其随机使用牌堆中的X张装备牌（X为你本局游戏发动过〖掠命〗的次数+1）。',
            minijixu: '击虚',
            minijixu_info: '出牌阶段限一次，若你有手牌，你可以令至多四名其他角色猜测你的手牌中是否有【杀】。所有角色猜测结束后，你依次弃置所有猜错的角色的一张牌并视为对其使用一张【杀】，然后你摸X张牌且本回合的手牌上限+X（X为猜对的角色数+1）。',
            minipingjian: '评荐',
            minipingjian_use: '评荐',
            minipingjian_info: '结束阶段/当你受到伤害后/出牌阶段限一次，你可以令系统从欢杀将池中随机检索出三张拥有发动时机为结束阶段/当你受到伤害后/出牌阶段的技能的武将牌。然后你可以选择尝试发动其中一个技能。每个技能每局只能选择一次。',
            Mbaby_characterlist_append: '<span style="font-family:yuanli">欢杀将池：<br>活动武将扩展页面自定义欢杀将池（未自定义将池/联机模式默认为欢乐三国杀全武将）。</span>',
            Mbaby_characterlist_faq: '欢杀将池',
            Mbaby_characterlist_faq_info: '<br>活动武将扩展页面自定义欢杀将池（未自定义将池/联机模式默认为欢乐三国杀全武将）。',
            minirelijian: '离间',
            minirelijian_info: '出牌阶段限两次，你可以弃置一张牌并选择两名角色（不能选择本回合因你发动〖离间〗受到伤害的角色），视为一名角色对另一名角色使用一张【决斗】（不可被【无懈可击】响应）。',
            minibiyue: '闭月',
            minibiyue_info: '结束阶段，你摸X张牌（X为你本回合发动〖离间〗的次数+1）。',
            minizhendu: '鸩毒',
            minizhendu2: '鸩毒',
            minizhendu_info: '一名角色的出牌阶段开始时，你可以弃置一张牌，令该角色视为使用一张【酒】；若该角色不是你，你对其造成1点伤害，且本回合其计算与他人的距离时+1。',
            miniqiluan: '戚乱',
            miniqiluan_info: '①一名角色进入濒死状态时，你可以摸一张牌。②当你杀死一名角色后，你摸两张牌。',
            minisevenbian: '７２变',
            'minisevenbian_info': '每回合每种类型限一次，出牌阶段，你可以将一张基本牌/锦囊牌/装备牌置入弃牌堆，然后从牌堆中获得一张锦囊牌/装备牌/基本牌。',
            miniruyi: '如意',
            miniruyi_info: '锁定技，若你未装备武器且你的武器栏未被废除，你视为装备【如意金箍棒】。',
            miniruyi_jingubang: '如意金箍棒',
            miniruyi_jingubang2: '如意金箍棒',
            miniruyi_jingubang_info: '回合开始时，你可以将【如意金箍棒】的攻击范围调整至1，2，3，4之间的任意值。当【如意金箍棒】的攻击范围为：1，你使用【杀】不计入次数限制；2，你于回合内使用的第一张【杀】造成的伤害+1；3，你使用【杀】无法被响应；4，你使用【杀】可以额外选择一个目标。',
            miniqitian: '齐天',
            miniqitian_info: '觉醒技，游戏开始时或当你的体力值发生变化时，若你的体力值为1，你减1点体力上限，然后获得〖火眼〗和〖筋斗云〗。',
            minihuoyan: '火眼',
            minihuoyan_info: '锁定技，其他角色的手牌始终对你可见。',
            minijindouyun: '筋斗云',
            minijindouyun_info: '锁定技，你计算与其他角色的距离-1；其他角色计算与你的距离+1。',
            minizuzhou: '诅咒',
            minizuzhou_info: '一名角色的回合开始时，你可以失去1点体力，然后选择一项：①令其本回合手牌中的所有【杀】视为【闪】；②令其本回合手牌中的所有【闪】视为【杀】。',
            minimoyu: '摸鱼',
            minimoyu2: '摸鱼',
            minimoyu4: '摸鱼',
            minimoyu_info: '出牌阶段开始时，你可以令本回合手牌上限+2，下回合摸牌阶段额外摸两张牌。若如此做，你本回合不能对其他角色使用牌，且回合结束时回复1点体力。',
            minisanlian: '三连',
            minisanlian_info: '出牌阶段，你可以弃置三张类型相同的手牌，然后摸X张牌（X为你已损失的体力值），对所有角色各造成1点伤害，若你弃置的牌名均相同，则你弃置所有其他角色各一张牌。',
            miniminsi: '敏思',
            miniminsi2: '敏思',
            miniminsi_info: '出牌阶段限一次，你可以弃置任意张点数之和为13的牌，然后摸两倍数量的牌。本回合你使用这些牌无距离限制且这些牌本回合不计入手牌上限。',
            minijijing: '吉境',
            minijijing_info: '当你受到伤害后，你可以进行一次判定，然后你可以弃置任意张点数之和不小于判定结果点数的牌并回复1点体力。',
            minimanwang: '蛮王',
            minimanwang_info: '出牌阶段，你可以弃置任意张牌。然后你依次执行以下选项中的前X项：⒈获得〖叛侵〗。⒉摸一张牌。⒊回复1点体力。⒋摸两张牌并失去〖叛侵〗。然后你获得〖祸首〗直到你的下个回合开始。',
            miniliushi: '流矢',
            miniliushi_info: '①出牌阶段，你可以将一张红桃牌置于牌堆顶，视为对一名角色使用一张【杀】（此【杀】无距离限制且不计入使用次数）。②当你使用【杀】造成伤害后，受到伤害的角色获得一个“流”，有“流”的角色手牌上限-X（X为其“流”数）。',
            minilulve: '掳掠',
            minilulve_info: '出牌阶段开始时，你可选择一名有手牌且手牌数不大于你的角色。其选择一项：①将所有手牌交给你，然后你将武将牌翻面。②将武将牌翻面，然后其视为对你使用一张【杀】。',
            minishouxi: '守玺',
            minishouxi_info: '当你成为【杀】的目标后，你可声明一种本局未因〖守玺〗声明过的基本或锦囊牌牌名，然后除非使用者弃置一张你声明的牌，并获得你的一张牌；否则此【杀】对你无效，且你从剩余牌堆中获得一张牌名与其相同的牌。',
            minihuimin: '惠民',
            minihuimin_info: '结束阶段，你可以摸X张牌，然后展示X-1张手牌（X为手牌数小于等于体力值的角色数），然后你选择一名手牌数小于等于体力值的角色，从该角色开始，所有手牌数小于等于体力值的角色依次选择并获得其中一张。',
            minikangge: '抗歌',
            minikangge_info: '回合开始时，你选择一名其他角色作为“抗歌”角色（覆盖之前选择的“抗歌”角色）。该角色每次于其回合外获得牌后，你摸等量的牌（每回合至多摸三张）；其进入濒死状态时，你可令其回复体力至1点（每轮限一次）。',
            minijielie: '节烈',
            minijielie_info: '当你受到伤害时，你可以防止此伤害并选择一种花色，然后你失去1点体力，令“抗歌”角色从弃牌堆中随机获得X张此花色的牌（X为伤害值）。',
            minishixian: '诗仙',
            minishixian_info: '锁定技，回合开始时，你失去因〖诗仙〗获得的技能并亮出牌堆顶的四张牌，然后根据花色获得对应技能：红桃〖静夜思〗；方片〖行路难〗；黑桃〖侠客行〗；梅花〖将进酒〗，然后你可获得其中含有重复花色的牌。',
            minishixian_qiangjinjiu: '将进酒',
            minishixian_qiangjinjiu_info: '其他角色的回合开始时，你可以弃置一张手牌，然后选择一项：⒈弃置其装备区里的所有的牌，然后令其从牌堆中获得一张【酒】；⒉获得其手牌中所有【酒】（若其手牌中没有【酒】则改为获得其一张牌）。',
            minishixian_jingyesi: '静夜思',
            minishixian_jingyesi_info: '①出牌阶段结束时，你可以观看牌堆顶一张牌，然后你可以使用此牌。②弃牌阶段结束时，你获得牌堆底的一张牌。',
            minishixian_xiakexing: '侠客行',
            minishixian_xiakexing_info: '①当你使用了牌名含有“剑”的武器牌时，你视为使用一张【万箭齐发】。②当你使用【杀】造成伤害后，若你的装备区里有武器牌，你可以与受伤角色拼点。若你赢，该角色减1点体力上限；若你没赢，你弃置装备区里的武器牌。',
            minishixian_xinglunan: '行路难',
            minishixian_xingluBuff: '行路难',
            minishixian_xinglunan_info: '其他角色使用目标角色包含你的【杀】结算完毕后，若当前回合角色不为你，则其他角色计算与你的距离时+1直到你的下回合开始。',
            minijigong: '急攻',
            minijigong_info: '出牌阶段开始时，你可以摸至多三张牌。若如此做，你本回合的手牌上限基数改为X+1，且弃牌阶段结束时，若X不小于Y，则你回复1点体力。（X为你本回合内造成的伤害值之和，Y为你本回合内因〖急攻〗摸牌而获得的牌的数量总和）',
            minishifei: '饰非',
            minishifei_info: '当你需要使用或打出【闪】时，你可以令当前回合角色摸一张牌。然后若其手牌数不为全场唯一最多，则你弃置一名角色的一张牌，视为你使用或打出了一张【闪】。',
            minigongxiu: '共修',
            minigongxiu_info: '结束阶段，若你本回合内发动过〖经合〗，则你选择一项：①令所有本回合内成为过〖经合〗目标的角色各摸一张牌；②令所有本回合内未成为过〖经合〗目标的角色各弃置一张手牌。',
            minijinghe: '经合',
            minijinghe_info: '出牌阶段限一次，你可以展示四张牌名各不相同的牌并选择等量的角色。系统从“写满技能的天书”中随机选择等量的技能，然后这些角色依次选择获得其中的一个。',
            minichanni: '谗逆',
            minichanni_info: '出牌阶段限一次，你可将任意张手牌交给一名其他角色，然后其可以将等量的手牌当做【决斗】使用。其因此【决斗】造成伤害后摸X张牌（X为此【决斗】对应的实体牌数）。其因此【决斗】受到伤害时，你可以弃置所有手牌并防止此伤害。',
            mininifu: '匿伏',
            mininifu_info: '锁定技，一名角色的回合结束时，你将手牌摸至三张。',
            minihuaiyi: '怀异',
            minihuaiyi_info: '出牌阶段限一次，你可以展示所有手牌，若这些牌的颜色不全部相同，则你选择一种颜色并弃置该颜色的所有手牌，然后你可以获得至多X名角色的各一张牌（X为你以此法弃置的手牌数）。',
            minirehuaiyi: '怀异',
            minirehuaiyi_info: '出牌阶段限一次，你可以展示所有手牌，然后弃置任意张颜色相同的手牌，并重铸剩余此颜色的手牌，然后你可以获得至多X名角色的各一张牌（X为你本次弃置的牌数）。',
            minimubing: '募兵',
            minimubing_info: '出牌阶段限一次，你可以观看牌堆顶的四张牌，然后你可以弃置任意张手牌，获得任意张展示的牌（你弃置的牌点数和不得小于你获得的牌的点数之和），将其余牌置入弃牌堆。',
            miniziqu: '资取',
            miniziqu_info: '每名角色每轮限一次，你对其他角色造成伤害时，你可防止此伤害，令其将其的一张点数最大的牌交给你。',
            minidiaoling: '调令',
            minidiaoling_info: '出牌阶段，你可以将任意张因〖募兵〗获得的牌交给一名其他角色，若以此法给出的牌数大于1且这些牌的点数连续，你可以获得场上至多X名角色的各一张手牌（X为你本次交出的〖募兵〗牌数-1）。',
            minizhouxuan: '周旋',
            minizhouxuan_info: '①弃牌阶段开始时，你可将任意张手牌称为“旋”置于武将牌上（你至多拥有五张“旋”）。②当你使用或打出一张牌时，你摸一张牌，然后移去一张“旋”（若你的手牌不是场上唯一最多则改为摸X张牌，然后移去两张“旋”）。③当你使用牌时，若你没有“旋”，你可令此牌结算完毕后将此牌对应的所有实体牌称为“旋”置于武将牌上。',
            minidaoyao: '捣药',
            minidaoyao_info: '出牌阶段限一次，你可以弃置一张手牌，然后从牌堆中获得一张【桃】并摸两张牌（若牌堆中没有【桃】则改为摸三张牌）。',
            minibenyue: '奔月',
            minibenyue_info: '觉醒技。当你得到【桃】后，若你的手牌中有三张【桃】，或当你回复体力后，若你本局游戏累计回复至少3点体力。则你将体力上限增加至15点并获得〖广寒〗。',
            miniguanghan: '广寒',
            miniguanghan_info: '锁定技。一名角色受到伤害后，该角色的非你上家和非你下家依次选择一项：①弃置一张牌；②失去等量的体力。',
            minigongjian: '攻坚',
            minigongjian_info: '每回合限一次，当有角色使用【杀】指定第一个目标后，若此【杀】的目标和本局游戏内被使用的上一张【杀】的目标有交集，则你可以依次弃置交集中所有角色的至多两张牌，然后获得以此法弃置的所有基本牌。',
            minizjjuxiang: '拒降',
            minizjjuxiang_info: '当你不于摸牌阶段得到牌后，你可以弃置其中任意张牌，令当前回合角色于此回合额定的出牌阶段内使用【杀】的次数上限+X（X为你以此法弃置的牌的花色数）。',
            miniwushuang: '无双',
            miniwushuang_info: '锁定技。①你使用【杀】可以额外指定一个目标。②当你使用【杀】或【决斗】指定目标后，或成为【决斗】的目标后，你令对方需要依次使用或打出两张【闪】或【杀】响应此牌。',
            miniwuchang: '无常',
            miniwuchang_info: '①当你使用【杀】或【决斗】对与你势力相同的角色造成伤害时，若其未响应过此牌，则你可以令此伤害+1，然后你变更为其他势力。②出牌阶段限一次，你可以令一名其他角色摸一张牌，然后你变更势力至与其相同并从牌堆中获得一张【杀】。',
            minilirang: '礼让',
            minilirang_info: '游戏开始时/准备阶段，若场上没有你选择的存活“礼让”角色，你可以选择一名其他角色作为“礼让”角色。“礼让”角色的摸牌阶段额外摸一张牌，“礼让”角色的弃牌阶段结束时，你获得本阶段进入弃牌堆的所有牌。',
            minizhengyi: '争义',
            minizhengyi_info: '若场上有你选择的存活“礼让”角色，则当你或其受到伤害时，另一名角色可以代替承受本次伤害并摸一张牌（不嵌套触发）。',
            minixiaowu: '绡舞',
            minixiaowu_info: '出牌阶段限一次，你可以选择任意名座位连续且包含你的上家/下家的角色。这些角色依次选择一项：⒈令你摸一张牌；⒉其摸一张牌。然后你获得X枚“沙”（X为选择选项一的角色数的一半，向上取整），且若选择选项二的角色数大于选项一的角色数，则你对这些角色依次造成1点伤害。',
            minihuaping: '化萍',
            minihuaping_info: '限定技。①一名其他角色死亡时，你可获得其当前拥有的所有不带有「Charlotte」标签的技能，然后你失去〖绡舞〗，移去所有“沙”并摸等量的牌。②当你死亡时，你可令一名其他角色获得〖沙舞〗和你的所有“沙”。',
            minisbluanji: '乱击',
            minisbluanji_info: '①出牌阶段，你可以将两张手牌当【万箭齐发】使用（每种颜色的牌每回合限以此法被转化一次）。②每回合限三次，当其他角色因响应你使用的【万箭齐发】而打出【闪】时，你摸一张牌。③每回合限三次，当你使用【万箭齐发】造成伤害后，你可以弃置受伤角色的一张牌。',
            minisbxueyi: '血裔',
            minisbxueyi_info: '主公技，锁定技。①你的手牌上限+2X（X为场上的群势力角色数）。②每回合限两次，当你使用牌指定群势力角色为目标后，你摸一张牌。',
            minixiongzheng: '雄争',
            minixiongzheng_info: '每轮开始时，你可以选择一名上一轮未以此法选择过的角色，称为“雄争”角色。若如此做，本轮结束时，你可以选择一项：1.视为对任意名本轮内未对“雄争”角色造成过伤害的角色依次使用一张【杀】；2.令任意名本轮对“雄争”角色造成过伤害的角色摸两张牌。',
            miniluannian: '乱年',
            miniluannian_info: '主公技。其他群势力角色的出牌阶段限一次。其可以弃置X张牌并对“雄争”角色造成1点伤害（X为所有角色于本轮发动〖乱年〗的次数+1）。',
            minizecai: '择才',
            minizecai_info: '限定技，每轮结束时，你可令一名角色获得〖集智〗直到下一轮游戏开始；若其是本轮内使用过锦囊牌数量唯一最多的角色，则其获得一个额外的回合。',
            minijianjie: '荐杰',
            minijianjie_info: '①你的第一个准备阶段，你令一名角色获得“龙印”，然后令另一名角色获得“凤印”。②出牌阶段限一次。若当前回合不是你的第一个回合，则你可以移动场上的“龙印”或“凤印”。③拥有“龙印”或“凤印”的其他角色死亡时，你转移该角色的“龙印”和“凤印”。④拥有“龙印”/“凤印”的角色视为拥有〖火计〗/〖连环〗，且同时拥有这两种标记的角色视为拥有〖业炎〗。',
            minijianjie_huoji: '火计',
            minijianjie_viewAs: '火计',
            minijianjie_huoji_info: '①出牌阶段限三次，你可以将一张红色牌当作【火攻】使用。②当你使用【火攻】需要弃牌时，你可以观看牌堆顶的四张牌，选择其中一张符合要求的牌作为需要弃置的牌，然后将其余的牌放回牌堆顶。',
            minijianjie_lianhuan: '连环',
            minijianjie_lianhuan_info: '出牌阶段限三次。你可以将一张♣牌当作【铁索连环】使用或重铸。',
            minijianjie_yeyan: '业炎',
            minijianjie_yeyan_info: '限定技，出牌阶段，你可以对至多三名角色造成至多共3点火焰伤害（你可以任意分配每名目标角色受到的伤害点数），若你将对一名角色分配2点或更多的火焰伤害，你须先弃置四张不同花色的手牌和你的“龙印”和“凤印”。',
            miniyinshi: '隐士',
            miniyinshi_info: '锁定技，若你没有“龙印”或“凤印”，且你有空置的防具栏，则防止你受到的属性伤害和锦囊牌造成的伤害。',
            minihuoshui: '祸水',
            minihuoshui_info: '出牌阶段限三次，你可以选择一名其他角色并选择一个本回合未选择过的项：①令其本回合非锁定技失效；②观看其手牌并获得其中一张；③弃置其装备区所有牌。',
            miniqingcheng: '倾城',
            miniqingcheng_info: '出牌阶段限一次，你可以与一名手牌数小于等于X的其他角色交换手牌（X为你的手牌数和已损失体力值之和）。',
            minilianji: '连计',
            minilianji_info: '出牌阶段限一次，你可以令一名其他角色使用牌堆中的一张随机武器牌，令其视为对你指定的一名角色使用一张【杀】，然后你将其装备区里的武器牌交给任意角色。',
            minimoucheng: '谋逞',
            minimoucheng_info: '觉醒技，回合开始时，若有角色因你发动〖连计〗使用【杀】而造成过伤害，则你获得〖矜功〗。',
            minishanshan: '闪闪',
            minishanshan_info: '①当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以打出一张【闪】令此牌对你无效，然后你摸一张牌。②你可以将一张装备牌当作【闪】使用或打出。',
            minianshi: '暗示',
            minianshi_info: '锁定技，每轮开始时，你随机获得以下一个效果（仅对你可见）：①一名角色于本轮使用或打出【杀】时，其弃置所有手牌；②本轮结束时，所有未于本轮使用、打出或弃置过【闪】的角色各受到你对其造成的1点雷属性伤害；③一名角色的装备区的牌数于本轮发生变化后，其弃置所有装备牌；④一名角色于本轮使用或打出【桃】或【酒】后，其本回合无法使用或打出手牌；⑤一名角色于本轮使用单目标锦囊牌指定目标时，你摸一张牌。',
            miniyishe: '义舍',
            miniyishe_info: '①结束阶段，你可以摸两张牌，然后将两张牌置于武将牌上，称为「米」。②当有「米」移至其他区域后，若你的武将牌上没有「米」，则你回复1点体力。',
            minibushi: '布施',
            minibushi_info: '当你受到1点伤害后，或其他角色受到你造成的1点伤害后，你可以选择一张「米」令受伤角色获得之。',
            minimidao: '米道',
            minimidao_info: '一名角色的判定牌生效前，你可以打出一张「米」代替之，然后你摸一张牌。',
            minitianze: '天则',
            minitianze_info: '①每回合限一次，其他角色于其出牌阶段内使用的黑色手牌结算结束后，你可以弃置一张黑色牌，并对其造成1点伤害。②其他角色的判定生效后，若结果为黑色，则你摸一张牌。',
            minidifa: '地法',
            minidifa_info: '出牌阶段限一次，你可以重铸一张红色手牌，然后选择一个锦囊牌的牌名并从牌堆中获得一张此牌名的牌。',
            minicixiao: '慈孝',
            minicixiao_info: '准备阶段，你可令一名没有“义子”标记的其他角色获得一个“义子”标记，然后你可以交给其一张手牌，令其视为对你选择的其攻击范围内的另一名角色使用一张【杀】。拥有“义子”标记的角色获得〖叛弑〗。',
            minipanshi: '叛弑',
            minipanshi_info: '锁定技，准备阶段，你交给有“慈孝”技能的角色一张手牌；当你于出牌阶段因使用【杀】对其他角色造成伤害时，若其拥有技能“慈孝”，则此伤害+1，且你失去“义子”标记并结束出牌阶段。',
            minidushi: '毒逝',
            minidushi_info: '锁定技。①你处于濒死状态时，其他角色不能对你使用【桃】。②当你的濒死状态结算完毕后，你失去〖毒逝〗，然后令一名其他角色获得〖毒逝〗。',
            miniheqia: '和洽',
            miniheqia_info: '出牌阶段限一次，你可将任意张牌交给一名其他角色或令一名有手牌的其他角色交给你任意张牌。然后以此法得到牌的角色可以将一张手牌当作任意基本牌使用，且当其声明使用此牌后，可以为此牌增加至至多X个目标（X为本次使用者以此法得到的牌数）。',
            miniqibie: '泣别',
            miniqibie_info: '一名角色死亡后，你可以弃置任意张手牌，然后回复1点体力并摸X+1张牌（X为你弃置的牌数）。',
            minixiaojuan: '骁隽',
            minixiaojuan_info: '当你使用牌指定其他角色为唯一目标后，你可以弃置其一半的手牌（向上取整）。若这些牌中有与你使用牌花色相同的牌，则你弃置一张手牌。',
            minizhidao: '雉盗',
            minizhidao_info: '锁定技，当你于出牌阶段内第一次对区域里有牌的其他角色造成伤害后，你获得其手牌、装备区和判定区里的各一张牌，然后直到回合结束，本回合你不能对其使用牌。',
            minybhijili: '寄篱',
            minybhijili_info: '锁定技，当一名其他角色成为红色基本牌或红色普通锦囊牌的目标时，若其与你的距离为1且你既不是此牌的使用者也不是目标，你也成为此牌的目标。若此牌造成伤害，你摸一张牌。',
            minirejiuchi: '酒池',
            minirejiuchi_info: '你可以将一张黑色牌当做【酒】使用。你使用【酒】无次数限制，且当你于回合内使用带有【酒】效果的【杀】造成伤害后，你可以摸一张牌并令〖崩坏〗失效直到回合结束。',
            miniroulin: '肉林',
            miniroulin_info: '锁定技。你对女性角色、女性角色对你使用【杀】时，都需连续使用两张【闪】才能抵消。此【杀】结算结束后，若此牌未造成伤害，你摸一张黑色牌。',
            minirebenghuai: '崩坏',
            minirebenghuai_info: '锁定技。①结束阶段，若你的体力不为全场最少，你须减1点体力或体力上限，然后摸一张牌。②回合开始时，若你的体力为全场最低，本回合〖肉林〗改为对所有角色生效。',
            minitanbei: '贪狈',
            minitanbei_info: '出牌阶段限一次，你可以令一名其他角色选择一项：1.你获得其区域内的一张牌，本回合不能再对其使用牌；2.你本回合对其使用牌无距离和次数限制。',
            minisidao: '伺盗',
            minisidao_info: '出牌阶段限一次，当你对一名其他角色连续使用两张牌后，你可以获得其区域内一张牌。',
            minixingluan: '兴乱',
            minixingluan_info: '出牌阶段限一次，当你使用的指定唯一目标角色的牌结算完成后，你观看牌堆中的两张点数为6的牌并获得其中一张（没有则改为摸六张牌）。',
            minijuxia: '居下',
            minijuxia_info: '锁定技，若你的拼点牌点数为A，则你于确定拼点结果前将本次拼点胜利角色改为自己。',
            miniranshang: '燃殇',
            miniranshang_info: '锁定技。①当你受到1点火焰伤害后，你获得1枚“燃”标记。②结束阶段，你失去X点体力。然后若X不小于2，则你减2点体力上限并摸X张牌（X为“燃”标记数）。',
            minimoukui: '谋溃',
            minimoukui_info: '当你成为【杀】的目标或使用【杀】指定目标后，你可以选择任意项：1.摸一张牌；2.弃置该角色一张牌。若你仅选择一项，则此【杀】造成伤害后，你执行一次此选项；若你均选择，则此【杀】被无效或抵消后，该角色弃置你一张牌。',
            minijiaoxia: '狡黠',
            minijiaoxia_info: '①出牌阶段，你可以将一张手牌当【杀】使用；你使用以此法转化的【杀】结算完成后，若此【杀】造成过伤害，你可以使用此牌对应的原卡牌。②出牌阶段，你对你本阶段未使用过【杀】的角色使用【杀】无距离和次数限制。',
            minihumei: '狐魅',
            minihumei_info: '出牌阶段限X次（X为你本阶段造成的伤害数），你可以令一名角色执行本回合未选择的一项：①摸一张牌。②交给你一张牌。③回复1点体力。',
            minidunshi: '遁世',
            minidunshi_info: '每回合限一次，你可以视为使用或打出一张【杀】/【闪】/【桃】/【酒】，然后当前回合角色于本回合内下一次造成伤害时，你选择两项：⒈防止此伤害。系统从技能名中包含“仁/义/礼/智/信”字样的技能中随机选择三个其未拥有的技能，然后你令当前回合角色获得其中一个技能。⒉从〖遁世〗中删除你本次使用或打出的牌名。⒊减1点体力上限并摸X张牌（X为〖遁世〗的剩余牌名数）。',
            mininiluan: '逆乱',
            mininiluan_info: '①你可以将一张黑色牌当作【杀】使用或打出。②当你使用【杀】结算完毕后，若此【杀】未造成过伤害，则此【杀】不计入次数限制。',
            miniluanzhan: '乱战',
            miniluanzhan_info: '①当你造成伤害后，你获得一个“乱”。②当你使用【杀】或黑色普通锦囊牌选择目标后，你可以令至多X名角色也成为此牌的目标；当你使用这些牌指定第一个目标后，若此牌目标数小于X，则你移去X/2（向上取整）个“乱”（X为“乱”数）。',
            minireluanzhan: '乱战',
            minireluanzhan_info: '①当一名角色体力值减少后，你获得一个“乱”。②当你使用【杀】或黑色普通锦囊牌选择目标后，你可以令至多X名角色也成为此牌的目标。③每回合限一次。当你使用使用【杀】或黑色普通锦囊牌指定第一个目标后，若此牌目标数小于X，则你移去X/2（向上取整）个“乱”，然后摸X张牌（X为“乱”数）。',
            minixizhen: '袭阵',
            minixizhen_info: '出牌阶段开始时，你可选择一名其他角色，视为对其使用【杀】或【决斗】。然后当有角色于本阶段内使用或打出牌响应你时，该角色回复1点体力，你摸两张牌。',
            minizhenliang: '贞良',
            minizhenliang_info: '转换技。阳：出牌阶段限一次，你可以弃置一张与“任”颜色相同的牌并对攻击范围内的一名角色造成1点伤害。阴：你的回合外，一名角色使用或打出牌结算完成后，若此牌与“任”颜色相同，则你可以令一名角色摸两张牌。',
            miniyouqi: '幽栖',
            miniyouqi_info: '锁定技，当其他角色因〖引路〗标记弃置牌后，你获得此牌。',
            miniyongsi: '庸肆',
            miniyongsi_info: '锁定技。①摸牌阶段，你多摸X张牌。②弃牌阶段开始时，你弃置X张牌。③回合结束时，若你本回合造成的伤害值不大于1，你摸X张牌（X为场上势力数）。',
            minireweidi: '伪帝',
            minireweidi_info: '弃牌阶段结束时，你可以将其中一种颜色的所有牌交给一名其他角色。若该角色为群势力角色，你可以令其交给你等量张另一种颜色的牌。',
            minibizhuan: '辟撰',
            minibizhuan_info: '①当你使用黑色牌后，或成为其他角色使用黑色牌的目标后，你可以将牌堆顶的一张牌置于武将牌上，称为“书”（你至多拥有四张“书”）。②你的手牌上限+X（X为“书”数）。',
            minitongbo: '通博',
            minitongbo_info: '摸牌阶段结束时，你可以用任意手牌交换等量“书”。然后若“书”数至少为4，你可以将四张“书”任意交给其他角色。然后你回复1点体力且“书”的上限+1（至多增加等同存活角色数的上限）。',
            miniyingshui: '营说',
            miniyingshui_info: '出牌阶段限一次，你可将一张牌交给攻击范围内的一名本回合未已此法选择过的其他角色，然后其选择一项：①交给你至少两张装备牌；②受到1点伤害，你重置〖营说〗。',
            minilangmie: '狼灭',
            minilangmie_info: '其他角色结束阶段。若其本回合使用过的牌中有类型相同的牌，则你可以弃置一张牌并摸两张牌；若其本回合内造成的伤害大于1，则你可以弃置一张牌并对其造成1点伤害。',
            minikuanmeng: '宽猛',
            minikuanmeng_info: '当你的体力值每回合首次变化后，若你不处于濒死状态，你可以摸/弃置至多两张牌并展示所有手牌，若其中的基本牌数与你体力值相同，你令另一名其他角色执行等量效果。',
            minixuefeng: '血奉',
            minixuefeng_info: '出牌阶段限一次。你可以展示一张基本牌并令一名其他角色A对你选择的一名不为A的角色的B执行一项：1.交给B一张基本牌且此牌伤害值/回复值+1；2.失去1点体力并令B回复1点体力。然后你执行另一项。',
            minitaoluan: '滔乱',
            minitaoluan_info: '每回合每种花色限一次，你可将一张牌当做任意一张你未以此法使用过的基本牌或普通锦囊牌使用，然后你令一名其他角色选择一项：1.交给你一张与本次〖滔乱〗声明的牌类别不同的牌；2.本回合〖滔乱〗失效，若你为当前回合角色，则回合结束时其失去1点体力。',
            minizhuyi: '逐义',
            minizhuyi_info: '每轮每项各限一次。①当你获得牌后，你可以弃置一张牌令一名角色摸两张牌；②一名角色受到伤害时，你可以弃置一张牌防止之；③一名角色的回合的开始时，你可以弃置一张牌令其获得一张基本牌且以此法获得的牌的回复值或伤害值+1。然后若你执行了所有选项，你可以为〖侠锋〗添加一个基本牌牌名。',
            minixiafeng: '侠锋',
            minixiafeng_info: '每回合限一次。当你使用【杀】后，你可以对场上体力值最大的角色造成1点伤害或令场上体力值最小的角色回复1点体力。',
            minisbyangwei: '扬威',
            minisbyangwei_info: '锁定技。①当你于摸牌/弃牌阶段外摸/弃置了本回合的第二张牌后，你下一次造成/受到的伤害+1。②出牌阶段结束时，若本阶段你使用过至少三张【杀】，你回复1点体力。',
            minishuangren: '双刃',
            minishuangren_info: '出牌阶段开始时，你可以与一名角色拼点。若你：赢，你可以视为对计算与其距离为1的至多两名角色各使用一张无距离和次数限制的【杀】；没赢，你本阶段不能使用【杀】。',
            ministarpizhi: '圮秩',
            ministarpizhi_info: '锁定技。①一名角色死亡后，若你拥有该角色对应的“玺角”标记且你本轮发动〖残玺〗的势力与其相同，或其是该势力最后一名角色，你失去之，然后摸X张牌并回复1点体力。②结束阶段，你摸X张牌。（X为初始势力数-你的“玺角”标记数）',
            ministarzhonggu: '冢骨',
            ministarzhonggu_info: '主公技，锁定技。摸牌阶段，若游戏轮数大于等于场上的群势力角色数，则你额外摸两张牌。',
            miniyingyi: '英毅',
            miniyingyi_info: '每轮开始时，你可以失去X点体力（X为你体力值的一半，向下取整且至少为1），令一名其他角色弃置其所有黑色牌，你将位于弃牌堆的这些牌依次当【杀】对其使用直到你以此法造成伤害，然后你获得位于弃牌堆的剩余牌。若你未因此获得牌，本轮你对其使用【杀】无次数限制。',
            miniliezhi: '烈志',
            miniliezhi_info: '锁定技。每回合限三次，当你使用牌指定其他角色为唯一目标时，若其本回合未受到过你造成的伤害，你摸X张牌（X为本回合此技能发动的次数）。',
            minimouzhu: '谋诛',
            minimouzhu_info: '出牌阶段限一次，你可以选择任意名其他角色，这些角色依次进行以下结算：交给你一张手牌，然后若其手牌数小于你，则其视为对你使用一张【杀】或【决斗】。',
            miniyanhuo: '延祸',
            miniyanhuo_info: '当你死亡时，你可令任意名角色本局游戏获得以下效果：当其使用【杀】时，此【杀】的伤害值基数+1。',
            minizhaohuo: '招祸',
            minizhaohuo_info: '锁定技，当其他角色进入濒死状态时，你将体力上限调整为1点。若你的体力上限因此减少，则你摸2X张牌（X为你以此法减少的体力上限）。',
            minixionghuo: '凶镬',
            minixionghuo_info: '游戏开始时，你获得3枚“暴戾”标记。出牌阶段，你可以交给一名其他角色1枚“暴戾”标记。当你对有“暴戾”标记的其他角色造成伤害时，此伤害+1。有“暴戾”标记的其他角色的出牌阶段开始时，其移去所有“暴戾”标记并随机执行一项：1.受到1点火焰伤害且本回合不能使用【杀】；2.失去1点体力且本回合手牌上限-1；3.你随机获得其手牌区和装备区的各一张牌。',
            minishajue: '杀绝',
            minishajue_info: '锁定技，其他角色进入濒死状态时，你获得1枚“暴戾”标记。若其体力值小于0，你获得使其进入濒死状态的牌。',
            minizishou: '自守',
            minizishou_info: '摸牌阶段，你可以额外摸两张牌。若如此做，本回合你使用牌不能指定其他角色为目标。',
            minizongshi: '宗室',
            minizongshi_info: '锁定技，你的手牌上限+2。',
            //神
            Mbaby_shen_lvbu: '欢杀神吕布',
            Mbaby_shen_guanyu: '欢杀神关羽',
            Mbaby_shen_zhugeliang: '欢杀神诸葛亮',
            Mbaby_shen_lvmeng: '欢杀神吕蒙',
            Mbaby_shen_liubei: '欢杀神刘备',
            Mbaby_shen_zhangliao: '欢杀神张辽',
            Mbaby_shen_caocao: '欢杀神曹操',
            Mbaby_shen_zhouyu: '欢杀神周瑜',
            Mbaby_shen_sunquan: '欢杀神孙权',
            Mbaby_shen_simayi: '欢杀神司马懿',
            Mbaby_shen_zhaoyun: '欢杀神赵云',
            Mbaby_shen_ganning: '欢杀神甘宁',
            Mbaby_shen_dianwei: '欢杀神典韦',
            Mbaby_shen_huatuo: '欢杀神华佗',
            Mbaby_shen_guojia: '欢杀神郭嘉',
            Mbaby_shen_zhenji: '欢杀神甄宓',
            Mbaby_shen_daxiaoqiao: '欢杀神大乔小乔',
            Mbaby_old_1_daxiaoqiao: `${get.poptip('rule_mamba')}神大乔小乔`,
            Mbaby_old_2_daxiaoqiao: `${get.poptip('rule_mamba')}神大乔小乔`,
            Mbaby_shen_diaochan: '欢杀神貂蝉',
            Mbaby_sunwukong: '欢杀孙悟空',
            Mbaby_dalanmao: '大懒猫',
            Mbaby_change: '嫦娥',
            Mbaby_shen_taishici: '欢杀神太史慈',
            Mbaby_nvwa: '女娲',
            Mbaby_tunxingmenglix: '吞星梦狸',
            Mbaby_shen_zuoci: '欢杀神左慈',
            Mbaby_shen_dengai: '欢杀神邓艾',
            Mbaby_shen_luxun: '欢杀神陆逊',
            Mbaby_shen_pangtong: '欢杀神庞统',
            Mbaby_jingwei: '精卫',
            Mbaby_shen_lusu: '欢杀神鲁肃',
            miniwuqian: '无前',
            miniwuqian_info: '锁定技，当你于回合内第一次使用【杀】或【决斗】指定目标后，则你令此牌无视目标角色的防具且视为具有〖无双〗效果。',
            minishenfen: '神愤',
            minishenfen_info: '限定技，出牌阶段，你可以失去3点体力，对所有其他角色各造成1点伤害。这些角色弃置装备区内的所有牌，然后弃置四张手牌。',
            minishelie: '涉猎',
            minishelie_info: '锁定技，摸牌阶段，你放弃摸牌，改为亮出牌堆顶的五张牌，并获得其中不同花色的牌各一张。',
            minigongxin: '攻心',
            minigongxin_info: '每回合限一次，当你使用牌指定其他角色为唯一目标后，或成为其他角色使用牌的唯一目标后，你可观看对方的手牌。然后你可以展示其中的一张红色牌并选择一项：①获得此牌。②将此牌置于牌堆顶。',
            minikuangfeng: '狂风',
            minikuangfeng_info: '出牌阶段结束时，你可选择任意名角色并将等量的“星”置入弃牌堆，然后对这些角色各造成1点伤害。',
            minidawu: '大雾',
            minidawu_info: '结束阶段，你可以将一张“星”置入弃牌堆。当你于下回合开始前受到非属性伤害时，此伤害-1。',
            miniguixin: '归心',
            miniguixin_info: '当你受到1点伤害后，你可以随机获得所有其他角色区域一张牌，若你本次以此法获得的牌不少于五张且你正面向上，你翻面。',
            miniwushen: '武神',
            miniwushen_info: '你可以将红桃手牌视为【杀】使用或打出；你使用红桃【杀】无距离限制且造成的伤害+1。',
            miniwuhun: '武魂',
            miniwuhun_info: '锁定技，当你受到伤害后，伤害来源获得X个“梦魇”标记（X为伤害点数）。锁定技，当你死亡或脱离濒死时，你选择一名“梦魇”标记数量最多的其他角色，令该角色进行判定：若判定结果不为【桃】或【桃园结义】，则该角色失去5点体力。',
            miniqinyin: '琴音',
            miniqinyin_info: '弃牌阶段结束时，若你于此阶段内弃置过牌，则你可以选择一项：1. 令所有角色各回复1点体力；2. 令所有角色各失去1点体力；3.令所有角色各摸一张牌。',
            miniyeyan: '业炎',
            miniyeyan_info: '出牌阶段开始时，你可以对一名其他角色造成1点火焰伤害。',
            minilongnu: '龙怒',
            minilongnu_info: '锁定技，出牌阶段开始时，你须选择一项：①失去1点体力并摸两张牌，本回合你的红色手牌均视为无距离限制的火【杀】； ②减1点体力上限，本回合你的黑色手牌均视为无次数限制的雷【杀】。',
            minijieyig: '结营',
            minijieyig_info: '锁定技，游戏开始时或当你的武将牌重置时，你横置；所有已横置的角色手牌上限+2；结束阶段，你可以横置一名其他角色。当你受到伤害时，你摸一张牌。',
            miniduorui: '夺锐',
            miniduorui_info: '出牌阶段开始时，你可以观看一名其他角色的手牌并获得其中一张，本回合你使用该颜色的牌不能被其响应。',
            minizhiti: '止啼',
            minizhiti_info: '锁定技，若已受伤角色数：大于1，你摸牌阶段摸牌数+1；大于2， 你使用【杀】的次数上限+1。',
            miniquanxue: '劝学',
            miniquanxue_info: '出牌阶段开始时，你可令至多两名其他角色各获得1枚“学”。有“学”的角色回合开始时移除“学”并选择一项：① 出牌阶段不能对其他角色使用牌；②失去1点体力。',
            minishehu: '射虎',
            minishehu_info: '锁定技，当你对拥有“学”的角色使用【杀】时，你弃置其一张手牌。',
            minidingli: '鼎立',
            minidingli_info: '每轮限一次，其他角色移除“学”时，如果其体力值不小于你，你可以回复1点体力；如果其体力值小于你，你可以摸X张牌（X为其与你的体力值之差且至多为2）。',
            minirenjie: '忍戒',
            minirenjie_info: '锁定技，游戏开始时/当你受到伤害后/当你于弃牌阶段弃牌后，你获得1/X/Y枚“忍”标记。（X为伤害值，Y为你本次的弃牌数）',
            minijilve: '极略',
            minijilve_info: '①你可以于合理的时机弃置1枚“忍”并发动以下技能：〖鬼才〗、〖放逐〗、〖完杀〗、〖集智〗。②当你于每回合第一次发动〖极略①〗时，你可以摸一张牌。',
            minijilve_guicai: '鬼才',
            minijilve_guicai_info: '当一名角色的判定牌生效前，你可以弃置1枚“忍”并打出一张牌代替之，然后若此牌的花色为：红桃，你回复1点体力；梅花，你摸两张牌。',
            minijilve_fangzhu: '放逐',
            minijilve_fangzhu_info: '当你受到伤害后，你可以弃置1枚“忍”并令一名其他角色翻面，然后该角色摸一张牌。',
            minijilve_jizhi: '集智',
            minijilve_jizhi_info: '当你使用锦囊牌时，你可以弃置1枚“忍”并摸一张牌。若此牌为：基本牌，你本回合手牌上限+1；锦囊牌，你本回合使用【杀】的额定次数+1；装备牌，你可以将此牌置入一名其他角色的装备区。',
            minijilve_wansha: '完杀',
            minijilve_miniwansha: '完杀',
            minijilve_wansha_info: '当一名角色于你的回合内进入濒死状态时，你可以弃置1枚“忍”并于本阶段获得〖完杀〗效果。',
            minijuejing: '绝境',
            minijuejing_info: '锁定技，你的手牌上限+3；当你进入或脱离濒死状态时，你摸一张牌。',
            minilonghun: '龙魂',
            minilonghun_info: '你可以将同花色的一至两张牌按下列规则使用或打出：红桃当【桃】，方块当火【杀】，梅花当【闪】，黑桃当普【无懈可击】。若你以此法使用了两张红色牌，则此牌回复值或伤害值+1且你摸一张牌。若你以此法使用了两张黑色牌，则你获得当前回合角色一张牌。',
            minipoxi: '魄袭',
            minipoxi_info: '出牌阶段限一次，你可以观看一名其他角色的手牌，然后你可以弃置你与其手牌中的三张花色不同的牌。若如此做，根据此次弃置你的牌的数量执行以下效果：没有，你减1点体力上限；两张，你回复1点体力并摸一张牌；三张，你摸三张牌。',
            minishenwei: '神卫',
            minishenwei_info: '准备阶段，你可以令一名没有“卫”标记的角色获得1枚“卫”标记（若你的体力值为1则改为至多两名角色）。有“卫”标记的角色受到伤害时，该角色可以弃置其“卫”标记并将伤害转移给你。',
            minielai: '恶来',
            minielai_info: '锁定技，当场上的“卫”标记被移除时，你须选择一项：①回复1点体力；②对一名攻击范围内的其他角色造成1点伤害。',
            minikuangxi: '狂袭',
            minikuangxi_info: '锁定技，当场上存在“卫”标记时，你造成的伤害+1。',
            minijishi: '济世',
            minijishi_info: '游戏开始时，你获得3枚“药”标记（你至多拥有3枚“药”标记）。当有角色进入濒死状态时，你可以弃置1枚“药”标记并令其回复至1点体力。当你于回合外失去红色手牌时，你获得等量的“药”标记。你的手牌上限+3。',
            minitaoxian: '桃仙',
            minitaoxian_info: '你可以将一张红桃牌当【桃】使用；其他角色使用【桃】时，你摸一张牌。',
            minishenzhen: '神针',
            minishenzhen_info: '回合开始时，你可以弃置任意枚“药”标记，然后选择一项：1.令等量角色各回复1点体力；2.令等量角色各失去1点体力。',
            minigjtianyi: '天翊',
            minigjtianyi_info: '觉醒技，准备阶段，若场上的所有存活角色均于本局游戏内受到过伤害，则你加2点体力上限并回复1点体力，然后令一名角色获得〖佐幸〗。',
            minizuoxing: '佐幸',
            minizuoxing_info: '出牌阶段开始时，若令你获得〖佐幸〗的角色存活且体力上限大于1，则你可以令其减1点体力上限。若如此做，你于本回合获得如下效果：出牌阶段限一次，你可以视为使用一张普通锦囊牌。',
            minihuishi: '辉逝',
            minihuishi_info: '限定技，出牌阶段，你可选择一名角色。若其有未发动的觉醒技且你的体力上限不小于存活人数，则你选择其中一个技能，令其发动此技能无视条件；若其没有未发动的觉醒技且你的体力上限不小于3，其摸四张牌。然后你减2点体力上限。',
            minishenfu: '神赋',
            minishenfu_info: '①回合结束时，若你的手牌数为：奇数，你可对一名其他角色造成1点雷属性伤害，若其死亡，你可重复此流程；偶数，你可选择一名角色，你令其摸一张牌或弃置其一张牌，若其手牌数等于体力值，你可重复此流程。（重复流程中不能选择本次技能结算中已经选择过的角色）②回合结束后，你摸X张牌（X为你本回合发动〖神赋〗的次数且至多为5）。',
            minireqixian: '七弦',
            minireqixian2: '七弦',
            minireqixian_info: '锁定技，你的手牌上限视为7。出牌阶段结束时，你可以将一张牌移出游戏，此牌于回合结束后归还。',
            minifeifu: '飞凫',
            minifeifu_info: '你可以将一张黑色牌当作【闪】使用或打出。',
            minishuangshu: '双姝',
            minishuangshu_pingting: '双姝·娉婷',
            minishuangshu_yizheng: '双姝·移筝',
            minishuangshu_info: '准备阶段，你可以亮出牌堆顶的两张牌。若其中包含：方片牌，本回合发动〖娉婷〗可选择的选项上限+1；红桃牌，本回合发动〖移筝〗可移动装备牌上限+1；只有黑色牌，你获得展示的牌。',
            minipingting: '娉婷',
            minipingting_info: '出牌阶段开始时，你可以选择以下选项中的至多两项：⒈本阶段使用的第一张牌无距离限制。⒉本阶段使用第二张牌指定目标后获得此牌对应的所有实体牌。⒊本阶段使用的第三张牌结算完毕后摸两张牌。⒋本阶段使用的第四张牌额外结算一次。',
            miniyizheng: '移筝',
            miniyizheng_info: '出牌阶段结束时，你可以移动场上至多一张装备牌（只能移动武器、防具和坐骑牌，且一次技能结算中每种副类别的装备限移动一次），然后若你于本次技能结算中移动了：一张装备牌，你回复1点体力；两张装备牌，直到你的下回合开始，当你失去一张牌时，摸一张牌。',
            minishuangshu1: '双姝',
            minishuangshu1_info: '锁定技。①回合开始时，你执行一个额外的摸牌阶段。②你拥有“大乔”和“小乔”两段体力，当你执行体力变化时，你选择“大乔”或“小乔”执行此操作，“大乔”或“小乔”阵亡即你阵亡。',
            minishutu: '殊途',
            minishutu_info: '①大乔回复体力后，你可以从牌堆或弃牌堆获得两张指定花色的红色牌。②小乔受到伤害后，你可以使用一张牌（无次数限制且不可被响应）。',
            minitongdi: '同蒂',
            minitongdi_info: '当你使用红色牌令一名角色的体力值变化后，你依次执行：①若大乔和小乔的体力值相同，则你可以回复1点体力；②若你手牌中的红桃牌和方片牌的数量相同，则你可以弃置一张红色牌，对一名角色造成1点伤害。',
            minishuangshu2: '双姝',
            minishuangshu2_info: '转换技。①游戏开始时，你可以转换此技能状态；②阳：当你使用或打出一张方片牌后，你摸X张牌（X为你装备区的红色牌数）；阴：当你使用或打出一张红桃牌后，你可以弃置一张牌，然后从牌堆或弃牌堆获得两张与此牌花色不同的牌。',
            miniyizheng2: '移筝',
            miniyizheng2_info: '回合开始时，你可以失去1点体力并移动场上一张牌。',
            minishutu2: '殊途',
            minishutu2_info: '限定技。当你进入濒死状态时，你可以减少1点体力上限并将体力回复至2点，然后删除〖双姝〗的一个分支。',
            minimeihun: '魅魂',
            minimeihun_info: '结束阶段，或你于当前回合首次成为【杀】的目标后，你可以选择一名其他角色，然后声明一个花色，令其交给你所有你此花色的牌，若其没有此花色的牌，则你观看其手牌并获得其中一张。',
            minihuoxin: '惑心',
            minihuoxin_info: '出牌阶段限一次，你可以弃置一张牌并令两名角色拼点，然后你可以声明一个花色，没赢的角色须选择一项：①令你获得其所有此花色的牌；②其不能使用或打出你此次声明的花色的牌直到其下个回合结束。',
            minidulie: '笃烈',
            minidulie_info: '锁定技。①当你成为【杀】的目标时，你进行判定。若结果为红桃，则取消此目标。②当你首次进入濒死状态时，你将体力回复至X点（X为场上拥有“围”标记的角色数）。',
            minichongwei: '重围',
            minichongwei_info: '①游戏开始时，你令所有其他角色获得1个“围”。②一名角色受到伤害后，若其有“围”，则其移去“围”。③回合开始时，你选择所有有“围”的角色。这些角色失去“围”，然后这些角色的第一个不为你的下家获得等量的“围”。④一名其他角色的回合开始时，若其有“围”，则你可以选择一项：⒈弃置一张手牌并对其造成1点伤害。⒉若其体力值不大于你，则你获得其一张手牌。选择完成后，你视为在其攻击范围内直到回合结束。',
            minipowei: '破围',
            minipowei_info: '觉醒技。一名角色的回合结束时，若场上角色均没有“围”标记，你获得〖神著〗，然后摸Y张牌（Y为本轮移去的“围”数）。',
            minishenzhu: '神著',
            minishenzhu_info: '锁定技。①回合开始时，你从牌堆或弃牌堆获得一张【杀】。②当你使用有对应实体牌的非转化【杀】结算结束后，你选择一项：1.摸一张牌，且本回合使用【杀】的次数上限+1。2.摸三张牌，且本回合不能再使用【杀】。',
            minibutian: '补天',
            minibutian_info: '锁定技。①当你对其他角色造成伤害后，你回复X点体力。②当你受到伤害后或非首轮开始时，你失去X点体力。③游戏开始时，或你的体力值或体力上限变化后，若你未受伤，则你令场上所有其他角色死亡。（X为你已损失体力值的1/5，向下取整）',
            minilianshi: '炼石',
            minilianshi_info: '锁定技。①你的手牌上限始终为5。②当你使用、打出或弃置牌时，你记录这些牌的花色，然后若你已记录四种花色，则你摸一张牌并回复Y点体力，然后清除花色记录（Y为这些牌中的最后一张牌的点数）。',
            minituantu: '抟土',
            minituantu_info: '出牌阶段限一次，你可以从弃牌堆中获得你手牌中有的牌名的牌各一张。',
            minitunxing: '吞星',
            minitunxing_info: '锁定技，游戏开始时或你发动〖梦狸〗后，你从随机三张主公武将牌中选择一张，然后获得此武将牌上所有主公技和觉醒技外的技能直到你下次发动此技能。',
            minitunxing_faq: '〖吞星〗将池',
            minitunxing_faq_info: '活动武将扩展页面自定义欢杀〖评鉴〗将池的全部武将（未自定义将池/联机模式默认为欢乐三国杀全武将）。',
            minitunxing_append: '<span style="font-family:yuanli">〖吞星〗将池：<br>活动武将扩展页面自定义欢杀〖评鉴〗将池的全部武将（未自定义将池/联机模式默认为欢乐三国杀全武将）。</span>',
            minimengli: '梦狸',
            minimengli_info: '锁定技，当你的体力值发生变化后，若你变化前和变化后的体力值与3的大小关系不同，则你变换形态，然后你摸一张牌。',
            minihuanshu: '幻术',
            minihuanshu_info: '锁定技。①每轮开始时，或当你受到1点伤害后，你获得两张“幻术”牌。②当一张“幻术”牌销毁后，你摸一张牌。③出牌阶段开始时，你令所有未被〖幻化〗定向转化过的“幻术”牌随机变成本局游戏存在的另一张牌的镜像。',
            minihuanshu_faq: '关于“幻术”牌',
            minihuanshu_faq_info: (() => {
                const list = [
                    '“幻术”牌为本局游戏牌组中随机一张牌的镜像，此牌可进行常规牌可进行的任何一般操作。',
                    '“幻术”牌不计入手牌上限，一名角色最多持有其体力上限两倍的“幻术”牌，超出的部分改为摸等量的牌',
                    '已/未被〖幻化〗定向转化过的“幻术”牌呈现金/深蓝色与常规牌进行区分。',
                    '无〖幻术〗技能的角色获得“幻术”牌后，“幻术”牌会被销毁。',
                ];
                return '<br><li>' + list.join('<br><li>');
            })(),
            minihuanshu_append: (() => {
                const list = [
                    '“幻术”牌为本局游戏牌组中随机一张牌的镜像，此牌可进行常规牌可进行的任何一般操作。',
                    '一名角色最多持有其体力上限两倍的“幻术”牌，超出的部分改为摸等量的牌',
                    '已/未被〖幻化〗定向转化过的“幻术”牌呈现金/深蓝色与常规牌进行区分。',
                    '无〖幻术〗技能的角色获得“幻术”牌后，“幻术”牌会被销毁。',
                ];
                return '<span style="font-family: yuanli">关于“幻术”牌<br><li>' + list.join('<br><li>') + '</span>';
            })(),
            minihuanhua: '幻化',
            minihuanhua_tag: '已选择',
            minihuanhua_info: '每回合限两次，出牌阶段，你可选择一张未被〖幻化〗定向转化过的“幻术”牌和一张未被〖幻化〗选择过的非“幻术”牌，你将前者的牌名、属性、花色和点数转化为和后者一致，若两张牌的花色相同，你获得一张“幻术”牌。',
            minihuanjing: '幻境',
            minihuanjing_info: '限定技，出牌阶段，你可令本回合发动〖幻化〗的次数+X且你发动〖幻化〗可以选择“幻术”牌为转化目标卡牌，然后你获得X张“幻术”牌。（X为你已损失的体力值的两倍且X至少为1）',
            minixianjin: '险进',
            minixianjin_info: '锁定技，当你每造成或受到两次伤害后，你激活一个副区域标签并摸X张牌（X为你已激活的副区域数）。',
            minicuike: '摧克',
            minicuike_info: '出牌阶段开始时，若你的“军略”标记数为：奇数，你可以对一名角色造成1点伤害；偶数，你可以横置一名角色并弃置其区域内的一张牌。若你的“军略”标记数量大于场上存活角色数，则你可以移去全部“军略”标记并对任意名其他角色造成1点伤害。',
            minilunce: '论策',
            minilunce_info: '每轮开始时，你可以选择一名角色，然后为其选择一个策略（每名角色每个策略至多拥有一个）。',
            'minilunce_上策': '上策',
            'minilunce_上策_info': '出牌阶段开始时，其可以对一名角色使用一张无距离限制的【杀】。',
            'minilunce_中策': '中策',
            'minilunce_中策_info': '其于回合内首次使用【杀】指定目标后，你获得其一张牌，直到其回合结束。',
            'minilunce_下策': '下策',
            'minilunce_下策_info': '其回合结束时，若其本回合未于出牌阶段使用【杀】造成过伤害，则你可以交给其至多三张牌并令其回复1点体力。',
            minilanhai: '览害',
            minilanhai_info: '锁定技。一名角色的回合结束时，若本回合你的计策被成功执行，则你可以摸X张牌并发动一次〖论策〗（X为你本轮策略被成功执行的次数）；否则你增加1点体力上限并回复1点体力（你以此法至多增加3点体力上限）。',
            minitianhai: '填海',
            minitianhai_info: '锁定技。①当你使用或打出手牌时，若此牌有点数且你未记录，则你记录之。②其他角色使用或打出与你〖填海①〗记录的点数相同的牌时，若此牌点数：不大于4，其下次受到的伤害+1；大于4且小于10，你摸一张牌；不小于10，其须弃置任意张牌直到这些牌的点数不小于此牌点数。',
            minihaiku: '海枯',
            minihaiku_info: '锁定技。若所有的点数均被〖填海①〗记录，其他角色于摸牌阶段外获得牌后弃置这些牌，然后你获得这些牌中位于弃牌堆的牌。',
            minitamo: '榻谟',
            minitamo_info: '游戏开始时，你可以重新分配除主公外所有角色的座次。',
            minitamo_info_doudizhu: '游戏开始时，你可以重新分配除三号位角色外所有角色的座次。',
            minidingzhou: '定州',
            minidingzhou_info: '出牌阶段限一次。你可以选择一项：1.将X张牌交给一名场上有牌的其他角色，然后你获得其场上的所有牌（X为其场上的牌数）；2.获得一名其他角色的所有手牌，然后交给其等量张牌。',
            //喵
            Mmiao_caiwenji: '喵蔡琰',
            Mmiao_diaochan: '喵貂蝉',
            Mmiao_caifuren: '喵蔡夫人',
            Mmiao_zhangxingcai: '喵张星彩',
            Mmiao_zhurong: '喵祝融',
            Mmiao_huangyueying: '喵黄月英',
            Mmiao_daqiao: '喵大乔',
            Mmiao_wangyi: '喵王异',
            Mmiao_zhangchunhua: '喵张春华',
            Mmiao_zhenji: '喵甄宓',
            Mmiao_sunshangxiang: '喵孙尚香',
            Mmiao_xiaoqiao: '喵小乔',
            Mmiao_lvlingqi: '喵吕玲绮',
            Mmiao_caoying: '喵曹婴',
            Mmiao_guanyinping: '喵关银屏',
            Mmiao_mayunlu: '喵马云騄',
            minidoumao: '逗猫',
            minidoumao_info: '①回合开始时，你可以弃置一张牌并选择一名其他角色，你失去〖逗猫〗并令其获得〖逗猫〗，然后其摸一张牌。②回合结束时，你弃置一张牌。',
            minimiaobeige: '悲歌',
            minimiaobeige_info: `当一名角色受到【杀】造成的伤害后，你可以弃置一张牌，根据此牌花色执行相应效果：红桃，其回复1点体力；方片：其摸两张牌；梅花，伤害来源弃置两张牌；黑桃，伤害来源将武将牌翻面。然后若你没有${get.poptip('minidoumao')}，则你可以选择一个效果执行。`,
            minimiaoduanchang: '断肠',
            minimiaoduanchang_info: `锁定技。①杀死你的角色失去所有技能。②当你受到有来源的伤害进入濒死状态后，若你没有${get.poptip('minidoumao')}，则伤害来源须弃置两张牌。`,
            minimiaolijian: '离间',
            minimiaolijian_info: `出牌阶段限一次，你可以选择至少两名角色并弃置X张牌（X为你选择的角色数，若你没有${get.poptip('minidoumao')}则改为弃置X-1张牌）。然后每名你选择的角色依次视为对这些角色中与其逆时针座次最近的另一名角色使用一张【决斗】。`,
            minimiaobiyue: '闭月',
            minimiaobiyue_info: `锁定技，结束阶段，你摸Y张牌（Y为本回合受到过伤害的角色数+1（若你没有${get.poptip('minidoumao')}则改为+2），且Y至多为5）。`,
            minimiaoqieting: '窃听',
            minimiaoqieting_info: `其他角色的回合结束时，你可以选择[ ]中的一项：[“摸一张牌”]。若其拥有${get.poptip('minidoumao')}，[ ]中添加“观看其两张手牌并获得其中一张”，否则[ ]中添加“将其装备区里的一张牌置入自己的装备区”。`,
            minimiaoxianzhou: '献州',
            minimiaoxianzhou_info: `限定技，出牌阶段，你可以交给一名其他角色任意张手牌，然后其选择令你回复X点体力或对其攻击范围内的至多X名角色各造成1点伤害（X为你交给其的牌数）。当你获得${get.poptip('minidoumao')}后，你重置技能〖献州〗。`,
            minimiaoshenxian: '甚贤',
            minimiaoshenxian_info: `每回合限一次，其他角色因弃置失去基本牌后（若你没有${get.poptip('minidoumao')}则改为非装备牌），你可以摸一张牌。`,
            minimiaoqiangwu: '枪舞',
            minimiaoqiangwu_info: `①你对没有/有技能${get.poptip('minidoumao')}的角色使用【杀】无距离/次数限制。②若你拥有${get.poptip('minidoumao')}，当你使用【杀】造成伤害后，你摸一张牌。`,
            minimiaojuxiang: '巨象',
            minimiaojuxiang_info: `锁定技。①【南蛮入侵】对你无效。②其他角色弃置【南蛮入侵】后，你获得之。③其他角色使用【南蛮入侵】结算完毕后，你获得此牌对应的所有实体牌。④拥有${get.poptip('minidoumao')}的角色无法响应你使用的【南蛮入侵】。⑤当你使用【南蛮入侵】对没有${get.poptip('minidoumao')}的角色造成伤害后，你摸一张牌。`,
            minimiaolieren: '烈刃',
            minimiaolieren_info: `①当你使用【杀】指定目标后，你可以和目标角色进行拼点，然后你获得其的拼点牌。若你赢，你获得其一张牌。②出牌阶段开始时，若你本回合失去过${get.poptip('minidoumao')}，你可以选择一名角色，对其发动〖烈刃①〗。`,
            minimiaochangbiao: '长标',
            minimiaochangbiao_info: `出牌阶段限一次，你可以将任意张手牌当做【杀】使用（无距离限制，若你拥有${get.poptip('minidoumao')}，则此牌可以额外指定一名目标）。若你因此【杀】对目标角色造成过伤害，则你于出牌阶段结束时摸X张牌（X为此【杀】对应的实体牌数量）。`,
            minimiaojizhi: '集智',
            minimiaojizhi_info: `①当你使用锦囊牌时，你可以摸一张牌。②每回合限一次，其他角色使用锦囊牌时，若你没有${get.poptip('minidoumao')}，你可以摸一张牌。`,
            minimiaoqicai: '奇才',
            minimiaoqicai_info: `锁定技。①你使用锦囊牌无距离限制，你装备区内的防具牌不能被其他角色弃置。②其他角色获得${get.poptip('minidoumao')}后，你从牌堆中获得一张锦囊牌。`,
            minimiaoguose: '国色',
            minimiaoguose_info: `出牌阶段限四次。你可以选择一项：1.将一张♦牌当【乐不思蜀】使用；2.弃置场上一张【乐不思蜀】。然后你摸一张牌（若目标角色拥有${get.poptip('minidoumao')}则改为摸两张牌并弃置一张牌）。`,
            minimiaoliuli: '流离',
            minimiaoliuli_info: `当你成为【杀】的目标时，你可以弃置一张牌并将此【杀】转移给一名你攻击范围内的不为此【杀】使用者的角色（若你没有${get.poptip('minidoumao')}，则改为至多两名角色）。`,
            minimiaozhenlie: '贞烈',
            minimiaozhenlie_info: `当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以失去1点体力并令此牌对你无效，然后弃置使用者一张牌（若你没有${get.poptip('minidoumao')}，则改为获得使用者一张牌）。`,
            minimiaomiji: '秘计',
            minimiaomiji_info: `结束阶段，你可以摸X张牌，然后可以将等量的牌交给一名其他角色（X为Y已损失的体力值，Y为你，若你没有${get.poptip('minidoumao')}则本次技能结算中Y改为你发动〖秘计〗时选择场上的一名已受伤角色，且X至多为5）。`,
            minimiaojueqing: '绝情',
            minimiaojueqing_info: `当你即将造成伤害时，你依次执行：①若你没有${get.poptip('minidoumao')}，你可以失去等同于伤害值的体力，然后令此伤害值翻倍；②你将此次伤害事件改为令受伤角色失去等同于伤害值的体力。`,
            minimiaoshangshi: '伤逝',
            minimiaoshangshi_info: `①当你的手牌数小于X时，你将手牌摸至X张（X为你已损失的体力值，且X至少为1）。②当你失去${get.poptip('minidoumao')}时，你加1点体力上限；当你获得${get.poptip('minidoumao')}时，你减1点体力上限。`,
            minimiaoluoshen: '洛神',
            minimiaoluoshen_info: `①准备阶段，你可以进行判定，然后你获得此牌，若结果为黑色，你可以重复此流程。②回合结束时，若你没有${get.poptip('minidoumao')}，则你可以发动〖洛神①〗。`,
            minimiaoqingguo: '倾国',
            minimiaoqingguo_info: `①你可以将一张黑色牌当作【闪】使用或打出。②若你没有${get.poptip('minidoumao')}，你可以将一张【闪】当作【桃】使用。`,
            minimiaojieyin: '结姻',
            minimiaojieyin_info: `出牌阶段限一次，你可以将一张手牌交给一名其他角色或将一张装备牌置入一名其他角色的装备区，然后你回复1点体力并摸一张牌。然后若你没有${get.poptip('minidoumao')}，你可令其回复1点体力并摸一张牌。`,
            minimiaoxiaoji: '枭姬',
            minimiaoxiaoji_info: `当你失去装备区里的一张牌后，你可以摸两张牌，然后若你没有${get.poptip('minidoumao')}，你可以弃置场上一张牌。`,
            minimiaotianxiang: '天香',
            minimiaotianxiang2: '天香',
            minimiaotianxiang_info: `当你受到伤害时，你可以将一张红桃牌交给一名其他角色并将此伤害转移给其。若如此做，此伤害结算完毕后，若其拥有${get.poptip('minidoumao')}，你对其造成1点伤害；没有${get.poptip('minidoumao')}，你弃置其一张牌。`,
            minimiaohongyan: '红颜',
            minimiaohongyan_info: `锁定技。①你的黑桃牌视为红桃牌。②没有${get.poptip('minidoumao')}的角色的红桃判定牌生效后，你回复1点体力并摸一张牌。`,
            minimiaozhuangrong: '妆戎',
            minimiaozhuangrong_info: `觉醒技，每回合结束时，若你的体力值或手牌数为1，你减少1点体力上限并回复体力至上限，将手牌摸至体力上限，然后获得${get.poptip('minillqshenwei')}和${get.poptip('miniwushuang')}。`,
            minillqshenwei: '神威',
            minillqshenwei_info: `锁定技。摸牌阶段，你令额外摸牌数+X；你的手牌上限+Y（若你没有${get.poptip('minidoumao')}，则X为3，Y为1，否则X为2，Y为2）。`,
            minimiaoguowu: '帼武',
            minimiaoguowu_info: '出牌阶段开始时，你可以展示所有手牌，根据你展示的类型数，你获得对应效果：至少一类，从弃牌堆获得一张普通锦囊牌；至少两类，此阶段使用牌无次数限制；至少三类，此阶段使用首张【杀】或普通锦囊牌可以令之额外结算一次。',
            minimiaolingren: '凌人',
            minimiaolingren_info: `每回合限一次，当你使用【杀】或伤害类锦囊牌指定目标后，你可以令所有其他目标角色选择以下两项（若这些角色数大于2则改为一项，拥有${get.poptip('minidoumao')}的角色须额外选择一项）：①令此牌对其造成的伤害+1；②令你摸两张牌；③获得1枚“伏间”标记，令你获得${get.poptip('minijianxiong')}和${get.poptip('minimiaoxingshang')}直到你的下回合开始。`,
            minimiaofujian: '伏间',
            minimiaofujian_info: `锁定技，结束阶段，你令一名其他角色获得1枚“伏间”标记，然后所有拥有“伏间”标记的角色随机弃置一张手牌，然后你清除场上的“伏间”标记，获得其中拥有${get.poptip('minidoumao')}的角色弃置的牌。`,
            minimiaoxingshang: '行殇',
            minimiaoxingshang_info: `一名角色死亡时，你可以获得该角色的所有牌并摸一张牌，然后若其拥有${get.poptip('minijianxiong')}，则你可以令一名角色获得${get.poptip('minimiaoxingshang')}。`,
            minimiaowuji: '武继',
            minimiaowuji_info: '①你可以将两张红色牌当无任何次数限制的火【杀】使用或打出。②每回合每种花色限一次，当你因〖武继①〗使用【杀】时，若此牌对应的实体牌数为2且花色相同，则此牌伤害值+1。③当你使用的【杀】被抵消后，你可以横置场上至多两名角色。',
            minimiaohuxiao: '虎啸',
            minimiaohuxiao_info: `锁定技。①每当你累计造成3点伤害后，你回复1点体力并令一名角色获得${get.poptip('minidoumao')}。②回合结束时，你从牌堆获得X张红色牌（X为场上拥有${get.poptip('minidoumao')}的角色数，且至少为1）。`,
            minimiaoyuma: '驭马',
            minimiaoyuma_info: `锁定技。①你计算与其他角色的距离-1；有${get.poptip('minidoumao')}的角色计算与你的距离+1。②当你失去装备区中的坐骑牌时，你摸两张牌。`,
            minimiaofengpo: '凤魄',
            minimiaofengpo_info: `每回合每种颜色限一次，当你使用伤害牌指定其他角色为目标后，你可令所有目标依次展示一张手牌A，若A的颜色为：1.黑色：随机交给你X张手牌；2.红色：此牌对其额外生效X次（X为1，若其拥有${get.poptip('minidoumao')}，则X为所有角色展示牌的颜色数）。`,
            //念
            Mnian_zhugeliang: '念诸葛亮',
            Mnian_lvbu: '念吕布',
            Mnian_zhouyu: '念周瑜',
            Mnian_caopi: '念曹丕',
            mininianxinghan: '兴汉',
            mininianxinghan_info: '每回合限一次，回合开始时或当你受到伤害时，若默认势力和场上的势力的并集存在非蜀势力和你此前未因“定乱”成功的势力，则你可以进行一次“定乱”。若“定乱”成功，则你增加1点体力上限并回复1点体力，然后将场上的“定乱”势力角色均改为蜀势力。',
            mininianxinghan_faq: '关于“定乱”',
            mininianxinghan_faq_info: '<br>系统为默认势力和场上的势力的并集存在非蜀势力和你此前未因“定乱”成功的势力各创造四枚对应势力棋子并随机置入这些势力数+2的试管中，每个试管最多存在四枚棋子，点击一个试管后再点击一个未满的试管，第一个试管最上方的元素将进入第二个试管最上方，玩家需要将其中一个试管的棋子均调整为同一势力的弃置，则“定乱”成功，“定乱”结果为你成功分配的这个势力。',
            mininianliaoyuan: '燎原',
            mininianliaoyuan_info: '①出牌阶段限一次，你可以视为使用【火攻】。②你使用【火攻】可以指定任意名角色。',
            mininianying_zgl: '念影',
            mininianying_zgl_info: '回合开始时，若场上角色均为蜀势力；一名角色的回合结束时，若本回合场上有蜀势力角色死亡/场上有原其他势力角色变更势力至过蜀势力/场上有原蜀势力角色变更至过其他势力。则你可以摸两张牌并选择一个存在“念影”效果的技能的“念影”效果执行。',
            mininiantazhen: '踏阵',
            mininiantazhen_sha: '杀',
            mininiantazhen_sha_info: '攻击力+1',
            mininiantazhen_horse: '马',
            mininiantazhen_horse_info: '踏阵步数+2',
            mininiantazhen_jiu: '酒',
            mininiantazhen_jiu_info: '下次攻击攻击力+2',
            mininiantazhen_info: '锁定技，回合开始时，你进行一次“踏阵”，若“踏阵”成功，你从牌堆或弃牌堆随机获得一张【杀】，然后获得〖无双〗直到你的下个回合开始，然后若你此次踏阵过程中未路经的路线包含：①一整列：你令“踏阵”中被击败的角色依次交给你一张牌；②一整行：你视为对“踏阵”中被击败的角色使用一张无距离和次数限制的【杀】；③中心格：“踏阵”中被击败的角色不能对你使用【杀】直到你的下回合开始。',
            mininiantazhen_faq: '关于“踏阵”',
            mininiantazhen_faq_info: '<br>系统生成一个九宫格，其中有三格为随机三名其他角色，两格为【酒】（下次攻击攻击力+2），一格为【马】（步数+2），其余格为【杀】（攻击力+1），玩家初始步数为玩家体力值+1，初始攻击力为0，在满足经过的路径不交叉的条件下，任选一个不为角色的格子作为初始位置进行八向移动，最终路线上存在被击败角色（攻击力大于等于其当前体力值）即为踏阵成功。',
            mininiandoupo: '斗破',
            mininiandoupo_info: '锁定技。①你使用【决斗】的目标上限数+2。②你使用【决斗】的效果改为“所有目标角色与你依次打出一张【杀】，未打出【杀】的角色受到你对其造成的1点伤害。然后重复此流程直到此轮有角色受到伤害。”。③当你使用【决斗】结算完毕后，你获得所有本次【决斗】失败一方的其他角色的各一张牌。',
            mininianying_lb: '念影',
            mininianying_lb_info: '每回合限一次，当你造成或受到伤害后，若你本回合造成或受到的伤害数之和大于等于2，则你可以选择一个存在“念影”效果的技能的“念影”效果执行。',
            mininiansuhui: '溯洄',
            mininiansuhui_info: '每轮限一次，一名角色的回合结束时，你可以进行一次“奏乐”，根据其中最多的同名音符数执行对应效果：3个，令其回溯至弃牌阶段；4个，令其回溯至出牌阶段；5个，令其回溯至准备阶段。然后令其获得本回合进入弃牌堆的所有牌且其本回合手牌上限+X（X为本次“奏乐”后的同名音符数）。',
            mininiansuhui_faq: '关于“奏乐”',
            mininiansuhui_faq_info: '<br>系统分配五个随机音符，且初始拥有五次即兴次数，可通过点击音符的方式对音符进行保留，点击即兴可将所有未选择保留的音符进行重置，玩家可随时点击“演奏”按钮结束“奏乐”，以当前的五个音符作为本次“奏乐”结果。',
            mininianchongzou: '重奏',
            mininianchongzou_info: '锁定技，每种类别每回合限一次，当你使用或打出牌时，若你本回合已使用或打出过此牌名的其他牌，则你获得一张与此牌类别不同的牌，并令下一轮〖溯洄〗的可即兴次数+1。',
            mininianying_zy: '念影',
            mininianying_zy_info: '一名角色的回合结束时，若其本回合至少使用了两组同名牌，则你可以选择一个存在“念影”效果的技能的“念影”效果执行。',
            zhouyu_宫: '宫',
            zhouyu_商: '商',
            zhouyu_角: '角',
            zhouyu_徵: '徵',
            zhouyu_羽: '羽',
            mininiandengji: '登极',
            mininiandengji_info: '游戏开始时，或每回合限一次，当你受到伤害后，若你未击败所有“登阶”目标，你可以进行一次“登阶”。',
            mininiandengji_faq: '关于“登阶”',
            mininiandengji_faq_info: '<br>系统随机分配四个11*5的地图中的一个，玩家需在地图中击败曹昂、曹植、曹冲、曹彰和刘协。击败前四名角色会失去此前因此获得的技能，然后获得对应技能并解锁〖承命〗对应的花色：曹昂：〖慷忾〗和♠；曹植：〖落英〗和♣；曹冲：〖称象〗和♥；曹彰：〖将驰〗和♦。击败刘协可增加1点体力上限并回复1点体力，并修改〖承命〗为“当你成为【杀】的目标时”也可发动。地图中有四种颜色的格子，其中黑色格子为未知格子，蓝色格子+1分，走过后变为灰色格子，红色格子-1分，本次“登阶”成功后所有走过的红色格子变为灰色格子，灰色格子不加不减。相邻格子颜色对你可见。在30秒内，你的分数大于需击败的角色分数为“登阶”成功。非首次进行“登阶”时，若你上次“登阶”成功，本次“登阶”从上次“登阶”的终点开始，否则从上次失败的起始点开始。',
            mininianchengming: '承命',
            mininianchengming_info: '出牌阶段，你可以重铸X张相同花色A的牌（X为本回合你发动过此技能的次数+1），然后你从牌堆或弃牌堆中获得一张指定花色B的牌（A、B均为〖登极〗已解锁的花色）。',
            mininianying_cp: '念影',
            mininianying_cp_info: '每回合限一次，当你于摸牌阶段外获得牌后，你可以选择一个存在“念影”效果的技能的“念影”效果执行。',
            mininiansongwei: '颂威',
            mininiansongwei_info: '主公技，其他魏势力的角色的判定生效后，其可以令你摸一张牌。',
            //战
            Mfight_huangzhong: '战黄忠',
            Mfight_zhangliao: '战张辽',
            Mfight_luxun: '战陆逊',
            Mfight_dianwei: '战典韦',
            Mfight_machao: '战马超',
            Mfight_jiangwei: '战姜维',
            minifightdingjun: '定军',
            minifightdingjun_info: '战场技，锁定技。①一名角色使用【杀】造成1点伤害后，获得1层士气。②士气增加1点后，你摸一张牌。③士气变化时，若士气层数大于等于本局游戏人数，则进入“定军山战场”；一名角色的回合结束时，若士气层数为0，则退出“定军山战场”。④一名角色使用【杀】时，若此时处于“定军山战场”，则你可以消耗2层士气，令其于此牌结算中视为拥有〖烈弓〗。',
            minifightliegong: '烈弓',
            minifightliegong_info: '锁定技，当你使用【杀】指定目标后，若目标角色的手牌数或体力值大于等于你的手牌数或体力值，则其不可响应此【杀】；目标角色的手牌数和体力值均大于等于你的手牌数或体力值，则此【杀】对其造成的伤害+1。',
            minifightreliegong: '烈弓',
            minifightreliegong_info: '①你使用【杀】无距离限制。②当你使用【杀】指定一个目标后，你可以根据下列条件执行相应的效果：1.其手牌数不大于你的手牌数，此【杀】不可被响应，2.其体力值不小于你的体力值，此【杀】伤害+1。',
            minifightlizhan: '力斩',
            minifightlizhan_info: '出牌阶段，你可以打出任意张【杀】，然后视为使用一张需要X张【闪】响应且伤害基数为X的【杀】（X为你打出的【杀】数），目标角色每使用【闪】响应一次此牌，此牌伤害基数-1。若此【杀】造成伤害，则你可以选择一名非此【杀】目标角色，视为对其使用一张无距离和次数限制的伤害牌。',
            minifightbiaoxi: '飚袭',
            minifightbiaoxi_info: '战场技。①一名角色于其出牌阶段失去第二张基本牌时，你可以进入“合淝战场”。②一名角色使用【杀】结算结束后，若此时处于“合淝战场”，你可令你或此【杀】的目标角色发动一次〖突袭〗，若该角色的手牌数因此成为全场唯一最多，则退出“合淝战场”。',
            minifightpozhen: '破阵',
            minifightpozhen_info: '当你获得其他角色的牌后，你可以重铸至多等量张牌，若被重铸的牌中包含：①基本牌：你本回合使用【杀】的次数上限+1；②非基本牌：你下个摸牌阶段摸牌数+1（至多+5）。',
            minifightxurui: '蓄锐',
            minifightxurui_info: `战场技。①一名角色失去所有手牌后，进入“夷陵战场”。②当前回合角色使用牌指定其他角色A为唯一目标时，若此时处于“夷陵战场”且你手牌数为全场最少，你可以选择一项并发动一次〖${get.poptip({
                name: '连营',
                info: '你可以摸两张牌，然后你可以将一张手牌交给一名其他角色',
            })}〗：1.你于此牌结算结束后对A的上家造成1点火焰伤害；2.你于此牌结算结束后对A的下家造成1点火焰伤害；3.此牌造成的伤害+1且改为火属性。③一名角色造成火焰伤害后，若本回合所有角色受到的火焰伤害数大于2，则退出“夷陵战场”。`,
            minifightshijie: '势节',
            minifightshijie_info: '每轮游戏开始时，若你的武将牌上没有“势”，你可以将任意张手牌置于武将牌上，称为“势”，且你于X个回合结束后，获得武将牌上的所有“势”并摸等量张牌（X为武将牌上的“势”数）。',
            minifightchuanglie: '创烈',
            minifightchuanglie_info: `战场技。①一名角色一回合内对同一名角色使用三次牌时，进入“宛城战场”。②处于“宛城战场”时：1.当其他角色成为【杀】的唯一目标时，你可以将此【杀】的目标转移为你；2.一名角色使用【杀】结算完成后，若此牌未造成伤害，你可以对此【杀】的使用者或目标发动一次〖${get.poptip({
                name: '强袭',
                info: '你可以失去1点体力并摸一张牌，然后你对目标角色造成1点伤害；一名角色因此受到伤害时，你可以弃置一张装备牌令此伤害+1',
            })}〗；3.当你进入濒死状态时，你回复2点体力并退出“宛城战场”。`,
            minifightkuangji: '狂戟',
            minifightkuangji_info: '①游戏开始时，你可以将至多两张手牌替换为牌堆中的等量张武器牌。②每回合限一次。你可以打出一张武器牌A并视为使用一张【闪】或额外结算X-1次的无任何次数限制的【杀】，且当你以此法使用【闪】时，你摸X张牌（X为A攻击范围的一半且向上取整）。',
            minifightdangfeng: '荡锋',
            minifightdangfeng_info: '一名角色的回合结束时，你依次执行以下项：1.若本回合没有角色受到过伤害，你从牌堆或弃牌堆中获得一张【杀】；2.若本回合没有角色使用过【杀】，你可以使用一张【杀】。',
            minifighthaiji: '骇击',
            minifighthaiji_info: `锁定技。①当你使用【杀】指定目标后：1.本轮你计算与其他角色的距离-1；2.若此【杀】目标均在你距离1以内，你摸一张牌；3.若其他角色均在你距离1以内，此【杀】具有${get.poptip('miniretieji')}效果。②每回合你使用的首张【杀】可以额外指定一个目标。`,
            minifightyilve: '毅略',
            minifightyilve_info: `出牌阶段限一次。你可以选择一项：1.令一名角色对你选择的一名其他角色发动${get.poptip('minitiaoxin')}；2.展示牌堆顶五张牌并选择至多等量名角色，这些角色依次获得其中一张牌，若其因此获得了【杀】，其可以使用之，然后你将剩余牌放回牌堆顶。若有角色因此使用或弃置了【杀】，你失去1点体力。`,
            minifightqizhi: '锲志',
            minifightqizhi_info: `锁定技。①当你体力值减少后，你摸X张牌（X为你已损失体力值）。②出牌阶段限五次，当你回复体力后，你可以弃置一张牌令${get.poptip('minifightyilve')}本回合发动次数+1。`,
            // 隐
            Myin_xushu: '隐徐庶',
            miniyinyinxing: '隐姓',
            miniyinyinxing_info: `锁定技。①当你需要使用或打出牌时，你只能使用或打出虚拟牌或转化，且你可以将任意张手牌按以下规则使用或打出：1.${get.poptip({
                id: 'miniyinyinxing_duizi',
                name: '对子',
                info: '两张点数相同的牌',
            })}：当任意基本牌；2.${get.poptip({
                id: 'miniyinyinxing_sanshun',
                name: '三顺',
                info: '三张点数连续的牌（欢杀定义）',
            })}：当任意普通锦囊牌（每回合每种牌名限一次）。若你以此法使用的牌花色相同，则此牌效果额外执行一次。②出牌阶段，你可以按以下规则弃置任意张手牌并执行对应效果：1.${get.poptip({
                id: 'miniyinyinxing_santiao',
                name: '三条',
                info: '三张点数相同的牌',
            })}：选择一名角色和其的一个装备栏或者判定区，令其将一张对应的类别牌置入该区域（可以替换原装备）；2.${get.poptip({
                id: 'miniyinyinxing_zhadan',
                name: '炸弹',
                info: '四张及以上点数相同的牌（欢杀定义）',
            })}，对所有其他角色造成X点伤害（X为你弃置的牌数-3）。若你以此法弃置的牌花色相同，则相应效果额外执行一次。③你的手牌数始终不小于5。`,
            miniyinjujian: '举荐',
            miniyinjujian_info: '准备阶段或结束阶段，你可以弃置一张手牌并令一名角色选择一项：1.获得两张点数大于其的牌；2.获得两张点数小于其的牌。',

            // ----------------------- 台词部分 ----------------------- //
            '#ext:活动武将/audio/skill/minispluoshen2': '动无常则，若危若安。',
            '#ext:活动武将/audio/skill/minispluoshen1': '进止难期，若往若还。',
            '#ext:活动武将/audio/skill/minijinghong1': '翩若惊鸿，婉若游龙。',
            '#ext:活动武将/audio/skill/minijinghong2': '神光离合，乍阴乍阳。',
            '#ext:活动武将/audio/die/Mbabysp_zhenji:die': '揽騑辔以抗策，怅盘桓而不能去。',
            '#ext:活动武将/audio/skill/minifightyilve1': '敌军有隙可乘，伐魏更待何时！',
            '#ext:活动武将/audio/skill/minifightyilve2': '君疑臣，则臣必死，岂不见邓艾乎？',
            '#ext:活动武将/audio/skill/minifightqizhi1': '穷途锋芒未减，陌路方彰胆魄！',
            '#ext:活动武将/audio/skill/minifightqizhi2': '山河破碎为局，肝胆嶙峋作旗。',
            '#ext:活动武将/audio/die/Mfight_jiangwei:die': '梦碎剑阁关外，魂系五丈原头……',
            '#ext:活动武将/audio/skill/miniyinyinxing1': '福本山野之人，微名不足挂齿。',
            '#ext:活动武将/audio/skill/miniyinyinxing2': '小隐于野，大隐于朝。',
            '#ext:活动武将/audio/skill/miniyinjujian1': '庶腐草之荧，怎比得沧海皓月？',
            '#ext:活动武将/audio/skill/miniyinjujian2': '卧龙之才，十倍于我。',
            '#ext:活动武将/audio/die/Myin_xushu:die': '人生一世，道难两全……',
            '#ext:活动武将/audio/skill/mininiantazhen1': '阵中诸将，布皆视如草芥。',
            '#ext:活动武将/audio/skill/mininiantazhen2': '且看我匹马踏连营。',
            '#ext:活动武将/audio/skill/mininiandoupo1': '哼！你们一起上吧。',
            '#ext:活动武将/audio/skill/mininiandoupo2': '哼！不过是乌合之众。',
            '#ext:活动武将/audio/skill/mininianying_Mnian_lvbu1': '哈哈哈，此间有功名，正可以汝首为阶。',
            '#ext:活动武将/audio/skill/mininianying_Mnian_lvbu2': '此身纵横天下，未逢敌手！',
            '#ext:活动武将/audio/die/Mnian_lvbu:die': '待我归来日，定斩一切敌。',
            '#ext:活动武将/audio/skill/mininianxinghan1': '汉贼不两立，王业不偏安！',
            '#ext:活动武将/audio/skill/mininianxinghan2': '著信义于四海，揽英杰于九州，诚如是，则汉室可兴。',
            '#ext:活动武将/audio/skill/mininianliaoyuan1': '星星之火，亦可燎原！',
            '#ext:活动武将/audio/skill/mininianliaoyuan2': '管乐用兵，未必过此。',
            '#ext:活动武将/audio/skill/mininianying_Mnian_zhugeliang1': '今兵甲已足，当奖率三军。',
            '#ext:活动武将/audio/skill/mininianying_Mnian_zhugeliang2': '策先定于内，功后成于外。',
            '#ext:活动武将/audio/die/Mnian_zhugeliang:die': '运去英雄不自由。',
            '#ext:活动武将/audio/skill/minishuangshu1': '有乔选乔，无乔不杀。',
            '#ext:活动武将/audio/skill/minishuangshu2': '大乔，小乔，你要怎么选？',
            '#ext:活动武将/audio/skill/minipingting1': '一步两步三步四步，步步生莲。',
            '#ext:活动武将/audio/skill/minipingting2': '身姿轻摇，三寸金莲四寸腰。',
            '#ext:活动武将/audio/skill/miniyizheng1': '只要是能动的，我都喜欢。',
            '#ext:活动武将/audio/skill/miniyizheng2': '只要我想要，就都是我的。',
            '#ext:活动武将/audio/skill/minishutu1': '且让妾身略尽绵薄之力。',
            '#ext:活动武将/audio/skill/minishutu2': '不堪一击！',
            '#ext:活动武将/audio/skill/minitongdi1': '并蒂连枝，休戚与共。',
            '#ext:活动武将/audio/skill/minitongdi2': '双姝同心，其利断金。',
            '#ext:活动武将/audio/die/Mbaby_shen_daxiaoqiao:die': '弦断音咽，曲终人散。',
            '#ext:活动武将/audio/skill/minishenwei1': '双戟在手，主公无忧！',
            '#ext:活动武将/audio/skill/minishenwei2': '休想靠近主公一步！',
            '#ext:活动武将/audio/skill/minielai1': '勇字当头，义字当先！',
            '#ext:活动武将/audio/skill/minielai2': '人戟合一，所向睥睨！',
            '#ext:活动武将/audio/die/Mbaby_shen_dianwei:die': '主公已经撤退，我也可以……休息了……',
            '#ext:活动武将/audio/skill/minimeihun1': '嗯~~妾身就是喜欢这些，给我嘛~',
            '#ext:活动武将/audio/skill/minimeihun2': '这个和这个不要，其他全给我吧~',
            '#ext:活动武将/audio/skill/minihuoxin1': '哎呀~妾身~能有什么坏心思呢？',
            '#ext:活动武将/audio/skill/minihuoxin2': '一笑倾城，一眼惑心~',
            '#ext:活动武将/audio/die/Mbaby_shen_diaochan:die': '纵使消逝，妾影长存……',
            '#ext:活动武将/audio/skill/minijishi1': '悬壶济世，妙手回春！',
            '#ext:活动武将/audio/skill/minijishi2': '鬼门关前能救死，奈何桥上可扶伤。',
            '#ext:活动武将/audio/skill/minitaoxian1': '喝下此药，必可药到病除。',
            '#ext:活动武将/audio/skill/minitaoxian2': '除人之病痛，医者之德修也。',
            '#ext:活动武将/audio/skill/minishenzhen': '医疑难之症，必以非常之法。',
            '#ext:活动武将/audio/die/Mbaby_shen_huatuo:die': '可叹，我毕生医术无人可继……',
            '#ext:活动武将/audio/skill/minitaoxian1': '喝下此药，必可药到病除。',
            '#ext:活动武将/audio/skill/minitaoxian2': '除人之病痛，医者之德修也。',
            '#ext:活动武将/audio/skill/minishenzhen': '医疑难之症，必以非常之法。',
            '#ext:活动武将/audio/die/Mbaby_shen_huatuo:die': '可叹，我毕生医术无人可继……',
            '#ext:活动武将/audio/skill/miniquanxue1': '多思多谋，筹谋长远。',
            '#ext:活动武将/audio/skill/minidingli1': '多势纷争，须衡平制稳为上。',
            '#ext:活动武将/audio/skill/minidingli2': '不急一时，且看时局变幻。',
            '#ext:活动武将/audio/die/Mbaby_shen_sunquan:die': '孤老独年，臣亲异心……',
            '#ext:活动武将/audio/skill/minihuanshu1': '穷则变，变则通，通则久。',
            '#ext:活动武将/audio/skill/minihuanshu2': '天动地宁，变化百灵。',
            '#ext:活动武将/audio/skill/minihuanhua1': '此事易耳。',
            '#ext:活动武将/audio/skill/minihuanhua2': '这有何难？',
            '#ext:活动武将/audio/skill/minihuanjing1': '借小千世界，行无常勾魂。',
            '#ext:活动武将/audio/skill/minihuanjing2': '金丹九转，变化万端。',
            '#ext:活动武将/audio/die/Mbaby_shen_zuoci:die': '当世荣华，不足贪……',
            '#ext:活动武将/audio/skill/minishanshan1': '你打不着！略略略~!',
            '#ext:活动武将/audio/skill/minishanshan2': '我闪！',
            '#ext:活动武将/audio/skill/minianshi1': '女孩的心思，别猜~',
            '#ext:活动武将/audio/skill/minianshi2': '一个小小的惊喜！',
            '#ext:活动武将/audio/die/Mbaby_xiaoshan:die': '时机已到，闪人喽~',
            '#ext:活动武将/audio/skill/minishixian1': '吾乃诗仙李太白！',
            '#ext:活动武将/audio/skill/minishixian2': '笔落惊风雨，诗成泣鬼神！',
            '#ext:活动武将/audio/skill/minishixian_qiangjinjiu1': '人生得意须尽欢，莫使金樽空对月。!',
            '#ext:活动武将/audio/skill/minishixian_jingyesi1': '举头望明月，低头思故乡。',
            '#ext:活动武将/audio/skill/minishixian_xiakexing1': '十步杀一人，千里不留行。',
            '#ext:活动武将/audio/skill/minishixian_xinglunan1': '行路难，行路难！多歧路，今安在？',
            '#ext:活动武将/audio/die/Mbaby_libai:die': '生者为过客，死者为归人。',
            '#ext:活动武将/audio/skill/minitunxing1': '哼哼……每颗星星看起来都这么美味。!',
            '#ext:活动武将/audio/skill/minitunxing2': '北斗七星……快让我尝尝。',
            '#ext:活动武将/audio/skill/minimengli1': '生杀有时，轮回不止。',
            '#ext:活动武将/audio/skill/minimengli2': '破去执念，再塑新生！',
            '#ext:活动武将/audio/die/Mbaby_tunxingmenglix:die': '这颗北斗星，就是我为你选的孩子了……',
            '#ext:活动武将/audio/skill/minisevenbian1': '看我七十二变！',
            '#ext:活动武将/audio/skill/miniruyi1': '呔，吃俺老孙一棒！',
            '#ext:活动武将/audio/skill/miniqitian1': '俺乃五百年前大闹天宫的齐天大圣，孙悟空！',
            '#ext:活动武将/audio/die/Mbaby_sunwukong:die': '俺老孙……不服……',
            '#ext:活动武将/audio/skill/minibutian1': '断鳌足，以立四极！',
            '#ext:活动武将/audio/skill/minibutian2': '洪水涸，九州平！',
            '#ext:活动武将/audio/skill/minilianshi1': '采五方，凝五色，炼石补天，定胜万难！!',
            '#ext:活动武将/audio/skill/minilianshi2': '五色蕴华，万物化生！',
            '#ext:活动武将/audio/skill/minituantu1': '抟黄土作人，力不暇供！',
            '#ext:活动武将/audio/skill/minituantu2': '引绳于泥中，举以为人！',
            '#ext:活动武将/audio/die/Mbaby_nvwa:die': '四极废，九州裂……',
            '#ext:活动武将/audio/skill/minizuzhou': '嗯喵！喵！！',
            '#ext:活动武将/audio/skill/minimoyu': '呜呜呜~喵~',
            '#ext:活动武将/audio/skill/minisanlian': '喵！喵！！喵！！！',
            '#ext:活动武将/audio/die/Mbaby_dalanmao:die': '喵……',
            '#ext:活动武将/audio/skill/minidaoyao1': '入河蟾不没，捣药兔长生。',
            '#ext:活动武将/audio/skill/minidaoyao2': '转空轧𫐄冰轮响，捣药叮当玉杵鸣。',
            '#ext:活动武将/audio/skill/minibenyue1': '一入月宫去，千秋闭蛾眉。!',
            '#ext:活动武将/audio/skill/minibenyue2': '纵令奔月成仙去，且作行云入梦来。',
            '#ext:活动武将/audio/skill/miniguanghan1': '银河无声月宫冷，思念如影伴孤灯。',
            '#ext:活动武将/audio/skill/miniguanghan2': '月宫清冷人独立，寒梦纷飞思绪深。',
            '#ext:活动武将/audio/die/Mbaby_change:die': '月盈则缺……',
            '#ext:活动武将/audio/skill/minilunce1': '某有三策，请主公自择而行。',
            '#ext:活动武将/audio/skill/minilunce2': '此计若成，西川可定。',
            '#ext:活动武将/audio/skill/minilanhai1': '览倚仗之要害，吾似有一日之长，',
            '#ext:活动武将/audio/skill/minilanhai2': '有的放矢，计出万全。',
            '#ext:活动武将/audio/die/Mbaby_shen_pangtong:die': '沉吟不决，已致大患。',
            '#ext:活动武将/audio/skill/minifightdingjun1': '风尘催战鼓，沥血壮军威！',
            '#ext:活动武将/audio/skill/minifightdingjun2': '我军士气正锐，必将一击而中！',
            '#ext:活动武将/audio/skill/minifightlizhan1': '感君台上意，力斩定乾坤！',
            '#ext:活动武将/audio/skill/minifightlizhan2': '长刀饮赤血，皓首展神威！',
            '#ext:活动武将/audio/die/Mfight_huangzhong:die': '此役失了定军山，汉中不保啊……',
            '#ext:活动武将/audio/skill/mininiansuhui1': '光阴荏苒，须臾而回。',
            '#ext:活动武将/audio/skill/mininiansuhui2': '溯洄从之，道阻且长。',
            '#ext:活动武将/audio/skill/mininianchongzou1': '凤笙龙管，重奏人间曲。',
            '#ext:活动武将/audio/skill/mininianchongzou2': '再来一曲吧。',
            '#ext:活动武将/audio/skill/mininianying_Mnian_zhouyu1': '奇姿联璧耀江东。',
            '#ext:活动武将/audio/skill/mininianying_Mnian_zhouyu2': '双橹摇江催战鼓，虎踞江左霸业成。',
            '#ext:活动武将/audio/die/Mnian_zhouyu:die': '今番不见，另有来日。',
            '#ext:活动武将/audio/skill/minifightbiaoxi1': '敌将无胆，一击可擒！',
            '#ext:活动武将/audio/skill/minifightbiaoxi2': '折敌锋锐，余众不足为惧！',
            '#ext:活动武将/audio/skill/minifightpozhen1': '随我斩将搴旗，直取敌酋！',
            '#ext:活动武将/audio/skill/minifightpozhen2': '小儿休走，张文远来也！',
            '#ext:活动武将/audio/die/Mfight_zhangliao:die': '如此下场，徒令小儿耻笑……',
            '#ext:活动武将/audio/skill/mininiandengji1': '登阶踏星，以临紫微。',
            '#ext:活动武将/audio/skill/mininiandengji2': '充列于北辰，升降焉可知。',
            '#ext:活动武将/audio/skill/mininianying_Mnian_caopi1': '人生居天壤之间，何不恣意遨游？',
            '#ext:活动武将/audio/skill/mininianying_Mnian_caopi2': '嘉肴重叠来，珍果在一傍。',
            '#ext:活动武将/audio/skill/mininianchengming1': '天命在我！',
            '#ext:活动武将/audio/skill/mininianchengming2': '览公卿之议，顺皇天之命。',
            '#ext:活动武将/audio/skill/mininiansongwei1': '行教化之道，彰四时之功。',
            '#ext:活动武将/audio/skill/mininiansongwei2': '孤天威浩荡，当享四海九州！',
            '#ext:活动武将/audio/skill/minikangkai_Mnian_caopi': '列马踏阵，胆气纵横！',
            '#ext:活动武将/audio/skill/minijiangchi_Mnian_caopi': '猛虎破柙，干骑随风！',
            '#ext:活动武将/audio/skill/miniluoying_Mnian_caopi': '白鹤衔文，才蔽日月。',
            '#ext:活动武将/audio/skill/chengxiang_Mnian_caopi': '灵龟定策，谋破长空。',
            '#ext:活动武将/audio/die/Mnian_caopi:die': '嗟我白发，生一何早。',
            '#ext:活动武将/audio/skill/minifightxurui1': '此事我早有准备。',
            '#ext:活动武将/audio/skill/minifightxurui2': '先为不可胜，以待敌之可胜。',
            '#ext:活动武将/audio/skill/minifightshijie1': '势如彍弩，节如发机。',
            '#ext:活动武将/audio/skill/minifightshijie2': '因势利导，当机立断。',
            '#ext:活动武将/audio/die/Mfight_luxun:die': '恋栈不去，良机尽失。',
            '#ext:活动武将/audio/skill/miniyingyi1': '不计代价，直击董贼！',
            '#ext:活动武将/audio/skill/miniyingyi2': '一马当先，所向披靡！',
            '#ext:活动武将/audio/skill/miniliezhi1': '兵贵神速，以战养战！',
            '#ext:活动武将/audio/skill/miniliezhi2': '江东子弟，随我共诛逆贼！',
            '#ext:活动武将/audio/die/Mbabysp_sunjian:die': '逆贼垂破，恨无人与我戮力同心……',
            '#ext:活动武将/audio/skill/minifightdangfeng1': '青刃横空，宵小难逃！',
            '#ext:活动武将/audio/skill/minifightdangfeng2': '一个都逃不脱！',
            '#ext:活动武将/audio/skill/minifighthaiji1': '敌渡渭水，击其中流！',
            '#ext:活动武将/audio/skill/minifighthaiji2': '这一枪，定叫那渭水断流！',
            '#ext:活动武将/audio/die/Mfight_machao:die': '今且放你一马，此仇来日必报。',
            '#ext:活动武将/audio/skill/minisbluoshen1': '碧波耀清辉。',
            '#ext:活动武将/audio/skill/minisbluoshen2': '轻云拂素月。',
            '#ext:活动武将/audio/skill/minisbqingguo1': '眉目艳皎月，幽兰漫夜明。',
            '#ext:活动武将/audio/skill/minisbqingguo2': '一顾倾人城，再顾倾人国。',
            '#ext:活动武将/audio/die/Mbaby_sb_zhenji:die': '佳人难再得。',
            '#ext:活动武将/audio/skill/minizhuyi1': '义之所向，剑之所往！',
            '#ext:活动武将/audio/skill/minizhuyi2': '此善虽小，仍当行之。',
            '#ext:活动武将/audio/skill/minixiafeng1': '青锋三尺，荡尽不平！',
            '#ext:活动武将/audio/skill/minixiafeng2': '此恶虽微，仍应灭之。',
            '#ext:活动武将/audio/die/Mbabysp_liubei:die': '大丈夫行事，何惧生死！',
            '#ext:活动武将/audio/skill/minikuanmeng1': '宽猛兼备，方为正道。',
            '#ext:活动武将/audio/skill/minikuanmeng2': '慕容贷法，可使行阵齐整。',
            '#ext:活动武将/audio/skill/minixuefeng1': '陛下且自前行，晃随后便至。',
            '#ext:活动武将/audio/skill/minixuefeng2': '奉令誓死保护天子。',
            '#ext:活动武将/audio/die/Mbabysp_xuhuang:die': '一招不慎，满盘皆输！',
            '#ext:活动武将/audio/skill/miniyanxiao1': '此生容颜，只为君留。',
            '#ext:活动武将/audio/skill/miniyanxiao2': '古玉沁色，羞颜暖心。',
            '#ext:活动武将/audio/skill/miniguose_Mbabysp_daqiao1': '英雄壮志，红颜无怨。',
            '#ext:活动武将/audio/skill/miniguose_Mbabysp_daqiao2': '倾心一笑，愿君驻足。',
            '#ext:活动武将/audio/skill/minianxian1': '哈哈哈~',
            '#ext:活动武将/audio/die/Mbabysp_daqiao:die': '恨不能常侍君左右。',
            '#ext:活动武将/audio/skill/minixingwu1': '让开让开，你打扰本小姐赏花了。',
            '#ext:活动武将/audio/skill/minixingwu2': '请多多指教。',
            '#ext:活动武将/audio/skill/miniluoyan1': '欸嘿嘿，你抓不住我。',
            '#ext:活动武将/audio/skill/minihuimou1': '可否请您做那护花的人啊？',
            '#ext:活动武将/audio/die/Mbabysp_xiaoqiao:die': '红颜易失，刹那芳华……',
            '#ext:活动武将/audio/skill/minipaoxiao_Mbabysp_zhangfei1': '黄口孺子，怎闻霹雳之声！',
            '#ext:活动武将/audio/skill/minipaoxiao_Mbabysp_zhangfei2': '据桥一喝，闻者无不肝胆碎裂。',
            '#ext:活动武将/audio/skill/minixuhe1': '大军至，何以不降而敢拒战？',
            '#ext:活动武将/audio/die/Mbabysp_zhangfei:die': '大爷，有些累了。',
            '#ext:活动武将/audio/skill/minifightchuanglie1': '此战，不退！',
            '#ext:活动武将/audio/skill/minifightchuanglie2': '此路，不通！',
            '#ext:活动武将/audio/skill/minifightkuangji1': '双戟何在？',
            '#ext:活动武将/audio/skill/minifightkuangji2': '一下不够，那再吃我一戟！',
            '#ext:活动武将/audio/die/Mfight_dianwei:die': '到此为止了……',
        },
    };
    MiNikill_sight();//加载欢杀界面逻辑
    for (var skill in MiNikill.skill) {
        //特定化身将池添加注释
        if (MiNikill.skill[skill].derivation === 'Mbaby_characterlist_faq') MiNikill.translate[skill + '_append'] = MiNikill.translate.Mbaby_characterlist_append;
        //念影效果添加注释
        if (MiNikill.skill[skill].nianyingSkill) {
            MiNikill.skill[skill].derivation ??= [];
            MiNikill.skill[skill].derivation.push(skill + '_faq');
            MiNikill.translate[skill + '_faq'] = '念影——' + MiNikill.skill[skill].nianyingSkill[0];
            MiNikill.translate[skill + '_faq_info'] = '<br>' + MiNikill.skill[skill].nianyingSkill[1];
            MiNikill.translate[skill + '_append'] = '<span style="font-family: yuanli"><li>念影——' + MiNikill.skill[skill].nianyingSkill[0] + '<br>' + MiNikill.skill[skill].nianyingSkill[1] + '</span>';
        }
    }
    for (let i in MiNikill.character) {
        if (Array.isArray(MiNikill.character[i])) MiNikill.character[i] = get.convertedCharacter(MiNikill.character[i]);
        MiNikill.character[i].trashBin ??= [];
        MiNikill.character[i].dieAudios ??= [];
        MiNikill.character[i].tempname ??= [];
        if (_status['extension_活动武将_files']?.audio.die.files.includes(`${i}.mp3`)) {
            MiNikill.character[i].dieAudios.push('ext:活动武将/audio/die:true');
            MiNikill.translate[`#ext:活动武将/audio/die/${i}:die`] ??= '点击播放阵亡配音';
        }
        if (i.startsWith('Mbaby_')) {
            if (!MiNikill.character[i].dieAudios.length) MiNikill.character[i].dieAudios.push(i.slice(6));
            if (!MiNikill.character[i].tempname.length) MiNikill.character[i].tempname.push(i.slice(6));
        }
        if (_status['extension_活动武将_files']) {
            const { files } = _status['extension_活动武将_files']?.image.character;
            if (files.includes(`${i}.jpg`)) MiNikill.character[i].img = `extension/活动武将/image/character/${i}.jpg`;
            else {
                const skin = MiNikill.character[i].trashBin.find(str => str.startsWith('character:'))?.split(':')[1];
                if (skin && files.includes(`${skin}.jpg`)) MiNikill.character[i].img = `extension/活动武将/image/character/${skin}.jpg`;
            }
        }
        if (MiNikill.translate[i] && !lib.translate[i + '_prefix'] && !MiNikill.translate[i + '_prefix']) {
            if (MiNikill.translate[i].startsWith(get.poptip('rule_mamba'))) {
                MiNikill.translate[i + '_ab'] = `牢${MiNikill.translate[i].slice(get.poptip('rule_mamba').length)}`;
                MiNikill.translate[i + '_prefix'] = '牢';
            }
            else if (MiNikill.translate[i].startsWith('欢杀神')) MiNikill.translate[i + '_prefix'] = '欢杀|神';
            else if (MiNikill.translate[i].startsWith('SP欢杀神')) MiNikill.translate[i + '_prefix'] = 'SP|欢杀|神';
            else if (MiNikill.translate[i].startsWith('欢杀谋')) MiNikill.translate[i + '_prefix'] = '欢杀|谋';
            else if (MiNikill.translate[i].startsWith('欢杀星')) MiNikill.translate[i + '_prefix'] = '欢杀|星';
            else if (MiNikill.translate[i].startsWith('欢杀界')) MiNikill.translate[i + '_prefix'] = '欢杀|界';
            else if (MiNikill.translate[i].startsWith('欢杀')) MiNikill.translate[i + '_prefix'] = '欢杀';
            else if (MiNikill.translate[i].startsWith('SP欢杀')) MiNikill.translate[i + '_prefix'] = 'SP|欢杀';
            else if (MiNikill.translate[i].startsWith('喵')) MiNikill.translate[i + '_prefix'] = '喵';
            else if (MiNikill.translate[i].startsWith('念')) MiNikill.translate[i + '_prefix'] = '念';
            else if (MiNikill.translate[i].startsWith('战')) MiNikill.translate[i + '_prefix'] = '战';
            else if (MiNikill.translate[i].startsWith('隐')) MiNikill.translate[i + '_prefix'] = '隐';
        }
    }
    lib.namePrefix.set('喵', {
        color: '#fdd559',
        nature: 'soilmm',
    });
    lib.namePrefix.set('念', {
        color: '#bf3eff',
        nature: 'soilmm',
    });
    lib.namePrefix.set('战', {
        color: '#ff4500',
        nature: 'firemm',
    });
    lib.namePrefix.set('隐', {
        color: '#c5e2ebff',
        nature: 'soilmm',
    });
    lib.namePrefix.set('欢杀', {
        color: '#ff6a6a',
        nature: 'MXpink',
        showName: '欢',
    });
    lib.arenaReady.push(function () {
        //双武将牌机制
        const ori1 = lib.element.player.init;
        lib.element.player.init = function (character, character2) {
            const player = this;
            if (lib.character[character]?.hp2 || lib.character[character2]?.hp2) {
                let hp1 = 0, hp2 = 0;
                if (lib.character[character]?.hp2) hp1 = lib.character[character].hp2;
                if (lib.character[character2]?.hp2) hp2 = lib.character[character2].hp2;
                if (lib.character[character]?.hp2 && lib.character[character2]?.hp2) {
                    let double_hp;
                    if (_status.connectMode || get.mode() === 'single' && _status.mode === 'changban') double_hp = 'pingjun';
                    else double_hp = get.config('double_hp');
                    switch (double_hp) {
                        case 'pingjun': {
                            this.hp2 = Math.floor((hp1 + hp2) / 2);
                            break;
                        }
                        case 'zuidazhi': {
                            this.hp2 = Math.max(hp1, hp2);
                            break;
                        }
                        case 'zuixiaozhi': {
                            this.hp2 = Math.min(hp1, hp2);
                            break;
                        }
                        case 'zonghe': {
                            this.hp2 = hp1 + hp2;
                            break;
                        }
                        default: {
                            this.hp2 = hp1 + hp2 - 3;
                        }
                    }
                }
                else {
                    this.hp2 = lib.character[character]?.hp2 ? hp1 : hp2;
                }
            }
            return ori1.apply(this, arguments);
        };
        const ori2 = lib.element.player.uninit;
        lib.element.player.uninit = function () {
            delete this.hp2;
            return ori2.apply(this, arguments);
        };
        const ori3 = lib.element.player.$update;
        lib.element.player.$update = function () {
            const player = ori3.apply(this, arguments);
            if (typeof player.hp2 === 'number') {
                if (_status.event?.name === 'chooseCharacter') player.hp2++;
                if (player.hp2 >= player.maxHp) player.hp2 = player.maxHp;
                if (!player.storage.nohp) {
                    const hp = player.node.hp;
                    hp.style.transition = 'none';
                    if (window.decadeUI) {
                        player.dataset.maxHp = 4;
                        hp.style.writingMode = hp.style.webkitWritingMode = 'horizontal-tb';
                    }
                    else hp.style.writingMode = hp.style.webkitWritingMode = 'vertical-rl';
                    //hp.style.textOrientation = 'upright';不用这个用getStr处理的原因是为了让多位数也能横向显示
                    const getNum = num => isNaN(num) ? '×' : num === Infinity ? '∞' : num;
                    const getStr = str => {
                        const span = document.createElement('span'), style = span.style;
                        style.writingMode = style.webkitWritingMode = 'horizontal-tb';
                        span.textContent = str;
                        return span.outerHTML;
                    };
                    hp.innerHTML = `${getStr(getNum(player.hp2))}${getStr('/')}${getStr(getNum(player.maxHp))}<div></div><br>${getStr(getNum(player.hp))}${getStr('/')}${getStr(getNum(player.maxHp))}<div></div>`;
                    if (player.hp === 0 || player.hp2 === 0) hp.lastChild.classList.add('lost');
                    hp.classList.add('textstyle');
                    setTimeout(() => hp.style.transition = '');
                }
            }
            return player;
        };
        lib.element.player.getHandcardLimit = function () {
            let num = Math.max(this.hp, 0);
            if (typeof this.hp2 === 'number') num += Math.max(this.hp2, 0);
            num = game.checkMod(this, num, 'maxHandcardBase', this);
            num = game.checkMod(this, num, 'maxHandcard', this);
            num = game.checkMod(this, num, 'maxHandcardFinal', this);
            return Math.max(0, num);
        };
        lib.element.player.isDamaged = function () {
            return (this.hp < this.maxHp || (typeof this.hp2 === 'number' && this.hp2 < this.maxHp)) && !this.storage.nohp;
        };
        lib.element.player.isHealthy = function () {
            return (this.hp >= this.maxHp && (typeof this.hp2 !== 'number' || this.hp2 >= this.maxHp)) || this.storage.nohp;
        };
        lib.element.content.recover = function () {
            let list = [player.maxHp - player.hp];
            if (typeof player.hp2 === 'number') list.push(player.maxHp - player.hp2);
            event.num = num = Math.min(num, Math.max(...list));
            if (num > 0) {
                delete event.filterStop;
                game.broadcastAll(player => {
                    if (lib.config.background_audio) game.playAudio('effect', 'recover');
                    if (lib.config.animation && !lib.config.low_performance) player.$recover();
                }, player);
                player.$damagepop(num, "wood");
                game.log(player, `回复了${get.cnNumber(num)}点体力`);
                player.changeHp(num, false);
            }
            else event._triggered = null;
        };
        const ori4 = lib.element.player.getHp;
        lib.element.player.getHp = function (raw) {
            let num = ori4.apply(this, arguments);
            if (typeof this.hp2 === 'number') num += raw ? this.hp2 : Math.max(0, this.hp2);
            return num;
        };
        const ori5 = lib.element.player.getDamagedHp;
        lib.element.player.getDamagedHp = function (raw) {
            let num = ori5.apply(this, arguments);
            if (typeof this.hp2 === 'number') num += this.maxHp;
            return num;
        };
        lib.element.content.changeHp = async function (event, trigger, player) {
            game.getGlobalHistory().changeHp.push(event);
            if (event.num < 0 && player.hujia > 0 && event.getParent().name === 'damage' && !player.hasSkillTag('nohujia') && !event.getParent().nohujia) {
                event.hujia = Math.min(-event.num, player.hujia);
                event.getParent().hujia = event.hujia;
                event.num += event.hujia;
                const next = player.changeHujia(-event.hujia);
                next.type = 'damage';
                await next;
            }
            let num = event.num, choice = 'hp';
            if (num !== 0) {
                if (typeof player.hp2 === 'number') {
                    if (_status.dying.includes(player) && (player.hp <= 0 !== player.hp2 <= 0)) {
                        choice = player.hp <= 0 ? 'hp' : 'hp2';
                    }
                    else if (num > 0 && ((player.hp === player.maxHp) !== (player.hp2 === player.maxHp))) {
                        choice = (player.hp2 === player.maxHp) ? 'hp' : 'hp2';
                    }
                    else {
                        let result = await player.chooseControl('主武将牌', '副武将牌').set('ai', () => {
                            const { player, num } = get.event().getParent();
                            return (player.hp - player.hp2) * num <= 0 ? 0 : 1;
                        }).set('prompt', `请选择一张武将牌${num > 0 ? '+' : ''}${num}体力`).forResult();
                        choice = (result?.index === 0) ? 'hp' : 'hp2';
                    }
                }
            }
            event.choice = choice;
            player[choice] += num;
            if (isNaN(player[choice])) player[choice] = 0;
            if (player[choice] > player[`maxHp${choice[2]}`]) player[choice] = player[`maxHp${choice[2]}`];
            player.update();
            if (event.popup !== false) player.$damagepop(num, 'water');
            if (_status.dying.includes(player) && player.hp > 0 && (typeof player.hp2 !== 'number' || player.hp2 > 0)) {
                _status.dying.remove(player);
                game.broadcast(list => _status.dying = list, _status.dying);
                let evt = event.getParent('_save');
                if (evt?.finish) evt.finish();
                evt = event.getParent('dying');
                if (evt?.finish) evt.finish();
            }
            await event.trigger('changeHp');
        };
        const ori6 = ui.create.buttonPresets.character;
        ui.create.buttonPresets.character = function (item) {
            const node = ori6.apply(this, arguments);
            const func = node.refresh;
            node.refresh = function (node2, item2) {
                func.apply(this, arguments);
                const infoitem = lib.character[item2];
                if (typeof infoitem?.hp2 === 'number' && node2.node.hp?.querySelector('.text')) {
                    const { hp, maxHp, hp2 } = infoitem, goon = hp === maxHp;
                    node2.node.hp.querySelector('.text').textContent = `${hp}&${hp2}${goon ? '' : `/${maxHp}`}`;
                }
            };
            const infoitem = lib.character[item];
            if (typeof infoitem?.hp2 === 'number' && node.node.hp?.querySelector('.text')) {
                const { hp, maxHp, hp2 } = infoitem, goon = hp === maxHp;
                node.node.hp.querySelector('.text').textContent = `${hp}&${hp2}${goon ? '' : `/${maxHp}`}`;
            }
            return node;
        };
        const ori7 = ui.click.charactercard;
        ui.click.charactercard = function (name) {
            ori7.apply(this, arguments);
            const hpTextDiv = document.querySelector('.menubg.charactercard')?.querySelector('.text');
            if (hpTextDiv && typeof lib.character[name]?.hp2 === 'number') {
                const { hp, hp2, maxHp } = lib.character[name];
                hpTextDiv.innerHTML = `×${hp}&${hp2}${hp === maxHp ? '' : `/${maxHp}`}`;
            }
        };
    });
    lib.config.all.sgscharacters.push('MiNikill');
    if (!lib.config.characters.includes('MiNikill')) lib.config.characters.remove('MiNikill');
    lib.translate['MiNikill_character_config'] = '<span style="font-family: xingkai">欢乐三国杀</span>';
    return MiNikill;
};

export default packs;